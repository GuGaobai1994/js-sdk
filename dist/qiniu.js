/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;var MXI_DEBUG = true;
/**
 * mOxie - multi-runtime File API & XMLHttpRequest L2 Polyfill
 * v1.5.3
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 *
 * Date: 2017-02-02
 */
;(function (global, factory) {
	var extract = function() {
		var ctx = {};
		factory.apply(ctx, arguments);
		return ctx.moxie;
	};
	
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (extract),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === "object" && module.exports) {
		module.exports = extract();
	} else {
		global.moxie = extract();
	}
}(this || window, function() {
/**
 * Compiled inline version. (Library mode)
 */

/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
/*globals $code */

(function(exports, undefined) {
	"use strict";

	var modules = {};

	function require(ids, callback) {
		var module, defs = [];

		for (var i = 0; i < ids.length; ++i) {
			module = modules[ids[i]] || resolve(ids[i]);
			if (!module) {
				throw 'module definition dependecy not found: ' + ids[i];
			}

			defs.push(module);
		}

		callback.apply(null, defs);
	}

	function define(id, dependencies, definition) {
		if (typeof id !== 'string') {
			throw 'invalid module definition, module id must be defined and be a string';
		}

		if (dependencies === undefined) {
			throw 'invalid module definition, dependencies must be specified';
		}

		if (definition === undefined) {
			throw 'invalid module definition, definition function must be specified';
		}

		require(dependencies, function() {
			modules[id] = definition.apply(null, arguments);
		});
	}

	function defined(id) {
		return !!modules[id];
	}

	function resolve(id) {
		var target = exports;
		var fragments = id.split(/[.\/]/);

		for (var fi = 0; fi < fragments.length; ++fi) {
			if (!target[fragments[fi]]) {
				return;
			}

			target = target[fragments[fi]];
		}

		return target;
	}

	function expose(ids) {
		for (var i = 0; i < ids.length; i++) {
			var target = exports;
			var id = ids[i];
			var fragments = id.split(/[.\/]/);

			for (var fi = 0; fi < fragments.length - 1; ++fi) {
				if (target[fragments[fi]] === undefined) {
					target[fragments[fi]] = {};
				}

				target = target[fragments[fi]];
			}

			target[fragments[fragments.length - 1]] = modules[id];
		}
	}

// Included from: src/javascript/core/utils/Basic.js

/**
 * Basic.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/core/utils/Basic
@public
@static
*/
define('moxie/core/utils/Basic', [], function() {
	/**
	Gets the true type of the built-in object (better version of typeof).
	@author Angus Croll (http://javascriptweblog.wordpress.com/)

	@method typeOf
	@for Utils
	@static
	@param {Object} o Object to check.
	@return {String} Object [[Class]]
	*/
	function typeOf(o) {
		var undef;

		if (o === undef) {
			return 'undefined';
		} else if (o === null) {
			return 'null';
		} else if (o.nodeType) {
			return 'node';
		}

		// the snippet below is awesome, however it fails to detect null, undefined and arguments types in IE lte 8
		return ({}).toString.call(o).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
	}

	/**
	Extends the specified object with another object(s).

	@method extend
	@static
	@param {Object} target Object to extend.
	@param {Object} [obj]* Multiple objects to extend with.
	@return {Object} Same as target, the extended object.
	*/
	function extend() {
		return merge(false, false, arguments);
	}


	/**
	Extends the specified object with another object(s), but only if the property exists in the target.

	@method extendIf
	@static
	@param {Object} target Object to extend.
	@param {Object} [obj]* Multiple objects to extend with.
	@return {Object} Same as target, the extended object.
	*/
	function extendIf() {
		return merge(true, false, arguments);
	}


	function extendImmutable() {
		return merge(false, true, arguments);
	}


	function extendImmutableIf() {
		return merge(true, true, arguments);
	}


	function shallowCopy(obj) {
		switch (typeOf(obj)) {
			case 'array':
				return Array.prototype.slice.call(obj);

			case 'object':
				return extend({}, obj);
		}
		return obj;
	}


	function merge(strict, immutable, args) {
		var undef;
		var target = args[0];

		each(args, function(arg, i) {
			if (i > 0) {
				each(arg, function(value, key) {
					var isComplex = inArray(typeOf(value), ['array', 'object']) !== -1;

					if (value === undef || strict && target[key] === undef) {
						return true;
					}

					if (isComplex && immutable) {
						value = shallowCopy(value);
					}

					if (typeOf(target[key]) === typeOf(value) && isComplex) {
						merge(strict, immutable, [target[key], value]);
					} else {
						target[key] = value;
					}
				});
			}
		});

		return target;
	}


	/**
	A way to inherit one `class` from another in a consisstent way (more or less)

	@method inherit
	@static
	@since >1.4.1
	@param {Function} child
	@param {Function} parent
	@return {Function} Prepared constructor
	*/
	function inherit(child, parent) {
		// copy over all parent properties
		for (var key in parent) {
			if ({}.hasOwnProperty.call(parent, key)) {
				child[key] = parent[key];
			}
		}

		// give child `class` a place to define its own methods
		function ctor() {
			this.constructor = child;
		}
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();

		// keep a way to reference parent methods
		child.__parent__ = parent.prototype;
		return child;
	}


	/**
	Executes the callback function for each item in array/object. If you return false in the
	callback it will break the loop.

	@method each
	@static
	@param {Object} obj Object to iterate.
	@param {function} callback Callback function to execute for each item.
	*/
	function each(obj, callback) {
		var length, key, i, undef;

		if (obj) {
			try {
				length = obj.length;
			} catch(ex) {
				length = undef;
			}

			if (length === undef || typeof(length) !== 'number') {
				// Loop object items
				for (key in obj) {
					if (obj.hasOwnProperty(key)) {
						if (callback(obj[key], key) === false) {
							return;
						}
					}
				}
			} else {
				// Loop array items
				for (i = 0; i < length; i++) {
					if (callback(obj[i], i) === false) {
						return;
					}
				}
			}
		}
	}

	/**
	Checks if object is empty.

	@method isEmptyObj
	@static
	@param {Object} o Object to check.
	@return {Boolean}
	*/
	function isEmptyObj(obj) {
		var prop;

		if (!obj || typeOf(obj) !== 'object') {
			return true;
		}

		for (prop in obj) {
			return false;
		}

		return true;
	}

	/**
	Recieve an array of functions (usually async) to call in sequence, each  function
	receives a callback as first argument that it should call, when it completes. Finally,
	after everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the sequence and invoke main callback
	immediately.

	@method inSeries
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of error
	*/
	function inSeries(queue, cb) {
		var i = 0, length = queue.length;

		if (typeOf(cb) !== 'function') {
			cb = function() {};
		}

		if (!queue || !queue.length) {
			cb();
		}

		function callNext(i) {
			if (typeOf(queue[i]) === 'function') {
				queue[i](function(error) {
					/*jshint expr:true */
					++i < length && !error ? callNext(i) : cb(error);
				});
			}
		}
		callNext(i);
	}


	/**
	Recieve an array of functions (usually async) to call in parallel, each  function
	receives a callback as first argument that it should call, when it completes. After
	everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the process and invoke main callback
	immediately.

	@method inParallel
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of erro
	*/
	function inParallel(queue, cb) {
		var count = 0, num = queue.length, cbArgs = new Array(num);

		each(queue, function(fn, i) {
			fn(function(error) {
				if (error) {
					return cb(error);
				}

				var args = [].slice.call(arguments);
				args.shift(); // strip error - undefined or not

				cbArgs[i] = args;
				count++;

				if (count === num) {
					cbArgs.unshift(null);
					cb.apply(this, cbArgs);
				}
			});
		});
	}


	/**
	Find an element in array and return it's index if present, otherwise return -1.

	@method inArray
	@static
	@param {Mixed} needle Element to find
	@param {Array} array
	@return {Int} Index of the element, or -1 if not found
	*/
	function inArray(needle, array) {
		if (array) {
			if (Array.prototype.indexOf) {
				return Array.prototype.indexOf.call(array, needle);
			}

			for (var i = 0, length = array.length; i < length; i++) {
				if (array[i] === needle) {
					return i;
				}
			}
		}
		return -1;
	}


	/**
	Returns elements of first array if they are not present in second. And false - otherwise.

	@private
	@method arrayDiff
	@param {Array} needles
	@param {Array} array
	@return {Array|Boolean}
	*/
	function arrayDiff(needles, array) {
		var diff = [];

		if (typeOf(needles) !== 'array') {
			needles = [needles];
		}

		if (typeOf(array) !== 'array') {
			array = [array];
		}

		for (var i in needles) {
			if (inArray(needles[i], array) === -1) {
				diff.push(needles[i]);
			}
		}
		return diff.length ? diff : false;
	}


	/**
	Find intersection of two arrays.

	@private
	@method arrayIntersect
	@param {Array} array1
	@param {Array} array2
	@return {Array} Intersection of two arrays or null if there is none
	*/
	function arrayIntersect(array1, array2) {
		var result = [];
		each(array1, function(item) {
			if (inArray(item, array2) !== -1) {
				result.push(item);
			}
		});
		return result.length ? result : null;
	}


	/**
	Forces anything into an array.

	@method toArray
	@static
	@param {Object} obj Object with length field.
	@return {Array} Array object containing all items.
	*/
	function toArray(obj) {
		var i, arr = [];

		for (i = 0; i < obj.length; i++) {
			arr[i] = obj[i];
		}

		return arr;
	}


	/**
	Generates an unique ID. The only way a user would be able to get the same ID is if the two persons
	at the same exact millisecond manage to get the same 5 random numbers between 0-65535; it also uses
	a counter so each ID is guaranteed to be unique for the given page. It is more probable for the earth
	to be hit with an asteroid.

	@method guid
	@static
	@param {String} prefix to prepend (by default 'o' will be prepended).
	@method guid
	@return {String} Virtually unique id.
	*/
	var guid = (function() {
		var counter = 0;

		return function(prefix) {
			var guid = new Date().getTime().toString(32), i;

			for (i = 0; i < 5; i++) {
				guid += Math.floor(Math.random() * 65535).toString(32);
			}

			return (prefix || 'o_') + guid + (counter++).toString(32);
		};
	}());


	/**
	Trims white spaces around the string

	@method trim
	@static
	@param {String} str
	@return {String}
	*/
	function trim(str) {
		if (!str) {
			return str;
		}
		return String.prototype.trim ? String.prototype.trim.call(str) : str.toString().replace(/^\s*/, '').replace(/\s*$/, '');
	}


	/**
	Parses the specified size string into a byte value. For example 10kb becomes 10240.

	@method parseSizeStr
	@static
	@param {String/Number} size String to parse or number to just pass through.
	@return {Number} Size in bytes.
	*/
	function parseSizeStr(size) {
		if (typeof(size) !== 'string') {
			return size;
		}

		var muls = {
				t: 1099511627776,
				g: 1073741824,
				m: 1048576,
				k: 1024
			},
			mul;

		size = /^([0-9\.]+)([tmgk]?)$/.exec(size.toLowerCase().replace(/[^0-9\.tmkg]/g, ''));
		mul = size[2];
		size = +size[1];

		if (muls.hasOwnProperty(mul)) {
			size *= muls[mul];
		}
		return Math.floor(size);
	}


	/**
	 * Pseudo sprintf implementation - simple way to replace tokens with specified values.
	 *
	 * @param {String} str String with tokens
	 * @return {String} String with replaced tokens
	 */
	function sprintf(str) {
		var args = [].slice.call(arguments, 1);

		return str.replace(/%[a-z]/g, function() {
			var value = args.shift();
			return typeOf(value) !== 'undefined' ? value : '';
		});
	}



	function delay(cb, timeout) {
		var self = this;
		setTimeout(function() {
			cb.call(self);
		}, timeout || 1);
	}


	return {
		guid: guid,
		typeOf: typeOf,
		extend: extend,
		extendIf: extendIf,
		extendImmutable: extendImmutable,
		extendImmutableIf: extendImmutableIf,
		inherit: inherit,
		each: each,
		isEmptyObj: isEmptyObj,
		inSeries: inSeries,
		inParallel: inParallel,
		inArray: inArray,
		arrayDiff: arrayDiff,
		arrayIntersect: arrayIntersect,
		toArray: toArray,
		trim: trim,
		sprintf: sprintf,
		parseSizeStr: parseSizeStr,
		delay: delay
	};
});

// Included from: src/javascript/core/utils/Encode.js

/**
 * Encode.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Encode', [], function() {

	/**
	@class moxie/core/utils/Encode
	*/

	/**
	Encode string with UTF-8

	@method utf8_encode
	@for Utils
	@static
	@param {String} str String to encode
	@return {String} UTF-8 encoded string
	*/
	var utf8_encode = function(str) {
		return unescape(encodeURIComponent(str));
	};
	
	/**
	Decode UTF-8 encoded string

	@method utf8_decode
	@static
	@param {String} str String to decode
	@return {String} Decoded string
	*/
	var utf8_decode = function(str_data) {
		return decodeURIComponent(escape(str_data));
	};
	
	/**
	Decode Base64 encoded string (uses browser's default method if available),
	from: https://raw.github.com/kvz/phpjs/master/functions/url/base64_decode.js

	@method atob
	@static
	@param {String} data String to decode
	@return {String} Decoded string
	*/
	var atob = function(data, utf8) {
		if (typeof(window.atob) === 'function') {
			return utf8 ? utf8_decode(window.atob(data)) : window.atob(data);
		}

		// http://kevin.vanzonneveld.net
		// +   original by: Tyler Akins (http://rumkin.com)
		// +   improved by: Thunder.m
		// +      input by: Aman Gupta
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   bugfixed by: Onno Marsman
		// +   bugfixed by: Pellentesque Malesuada
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +      input by: Brett Zamir (http://brett-zamir.me)
		// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
		// *     returns 1: 'Kevin van Zonneveld'
		// mozilla has this native
		// - but breaks in 2.0.0.12!
		//if (typeof this.window.atob == 'function') {
		//    return atob(data);
		//}
		var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			dec = "",
			tmp_arr = [];

		if (!data) {
			return data;
		}

		data += '';

		do { // unpack four hexets into three octets using index points in b64
			h1 = b64.indexOf(data.charAt(i++));
			h2 = b64.indexOf(data.charAt(i++));
			h3 = b64.indexOf(data.charAt(i++));
			h4 = b64.indexOf(data.charAt(i++));

			bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

			o1 = bits >> 16 & 0xff;
			o2 = bits >> 8 & 0xff;
			o3 = bits & 0xff;

			if (h3 == 64) {
				tmp_arr[ac++] = String.fromCharCode(o1);
			} else if (h4 == 64) {
				tmp_arr[ac++] = String.fromCharCode(o1, o2);
			} else {
				tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
			}
		} while (i < data.length);

		dec = tmp_arr.join('');

		return utf8 ? utf8_decode(dec) : dec;
	};
	
	/**
	Base64 encode string (uses browser's default method if available),
	from: https://raw.github.com/kvz/phpjs/master/functions/url/base64_encode.js

	@method btoa
	@static
	@param {String} data String to encode
	@return {String} Base64 encoded string
	*/
	var btoa = function(data, utf8) {
		if (utf8) {
			data = utf8_encode(data);
		}

		if (typeof(window.btoa) === 'function') {
			return window.btoa(data);
		}

		// http://kevin.vanzonneveld.net
		// +   original by: Tyler Akins (http://rumkin.com)
		// +   improved by: Bayron Guevara
		// +   improved by: Thunder.m
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   bugfixed by: Pellentesque Malesuada
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   improved by: Rafał Kukawski (http://kukawski.pl)
		// *     example 1: base64_encode('Kevin van Zonneveld');
		// *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
		// mozilla has this native
		// - but breaks in 2.0.0.12!
		var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			enc = "",
			tmp_arr = [];

		if (!data) {
			return data;
		}

		do { // pack three octets into four hexets
			o1 = data.charCodeAt(i++);
			o2 = data.charCodeAt(i++);
			o3 = data.charCodeAt(i++);

			bits = o1 << 16 | o2 << 8 | o3;

			h1 = bits >> 18 & 0x3f;
			h2 = bits >> 12 & 0x3f;
			h3 = bits >> 6 & 0x3f;
			h4 = bits & 0x3f;

			// use hexets to index into b64, and append result to encoded string
			tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
		} while (i < data.length);

		enc = tmp_arr.join('');

		var r = data.length % 3;

		return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
	};


	return {
		utf8_encode: utf8_encode,
		utf8_decode: utf8_decode,
		atob: atob,
		btoa: btoa
	};
});

// Included from: src/javascript/core/utils/Env.js

/**
 * Env.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/utils/Env", [
	"moxie/core/utils/Basic"
], function(Basic) {
	
	/**
	 * UAParser.js v0.7.7
	 * Lightweight JavaScript-based User-Agent string parser
	 * https://github.com/faisalman/ua-parser-js
	 *
	 * Copyright © 2012-2015 Faisal Salman <fyzlman@gmail.com>
	 * Dual licensed under GPLv2 & MIT
	 */
	var UAParser = (function (undefined) {

	    //////////////
	    // Constants
	    /////////////


	    var EMPTY       = '',
	        UNKNOWN     = '?',
	        FUNC_TYPE   = 'function',
	        UNDEF_TYPE  = 'undefined',
	        OBJ_TYPE    = 'object',
	        MAJOR       = 'major',
	        MODEL       = 'model',
	        NAME        = 'name',
	        TYPE        = 'type',
	        VENDOR      = 'vendor',
	        VERSION     = 'version',
	        ARCHITECTURE= 'architecture',
	        CONSOLE     = 'console',
	        MOBILE      = 'mobile',
	        TABLET      = 'tablet';


	    ///////////
	    // Helper
	    //////////


	    var util = {
	        has : function (str1, str2) {
	            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
	        },
	        lowerize : function (str) {
	            return str.toLowerCase();
	        }
	    };


	    ///////////////
	    // Map helper
	    //////////////


	    var mapper = {

	        rgx : function () {

	            // loop through all regexes maps
	            for (var result, i = 0, j, k, p, q, matches, match, args = arguments; i < args.length; i += 2) {

	                var regex = args[i],       // even sequence (0,2,4,..)
	                    props = args[i + 1];   // odd sequence (1,3,5,..)

	                // construct object barebones
	                if (typeof(result) === UNDEF_TYPE) {
	                    result = {};
	                    for (p in props) {
	                        q = props[p];
	                        if (typeof(q) === OBJ_TYPE) {
	                            result[q[0]] = undefined;
	                        } else {
	                            result[q] = undefined;
	                        }
	                    }
	                }

	                // try matching uastring with regexes
	                for (j = k = 0; j < regex.length; j++) {
	                    matches = regex[j].exec(this.getUA());
	                    if (!!matches) {
	                        for (p = 0; p < props.length; p++) {
	                            match = matches[++k];
	                            q = props[p];
	                            // check if given property is actually array
	                            if (typeof(q) === OBJ_TYPE && q.length > 0) {
	                                if (q.length == 2) {
	                                    if (typeof(q[1]) == FUNC_TYPE) {
	                                        // assign modified match
	                                        result[q[0]] = q[1].call(this, match);
	                                    } else {
	                                        // assign given value, ignore regex match
	                                        result[q[0]] = q[1];
	                                    }
	                                } else if (q.length == 3) {
	                                    // check whether function or regex
	                                    if (typeof(q[1]) === FUNC_TYPE && !(q[1].exec && q[1].test)) {
	                                        // call function (usually string mapper)
	                                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
	                                    } else {
	                                        // sanitize match using given regex
	                                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
	                                    }
	                                } else if (q.length == 4) {
	                                        result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
	                                }
	                            } else {
	                                result[q] = match ? match : undefined;
	                            }
	                        }
	                        break;
	                    }
	                }

	                if(!!matches) break; // break the loop immediately if match found
	            }
	            return result;
	        },

	        str : function (str, map) {

	            for (var i in map) {
	                // check if array
	                if (typeof(map[i]) === OBJ_TYPE && map[i].length > 0) {
	                    for (var j = 0; j < map[i].length; j++) {
	                        if (util.has(map[i][j], str)) {
	                            return (i === UNKNOWN) ? undefined : i;
	                        }
	                    }
	                } else if (util.has(map[i], str)) {
	                    return (i === UNKNOWN) ? undefined : i;
	                }
	            }
	            return str;
	        }
	    };


	    ///////////////
	    // String map
	    //////////////


	    var maps = {

	        browser : {
	            oldsafari : {
	                major : {
	                    '1' : ['/8', '/1', '/3'],
	                    '2' : '/4',
	                    '?' : '/'
	                },
	                version : {
	                    '1.0'   : '/8',
	                    '1.2'   : '/1',
	                    '1.3'   : '/3',
	                    '2.0'   : '/412',
	                    '2.0.2' : '/416',
	                    '2.0.3' : '/417',
	                    '2.0.4' : '/419',
	                    '?'     : '/'
	                }
	            }
	        },

	        device : {
	            sprint : {
	                model : {
	                    'Evo Shift 4G' : '7373KT'
	                },
	                vendor : {
	                    'HTC'       : 'APA',
	                    'Sprint'    : 'Sprint'
	                }
	            }
	        },

	        os : {
	            windows : {
	                version : {
	                    'ME'        : '4.90',
	                    'NT 3.11'   : 'NT3.51',
	                    'NT 4.0'    : 'NT4.0',
	                    '2000'      : 'NT 5.0',
	                    'XP'        : ['NT 5.1', 'NT 5.2'],
	                    'Vista'     : 'NT 6.0',
	                    '7'         : 'NT 6.1',
	                    '8'         : 'NT 6.2',
	                    '8.1'       : 'NT 6.3',
	                    'RT'        : 'ARM'
	                }
	            }
	        }
	    };


	    //////////////
	    // Regex map
	    /////////////


	    var regexes = {

	        browser : [[
	        
	            // Presto based
	            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
	            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
	            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
	            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80

	            ], [NAME, VERSION], [

	            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
	            ], [[NAME, 'Opera'], VERSION], [

	            // Mixed
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,
	                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

	            // Trident based
	            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
	                                                                                // Avant/IEMobile/SlimBrowser/Baidu
	            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

	            // Webkit/KHTML based
	            /(rekonq)\/([\w\.]+)*/i,                                            // Rekonq
	            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi)\/([\w\.-]+)/i
	                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron
	            ], [NAME, VERSION], [

	            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
	            ], [[NAME, 'IE'], VERSION], [

	            /(edge)\/((\d+)?[\w\.]+)/i                                          // Microsoft Edge
	            ], [NAME, VERSION], [

	            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
	            ], [[NAME, 'Yandex'], VERSION], [

	            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
	            ], [[NAME, /_/g, ' '], VERSION], [

	            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i,
	                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
	            /(uc\s?browser|qqbrowser)[\/\s]?([\w\.]+)/i
	                                                                                // UCBrowser/QQBrowser
	            ], [NAME, VERSION], [

	            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
	            ], [[NAME, 'Dolphin'], VERSION], [

	            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
	            ], [[NAME, 'Chrome'], VERSION], [

	            /XiaoMi\/MiuiBrowser\/([\w\.]+)/i                                   // MIUI Browser
	            ], [VERSION, [NAME, 'MIUI Browser']], [

	            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)/i         // Android Browser
	            ], [VERSION, [NAME, 'Android Browser']], [

	            /FBAV\/([\w\.]+);/i                                                 // Facebook App for iOS
	            ], [VERSION, [NAME, 'Facebook']], [

	            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
	            ], [VERSION, [NAME, 'Mobile Safari']], [

	            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
	            ], [VERSION, NAME], [

	            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
	            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

	            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
	            /(webkit|khtml)\/([\w\.]+)/i
	            ], [NAME, VERSION], [

	            // Gecko based
	            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
	            ], [[NAME, 'Netscape'], VERSION], [
	            /(swiftfox)/i,                                                      // Swiftfox
	            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
	                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
	            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,
	                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
	            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

	            // Other
	            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf)[\/\s]?([\w\.]+)/i,
	                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf
	            /(links)\s\(([\w\.]+)/i,                                            // Links
	            /(gobrowser)\/?([\w\.]+)*/i,                                        // GoBrowser
	            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
	            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
	            ], [NAME, VERSION]
	        ],

	        engine : [[

	            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
	            ], [VERSION, [NAME, 'EdgeHTML']], [

	            /(presto)\/([\w\.]+)/i,                                             // Presto
	            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
	            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
	            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
	            ], [NAME, VERSION], [

	            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
	            ], [VERSION, NAME]
	        ],

	        os : [[

	            // Windows based
	            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
	            ], [NAME, VERSION], [
	            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
	            /(windows\sphone(?:\sos)*|windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
	            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
	            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
	            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

	            // Mobile/Embedded OS
	            /\((bb)(10);/i                                                      // BlackBerry 10
	            ], [[NAME, 'BlackBerry'], VERSION], [
	            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
	            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
	            /(android|webos|palm\os|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,
	                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
	            /linux;.+(sailfish);/i                                              // Sailfish OS
	            ], [NAME, VERSION], [
	            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
	            ], [[NAME, 'Symbian'], VERSION], [
	            /\((series40);/i                                                    // Series 40
	            ], [NAME], [
	            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
	            ], [[NAME, 'Firefox OS'], VERSION], [

	            // Console
	            /(nintendo|playstation)\s([wids3portablevu]+)/i,                    // Nintendo/Playstation

	            // GNU/Linux based
	            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
	            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
	            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?([\w\.-]+)*/i,
	                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
	                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
	            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
	            /(gnu)\s?([\w\.]+)*/i                                               // GNU
	            ], [NAME, VERSION], [

	            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
	            ], [[NAME, 'Chromium OS'], VERSION],[

	            // Solaris
	            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
	            ], [[NAME, 'Solaris'], VERSION], [

	            // BSD based
	            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
	            ], [NAME, VERSION],[

	            /(ip[honead]+)(?:.*os\s*([\w]+)*\slike\smac|;\sopera)/i             // iOS
	            ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [

	            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i,
	            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
	            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

	            // Other
	            /((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,                            // Solaris
	            /(haiku)\s(\w+)/i,                                                  // Haiku
	            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
	            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
	                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
	            /(unix)\s?([\w\.]+)*/i                                              // UNIX
	            ], [NAME, VERSION]
	        ]
	    };


	    /////////////////
	    // Constructor
	    ////////////////


	    var UAParser = function (uastring) {

	        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);

	        this.getBrowser = function () {
	            return mapper.rgx.apply(this, regexes.browser);
	        };
	        this.getEngine = function () {
	            return mapper.rgx.apply(this, regexes.engine);
	        };
	        this.getOS = function () {
	            return mapper.rgx.apply(this, regexes.os);
	        };
	        this.getResult = function() {
	            return {
	                ua      : this.getUA(),
	                browser : this.getBrowser(),
	                engine  : this.getEngine(),
	                os      : this.getOS()
	            };
	        };
	        this.getUA = function () {
	            return ua;
	        };
	        this.setUA = function (uastring) {
	            ua = uastring;
	            return this;
	        };
	        this.setUA(ua);
	    };

	    return UAParser;
	})();


	function version_compare(v1, v2, operator) {
	  // From: http://phpjs.org/functions
	  // +      original by: Philippe Jausions (http://pear.php.net/user/jausions)
	  // +      original by: Aidan Lister (http://aidanlister.com/)
	  // + reimplemented by: Kankrelune (http://www.webfaktory.info/)
	  // +      improved by: Brett Zamir (http://brett-zamir.me)
	  // +      improved by: Scott Baker
	  // +      improved by: Theriault
	  // *        example 1: version_compare('8.2.5rc', '8.2.5a');
	  // *        returns 1: 1
	  // *        example 2: version_compare('8.2.50', '8.2.52', '<');
	  // *        returns 2: true
	  // *        example 3: version_compare('5.3.0-dev', '5.3.0');
	  // *        returns 3: -1
	  // *        example 4: version_compare('4.1.0.52','4.01.0.51');
	  // *        returns 4: 1

	  // Important: compare must be initialized at 0.
	  var i = 0,
	    x = 0,
	    compare = 0,
	    // vm maps textual PHP versions to negatives so they're less than 0.
	    // PHP currently defines these as CASE-SENSITIVE. It is important to
	    // leave these as negatives so that they can come before numerical versions
	    // and as if no letters were there to begin with.
	    // (1alpha is < 1 and < 1.1 but > 1dev1)
	    // If a non-numerical value can't be mapped to this table, it receives
	    // -7 as its value.
	    vm = {
	      'dev': -6,
	      'alpha': -5,
	      'a': -5,
	      'beta': -4,
	      'b': -4,
	      'RC': -3,
	      'rc': -3,
	      '#': -2,
	      'p': 1,
	      'pl': 1
	    },
	    // This function will be called to prepare each version argument.
	    // It replaces every _, -, and + with a dot.
	    // It surrounds any nonsequence of numbers/dots with dots.
	    // It replaces sequences of dots with a single dot.
	    //    version_compare('4..0', '4.0') == 0
	    // Important: A string of 0 length needs to be converted into a value
	    // even less than an unexisting value in vm (-7), hence [-8].
	    // It's also important to not strip spaces because of this.
	    //   version_compare('', ' ') == 1
	    prepVersion = function (v) {
	      v = ('' + v).replace(/[_\-+]/g, '.');
	      v = v.replace(/([^.\d]+)/g, '.$1.').replace(/\.{2,}/g, '.');
	      return (!v.length ? [-8] : v.split('.'));
	    },
	    // This converts a version component to a number.
	    // Empty component becomes 0.
	    // Non-numerical component becomes a negative number.
	    // Numerical component becomes itself as an integer.
	    numVersion = function (v) {
	      return !v ? 0 : (isNaN(v) ? vm[v] || -7 : parseInt(v, 10));
	    };

	  v1 = prepVersion(v1);
	  v2 = prepVersion(v2);
	  x = Math.max(v1.length, v2.length);
	  for (i = 0; i < x; i++) {
	    if (v1[i] == v2[i]) {
	      continue;
	    }
	    v1[i] = numVersion(v1[i]);
	    v2[i] = numVersion(v2[i]);
	    if (v1[i] < v2[i]) {
	      compare = -1;
	      break;
	    } else if (v1[i] > v2[i]) {
	      compare = 1;
	      break;
	    }
	  }
	  if (!operator) {
	    return compare;
	  }

	  // Important: operator is CASE-SENSITIVE.
	  // "No operator" seems to be treated as "<."
	  // Any other values seem to make the function return null.
	  switch (operator) {
	  case '>':
	  case 'gt':
	    return (compare > 0);
	  case '>=':
	  case 'ge':
	    return (compare >= 0);
	  case '<=':
	  case 'le':
	    return (compare <= 0);
	  case '==':
	  case '=':
	  case 'eq':
	    return (compare === 0);
	  case '<>':
	  case '!=':
	  case 'ne':
	    return (compare !== 0);
	  case '':
	  case '<':
	  case 'lt':
	    return (compare < 0);
	  default:
	    return null;
	  }
	}


	var can = (function() {
		var caps = {
				define_property: (function() {
					/* // currently too much extra code required, not exactly worth it
					try { // as of IE8, getters/setters are supported only on DOM elements
						var obj = {};
						if (Object.defineProperty) {
							Object.defineProperty(obj, 'prop', {
								enumerable: true,
								configurable: true
							});
							return true;
						}
					} catch(ex) {}

					if (Object.prototype.__defineGetter__ && Object.prototype.__defineSetter__) {
						return true;
					}*/
					return false;
				}()),

				create_canvas: (function() {
					// On the S60 and BB Storm, getContext exists, but always returns undefined
					// so we actually have to call getContext() to verify
					// github.com/Modernizr/Modernizr/issues/issue/97/
					var el = document.createElement('canvas');
					return !!(el.getContext && el.getContext('2d'));
				}()),

				return_response_type: function(responseType) {
					try {
						if (Basic.inArray(responseType, ['', 'text', 'document']) !== -1) {
							return true;
						} else if (window.XMLHttpRequest) {
							var xhr = new XMLHttpRequest();
							xhr.open('get', '/'); // otherwise Gecko throws an exception
							if ('responseType' in xhr) {
								xhr.responseType = responseType;
								// as of 23.0.1271.64, Chrome switched from throwing exception to merely logging it to the console (why? o why?)
								if (xhr.responseType !== responseType) {
									return false;
								}
								return true;
							}
						}
					} catch (ex) {}
					return false;
				},

				// ideas for this heavily come from Modernizr (http://modernizr.com/)
				use_data_uri: (function() {
					var du = new Image();

					du.onload = function() {
						caps.use_data_uri = (du.width === 1 && du.height === 1);
					};
					
					setTimeout(function() {
						du.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP8AAAAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==";
					}, 1);
					return false;
				}()),

				use_data_uri_over32kb: function() { // IE8
					return caps.use_data_uri && (Env.browser !== 'IE' || Env.version >= 9);
				},

				use_data_uri_of: function(bytes) {
					return (caps.use_data_uri && bytes < 33000 || caps.use_data_uri_over32kb());
				},

				use_fileinput: function() {
					if (navigator.userAgent.match(/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\/(1.0|2.0|2.5|3.0))/)) {
						return false;
					}

					var el = document.createElement('input');
					el.setAttribute('type', 'file');
					return !el.disabled;
				}
			};

		return function(cap) {
			var args = [].slice.call(arguments);
			args.shift(); // shift of cap
			return Basic.typeOf(caps[cap]) === 'function' ? caps[cap].apply(this, args) : !!caps[cap];
		};
	}());


	var uaResult = new UAParser().getResult();


	var Env = {
		can: can,

		uaParser: UAParser,
		
		browser: uaResult.browser.name,
		version: uaResult.browser.version,
		os: uaResult.os.name, // everybody intuitively types it in a lowercase for some reason
		osVersion: uaResult.os.version,

		verComp: version_compare,
		
		swf_url: "../flash/Moxie.swf",
		xap_url: "../silverlight/Moxie.xap",
		global_event_dispatcher: "moxie.core.EventTarget.instance.dispatchEvent"
	};

	// for backward compatibility
	// @deprecated Use `Env.os` instead
	Env.OS = Env.os;

	if (MXI_DEBUG) {
		Env.debug = {
			runtime: true,
			events: false
		};

		Env.log = function() {
			
			function logObj(data) {
				// TODO: this should recursively print out the object in a pretty way
				console.appendChild(document.createTextNode(data + "\n"));
			}

			var data = arguments[0];

			if (Basic.typeOf(data) === 'string') {
				data = Basic.sprintf.apply(this, arguments);
			}

			if (window && window.console && window.console.log) {
				window.console.log(data);
			} else if (document) {
				var console = document.getElementById('moxie-console');
				if (!console) {
					console = document.createElement('pre');
					console.id = 'moxie-console';
					//console.style.display = 'none';
					document.body.appendChild(console);
				}

				if (Basic.inArray(Basic.typeOf(data), ['object', 'array']) !== -1) {
					logObj(data);
				} else {
					console.appendChild(document.createTextNode(data + "\n"));
				}
			}
		};
	}

	return Env;
});

// Included from: src/javascript/core/Exceptions.js

/**
 * Exceptions.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/Exceptions', [
	'moxie/core/utils/Basic'
], function(Basic) {
	
	function _findKey(obj, value) {
		var key;
		for (key in obj) {
			if (obj[key] === value) {
				return key;
			}
		}
		return null;
	}

	/**
	@class moxie/core/Exception
	*/
	return {
		RuntimeError: (function() {
			var namecodes = {
				NOT_INIT_ERR: 1,
				EXCEPTION_ERR: 3,
				NOT_SUPPORTED_ERR: 9,
				JS_ERR: 4
			};

			function RuntimeError(code, message) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + (message || ": RuntimeError " + this.code);
			}
			
			Basic.extend(RuntimeError, namecodes);
			RuntimeError.prototype = Error.prototype;
			return RuntimeError;
		}()),
		
		OperationNotAllowedException: (function() {
			
			function OperationNotAllowedException(code) {
				this.code = code;
				this.name = 'OperationNotAllowedException';
			}
			
			Basic.extend(OperationNotAllowedException, {
				NOT_ALLOWED_ERR: 1
			});
			
			OperationNotAllowedException.prototype = Error.prototype;
			
			return OperationNotAllowedException;
		}()),

		ImageError: (function() {
			var namecodes = {
				WRONG_FORMAT: 1,
				MAX_RESOLUTION_ERR: 2,
				INVALID_META_ERR: 3
			};

			function ImageError(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": ImageError " + this.code;
			}
			
			Basic.extend(ImageError, namecodes);
			ImageError.prototype = Error.prototype;

			return ImageError;
		}()),

		FileException: (function() {
			var namecodes = {
				NOT_FOUND_ERR: 1,
				SECURITY_ERR: 2,
				ABORT_ERR: 3,
				NOT_READABLE_ERR: 4,
				ENCODING_ERR: 5,
				NO_MODIFICATION_ALLOWED_ERR: 6,
				INVALID_STATE_ERR: 7,
				SYNTAX_ERR: 8
			};

			function FileException(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": FileException " + this.code;
			}
			
			Basic.extend(FileException, namecodes);
			FileException.prototype = Error.prototype;
			return FileException;
		}()),
		
		DOMException: (function() {
			var namecodes = {
				INDEX_SIZE_ERR: 1,
				DOMSTRING_SIZE_ERR: 2,
				HIERARCHY_REQUEST_ERR: 3,
				WRONG_DOCUMENT_ERR: 4,
				INVALID_CHARACTER_ERR: 5,
				NO_DATA_ALLOWED_ERR: 6,
				NO_MODIFICATION_ALLOWED_ERR: 7,
				NOT_FOUND_ERR: 8,
				NOT_SUPPORTED_ERR: 9,
				INUSE_ATTRIBUTE_ERR: 10,
				INVALID_STATE_ERR: 11,
				SYNTAX_ERR: 12,
				INVALID_MODIFICATION_ERR: 13,
				NAMESPACE_ERR: 14,
				INVALID_ACCESS_ERR: 15,
				VALIDATION_ERR: 16,
				TYPE_MISMATCH_ERR: 17,
				SECURITY_ERR: 18,
				NETWORK_ERR: 19,
				ABORT_ERR: 20,
				URL_MISMATCH_ERR: 21,
				QUOTA_EXCEEDED_ERR: 22,
				TIMEOUT_ERR: 23,
				INVALID_NODE_TYPE_ERR: 24,
				DATA_CLONE_ERR: 25
			};

			function DOMException(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": DOMException " + this.code;
			}
			
			Basic.extend(DOMException, namecodes);
			DOMException.prototype = Error.prototype;
			return DOMException;
		}()),
		
		EventException: (function() {
			function EventException(code) {
				this.code = code;
				this.name = 'EventException';
			}
			
			Basic.extend(EventException, {
				UNSPECIFIED_EVENT_TYPE_ERR: 0
			});
			
			EventException.prototype = Error.prototype;
			
			return EventException;
		}())
	};
});

// Included from: src/javascript/core/utils/Dom.js

/**
 * Dom.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Dom', ['moxie/core/utils/Env'], function(Env) {

	/**
	Get DOM Element by it's id.

	@method get
	@for Utils
	@param {String} id Identifier of the DOM Element
	@return {DOMElement}
	*/
	var get = function(id) {
		if (typeof id !== 'string') {
			return id;
		}
		return document.getElementById(id);
	};

	/**
	Checks if specified DOM element has specified class.

	@method hasClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var hasClass = function(obj, name) {
		if (!obj.className) {
			return false;
		}

		var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");
		return regExp.test(obj.className);
	};

	/**
	Adds specified className to specified DOM element.

	@method addClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var addClass = function(obj, name) {
		if (!hasClass(obj, name)) {
			obj.className = !obj.className ? name : obj.className.replace(/\s+$/, '') + ' ' + name;
		}
	};

	/**
	Removes specified className from specified DOM element.

	@method removeClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var removeClass = function(obj, name) {
		if (obj.className) {
			var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");
			obj.className = obj.className.replace(regExp, function($0, $1, $2) {
				return $1 === ' ' && $2 === ' ' ? ' ' : '';
			});
		}
	};

	/**
	Returns a given computed style of a DOM element.

	@method getStyle
	@static
	@param {Object} obj DOM element like object.
	@param {String} name Style you want to get from the DOM element
	*/
	var getStyle = function(obj, name) {
		if (obj.currentStyle) {
			return obj.currentStyle[name];
		} else if (window.getComputedStyle) {
			return window.getComputedStyle(obj, null)[name];
		}
	};


	/**
	Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.

	@method getPos
	@static
	@param {Element} node HTML element or element id to get x, y position from.
	@param {Element} root Optional root element to stop calculations at.
	@return {object} Absolute position of the specified element object with x, y fields.
	*/
	var getPos = function(node, root) {
		var x = 0, y = 0, parent, doc = document, nodeRect, rootRect;

		node = node;
		root = root || doc.body;

		// Returns the x, y cordinate for an element on IE 6 and IE 7
		function getIEPos(node) {
			var bodyElm, rect, x = 0, y = 0;

			if (node) {
				rect = node.getBoundingClientRect();
				bodyElm = doc.compatMode === "CSS1Compat" ? doc.documentElement : doc.body;
				x = rect.left + bodyElm.scrollLeft;
				y = rect.top + bodyElm.scrollTop;
			}

			return {
				x : x,
				y : y
			};
		}

		// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode
		if (node && node.getBoundingClientRect && Env.browser === 'IE' && (!doc.documentMode || doc.documentMode < 8)) {
			nodeRect = getIEPos(node);
			rootRect = getIEPos(root);

			return {
				x : nodeRect.x - rootRect.x,
				y : nodeRect.y - rootRect.y
			};
		}

		parent = node;
		while (parent && parent != root && parent.nodeType) {
			x += parent.offsetLeft || 0;
			y += parent.offsetTop || 0;
			parent = parent.offsetParent;
		}

		parent = node.parentNode;
		while (parent && parent != root && parent.nodeType) {
			x -= parent.scrollLeft || 0;
			y -= parent.scrollTop || 0;
			parent = parent.parentNode;
		}

		return {
			x : x,
			y : y
		};
	};

	/**
	Returns the size of the specified node in pixels.

	@method getSize
	@static
	@param {Node} node Node to get the size of.
	@return {Object} Object with a w and h property.
	*/
	var getSize = function(node) {
		return {
			w : node.offsetWidth || node.clientWidth,
			h : node.offsetHeight || node.clientHeight
		};
	};

	return {
		get: get,
		hasClass: hasClass,
		addClass: addClass,
		removeClass: removeClass,
		getStyle: getStyle,
		getPos: getPos,
		getSize: getSize
	};
});

// Included from: src/javascript/core/EventTarget.js

/**
 * EventTarget.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/EventTarget', [
	'moxie/core/utils/Env',
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic'
], function(Env, x, Basic) {

	// hash of event listeners by object uid
	var eventpool = {};

	/**
	Parent object for all event dispatching components and objects

	@class moxie/core/EventTarget
	@constructor EventTarget
	*/
	function EventTarget() {
		/**
		Unique id of the event dispatcher, usually overriden by children

		@property uid
		@type String
		*/
		this.uid = Basic.guid();
	}


	Basic.extend(EventTarget.prototype, {

		/**
		Can be called from within a child  in order to acquire uniqie id in automated manner

		@method init
		*/
		init: function() {
			if (!this.uid) {
				this.uid = Basic.guid('uid_');
			}
		},

		/**
		Register a handler to a specific event dispatched by the object

		@method addEventListener
		@param {String} type Type or basically a name of the event to subscribe to
		@param {Function} fn Callback function that will be called when event happens
		@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first
		@param {Object} [scope=this] A scope to invoke event handler in
		*/
		addEventListener: function(type, fn, priority, scope) {
			var self = this, list;

			// without uid no event handlers can be added, so make sure we got one
			if (!this.hasOwnProperty('uid')) {
				this.uid = Basic.guid('uid_');
			}

			type = Basic.trim(type);

			if (/\s/.test(type)) {
				// multiple event types were passed for one handler
				Basic.each(type.split(/\s+/), function(type) {
					self.addEventListener(type, fn, priority, scope);
				});
				return;
			}

			type = type.toLowerCase();
			priority = parseInt(priority, 10) || 0;

			list = eventpool[this.uid] && eventpool[this.uid][type] || [];
			list.push({fn : fn, priority : priority, scope : scope || this});

			if (!eventpool[this.uid]) {
				eventpool[this.uid] = {};
			}
			eventpool[this.uid][type] = list;
		},

		/**
		Check if any handlers were registered to the specified event

		@method hasEventListener
		@param {String} [type] Type or basically a name of the event to check
		@return {Mixed} Returns a handler if it was found and false, if - not
		*/
		hasEventListener: function(type) {
			var list;
			if (type) {
				type = type.toLowerCase();
				list = eventpool[this.uid] && eventpool[this.uid][type];
			} else {
				list = eventpool[this.uid];
			}
			return list ? list : false;
		},

		/**
		Unregister the handler from the event, or if former was not specified - unregister all handlers

		@method removeEventListener
		@param {String} type Type or basically a name of the event
		@param {Function} [fn] Handler to unregister
		*/
		removeEventListener: function(type, fn) {
			var self = this, list, i;

			type = type.toLowerCase();

			if (/\s/.test(type)) {
				// multiple event types were passed for one handler
				Basic.each(type.split(/\s+/), function(type) {
					self.removeEventListener(type, fn);
				});
				return;
			}

			list = eventpool[this.uid] && eventpool[this.uid][type];

			if (list) {
				if (fn) {
					for (i = list.length - 1; i >= 0; i--) {
						if (list[i].fn === fn) {
							list.splice(i, 1);
							break;
						}
					}
				} else {
					list = [];
				}

				// delete event list if it has become empty
				if (!list.length) {
					delete eventpool[this.uid][type];

					// and object specific entry in a hash if it has no more listeners attached
					if (Basic.isEmptyObj(eventpool[this.uid])) {
						delete eventpool[this.uid];
					}
				}
			}
		},

		/**
		Remove all event handlers from the object

		@method removeAllEventListeners
		*/
		removeAllEventListeners: function() {
			if (eventpool[this.uid]) {
				delete eventpool[this.uid];
			}
		},

		/**
		Dispatch the event

		@method dispatchEvent
		@param {String/Object} Type of event or event object to dispatch
		@param {Mixed} [...] Variable number of arguments to be passed to a handlers
		@return {Boolean} true by default and false if any handler returned false
		*/
		dispatchEvent: function(type) {
			var uid, list, args, tmpEvt, evt = {}, result = true, undef;

			if (Basic.typeOf(type) !== 'string') {
				// we can't use original object directly (because of Silverlight)
				tmpEvt = type;

				if (Basic.typeOf(tmpEvt.type) === 'string') {
					type = tmpEvt.type;

					if (tmpEvt.total !== undef && tmpEvt.loaded !== undef) { // progress event
						evt.total = tmpEvt.total;
						evt.loaded = tmpEvt.loaded;
					}
					evt.async = tmpEvt.async || false;
				} else {
					throw new x.EventException(x.EventException.UNSPECIFIED_EVENT_TYPE_ERR);
				}
			}

			// check if event is meant to be dispatched on an object having specific uid
			if (type.indexOf('::') !== -1) {
				(function(arr) {
					uid = arr[0];
					type = arr[1];
				}(type.split('::')));
			} else {
				uid = this.uid;
			}

			type = type.toLowerCase();

			list = eventpool[uid] && eventpool[uid][type];

			if (list) {
				// sort event list by prority
				list.sort(function(a, b) { return b.priority - a.priority; });

				args = [].slice.call(arguments);

				// first argument will be pseudo-event object
				args.shift();
				evt.type = type;
				args.unshift(evt);

				if (MXI_DEBUG && Env.debug.events) {
					Env.log("Event '%s' fired on %u", evt.type, uid);
				}

				// Dispatch event to all listeners
				var queue = [];
				Basic.each(list, function(handler) {
					// explicitly set the target, otherwise events fired from shims do not get it
					args[0].target = handler.scope;
					// if event is marked as async, detach the handler
					if (evt.async) {
						queue.push(function(cb) {
							setTimeout(function() {
								cb(handler.fn.apply(handler.scope, args) === false);
							}, 1);
						});
					} else {
						queue.push(function(cb) {
							cb(handler.fn.apply(handler.scope, args) === false); // if handler returns false stop propagation
						});
					}
				});
				if (queue.length) {
					Basic.inSeries(queue, function(err) {
						result = !err;
					});
				}
			}
			return result;
		},

		/**
		Register a handler to the event type that will run only once

		@method bindOnce
		@since >1.4.1
		@param {String} type Type or basically a name of the event to subscribe to
		@param {Function} fn Callback function that will be called when event happens
		@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first
		@param {Object} [scope=this] A scope to invoke event handler in
		*/
		bindOnce: function(type, fn, priority, scope) {
			var self = this;
			self.bind.call(this, type, function cb() {
				self.unbind(type, cb);
				return fn.apply(this, arguments);
			}, priority, scope);
		},

		/**
		Alias for addEventListener

		@method bind
		@protected
		*/
		bind: function() {
			this.addEventListener.apply(this, arguments);
		},

		/**
		Alias for removeEventListener

		@method unbind
		@protected
		*/
		unbind: function() {
			this.removeEventListener.apply(this, arguments);
		},

		/**
		Alias for removeAllEventListeners

		@method unbindAll
		@protected
		*/
		unbindAll: function() {
			this.removeAllEventListeners.apply(this, arguments);
		},

		/**
		Alias for dispatchEvent

		@method trigger
		@protected
		*/
		trigger: function() {
			return this.dispatchEvent.apply(this, arguments);
		},


		/**
		Handle properties of on[event] type.

		@method handleEventProps
		@private
		*/
		handleEventProps: function(dispatches) {
			var self = this;

			this.bind(dispatches.join(' '), function(e) {
				var prop = 'on' + e.type.toLowerCase();
				if (Basic.typeOf(this[prop]) === 'function') {
					this[prop].apply(this, arguments);
				}
			});

			// object must have defined event properties, even if it doesn't make use of them
			Basic.each(dispatches, function(prop) {
				prop = 'on' + prop.toLowerCase(prop);
				if (Basic.typeOf(self[prop]) === 'undefined') {
					self[prop] = null;
				}
			});
		}

	});


	EventTarget.instance = new EventTarget();

	return EventTarget;
});

// Included from: src/javascript/runtime/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/Runtime', [
	"moxie/core/utils/Env",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/EventTarget"
], function(Env, Basic, Dom, EventTarget) {
	var runtimeConstructors = {}, runtimes = {};

	/**
	Common set of methods and properties for every runtime instance

	@class moxie/runtime/Runtime

	@param {Object} options
	@param {String} type Sanitized name of the runtime
	@param {Object} [caps] Set of capabilities that differentiate specified runtime
	@param {Object} [modeCaps] Set of capabilities that do require specific operational mode
	@param {String} [preferredMode='browser'] Preferred operational mode to choose if no required capabilities were requested
	*/
	function Runtime(options, type, caps, modeCaps, preferredMode) {
		/**
		Dispatched when runtime is initialized and ready.
		Results in RuntimeInit on a connected component.

		@event Init
		*/

		/**
		Dispatched when runtime fails to initialize.
		Results in RuntimeError on a connected component.

		@event Error
		*/

		var self = this
		, _shim
		, _uid = Basic.guid(type + '_')
		, defaultMode = preferredMode || 'browser'
		;

		options = options || {};

		// register runtime in private hash
		runtimes[_uid] = this;

		/**
		Default set of capabilities, which can be redifined later by specific runtime

		@private
		@property caps
		@type Object
		*/
		caps = Basic.extend({
			// Runtime can: 
			// provide access to raw binary data of the file
			access_binary: false,
			// provide access to raw binary data of the image (image extension is optional) 
			access_image_binary: false,
			// display binary data as thumbs for example
			display_media: false,
			// make cross-domain requests
			do_cors: false,
			// accept files dragged and dropped from the desktop
			drag_and_drop: false,
			// filter files in selection dialog by their extensions
			filter_by_extension: true,
			// resize image (and manipulate it raw data of any file in general)
			resize_image: false,
			// periodically report how many bytes of total in the file were uploaded (loaded)
			report_upload_progress: false,
			// provide access to the headers of http response 
			return_response_headers: false,
			// support response of specific type, which should be passed as an argument
			// e.g. runtime.can('return_response_type', 'blob')
			return_response_type: false,
			// return http status code of the response
			return_status_code: true,
			// send custom http header with the request
			send_custom_headers: false,
			// pick up the files from a dialog
			select_file: false,
			// select whole folder in file browse dialog
			select_folder: false,
			// select multiple files at once in file browse dialog
			select_multiple: true,
			// send raw binary data, that is generated after image resizing or manipulation of other kind
			send_binary_string: false,
			// send cookies with http request and therefore retain session
			send_browser_cookies: true,
			// send data formatted as multipart/form-data
			send_multipart: true,
			// slice the file or blob to smaller parts
			slice_blob: false,
			// upload file without preloading it to memory, stream it out directly from disk
			stream_upload: false,
			// programmatically trigger file browse dialog
			summon_file_dialog: false,
			// upload file of specific size, size should be passed as argument
			// e.g. runtime.can('upload_filesize', '500mb')
			upload_filesize: true,
			// initiate http request with specific http method, method should be passed as argument
			// e.g. runtime.can('use_http_method', 'put')
			use_http_method: true
		}, caps);
			
	
		// default to the mode that is compatible with preferred caps
		if (options.preferred_caps) {
			defaultMode = Runtime.getMode(modeCaps, options.preferred_caps, defaultMode);
		}

		if (MXI_DEBUG && Env.debug.runtime) {
			Env.log("\tdefault mode: %s", defaultMode);	
		}
		
		// small extension factory here (is meant to be extended with actual extensions constructors)
		_shim = (function() {
			var objpool = {};
			return {
				exec: function(uid, comp, fn, args) {
					if (_shim[comp]) {
						if (!objpool[uid]) {
							objpool[uid] = {
								context: this,
								instance: new _shim[comp]()
							};
						}
						if (objpool[uid].instance[fn]) {
							return objpool[uid].instance[fn].apply(this, args);
						}
					}
				},

				removeInstance: function(uid) {
					delete objpool[uid];
				},

				removeAllInstances: function() {
					var self = this;
					Basic.each(objpool, function(obj, uid) {
						if (Basic.typeOf(obj.instance.destroy) === 'function') {
							obj.instance.destroy.call(obj.context);
						}
						self.removeInstance(uid);
					});
				}
			};
		}());


		// public methods
		Basic.extend(this, {
			/**
			Specifies whether runtime instance was initialized or not

			@property initialized
			@type {Boolean}
			@default false
			*/
			initialized: false, // shims require this flag to stop initialization retries

			/**
			Unique ID of the runtime

			@property uid
			@type {String}
			*/
			uid: _uid,

			/**
			Runtime type (e.g. flash, html5, etc)

			@property type
			@type {String}
			*/
			type: type,

			/**
			Runtime (not native one) may operate in browser or client mode.

			@property mode
			@private
			@type {String|Boolean} current mode or false, if none possible
			*/
			mode: Runtime.getMode(modeCaps, (options.required_caps), defaultMode),

			/**
			id of the DOM container for the runtime (if available)

			@property shimid
			@type {String}
			*/
			shimid: _uid + '_container',

			/**
			Number of connected clients. If equal to zero, runtime can be destroyed

			@property clients
			@type {Number}
			*/
			clients: 0,

			/**
			Runtime initialization options

			@property options
			@type {Object}
			*/
			options: options,

			/**
			Checks if the runtime has specific capability

			@method can
			@param {String} cap Name of capability to check
			@param {Mixed} [value] If passed, capability should somehow correlate to the value
			@param {Object} [refCaps] Set of capabilities to check the specified cap against (defaults to internal set)
			@return {Boolean} true if runtime has such capability and false, if - not
			*/
			can: function(cap, value) {
				var refCaps = arguments[2] || caps;

				// if cap var is a comma-separated list of caps, convert it to object (key/value)
				if (Basic.typeOf(cap) === 'string' && Basic.typeOf(value) === 'undefined') {
					cap = Runtime.parseCaps(cap);
				}

				if (Basic.typeOf(cap) === 'object') {
					for (var key in cap) {
						if (!this.can(key, cap[key], refCaps)) {
							return false;
						}
					}
					return true;
				}

				// check the individual cap
				if (Basic.typeOf(refCaps[cap]) === 'function') {
					return refCaps[cap].call(this, value);
				} else {
					return (value === refCaps[cap]);
				}
			},

			/**
			Returns container for the runtime as DOM element

			@method getShimContainer
			@return {DOMElement}
			*/
			getShimContainer: function() {
				var container, shimContainer = Dom.get(this.shimid);

				// if no container for shim, create one
				if (!shimContainer) {
					container = Dom.get(this.options.container) || document.body;

					// create shim container and insert it at an absolute position into the outer container
					shimContainer = document.createElement('div');
					shimContainer.id = this.shimid;
					shimContainer.className = 'moxie-shim moxie-shim-' + this.type;

					Basic.extend(shimContainer.style, {
						position: 'absolute',
						top: '0px',
						left: '0px',
						width: '1px',
						height: '1px',
						overflow: 'hidden'
					});

					container.appendChild(shimContainer);
					container = null;
				}

				return shimContainer;
			},

			/**
			Returns runtime as DOM element (if appropriate)

			@method getShim
			@return {DOMElement}
			*/
			getShim: function() {
				return _shim;
			},

			/**
			Invokes a method within the runtime itself (might differ across the runtimes)

			@method shimExec
			@param {Mixed} []
			@protected
			@return {Mixed} Depends on the action and component
			*/
			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return self.getShim().exec.call(this, this.uid, component, action, args);
			},

			/**
			Operaional interface that is used by components to invoke specific actions on the runtime
			(is invoked in the scope of component)

			@method exec
			@param {Mixed} []*
			@protected
			@return {Mixed} Depends on the action and component
			*/
			exec: function(component, action) { // this is called in the context of component, not runtime
				var args = [].slice.call(arguments, 2);

				if (self[component] && self[component][action]) {
					return self[component][action].apply(this, args);
				}
				return self.shimExec.apply(this, arguments);
			},

			/**
			Destroys the runtime (removes all events and deletes DOM structures)

			@method destroy
			*/
			destroy: function() {
				if (!self) {
					return; // obviously already destroyed
				}

				var shimContainer = Dom.get(this.shimid);
				if (shimContainer) {
					shimContainer.parentNode.removeChild(shimContainer);
				}

				if (_shim) {
					_shim.removeAllInstances();
				}

				this.unbindAll();
				delete runtimes[this.uid];
				this.uid = null; // mark this runtime as destroyed
				_uid = self = _shim = shimContainer = null;
			}
		});

		// once we got the mode, test against all caps
		if (this.mode && options.required_caps && !this.can(options.required_caps)) {
			this.mode = false;
		}	
	}


	/**
	Default order to try different runtime types

	@property order
	@type String
	@static
	*/
	Runtime.order = 'html5,flash,silverlight,html4';


	/**
	Retrieves runtime from private hash by it's uid

	@method getRuntime
	@private
	@static
	@param {String} uid Unique identifier of the runtime
	@return {Runtime|Boolean} Returns runtime, if it exists and false, if - not
	*/
	Runtime.getRuntime = function(uid) {
		return runtimes[uid] ? runtimes[uid] : false;
	};


	/**
	Register constructor for the Runtime of new (or perhaps modified) type

	@method addConstructor
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@param {Function} construct Constructor for the Runtime type
	*/
	Runtime.addConstructor = function(type, constructor) {
		constructor.prototype = EventTarget.instance;
		runtimeConstructors[type] = constructor;
	};


	/**
	Get the constructor for the specified type.

	method getConstructor
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@return {Function} Constructor for the Runtime type
	*/
	Runtime.getConstructor = function(type) {
		return runtimeConstructors[type] || null;
	};


	/**
	Get info about the runtime (uid, type, capabilities)

	@method getInfo
	@static
	@param {String} uid Unique identifier of the runtime
	@return {Mixed} Info object or null if runtime doesn't exist
	*/
	Runtime.getInfo = function(uid) {
		var runtime = Runtime.getRuntime(uid);

		if (runtime) {
			return {
				uid: runtime.uid,
				type: runtime.type,
				mode: runtime.mode,
				can: function() {
					return runtime.can.apply(runtime, arguments);
				}
			};
		}
		return null;
	};


	/**
	Convert caps represented by a comma-separated string to the object representation.

	@method parseCaps
	@static
	@param {String} capStr Comma-separated list of capabilities
	@return {Object}
	*/
	Runtime.parseCaps = function(capStr) {
		var capObj = {};

		if (Basic.typeOf(capStr) !== 'string') {
			return capStr || {};
		}

		Basic.each(capStr.split(','), function(key) {
			capObj[key] = true; // we assume it to be - true
		});

		return capObj;
	};

	/**
	Test the specified runtime for specific capabilities.

	@method can
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@param {String|Object} caps Set of capabilities to check
	@return {Boolean} Result of the test
	*/
	Runtime.can = function(type, caps) {
		var runtime
		, constructor = Runtime.getConstructor(type)
		, mode
		;
		if (constructor) {
			runtime = new constructor({
				required_caps: caps
			});
			mode = runtime.mode;
			runtime.destroy();
			return !!mode;
		}
		return false;
	};


	/**
	Figure out a runtime that supports specified capabilities.

	@method thatCan
	@static
	@param {String|Object} caps Set of capabilities to check
	@param {String} [runtimeOrder] Comma-separated list of runtimes to check against
	@return {String} Usable runtime identifier or null
	*/
	Runtime.thatCan = function(caps, runtimeOrder) {
		var types = (runtimeOrder || Runtime.order).split(/\s*,\s*/);
		for (var i in types) {
			if (Runtime.can(types[i], caps)) {
				return types[i];
			}
		}
		return null;
	};


	/**
	Figure out an operational mode for the specified set of capabilities.

	@method getMode
	@static
	@param {Object} modeCaps Set of capabilities that depend on particular runtime mode
	@param {Object} [requiredCaps] Supplied set of capabilities to find operational mode for
	@param {String|Boolean} [defaultMode='browser'] Default mode to use 
	@return {String|Boolean} Compatible operational mode
	*/
	Runtime.getMode = function(modeCaps, requiredCaps, defaultMode) {
		var mode = null;

		if (Basic.typeOf(defaultMode) === 'undefined') { // only if not specified
			defaultMode = 'browser';
		}

		if (requiredCaps && !Basic.isEmptyObj(modeCaps)) {
			// loop over required caps and check if they do require the same mode
			Basic.each(requiredCaps, function(value, cap) {
				if (modeCaps.hasOwnProperty(cap)) {
					var capMode = modeCaps[cap](value);

					// make sure we always have an array
					if (typeof(capMode) === 'string') {
						capMode = [capMode];
					}
					
					if (!mode) {
						mode = capMode;						
					} else if (!(mode = Basic.arrayIntersect(mode, capMode))) {
						// if cap requires conflicting mode - runtime cannot fulfill required caps

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("\t\t%c: %v (conflicting mode requested: %s)", cap, value, capMode);	
						}

						return (mode = false);
					}					
				}

				if (MXI_DEBUG && Env.debug.runtime) {
					Env.log("\t\t%c: %v (compatible modes: %s)", cap, value, mode);	
				}
			});

			if (mode) {
				return Basic.inArray(defaultMode, mode) !== -1 ? defaultMode : mode[0];
			} else if (mode === false) {
				return false;
			}
		}
		return defaultMode; 
	};


	/**
	Capability check that always returns true

	@private
	@static
	@return {True}
	*/
	Runtime.capTrue = function() {
		return true;
	};

	/**
	Capability check that always returns false

	@private
	@static
	@return {False}
	*/
	Runtime.capFalse = function() {
		return false;
	};

	/**
	Evaluate the expression to boolean value and create a function that always returns it.

	@private
	@static
	@param {Mixed} expr Expression to evaluate
	@return {Function} Function returning the result of evaluation
	*/
	Runtime.capTest = function(expr) {
		return function() {
			return !!expr;
		};
	};

	return Runtime;
});

// Included from: src/javascript/runtime/RuntimeClient.js

/**
 * RuntimeClient.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/RuntimeClient', [
	'moxie/core/utils/Env',
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic',
	'moxie/runtime/Runtime'
], function(Env, x, Basic, Runtime) {
	/**
	Set of methods and properties, required by a component to acquire ability to connect to a runtime

	@class moxie/runtime/RuntimeClient
	*/
	return function RuntimeClient() {
		var runtime;

		Basic.extend(this, {
			/**
			Connects to the runtime specified by the options. Will either connect to existing runtime or create a new one.
			Increments number of clients connected to the specified runtime.

			@private
			@method connectRuntime
			@param {Mixed} options Can be a runtme uid or a set of key-value pairs defining requirements and pre-requisites
			*/
			connectRuntime: function(options) {
				var comp = this, ruid;

				function initialize(items) {
					var type, constructor;

					// if we ran out of runtimes
					if (!items.length) {
						comp.trigger('RuntimeError', new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));
						runtime = null;
						return;
					}

					type = items.shift().toLowerCase();
					constructor = Runtime.getConstructor(type);
					if (!constructor) {
						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Constructor for '%s' runtime is not available.", type);
						}
						initialize(items);
						return;
					}

					if (MXI_DEBUG && Env.debug.runtime) {
						Env.log("Trying runtime: %s", type);
						Env.log(options);
					}

					// try initializing the runtime
					runtime = new constructor(options);

					runtime.bind('Init', function() {
						// mark runtime as initialized
						runtime.initialized = true;

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Runtime '%s' initialized", runtime.type);
						}

						// jailbreak ...
						setTimeout(function() {
							runtime.clients++;
							comp.ruid = runtime.uid;
							// this will be triggered on component
							comp.trigger('RuntimeInit', runtime);
						}, 1);
					});

					runtime.bind('Error', function() {
						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Runtime '%s' failed to initialize", runtime.type);
						}

						runtime.destroy(); // runtime cannot destroy itself from inside at a right moment, thus we do it here
						initialize(items);
					});

					runtime.bind('Exception', function(e, err) {
						var message = err.name + "(#" + err.code + ")" + (err.message ? ", from: " + err.message : '');
						
						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Runtime '%s' has thrown an exception: %s", this.type, message);
						}
						comp.trigger('RuntimeError', new x.RuntimeError(x.RuntimeError.EXCEPTION_ERR, message));
					});

					if (MXI_DEBUG && Env.debug.runtime) {
						Env.log("\tselected mode: %s", runtime.mode);	
					}

					// check if runtime managed to pick-up operational mode
					if (!runtime.mode) {
						runtime.trigger('Error');
						return;
					}

					runtime.init();
				}

				// check if a particular runtime was requested
				if (Basic.typeOf(options) === 'string') {
					ruid = options;
				} else if (Basic.typeOf(options.ruid) === 'string') {
					ruid = options.ruid;
				}

				if (ruid) {
					runtime = Runtime.getRuntime(ruid);
					if (runtime) {
						comp.ruid = ruid;
						runtime.clients++;
						return runtime;
					} else {
						// there should be a runtime and there's none - weird case
						throw new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR);
					}
				}

				// initialize a fresh one, that fits runtime list and required features best
				initialize((options.runtime_order || Runtime.order).split(/\s*,\s*/));
			},


			/**
			Disconnects from the runtime. Decrements number of clients connected to the specified runtime.

			@private
			@method disconnectRuntime
			*/
			disconnectRuntime: function() {
				if (runtime && --runtime.clients <= 0) {
					runtime.destroy();
				}

				// once the component is disconnected, it shouldn't have access to the runtime
				runtime = null;
			},


			/**
			Returns the runtime to which the client is currently connected.

			@method getRuntime
			@return {Runtime} Runtime or null if client is not connected
			*/
			getRuntime: function() {
				if (runtime && runtime.uid) {
					return runtime;
				}
				return runtime = null; // make sure we do not leave zombies rambling around
			},


			/**
			Handy shortcut to safely invoke runtime extension methods.
			
			@private
			@method exec
			@return {Mixed} Whatever runtime extension method returns
			*/
			exec: function() {
				return runtime ? runtime.exec.apply(this, arguments) : null;
			},


			/**
			Test runtime client for specific capability
			
			@method can
			@param {String} cap
			@return {Bool}
			*/
			can: function(cap) {
				return runtime ? runtime.can(cap) : false;
			}

		});
	};


});

// Included from: src/javascript/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/Blob', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Encode',
	'moxie/runtime/RuntimeClient'
], function(Basic, Encode, RuntimeClient) {
	
	var blobpool = {};

	/**
	@class moxie/file/Blob
	@constructor
	@param {String} ruid Unique id of the runtime, to which this blob belongs to
	@param {Object} blob Object "Native" blob object, as it is represented in the runtime
	*/
	function Blob(ruid, blob) {

		function _sliceDetached(start, end, type) {
			var blob, data = blobpool[this.uid];

			if (Basic.typeOf(data) !== 'string' || !data.length) {
				return null; // or throw exception
			}

			blob = new Blob(null, {
				type: type,
				size: end - start
			});
			blob.detach(data.substr(start, blob.size));

			return blob;
		}

		RuntimeClient.call(this);

		if (ruid) {	
			this.connectRuntime(ruid);
		}

		if (!blob) {
			blob = {};
		} else if (Basic.typeOf(blob) === 'string') { // dataUrl or binary string
			blob = { data: blob };
		}

		Basic.extend(this, {
			
			/**
			Unique id of the component

			@property uid
			@type {String}
			*/
			uid: blob.uid || Basic.guid('uid_'),
			
			/**
			Unique id of the connected runtime, if falsy, then runtime will have to be initialized 
			before this Blob can be used, modified or sent

			@property ruid
			@type {String}
			*/
			ruid: ruid,
	
			/**
			Size of blob

			@property size
			@type {Number}
			@default 0
			*/
			size: blob.size || 0,
			
			/**
			Mime type of blob

			@property type
			@type {String}
			@default ''
			*/
			type: blob.type || '',
			
			/**
			@method slice
			@param {Number} [start=0]
			*/
			slice: function(start, end, type) {		
				if (this.isDetached()) {
					return _sliceDetached.apply(this, arguments);
				}
				return this.getRuntime().exec.call(this, 'Blob', 'slice', this.getSource(), start, end, type);
			},

			/**
			Returns "native" blob object (as it is represented in connected runtime) or null if not found

			@method getSource
			@return {Blob} Returns "native" blob object or null if not found
			*/
			getSource: function() {
				if (!blobpool[this.uid]) {
					return null;	
				}
				return blobpool[this.uid];
			},

			/** 
			Detaches blob from any runtime that it depends on and initialize with standalone value

			@method detach
			@protected
			@param {DOMString} [data=''] Standalone value
			*/
			detach: function(data) {
				if (this.ruid) {
					this.getRuntime().exec.call(this, 'Blob', 'destroy');
					this.disconnectRuntime();
					this.ruid = null;
				}

				data = data || '';

				// if dataUrl, convert to binary string
				if (data.substr(0, 5) == 'data:') {
					var base64Offset = data.indexOf(';base64,');
					this.type = data.substring(5, base64Offset);
					data = Encode.atob(data.substring(base64Offset + 8));
				}

				this.size = data.length;

				blobpool[this.uid] = data;
			},

			/**
			Checks if blob is standalone (detached of any runtime)
			
			@method isDetached
			@protected
			@return {Boolean}
			*/
			isDetached: function() {
				return !this.ruid && Basic.typeOf(blobpool[this.uid]) === 'string';
			},
			
			/** 
			Destroy Blob and free any resources it was using

			@method destroy
			*/
			destroy: function() {
				this.detach();
				delete blobpool[this.uid];
			}
		});

		
		if (blob.data) {
			this.detach(blob.data); // auto-detach if payload has been passed
		} else {
			blobpool[this.uid] = blob;	
		}
	}
	
	return Blob;
});

// Included from: src/javascript/core/I18n.js

/**
 * I18n.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/I18n", [
	"moxie/core/utils/Basic"
], function(Basic) {
	var i18n = {};

	/**
	@class moxie/core/I18n
	*/
	return {
		/**
		 * Extends the language pack object with new items.
		 *
		 * @param {Object} pack Language pack items to add.
		 * @return {Object} Extended language pack object.
		 */
		addI18n: function(pack) {
			return Basic.extend(i18n, pack);
		},

		/**
		 * Translates the specified string by checking for the english string in the language pack lookup.
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		translate: function(str) {
			return i18n[str] || str;
		},

		/**
		 * Shortcut for translate function
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		_: function(str) {
			return this.translate(str);
		},

		/**
		 * Pseudo sprintf implementation - simple way to replace tokens with specified values.
		 *
		 * @param {String} str String with tokens
		 * @return {String} String with replaced tokens
		 */
		sprintf: function(str) {
			var args = [].slice.call(arguments, 1);

			return str.replace(/%[a-z]/g, function() {
				var value = args.shift();
				return Basic.typeOf(value) !== 'undefined' ? value : '';
			});
		}
	};
});

// Included from: src/javascript/core/utils/Mime.js

/**
 * Mime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/utils/Mime", [
	"moxie/core/utils/Basic",
	"moxie/core/I18n"
], function(Basic, I18n) {
	
	var mimeData = "" +
		"application/msword,doc dot," +
		"application/pdf,pdf," +
		"application/pgp-signature,pgp," +
		"application/postscript,ps ai eps," +
		"application/rtf,rtf," +
		"application/vnd.ms-excel,xls xlb," +
		"application/vnd.ms-powerpoint,ppt pps pot," +
		"application/zip,zip," +
		"application/x-shockwave-flash,swf swfl," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document,docx," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template,dotx," +
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,xlsx," +
		"application/vnd.openxmlformats-officedocument.presentationml.presentation,pptx," +
		"application/vnd.openxmlformats-officedocument.presentationml.template,potx," +
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow,ppsx," +
		"application/x-javascript,js," +
		"application/json,json," +
		"audio/mpeg,mp3 mpga mpega mp2," +
		"audio/x-wav,wav," +
		"audio/x-m4a,m4a," +
		"audio/ogg,oga ogg," +
		"audio/aiff,aiff aif," +
		"audio/flac,flac," +
		"audio/aac,aac," +
		"audio/ac3,ac3," +
		"audio/x-ms-wma,wma," +
		"image/bmp,bmp," +
		"image/gif,gif," +
		"image/jpeg,jpg jpeg jpe," +
		"image/photoshop,psd," +
		"image/png,png," +
		"image/svg+xml,svg svgz," +
		"image/tiff,tiff tif," +
		"text/plain,asc txt text diff log," +
		"text/html,htm html xhtml," +
		"text/css,css," +
		"text/csv,csv," +
		"text/rtf,rtf," +
		"video/mpeg,mpeg mpg mpe m2v," +
		"video/quicktime,qt mov," +
		"video/mp4,mp4," +
		"video/x-m4v,m4v," +
		"video/x-flv,flv," +
		"video/x-ms-wmv,wmv," +
		"video/avi,avi," +
		"video/webm,webm," +
		"video/3gpp,3gpp 3gp," +
		"video/3gpp2,3g2," +
		"video/vnd.rn-realvideo,rv," +
		"video/ogg,ogv," + 
		"video/x-matroska,mkv," +
		"application/vnd.oasis.opendocument.formula-template,otf," +
		"application/octet-stream,exe";
	
	
	var Mime = {

		mimes: {},

		extensions: {},

		// Parses the default mime types string into a mimes and extensions lookup maps
		addMimeType: function (mimeData) {
			var items = mimeData.split(/,/), i, ii, ext;
			
			for (i = 0; i < items.length; i += 2) {
				ext = items[i + 1].split(/ /);

				// extension to mime lookup
				for (ii = 0; ii < ext.length; ii++) {
					this.mimes[ext[ii]] = items[i];
				}
				// mime to extension lookup
				this.extensions[items[i]] = ext;
			}
		},


		extList2mimes: function (filters, addMissingExtensions) {
			var self = this, ext, i, ii, type, mimes = [];
			
			// convert extensions to mime types list
			for (i = 0; i < filters.length; i++) {
				ext = filters[i].extensions.toLowerCase().split(/\s*,\s*/);

				for (ii = 0; ii < ext.length; ii++) {
					
					// if there's an asterisk in the list, then accept attribute is not required
					if (ext[ii] === '*') {
						return [];
					}

					type = self.mimes[ext[ii]];

					// future browsers should filter by extension, finally
					if (addMissingExtensions && /^\w+$/.test(ext[ii])) {
						mimes.push('.' + ext[ii]);
					} else if (type && Basic.inArray(type, mimes) === -1) {
						mimes.push(type);
					} else if (!type) {
						// if we have no type in our map, then accept all
						return [];
					}
				}
			}
			return mimes;
		},


		mimes2exts: function(mimes) {
			var self = this, exts = [];
			
			Basic.each(mimes, function(mime) {
				mime = mime.toLowerCase();

				if (mime === '*') {
					exts = [];
					return false;
				}

				// check if this thing looks like mime type
				var m = mime.match(/^(\w+)\/(\*|\w+)$/);
				if (m) {
					if (m[2] === '*') { 
						// wildcard mime type detected
						Basic.each(self.extensions, function(arr, mime) {
							if ((new RegExp('^' + m[1] + '/')).test(mime)) {
								[].push.apply(exts, self.extensions[mime]);
							}
						});
					} else if (self.extensions[mime]) {
						[].push.apply(exts, self.extensions[mime]);
					}
				}
			});
			return exts;
		},


		mimes2extList: function(mimes) {
			var accept = [], exts = [];

			if (Basic.typeOf(mimes) === 'string') {
				mimes = Basic.trim(mimes).split(/\s*,\s*/);
			}

			exts = this.mimes2exts(mimes);
			
			accept.push({
				title: I18n.translate('Files'),
				extensions: exts.length ? exts.join(',') : '*'
			});
			
			// save original mimes string
			accept.mimes = mimes;

			return accept;
		},


		getFileExtension: function(fileName) {
			var matches = fileName && fileName.match(/\.([^.]+)$/);
			if (matches) {
				return matches[1].toLowerCase();
			}
			return '';
		},

		getFileMime: function(fileName) {
			return this.mimes[this.getFileExtension(fileName)] || '';
		}
	};

	Mime.addMimeType(mimeData);

	return Mime;
});

// Included from: src/javascript/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileInput', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Env',
	'moxie/core/utils/Mime',
	'moxie/core/utils/Dom',
	'moxie/core/Exceptions',
	'moxie/core/EventTarget',
	'moxie/core/I18n',
	'moxie/runtime/Runtime',
	'moxie/runtime/RuntimeClient'
], function(Basic, Env, Mime, Dom, x, EventTarget, I18n, Runtime, RuntimeClient) {
	/**
	Provides a convenient way to create cross-browser file-picker. Generates file selection dialog on click,
	converts selected files to _File_ objects, to be used in conjunction with _Image_, preloaded in memory
	with _FileReader_ or uploaded to a server through _XMLHttpRequest_.

	@class moxie/file/FileInput
	@constructor
	@extends EventTarget
	@uses RuntimeClient
	@param {Object|String|DOMElement} options If options is string or node, argument is considered as _browse\_button_.
		@param {String|DOMElement} options.browse_button DOM Element to turn into file picker.
		@param {Array} [options.accept] Array of mime types to accept. By default accepts all.
		@param {Boolean} [options.multiple=false] Enable selection of multiple files.
		@param {Boolean} [options.directory=false] Turn file input into the folder input (cannot be both at the same time).
		@param {String|DOMElement} [options.container] DOM Element to use as a container for file-picker. Defaults to parentNode 
		for _browse\_button_.
		@param {Object|String} [options.required_caps] Set of required capabilities, that chosen runtime must support.

	@example
		<div id="container">
			<a id="file-picker" href="javascript:;">Browse...</a>
		</div>

		<script>
			var fileInput = new mOxie.FileInput({
				browse_button: 'file-picker', // or document.getElementById('file-picker')
				container: 'container',
				accept: [
					{title: "Image files", extensions: "jpg,gif,png"} // accept only images
				],
				multiple: true // allow multiple file selection
			});

			fileInput.onchange = function(e) {
				// do something to files array
				console.info(e.target.files); // or this.files or fileInput.files
			};

			fileInput.init(); // initialize
		</script>
	*/
	var dispatches = [
		/**
		Dispatched when runtime is connected and file-picker is ready to be used.

		@event ready
		@param {Object} event
		*/
		'ready',

		/**
		Dispatched right after [ready](#event_ready) event, and whenever [refresh()](#method_refresh) is invoked. 
		Check [corresponding documentation entry](#method_refresh) for more info.

		@event refresh
		@param {Object} event
		*/

		/**
		Dispatched when selection of files in the dialog is complete.

		@event change
		@param {Object} event
		*/
		'change',

		'cancel', // TODO: might be useful

		/**
		Dispatched when mouse cursor enters file-picker area. Can be used to style element
		accordingly.

		@event mouseenter
		@param {Object} event
		*/
		'mouseenter',

		/**
		Dispatched when mouse cursor leaves file-picker area. Can be used to style element
		accordingly.

		@event mouseleave
		@param {Object} event
		*/
		'mouseleave',

		/**
		Dispatched when functional mouse button is pressed on top of file-picker area.

		@event mousedown
		@param {Object} event
		*/
		'mousedown',

		/**
		Dispatched when functional mouse button is released on top of file-picker area.

		@event mouseup
		@param {Object} event
		*/
		'mouseup'
	];

	function FileInput(options) {
		if (MXI_DEBUG) {
			Env.log("Instantiating FileInput...");	
		}

		var container, browseButton, defaults;

		// if flat argument passed it should be browse_button id
		if (Basic.inArray(Basic.typeOf(options), ['string', 'node']) !== -1) {
			options = { browse_button : options };
		}

		// this will help us to find proper default container
		browseButton = Dom.get(options.browse_button);
		if (!browseButton) {
			// browse button is required
			throw new x.DOMException(x.DOMException.NOT_FOUND_ERR);
		}

		// figure out the options
		defaults = {
			accept: [{
				title: I18n.translate('All Files'),
				extensions: '*'
			}],
			multiple: false,
			required_caps: false,
			container: browseButton.parentNode || document.body
		};
		
		options = Basic.extend({}, defaults, options);

		// convert to object representation
		if (typeof(options.required_caps) === 'string') {
			options.required_caps = Runtime.parseCaps(options.required_caps);
		}
					
		// normalize accept option (could be list of mime types or array of title/extensions pairs)
		if (typeof(options.accept) === 'string') {
			options.accept = Mime.mimes2extList(options.accept);
		}

		container = Dom.get(options.container);
		// make sure we have container
		if (!container) {
			container = document.body;
		}

		// make container relative, if it's not
		if (Dom.getStyle(container, 'position') === 'static') {
			container.style.position = 'relative';
		}

		container = browseButton = null; // IE
						
		RuntimeClient.call(this);
		
		Basic.extend(this, {
			/**
			Unique id of the component

			@property uid
			@protected
			@readOnly
			@type {String}
			@default UID
			*/
			uid: Basic.guid('uid_'),
			
			/**
			Unique id of the connected runtime, if any.

			@property ruid
			@protected
			@type {String}
			*/
			ruid: null,

			/**
			Unique id of the runtime container. Useful to get hold of it for various manipulations.

			@property shimid
			@protected
			@type {String}
			*/
			shimid: null,
			
			/**
			Array of selected mOxie.File objects

			@property files
			@type {Array}
			@default null
			*/
			files: null,

			/**
			Initializes the file-picker, connects it to runtime and dispatches event ready when done.

			@method init
			*/
			init: function() {
				var self = this;

				self.bind('RuntimeInit', function(e, runtime) {
					self.ruid = runtime.uid;
					self.shimid = runtime.shimid;

					self.bind("Ready", function() {
						self.trigger("Refresh");
					}, 999);

					// re-position and resize shim container
					self.bind('Refresh', function() {
						var pos, size, browseButton, shimContainer, zIndex;
						
						browseButton = Dom.get(options.browse_button);
						shimContainer = Dom.get(runtime.shimid); // do not use runtime.getShimContainer(), since it will create container if it doesn't exist

						if (browseButton) {
							pos = Dom.getPos(browseButton, Dom.get(options.container));
							size = Dom.getSize(browseButton);
							zIndex = parseInt(Dom.getStyle(browseButton, 'z-index'), 10) || 0;

							if (shimContainer) {
								Basic.extend(shimContainer.style, {
									top: pos.y + 'px',
									left: pos.x + 'px',
									width: size.w + 'px',
									height: size.h + 'px',
									zIndex: zIndex + 1
								});
							}
						}
						shimContainer = browseButton = null;
					});
					
					runtime.exec.call(self, 'FileInput', 'init', options);
				});

				// runtime needs: options.required_features, options.runtime_order and options.container
				self.connectRuntime(Basic.extend({}, options, {
					required_caps: {
						select_file: true
					}
				}));
			},


			/**
			 * Get current option value by its name
			 *
			 * @method getOption
			 * @param name
			 * @return {Mixed}
			 */
			getOption: function(name) {
				return options[name];
			},


			/**
			 * Sets a new value for the option specified by name
			 *
			 * @method setOption
			 * @param name
			 * @param value
			 */
			setOption: function(name, value) {
				if (!options.hasOwnProperty(name)) {
					return;
				}

				var oldValue = options[name];

				switch (name) {
					case 'accept':
						if (typeof(value) === 'string') {
							value = Mime.mimes2extList(value);
						}
						break;

					case 'container':
					case 'required_caps':
						throw new x.FileException(x.FileException.NO_MODIFICATION_ALLOWED_ERR);
				}

				options[name] = value;
				this.exec('FileInput', 'setOption', name, value);

				this.trigger('OptionChanged', name, value, oldValue);
			},

			/**
			Disables file-picker element, so that it doesn't react to mouse clicks.

			@method disable
			@param {Boolean} [state=true] Disable component if - true, enable if - false
			*/
			disable: function(state) {
				var runtime = this.getRuntime();
				if (runtime) {
					this.exec('FileInput', 'disable', Basic.typeOf(state) === 'undefined' ? true : state);
				}
			},


			/**
			Reposition and resize dialog trigger to match the position and size of browse_button element.

			@method refresh
			*/
			refresh: function() {
				this.trigger("Refresh");
			},


			/**
			Destroy component.

			@method destroy
			*/
			destroy: function() {
				var runtime = this.getRuntime();
				if (runtime) {
					runtime.exec.call(this, 'FileInput', 'destroy');
					this.disconnectRuntime();
				}

				if (Basic.typeOf(this.files) === 'array') {
					// no sense in leaving associated files behind
					Basic.each(this.files, function(file) {
						file.destroy();
					});
				} 
				this.files = null;

				this.unbindAll();
			}
		});

		this.handleEventProps(dispatches);
	}

	FileInput.prototype = EventTarget.instance;

	return FileInput;
});

// Included from: src/javascript/file/File.js

/**
 * File.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/File', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Mime',
	'moxie/file/Blob'
], function(Basic, Mime, Blob) {
	/**
	@class moxie/file/File
	@extends Blob
	@constructor
	@param {String} ruid Unique id of the runtime, to which this blob belongs to
	@param {Object} file Object "Native" file object, as it is represented in the runtime
	*/
	function File(ruid, file) {
		if (!file) { // avoid extra errors in case we overlooked something
			file = {};
		}

		Blob.apply(this, arguments);

		if (!this.type) {
			this.type = Mime.getFileMime(file.name);
		}

		// sanitize file name or generate new one
		var name;
		if (file.name) {
			name = file.name.replace(/\\/g, '/');
			name = name.substr(name.lastIndexOf('/') + 1);
		} else if (this.type) {
			var prefix = this.type.split('/')[0];
			name = Basic.guid((prefix !== '' ? prefix : 'file') + '_');
			
			if (Mime.extensions[this.type]) {
				name += '.' + Mime.extensions[this.type][0]; // append proper extension if possible
			}
		}
		
		
		Basic.extend(this, {
			/**
			File name

			@property name
			@type {String}
			@default UID
			*/
			name: name || Basic.guid('file_'),

			/**
			Relative path to the file inside a directory

			@property relativePath
			@type {String}
			@default ''
			*/
			relativePath: '',
			
			/**
			Date of last modification

			@property lastModifiedDate
			@type {String}
			@default now
			*/
			lastModifiedDate: file.lastModifiedDate || (new Date()).toLocaleString() // Thu Aug 23 2012 19:40:00 GMT+0400 (GET)
		});
	}

	File.prototype = Blob.prototype;

	return File;
});

// Included from: src/javascript/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileDrop', [
	'moxie/core/I18n',
	'moxie/core/utils/Dom',
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic',
	'moxie/core/utils/Env',
	'moxie/file/File',
	'moxie/runtime/RuntimeClient',
	'moxie/core/EventTarget',
	'moxie/core/utils/Mime'
], function(I18n, Dom, x, Basic, Env, File, RuntimeClient, EventTarget, Mime) {
	/**
	Turn arbitrary DOM element to a drop zone accepting files. Converts selected files to _File_ objects, to be used 
	in conjunction with _Image_, preloaded in memory with _FileReader_ or uploaded to a server through 
	_XMLHttpRequest_.

	@example
		<div id="drop_zone">
			Drop files here
		</div>
		<br />
		<div id="filelist"></div>

		<script type="text/javascript">
			var fileDrop = new mOxie.FileDrop('drop_zone'), fileList = mOxie.get('filelist');

			fileDrop.ondrop = function() {
				mOxie.each(this.files, function(file) {
					fileList.innerHTML += '<div>' + file.name + '</div>';
				});
			};

			fileDrop.init();
		</script>

	@class moxie/file/FileDrop
	@constructor
	@extends EventTarget
	@uses RuntimeClient
	@param {Object|String} options If options has typeof string, argument is considered as options.drop_zone
		@param {String|DOMElement} options.drop_zone DOM Element to turn into a drop zone
		@param {Array} [options.accept] Array of mime types to accept. By default accepts all
		@param {Object|String} [options.required_caps] Set of required capabilities, that chosen runtime must support
	*/
	var dispatches = [
		/**
		Dispatched when runtime is connected and drop zone is ready to accept files.

		@event ready
		@param {Object} event
		*/
		'ready', 

		/**
		Dispatched when dragging cursor enters the drop zone.

		@event dragenter
		@param {Object} event
		*/
		'dragenter',

		/**
		Dispatched when dragging cursor leaves the drop zone.

		@event dragleave
		@param {Object} event
		*/
		'dragleave', 

		/**
		Dispatched when file is dropped onto the drop zone.

		@event drop
		@param {Object} event
		*/
		'drop', 

		/**
		Dispatched if error occurs.

		@event error
		@param {Object} event
		*/
		'error'
	];

	function FileDrop(options) {
		if (MXI_DEBUG) {
			Env.log("Instantiating FileDrop...");	
		}

		var self = this, defaults;

		// if flat argument passed it should be drop_zone id
		if (typeof(options) === 'string') {
			options = { drop_zone : options };
		}

		// figure out the options
		defaults = {
			accept: [{
				title: I18n.translate('All Files'),
				extensions: '*'
			}],
			required_caps: {
				drag_and_drop: true
			}
		};
		
		options = typeof(options) === 'object' ? Basic.extend({}, defaults, options) : defaults;

		// this will help us to find proper default container
		options.container = Dom.get(options.drop_zone) || document.body;

		// make container relative, if it is not
		if (Dom.getStyle(options.container, 'position') === 'static') {
			options.container.style.position = 'relative';
		}
					
		// normalize accept option (could be list of mime types or array of title/extensions pairs)
		if (typeof(options.accept) === 'string') {
			options.accept = Mime.mimes2extList(options.accept);
		}

		RuntimeClient.call(self);

		Basic.extend(self, {
			uid: Basic.guid('uid_'),

			ruid: null,

			files: null,

			init: function() {		
				self.bind('RuntimeInit', function(e, runtime) {
					self.ruid = runtime.uid;
					runtime.exec.call(self, 'FileDrop', 'init', options);
					self.dispatchEvent('ready');
				});
							
				// runtime needs: options.required_features, options.runtime_order and options.container
				self.connectRuntime(options); // throws RuntimeError
			},

			destroy: function() {
				var runtime = this.getRuntime();
				if (runtime) {
					runtime.exec.call(this, 'FileDrop', 'destroy');
					this.disconnectRuntime();
				}
				this.files = null;
				
				this.unbindAll();
			}
		});

		this.handleEventProps(dispatches);
	}

	FileDrop.prototype = EventTarget.instance;

	return FileDrop;
});

// Included from: src/javascript/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileReader', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Encode',
	'moxie/core/Exceptions',
	'moxie/core/EventTarget',
	'moxie/file/Blob',
	'moxie/runtime/RuntimeClient'
], function(Basic, Encode, x, EventTarget, Blob, RuntimeClient) {
	/**
	Utility for preloading o.Blob/o.File objects in memory. By design closely follows [W3C FileReader](http://www.w3.org/TR/FileAPI/#dfn-filereader)
	interface. Where possible uses native FileReader, where - not falls back to shims.

	@class moxie/file/FileReader
	@constructor FileReader
	@extends EventTarget
	@uses RuntimeClient
	*/
	var dispatches = [

		/** 
		Dispatched when the read starts.

		@event loadstart
		@param {Object} event
		*/
		'loadstart', 

		/** 
		Dispatched while reading (and decoding) blob, and reporting partial Blob data (progess.loaded/progress.total).

		@event progress
		@param {Object} event
		*/
		'progress', 

		/** 
		Dispatched when the read has successfully completed.

		@event load
		@param {Object} event
		*/
		'load', 

		/** 
		Dispatched when the read has been aborted. For instance, by invoking the abort() method.

		@event abort
		@param {Object} event
		*/
		'abort', 

		/** 
		Dispatched when the read has failed.

		@event error
		@param {Object} event
		*/
		'error', 

		/** 
		Dispatched when the request has completed (either in success or failure).

		@event loadend
		@param {Object} event
		*/
		'loadend'
	];
	
	function FileReader() {

		RuntimeClient.call(this);

		Basic.extend(this, {
			/**
			UID of the component instance.

			@property uid
			@type {String}
			*/
			uid: Basic.guid('uid_'),

			/**
			Contains current state of FileReader object. Can take values of FileReader.EMPTY, FileReader.LOADING
			and FileReader.DONE.

			@property readyState
			@type {Number}
			@default FileReader.EMPTY
			*/
			readyState: FileReader.EMPTY,
			
			/**
			Result of the successful read operation.

			@property result
			@type {String}
			*/
			result: null,
			
			/**
			Stores the error of failed asynchronous read operation.

			@property error
			@type {DOMError}
			*/
			error: null,
			
			/**
			Initiates reading of File/Blob object contents to binary string.

			@method readAsBinaryString
			@param {Blob|File} blob Object to preload
			*/
			readAsBinaryString: function(blob) {
				_read.call(this, 'readAsBinaryString', blob);
			},
			
			/**
			Initiates reading of File/Blob object contents to dataURL string.

			@method readAsDataURL
			@param {Blob|File} blob Object to preload
			*/
			readAsDataURL: function(blob) {
				_read.call(this, 'readAsDataURL', blob);
			},
			
			/**
			Initiates reading of File/Blob object contents to string.

			@method readAsText
			@param {Blob|File} blob Object to preload
			*/
			readAsText: function(blob) {
				_read.call(this, 'readAsText', blob);
			},
			
			/**
			Aborts preloading process.

			@method abort
			*/
			abort: function() {
				this.result = null;
				
				if (Basic.inArray(this.readyState, [FileReader.EMPTY, FileReader.DONE]) !== -1) {
					return;
				} else if (this.readyState === FileReader.LOADING) {
					this.readyState = FileReader.DONE;
				}

				this.exec('FileReader', 'abort');
				
				this.trigger('abort');
				this.trigger('loadend');
			},

			/**
			Destroy component and release resources.

			@method destroy
			*/
			destroy: function() {
				this.abort();
				this.exec('FileReader', 'destroy');
				this.disconnectRuntime();
				this.unbindAll();
			}
		});

		// uid must already be assigned
		this.handleEventProps(dispatches);

		this.bind('Error', function(e, err) {
			this.readyState = FileReader.DONE;
			this.error = err;
		}, 999);
		
		this.bind('Load', function(e) {
			this.readyState = FileReader.DONE;
		}, 999);

		
		function _read(op, blob) {
			var self = this;			

			this.trigger('loadstart');

			if (this.readyState === FileReader.LOADING) {
				this.trigger('error', new x.DOMException(x.DOMException.INVALID_STATE_ERR));
				this.trigger('loadend');
				return;
			}

			// if source is not o.Blob/o.File
			if (!(blob instanceof Blob)) {
				this.trigger('error', new x.DOMException(x.DOMException.NOT_FOUND_ERR));
				this.trigger('loadend');
				return;
			}

			this.result = null;
			this.readyState = FileReader.LOADING;
			
			if (blob.isDetached()) {
				var src = blob.getSource();
				switch (op) {
					case 'readAsText':
					case 'readAsBinaryString':
						this.result = src;
						break;
					case 'readAsDataURL':
						this.result = 'data:' + blob.type + ';base64,' + Encode.btoa(src);
						break;
				}
				this.readyState = FileReader.DONE;
				this.trigger('load');
				this.trigger('loadend');
			} else {
				this.connectRuntime(blob.ruid);
				this.exec('FileReader', 'read', op, blob);
			}
		}
	}
	
	/**
	Initial FileReader state

	@property EMPTY
	@type {Number}
	@final
	@static
	@default 0
	*/
	FileReader.EMPTY = 0;

	/**
	FileReader switches to this state when it is preloading the source

	@property LOADING
	@type {Number}
	@final
	@static
	@default 1
	*/
	FileReader.LOADING = 1;

	/**
	Preloading is complete, this is a final state

	@property DONE
	@type {Number}
	@final
	@static
	@default 2
	*/
	FileReader.DONE = 2;

	FileReader.prototype = EventTarget.instance;

	return FileReader;
});

// Included from: src/javascript/core/utils/Url.js

/**
 * Url.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Url', [
	'moxie/core/utils/Basic'
], function(Basic) {
	/**
	Parse url into separate components and fill in absent parts with parts from current url,
	based on https://raw.github.com/kvz/phpjs/master/functions/url/parse_url.js

	@method parseUrl
	@for Utils
	@static
	@param {String} url Url to parse (defaults to empty string if undefined)
	@return {Object} Hash containing extracted uri components
	*/
	var parseUrl = function(url, currentUrl) {
		var key = ['source', 'scheme', 'authority', 'userInfo', 'user', 'pass', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'fragment']
		, i = key.length
		, ports = {
			http: 80,
			https: 443
		}
		, uri = {}
		, regex = /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@\/]*):?([^:@\/]*))?@)?(\[[\da-fA-F:]+\]|[^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/
		, m = regex.exec(url || '')
		, isRelative
		, isSchemeLess = /^\/\/\w/.test(url)
		;

		switch (Basic.typeOf(currentUrl)) {
			case 'undefined':
				currentUrl = parseUrl(document.location.href, false);
				break;

			case 'string':
				currentUrl = parseUrl(currentUrl, false);
				break;
		}

		while (i--) {
			if (m[i]) {
				uri[key[i]] = m[i];
			}
		}

		isRelative = !isSchemeLess && !uri.scheme;

		if (isSchemeLess || isRelative) {
			uri.scheme = currentUrl.scheme;
		}

		// when url is relative, we set the origin and the path ourselves
		if (isRelative) {
			uri.host = currentUrl.host;
			uri.port = currentUrl.port;

			var path = '';
			// for urls without trailing slash we need to figure out the path
			if (/^[^\/]/.test(uri.path)) {
				path = currentUrl.path;
				// if path ends with a filename, strip it
				if (/\/[^\/]*\.[^\/]*$/.test(path)) {
					path = path.replace(/\/[^\/]+$/, '/');
				} else {
					// avoid double slash at the end (see #127)
					path = path.replace(/\/?$/, '/');
				}
			}
			uri.path = path + (uri.path || ''); // site may reside at domain.com or domain.com/subdir
		}

		if (!uri.port) {
			uri.port = ports[uri.scheme] || 80;
		}

		uri.port = parseInt(uri.port, 10);

		if (!uri.path) {
			uri.path = "/";
		}

		delete uri.source;

		return uri;
	};

	/**
	Resolve url - among other things will turn relative url to absolute

	@method resolveUrl
	@static
	@param {String|Object} url Either absolute or relative, or a result of parseUrl call
	@return {String} Resolved, absolute url
	*/
	var resolveUrl = function(url) {
		var ports = { // we ignore default ports
			http: 80,
			https: 443
		}
		, urlp = typeof(url) === 'object' ? url : parseUrl(url);
		;

		return urlp.scheme + '://' + urlp.host + (urlp.port !== ports[urlp.scheme] ? ':' + urlp.port : '') + urlp.path + (urlp.query ? urlp.query : '');
	};

	/**
	Check if specified url has the same origin as the current document

	@method hasSameOrigin
	@param {String|Object} url
	@return {Boolean}
	*/
	var hasSameOrigin = function(url) {
		function origin(url) {
			return [url.scheme, url.host, url.port].join('/');
		}

		if (typeof url === 'string') {
			url = parseUrl(url);
		}

		return origin(parseUrl()) === origin(url);
	};

	return {
		parseUrl: parseUrl,
		resolveUrl: resolveUrl,
		hasSameOrigin: hasSameOrigin
	};
});

// Included from: src/javascript/runtime/RuntimeTarget.js

/**
 * RuntimeTarget.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/RuntimeTarget', [
	'moxie/core/utils/Basic',
	'moxie/runtime/RuntimeClient',
	"moxie/core/EventTarget"
], function(Basic, RuntimeClient, EventTarget) {
	/**
	Instance of this class can be used as a target for the events dispatched by shims,
	when allowing them onto components is for either reason inappropriate

	@class moxie/runtime/RuntimeTarget
	@constructor
	@protected
	@extends EventTarget
	*/
	function RuntimeTarget() {
		this.uid = Basic.guid('uid_');
		
		RuntimeClient.call(this);

		this.destroy = function() {
			this.disconnectRuntime();
			this.unbindAll();
		};
	}

	RuntimeTarget.prototype = EventTarget.instance;

	return RuntimeTarget;
});

// Included from: src/javascript/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileReaderSync', [
	'moxie/core/utils/Basic',
	'moxie/runtime/RuntimeClient',
	'moxie/core/utils/Encode'
], function(Basic, RuntimeClient, Encode) {
	/**
	Synchronous FileReader implementation. Something like this is available in WebWorkers environment, here
	it can be used to read only preloaded blobs/files and only below certain size (not yet sure what that'd be,
	but probably < 1mb). Not meant to be used directly by user.

	@class moxie/file/FileReaderSync
	@private
	@constructor
	*/
	return function() {
		RuntimeClient.call(this);

		Basic.extend(this, {
			uid: Basic.guid('uid_'),

			readAsBinaryString: function(blob) {
				return _read.call(this, 'readAsBinaryString', blob);
			},
			
			readAsDataURL: function(blob) {
				return _read.call(this, 'readAsDataURL', blob);
			},
			
			/*readAsArrayBuffer: function(blob) {
				return _read.call(this, 'readAsArrayBuffer', blob);
			},*/
			
			readAsText: function(blob) {
				return _read.call(this, 'readAsText', blob);
			}
		});

		function _read(op, blob) {
			if (blob.isDetached()) {
				var src = blob.getSource();
				switch (op) {
					case 'readAsBinaryString':
						return src;
					case 'readAsDataURL':
						return 'data:' + blob.type + ';base64,' + Encode.btoa(src);
					case 'readAsText':
						var txt = '';
						for (var i = 0, length = src.length; i < length; i++) {
							txt += String.fromCharCode(src[i]);
						}
						return txt;
				}
			} else {
				var result = this.connectRuntime(blob.ruid).exec.call(this, 'FileReaderSync', 'read', op, blob);
				this.disconnectRuntime();
				return result;
			}
		}
	};
});

// Included from: src/javascript/xhr/FormData.js

/**
 * FormData.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/xhr/FormData", [
	"moxie/core/Exceptions",
	"moxie/core/utils/Basic",
	"moxie/file/Blob"
], function(x, Basic, Blob) {
	/**
	FormData

	@class moxie/xhr/FormData
	@constructor
	*/
	function FormData() {
		var _blob, _fields = [];

		Basic.extend(this, {
			/**
			Append another key-value pair to the FormData object

			@method append
			@param {String} name Name for the new field
			@param {String|Blob|Array|Object} value Value for the field
			*/
			append: function(name, value) {
				var self = this, valueType = Basic.typeOf(value);

				// according to specs value might be either Blob or String
				if (value instanceof Blob) {
					_blob = {
						name: name,
						value: value // unfortunately we can only send single Blob in one FormData
					};
				} else if ('array' === valueType) {
					name += '[]';

					Basic.each(value, function(value) {
						self.append(name, value);
					});
				} else if ('object' === valueType) {
					Basic.each(value, function(value, key) {
						self.append(name + '[' + key + ']', value);
					});
				} else if ('null' === valueType || 'undefined' === valueType || 'number' === valueType && isNaN(value)) {
					self.append(name, "false");
				} else {
					_fields.push({
						name: name,
						value: value.toString()
					});
				}
			},

			/**
			Checks if FormData contains Blob.

			@method hasBlob
			@return {Boolean}
			*/
			hasBlob: function() {
				return !!this.getBlob();
			},

			/**
			Retrieves blob.

			@method getBlob
			@return {Object} Either Blob if found or null
			*/
			getBlob: function() {
				return _blob && _blob.value || null;
			},

			/**
			Retrieves blob field name.

			@method getBlobName
			@return {String} Either Blob field name or null
			*/
			getBlobName: function() {
				return _blob && _blob.name || null;
			},

			/**
			Loop over the fields in FormData and invoke the callback for each of them.

			@method each
			@param {Function} cb Callback to call for each field
			*/
			each: function(cb) {
				Basic.each(_fields, function(field) {
					cb(field.value, field.name);
				});

				if (_blob) {
					cb(_blob.value, _blob.name);
				}
			},

			destroy: function() {
				_blob = null;
				_fields = [];
			}
		});
	}

	return FormData;
});

// Included from: src/javascript/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/xhr/XMLHttpRequest", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/core/EventTarget",
	"moxie/core/utils/Encode",
	"moxie/core/utils/Url",
	"moxie/runtime/Runtime",
	"moxie/runtime/RuntimeTarget",
	"moxie/file/Blob",
	"moxie/file/FileReaderSync",
	"moxie/xhr/FormData",
	"moxie/core/utils/Env",
	"moxie/core/utils/Mime"
], function(Basic, x, EventTarget, Encode, Url, Runtime, RuntimeTarget, Blob, FileReaderSync, FormData, Env, Mime) {

	var httpCode = {
		100: 'Continue',
		101: 'Switching Protocols',
		102: 'Processing',

		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		207: 'Multi-Status',
		226: 'IM Used',

		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		306: 'Reserved',
		307: 'Temporary Redirect',

		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Timeout',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Long',
		415: 'Unsupported Media Type',
		416: 'Requested Range Not Satisfiable',
		417: 'Expectation Failed',
		422: 'Unprocessable Entity',
		423: 'Locked',
		424: 'Failed Dependency',
		426: 'Upgrade Required',

		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Timeout',
		505: 'HTTP Version Not Supported',
		506: 'Variant Also Negotiates',
		507: 'Insufficient Storage',
		510: 'Not Extended'
	};

	function XMLHttpRequestUpload() {
		this.uid = Basic.guid('uid_');
	}

	XMLHttpRequestUpload.prototype = EventTarget.instance;

	/**
	Implementation of XMLHttpRequest

	@class moxie/xhr/XMLHttpRequest
	@constructor
	@uses RuntimeClient
	@extends EventTarget
	*/
	var dispatches = [
		'loadstart',

		'progress',

		'abort',

		'error',

		'load',

		'timeout',

		'loadend'

		// readystatechange (for historical reasons)
	];

	var NATIVE = 1, RUNTIME = 2;

	function XMLHttpRequest() {
		var self = this,
			// this (together with _p() @see below) is here to gracefully upgrade to setter/getter syntax where possible
			props = {
				/**
				The amount of milliseconds a request can take before being terminated. Initially zero. Zero means there is no timeout.

				@property timeout
				@type Number
				@default 0
				*/
				timeout: 0,

				/**
				Current state, can take following values:
				UNSENT (numeric value 0)
				The object has been constructed.

				OPENED (numeric value 1)
				The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the request can be made using the send() method.

				HEADERS_RECEIVED (numeric value 2)
				All redirects (if any) have been followed and all HTTP headers of the final response have been received. Several response members of the object are now available.

				LOADING (numeric value 3)
				The response entity body is being received.

				DONE (numeric value 4)

				@property readyState
				@type Number
				@default 0 (UNSENT)
				*/
				readyState: XMLHttpRequest.UNSENT,

				/**
				True when user credentials are to be included in a cross-origin request. False when they are to be excluded
				in a cross-origin request and when cookies are to be ignored in its response. Initially false.

				@property withCredentials
				@type Boolean
				@default false
				*/
				withCredentials: false,

				/**
				Returns the HTTP status code.

				@property status
				@type Number
				@default 0
				*/
				status: 0,

				/**
				Returns the HTTP status text.

				@property statusText
				@type String
				*/
				statusText: "",

				/**
				Returns the response type. Can be set to change the response type. Values are:
				the empty string (default), "arraybuffer", "blob", "document", "json", and "text".

				@property responseType
				@type String
				*/
				responseType: "",

				/**
				Returns the document response entity body.

				Throws an "InvalidStateError" exception if responseType is not the empty string or "document".

				@property responseXML
				@type Document
				*/
				responseXML: null,

				/**
				Returns the text response entity body.

				Throws an "InvalidStateError" exception if responseType is not the empty string or "text".

				@property responseText
				@type String
				*/
				responseText: null,

				/**
				Returns the response entity body (http://www.w3.org/TR/XMLHttpRequest/#response-entity-body).
				Can become: ArrayBuffer, Blob, Document, JSON, Text

				@property response
				@type Mixed
				*/
				response: null
			},

			_async = true,
			_url,
			_method,
			_headers = {},
			_user,
			_password,
			_encoding = null,
			_mimeType = null,

			// flags
			_sync_flag = false,
			_send_flag = false,
			_upload_events_flag = false,
			_upload_complete_flag = false,
			_error_flag = false,
			_same_origin_flag = false,

			// times
			_start_time,
			_timeoutset_time,

			_finalMime = null,
			_finalCharset = null,

			_options = {},
			_xhr,
			_responseHeaders = '',
			_responseHeadersBag
			;


		Basic.extend(this, props, {
			/**
			Unique id of the component

			@property uid
			@type String
			*/
			uid: Basic.guid('uid_'),

			/**
			Target for Upload events

			@property upload
			@type XMLHttpRequestUpload
			*/
			upload: new XMLHttpRequestUpload(),


			/**
			Sets the request method, request URL, synchronous flag, request username, and request password.

			Throws a "SyntaxError" exception if one of the following is true:

			method is not a valid HTTP method.
			url cannot be resolved.
			url contains the "user:password" format in the userinfo production.
			Throws a "SecurityError" exception if method is a case-insensitive match for CONNECT, TRACE or TRACK.

			Throws an "InvalidAccessError" exception if one of the following is true:

			Either user or password is passed as argument and the origin of url does not match the XMLHttpRequest origin.
			There is an associated XMLHttpRequest document and either the timeout attribute is not zero,
			the withCredentials attribute is true, or the responseType attribute is not the empty string.


			@method open
			@param {String} method HTTP method to use on request
			@param {String} url URL to request
			@param {Boolean} [async=true] If false request will be done in synchronous manner. Asynchronous by default.
			@param {String} [user] Username to use in HTTP authentication process on server-side
			@param {String} [password] Password to use in HTTP authentication process on server-side
			*/
			open: function(method, url, async, user, password) {
				var urlp;

				// first two arguments are required
				if (!method || !url) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 2 - check if any code point in method is higher than U+00FF or after deflating method it does not match the method
				if (/[\u0100-\uffff]/.test(method) || Encode.utf8_encode(method) !== method) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 3
				if (!!~Basic.inArray(method.toUpperCase(), ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'])) {
					_method = method.toUpperCase();
				}


				// 4 - allowing these methods poses a security risk
				if (!!~Basic.inArray(_method, ['CONNECT', 'TRACE', 'TRACK'])) {
					throw new x.DOMException(x.DOMException.SECURITY_ERR);
				}

				// 5
				url = Encode.utf8_encode(url);

				// 6 - Resolve url relative to the XMLHttpRequest base URL. If the algorithm returns an error, throw a "SyntaxError".
				urlp = Url.parseUrl(url);

				_same_origin_flag = Url.hasSameOrigin(urlp);

				// 7 - manually build up absolute url
				_url = Url.resolveUrl(url);

				// 9-10, 12-13
				if ((user || password) && !_same_origin_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				_user = user || urlp.user;
				_password = password || urlp.pass;

				// 11
				_async = async || true;

				if (_async === false && (_p('timeout') || _p('withCredentials') || _p('responseType') !== "")) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 14 - terminate abort()

				// 15 - terminate send()

				// 18
				_sync_flag = !_async;
				_send_flag = false;
				_headers = {};
				_reset.call(this);

				// 19
				_p('readyState', XMLHttpRequest.OPENED);

				// 20
				this.dispatchEvent('readystatechange');
			},

			/**
			Appends an header to the list of author request headers, or if header is already
			in the list of author request headers, combines its value with value.

			Throws an "InvalidStateError" exception if the state is not OPENED or if the send() flag is set.
			Throws a "SyntaxError" exception if header is not a valid HTTP header field name or if value
			is not a valid HTTP header field value.

			@method setRequestHeader
			@param {String} header
			@param {String|Number} value
			*/
			setRequestHeader: function(header, value) {
				var uaHeaders = [ // these headers are controlled by the user agent
						"accept-charset",
						"accept-encoding",
						"access-control-request-headers",
						"access-control-request-method",
						"connection",
						"content-length",
						"cookie",
						"cookie2",
						"content-transfer-encoding",
						"date",
						"expect",
						"host",
						"keep-alive",
						"origin",
						"referer",
						"te",
						"trailer",
						"transfer-encoding",
						"upgrade",
						"user-agent",
						"via"
					];

				// 1-2
				if (_p('readyState') !== XMLHttpRequest.OPENED || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3
				if (/[\u0100-\uffff]/.test(header) || Encode.utf8_encode(header) !== header) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 4
				/* this step is seemingly bypassed in browsers, probably to allow various unicode characters in header values
				if (/[\u0100-\uffff]/.test(value) || Encode.utf8_encode(value) !== value) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}*/

				header = Basic.trim(header).toLowerCase();

				// setting of proxy-* and sec-* headers is prohibited by spec
				if (!!~Basic.inArray(header, uaHeaders) || /^(proxy\-|sec\-)/.test(header)) {
					return false;
				}

				// camelize
				// browsers lowercase header names (at least for custom ones)
				// header = header.replace(/\b\w/g, function($1) { return $1.toUpperCase(); });

				if (!_headers[header]) {
					_headers[header] = value;
				} else {
					// http://tools.ietf.org/html/rfc2616#section-4.2 (last paragraph)
					_headers[header] += ', ' + value;
				}
				return true;
			},

			/**
			 * Test if the specified header is already set on this request.
			 * Returns a header value or boolean false if it's not yet set.
			 *
			 * @method hasRequestHeader
			 * @param {String} header Name of the header to test
			 * @return {Boolean|String}
			 */
			hasRequestHeader: function(header) {
				return header && _headers[header.toLowerCase()] || false;
			},

			/**
			Returns all headers from the response, with the exception of those whose field name is Set-Cookie or Set-Cookie2.

			@method getAllResponseHeaders
			@return {String} reponse headers or empty string
			*/
			getAllResponseHeaders: function() {
				return _responseHeaders || '';
			},

			/**
			Returns the header field value from the response of which the field name matches header,
			unless the field name is Set-Cookie or Set-Cookie2.

			@method getResponseHeader
			@param {String} header
			@return {String} value(s) for the specified header or null
			*/
			getResponseHeader: function(header) {
				header = header.toLowerCase();

				if (_error_flag || !!~Basic.inArray(header, ['set-cookie', 'set-cookie2'])) {
					return null;
				}

				if (_responseHeaders && _responseHeaders !== '') {
					// if we didn't parse response headers until now, do it and keep for later
					if (!_responseHeadersBag) {
						_responseHeadersBag = {};
						Basic.each(_responseHeaders.split(/\r\n/), function(line) {
							var pair = line.split(/:\s+/);
							if (pair.length === 2) { // last line might be empty, omit
								pair[0] = Basic.trim(pair[0]); // just in case
								_responseHeadersBag[pair[0].toLowerCase()] = { // simply to retain header name in original form
									header: pair[0],
									value: Basic.trim(pair[1])
								};
							}
						});
					}
					if (_responseHeadersBag.hasOwnProperty(header)) {
						return _responseHeadersBag[header].header + ': ' + _responseHeadersBag[header].value;
					}
				}
				return null;
			},

			/**
			Sets the Content-Type header for the response to mime.
			Throws an "InvalidStateError" exception if the state is LOADING or DONE.
			Throws a "SyntaxError" exception if mime is not a valid media type.

			@method overrideMimeType
			@param String mime Mime type to set
			*/
			overrideMimeType: function(mime) {
				var matches, charset;

				// 1
				if (!!~Basic.inArray(_p('readyState'), [XMLHttpRequest.LOADING, XMLHttpRequest.DONE])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2
				mime = Basic.trim(mime.toLowerCase());

				if (/;/.test(mime) && (matches = mime.match(/^([^;]+)(?:;\scharset\=)?(.*)$/))) {
					mime = matches[1];
					if (matches[2]) {
						charset = matches[2];
					}
				}

				if (!Mime.mimes[mime]) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 3-4
				_finalMime = mime;
				_finalCharset = charset;
			},

			/**
			Initiates the request. The optional argument provides the request entity body.
			The argument is ignored if request method is GET or HEAD.

			Throws an "InvalidStateError" exception if the state is not OPENED or if the send() flag is set.

			@method send
			@param {Blob|Document|String|FormData} [data] Request entity body
			@param {Object} [options] Set of requirements and pre-requisities for runtime initialization
			*/
			send: function(data, options) {
				if (Basic.typeOf(options) === 'string') {
					_options = { ruid: options };
				} else if (!options) {
					_options = {};
				} else {
					_options = options;
				}

				// 1-2
				if (this.readyState !== XMLHttpRequest.OPENED || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3
				// sending Blob
				if (data instanceof Blob) {
					_options.ruid = data.ruid;
					_mimeType = data.type || 'application/octet-stream';
				}

				// FormData
				else if (data instanceof FormData) {
					if (data.hasBlob()) {
						var blob = data.getBlob();
						_options.ruid = blob.ruid;
						_mimeType = blob.type || 'application/octet-stream';
					}
				}

				// DOMString
				else if (typeof data === 'string') {
					_encoding = 'UTF-8';
					_mimeType = 'text/plain;charset=UTF-8';

					// data should be converted to Unicode and encoded as UTF-8
					data = Encode.utf8_encode(data);
				}

				// if withCredentials not set, but requested, set it automatically
				if (!this.withCredentials) {
					this.withCredentials = (_options.required_caps && _options.required_caps.send_browser_cookies) && !_same_origin_flag;
				}

				// 4 - storage mutex
				// 5
				_upload_events_flag = (!_sync_flag && this.upload.hasEventListener()); // DSAP
				// 6
				_error_flag = false;
				// 7
				_upload_complete_flag = !data;
				// 8 - Asynchronous steps
				if (!_sync_flag) {
					// 8.1
					_send_flag = true;
					// 8.2
					// this.dispatchEvent('loadstart'); // will be dispatched either by native or runtime xhr
					// 8.3
					//if (!_upload_complete_flag) {
						// this.upload.dispatchEvent('loadstart');	// will be dispatched either by native or runtime xhr
					//}
				}
				// 8.5 - Return the send() method call, but continue running the steps in this algorithm.
				_doXHR.call(this, data);
			},

			/**
			Cancels any network activity.

			@method abort
			*/
			abort: function() {
				_error_flag = true;
				_sync_flag = false;

				if (!~Basic.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED, XMLHttpRequest.DONE])) {
					_p('readyState', XMLHttpRequest.DONE);
					_send_flag = false;

					if (_xhr) {
						_xhr.getRuntime().exec.call(_xhr, 'XMLHttpRequest', 'abort', _upload_complete_flag);
					} else {
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}

					_upload_complete_flag = true;
				} else {
					_p('readyState', XMLHttpRequest.UNSENT);
				}
			},

			destroy: function() {
				if (_xhr) {
					if (Basic.typeOf(_xhr.destroy) === 'function') {
						_xhr.destroy();
					}
					_xhr = null;
				}

				this.unbindAll();

				if (this.upload) {
					this.upload.unbindAll();
					this.upload = null;
				}
			}
		});

		this.handleEventProps(dispatches.concat(['readystatechange'])); // for historical reasons
		this.upload.handleEventProps(dispatches);

		/* this is nice, but maybe too lengthy

		// if supported by JS version, set getters/setters for specific properties
		o.defineProperty(this, 'readyState', {
			configurable: false,

			get: function() {
				return _p('readyState');
			}
		});

		o.defineProperty(this, 'timeout', {
			configurable: false,

			get: function() {
				return _p('timeout');
			},

			set: function(value) {

				if (_sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// timeout still should be measured relative to the start time of request
				_timeoutset_time = (new Date).getTime();

				_p('timeout', value);
			}
		});

		// the withCredentials attribute has no effect when fetching same-origin resources
		o.defineProperty(this, 'withCredentials', {
			configurable: false,

			get: function() {
				return _p('withCredentials');
			},

			set: function(value) {
				// 1-2
				if (!~o.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED]) || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3-4
				if (_anonymous_flag || _sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 5
				_p('withCredentials', value);
			}
		});

		o.defineProperty(this, 'status', {
			configurable: false,

			get: function() {
				return _p('status');
			}
		});

		o.defineProperty(this, 'statusText', {
			configurable: false,

			get: function() {
				return _p('statusText');
			}
		});

		o.defineProperty(this, 'responseType', {
			configurable: false,

			get: function() {
				return _p('responseType');
			},

			set: function(value) {
				// 1
				if (!!~o.inArray(_p('readyState'), [XMLHttpRequest.LOADING, XMLHttpRequest.DONE])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2
				if (_sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 3
				_p('responseType', value.toLowerCase());
			}
		});

		o.defineProperty(this, 'responseText', {
			configurable: false,

			get: function() {
				// 1
				if (!~o.inArray(_p('responseType'), ['', 'text'])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2-3
				if (_p('readyState') !== XMLHttpRequest.DONE && _p('readyState') !== XMLHttpRequest.LOADING || _error_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				return _p('responseText');
			}
		});

		o.defineProperty(this, 'responseXML', {
			configurable: false,

			get: function() {
				// 1
				if (!~o.inArray(_p('responseType'), ['', 'document'])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2-3
				if (_p('readyState') !== XMLHttpRequest.DONE || _error_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				return _p('responseXML');
			}
		});

		o.defineProperty(this, 'response', {
			configurable: false,

			get: function() {
				if (!!~o.inArray(_p('responseType'), ['', 'text'])) {
					if (_p('readyState') !== XMLHttpRequest.DONE && _p('readyState') !== XMLHttpRequest.LOADING || _error_flag) {
						return '';
					}
				}

				if (_p('readyState') !== XMLHttpRequest.DONE || _error_flag) {
					return null;
				}

				return _p('response');
			}
		});

		*/

		function _p(prop, value) {
			if (!props.hasOwnProperty(prop)) {
				return;
			}
			if (arguments.length === 1) { // get
				return Env.can('define_property') ? props[prop] : self[prop];
			} else { // set
				if (Env.can('define_property')) {
					props[prop] = value;
				} else {
					self[prop] = value;
				}
			}
		}

		/*
		function _toASCII(str, AllowUnassigned, UseSTD3ASCIIRules) {
			// TODO: http://tools.ietf.org/html/rfc3490#section-4.1
			return str.toLowerCase();
		}
		*/


		function _doXHR(data) {
			var self = this;

			_start_time = new Date().getTime();

			_xhr = new RuntimeTarget();

			function loadEnd() {
				if (_xhr) { // it could have been destroyed by now
					_xhr.destroy();
					_xhr = null;
				}
				self.dispatchEvent('loadend');
				self = null;
			}

			function exec(runtime) {
				_xhr.bind('LoadStart', function(e) {
					_p('readyState', XMLHttpRequest.LOADING);
					self.dispatchEvent('readystatechange');

					self.dispatchEvent(e);

					if (_upload_events_flag) {
						self.upload.dispatchEvent(e);
					}
				});

				_xhr.bind('Progress', function(e) {
					if (_p('readyState') !== XMLHttpRequest.LOADING) {
						_p('readyState', XMLHttpRequest.LOADING); // LoadStart unreliable (in Flash for example)
						self.dispatchEvent('readystatechange');
					}
					self.dispatchEvent(e);
				});

				_xhr.bind('UploadProgress', function(e) {
					if (_upload_events_flag) {
						self.upload.dispatchEvent({
							type: 'progress',
							lengthComputable: false,
							total: e.total,
							loaded: e.loaded
						});
					}
				});

				_xhr.bind('Load', function(e) {
					_p('readyState', XMLHttpRequest.DONE);
					_p('status', Number(runtime.exec.call(_xhr, 'XMLHttpRequest', 'getStatus') || 0));
					_p('statusText', httpCode[_p('status')] || "");

					_p('response', runtime.exec.call(_xhr, 'XMLHttpRequest', 'getResponse', _p('responseType')));

					if (!!~Basic.inArray(_p('responseType'), ['text', ''])) {
						_p('responseText', _p('response'));
					} else if (_p('responseType') === 'document') {
						_p('responseXML', _p('response'));
					}

					_responseHeaders = runtime.exec.call(_xhr, 'XMLHttpRequest', 'getAllResponseHeaders');

					self.dispatchEvent('readystatechange');

					if (_p('status') > 0) { // status 0 usually means that server is unreachable
						if (_upload_events_flag) {
							self.upload.dispatchEvent(e);
						}
						self.dispatchEvent(e);
					} else {
						_error_flag = true;
						self.dispatchEvent('error');
					}
					loadEnd();
				});

				_xhr.bind('Abort', function(e) {
					self.dispatchEvent(e);
					loadEnd();
				});

				_xhr.bind('Error', function(e) {
					_error_flag = true;
					_p('readyState', XMLHttpRequest.DONE);
					self.dispatchEvent('readystatechange');
					_upload_complete_flag = true;
					self.dispatchEvent(e);
					loadEnd();
				});

				runtime.exec.call(_xhr, 'XMLHttpRequest', 'send', {
					url: _url,
					method: _method,
					async: _async,
					user: _user,
					password: _password,
					headers: _headers,
					mimeType: _mimeType,
					encoding: _encoding,
					responseType: self.responseType,
					withCredentials: self.withCredentials,
					options: _options
				}, data);
			}

			// clarify our requirements
			if (typeof(_options.required_caps) === 'string') {
				_options.required_caps = Runtime.parseCaps(_options.required_caps);
			}

			_options.required_caps = Basic.extend({}, _options.required_caps, {
				return_response_type: self.responseType
			});

			if (data instanceof FormData) {
				_options.required_caps.send_multipart = true;
			}

			if (!Basic.isEmptyObj(_headers)) {
				_options.required_caps.send_custom_headers = true;
			}

			if (!_same_origin_flag) {
				_options.required_caps.do_cors = true;
			}


			if (_options.ruid) { // we do not need to wait if we can connect directly
				exec(_xhr.connectRuntime(_options));
			} else {
				_xhr.bind('RuntimeInit', function(e, runtime) {
					exec(runtime);
				});
				_xhr.bind('RuntimeError', function(e, err) {
					self.dispatchEvent('RuntimeError', err);
				});
				_xhr.connectRuntime(_options);
			}
		}


		function _reset() {
			_p('responseText', "");
			_p('responseXML', null);
			_p('response', null);
			_p('status', 0);
			_p('statusText', "");
			_start_time = _timeoutset_time = null;
		}
	}

	XMLHttpRequest.UNSENT = 0;
	XMLHttpRequest.OPENED = 1;
	XMLHttpRequest.HEADERS_RECEIVED = 2;
	XMLHttpRequest.LOADING = 3;
	XMLHttpRequest.DONE = 4;

	XMLHttpRequest.prototype = EventTarget.instance;

	return XMLHttpRequest;
});

// Included from: src/javascript/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/runtime/Transporter", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Encode",
	"moxie/runtime/RuntimeClient",
	"moxie/core/EventTarget"
], function(Basic, Encode, RuntimeClient, EventTarget) {

	/**
	@class moxie/runtime/Transporter
	@constructor
	*/
	function Transporter() {
		var mod, _runtime, _data, _size, _pos, _chunk_size;

		RuntimeClient.call(this);

		Basic.extend(this, {
			uid: Basic.guid('uid_'),

			state: Transporter.IDLE,

			result: null,

			transport: function(data, type, options) {
				var self = this;

				options = Basic.extend({
					chunk_size: 204798
				}, options);

				// should divide by three, base64 requires this
				if ((mod = options.chunk_size % 3)) {
					options.chunk_size += 3 - mod;
				}

				_chunk_size = options.chunk_size;

				_reset.call(this);
				_data = data;
				_size = data.length;

				if (Basic.typeOf(options) === 'string' || options.ruid) {
					_run.call(self, type, this.connectRuntime(options));
				} else {
					// we require this to run only once
					var cb = function(e, runtime) {
						self.unbind("RuntimeInit", cb);
						_run.call(self, type, runtime);
					};
					this.bind("RuntimeInit", cb);
					this.connectRuntime(options);
				}
			},

			abort: function() {
				var self = this;

				self.state = Transporter.IDLE;
				if (_runtime) {
					_runtime.exec.call(self, 'Transporter', 'clear');
					self.trigger("TransportingAborted");
				}

				_reset.call(self);
			},


			destroy: function() {
				this.unbindAll();
				_runtime = null;
				this.disconnectRuntime();
				_reset.call(this);
			}
		});

		function _reset() {
			_size = _pos = 0;
			_data = this.result = null;
		}

		function _run(type, runtime) {
			var self = this;

			_runtime = runtime;

			//self.unbind("RuntimeInit");

			self.bind("TransportingProgress", function(e) {
				_pos = e.loaded;

				if (_pos < _size && Basic.inArray(self.state, [Transporter.IDLE, Transporter.DONE]) === -1) {
					_transport.call(self);
				}
			}, 999);

			self.bind("TransportingComplete", function() {
				_pos = _size;
				self.state = Transporter.DONE;
				_data = null; // clean a bit
				self.result = _runtime.exec.call(self, 'Transporter', 'getAsBlob', type || '');
			}, 999);

			self.state = Transporter.BUSY;
			self.trigger("TransportingStarted");
			_transport.call(self);
		}

		function _transport() {
			var self = this,
				chunk,
				bytesLeft = _size - _pos;

			if (_chunk_size > bytesLeft) {
				_chunk_size = bytesLeft;
			}

			chunk = Encode.btoa(_data.substr(_pos, _chunk_size));
			_runtime.exec.call(self, 'Transporter', 'receive', chunk, _size);
		}
	}

	Transporter.IDLE = 0;
	Transporter.BUSY = 1;
	Transporter.DONE = 2;

	Transporter.prototype = EventTarget.instance;

	return Transporter;
});

// Included from: src/javascript/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/image/Image", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/file/FileReaderSync",
	"moxie/xhr/XMLHttpRequest",
	"moxie/runtime/Runtime",
	"moxie/runtime/RuntimeClient",
	"moxie/runtime/Transporter",
	"moxie/core/utils/Env",
	"moxie/core/EventTarget",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/core/utils/Encode"
], function(Basic, Dom, x, FileReaderSync, XMLHttpRequest, Runtime, RuntimeClient, Transporter, Env, EventTarget, Blob, File, Encode) {
	/**
	Image preloading and manipulation utility. Additionally it provides access to image meta info (Exif, GPS) and raw binary data.

	@class moxie/image/Image
	@constructor
	@extends EventTarget
	*/
	var dispatches = [
		'progress',

		/**
		Dispatched when loading is complete.

		@event load
		@param {Object} event
		*/
		'load',

		'error',

		/**
		Dispatched when resize operation is complete.
		
		@event resize
		@param {Object} event
		*/
		'resize',

		/**
		Dispatched when visual representation of the image is successfully embedded
		into the corresponsing container.

		@event embedded
		@param {Object} event
		*/
		'embedded'
	];

	function Image() {

		RuntimeClient.call(this);

		Basic.extend(this, {
			/**
			Unique id of the component

			@property uid
			@type {String}
			*/
			uid: Basic.guid('uid_'),

			/**
			Unique id of the connected runtime, if any.

			@property ruid
			@type {String}
			*/
			ruid: null,

			/**
			Name of the file, that was used to create an image, if available. If not equals to empty string.

			@property name
			@type {String}
			@default ""
			*/
			name: "",

			/**
			Size of the image in bytes. Actual value is set only after image is preloaded.

			@property size
			@type {Number}
			@default 0
			*/
			size: 0,

			/**
			Width of the image. Actual value is set only after image is preloaded.

			@property width
			@type {Number}
			@default 0
			*/
			width: 0,

			/**
			Height of the image. Actual value is set only after image is preloaded.

			@property height
			@type {Number}
			@default 0
			*/
			height: 0,

			/**
			Mime type of the image. Currently only image/jpeg and image/png are supported. Actual value is set only after image is preloaded.

			@property type
			@type {String}
			@default ""
			*/
			type: "",

			/**
			Holds meta info (Exif, GPS). Is populated only for image/jpeg. Actual value is set only after image is preloaded.

			@property meta
			@type {Object}
			@default {}
			*/
			meta: {},

			/**
			Alias for load method, that takes another mOxie.Image object as a source (see load).

			@method clone
			@param {Image} src Source for the image
			@param {Boolean} [exact=false] Whether to activate in-depth clone mode
			*/
			clone: function() {
				this.load.apply(this, arguments);
			},

			/**
			Loads image from various sources. Currently the source for new image can be: mOxie.Image, mOxie.Blob/mOxie.File, 
			native Blob/File, dataUrl or URL. Depending on the type of the source, arguments - differ. When source is URL, 
			Image will be downloaded from remote destination and loaded in memory.

			@example
				var img = new mOxie.Image();
				img.onload = function() {
					var blob = img.getAsBlob();
					
					var formData = new mOxie.FormData();
					formData.append('file', blob);

					var xhr = new mOxie.XMLHttpRequest();
					xhr.onload = function() {
						// upload complete
					};
					xhr.open('post', 'upload.php');
					xhr.send(formData);
				};
				img.load("http://www.moxiecode.com/images/mox-logo.jpg"); // notice file extension (.jpg)
			

			@method load
			@param {Image|Blob|File|String} src Source for the image
			@param {Boolean|Object} [mixed]
			*/
			load: function() {
				_load.apply(this, arguments);
			},


			/**
			Resizes the image to fit the specified width/height. If crop is specified, image will also be 
			cropped to the exact dimensions.

			@method resize
			@since 3.0
			@param {Object} options
				@param {Number} options.width Resulting width
				@param {Number} [options.height=width] Resulting height (optional, if not supplied will default to width)
				@param {String} [options.type='image/jpeg'] MIME type of the resulting image
				@param {Number} [options.quality=90] In the case of JPEG, controls the quality of resulting image
				@param {Boolean} [options.crop='cc'] If not falsy, image will be cropped, by default from center
				@param {Boolean} [options.fit=true] In case of crop whether to upscale the image to fit the exact dimensions
				@param {Boolean} [options.preserveHeaders=true] Whether to preserve meta headers (on JPEGs after resize)
				@param {String} [options.resample='default'] Resampling algorithm to use during resize
				@param {Boolean} [options.multipass=true] Whether to scale the image in steps (results in better quality)
			*/
			resize: function(options) {
				var self = this;
				var orientation;
				var scale;

				var srcRect = {
					x: 0,
					y: 0,
					width: self.width,
					height: self.height
				};

				var opts = Basic.extendIf({
					width: self.width,
					height: self.height,
					type: self.type || 'image/jpeg',
					quality: 90,
					crop: false,
					fit: true,
					preserveHeaders: true,
					resample: 'default',
					multipass: true
				}, options);

				try {
					if (!self.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}

					// no way to reliably intercept the crash due to high resolution, so we simply avoid it
					if (self.width > Image.MAX_RESIZE_WIDTH || self.height > Image.MAX_RESIZE_HEIGHT) {
						throw new x.ImageError(x.ImageError.MAX_RESOLUTION_ERR);
					}

					// take into account orientation tag
					orientation = (self.meta && self.meta.tiff && self.meta.tiff.Orientation) || 1;

					if (Basic.inArray(orientation, [5,6,7,8]) !== -1) { // values that require 90 degree rotation
						var tmp = opts.width;
						opts.width = opts.height;
						opts.height = tmp;
					}

					if (opts.crop) {
						scale = Math.max(opts.width/self.width, opts.height/self.height);

						if (options.fit) {
							// first scale it up or down to fit the original image
							srcRect.width = Math.min(Math.ceil(opts.width/scale), self.width);
							srcRect.height = Math.min(Math.ceil(opts.height/scale), self.height);
							
							// recalculate the scale for adapted dimensions
							scale = opts.width/srcRect.width;
						} else {
							srcRect.width = Math.min(opts.width, self.width);
							srcRect.height = Math.min(opts.height, self.height);

							// now we do not need to scale it any further
							scale = 1; 
						}

						if (typeof(opts.crop) === 'boolean') {
							opts.crop = 'cc';
						}

						switch (opts.crop.toLowerCase().replace(/_/, '-')) {
							case 'rb':
							case 'right-bottom':
								srcRect.x = self.width - srcRect.width;
								srcRect.y = self.height - srcRect.height;
								break;

							case 'cb':
							case 'center-bottom':
								srcRect.x = Math.floor((self.width - srcRect.width) / 2);
								srcRect.y = self.height - srcRect.height;
								break;

							case 'lb':
							case 'left-bottom':
								srcRect.x = 0;
								srcRect.y = self.height - srcRect.height;
								break;

							case 'lt':
							case 'left-top':
								srcRect.x = 0;
								srcRect.y = 0;
								break;

							case 'ct':
							case 'center-top':
								srcRect.x = Math.floor((self.width - srcRect.width) / 2);
								srcRect.y = 0;
								break;

							case 'rt':
							case 'right-top':
								srcRect.x = self.width - srcRect.width;
								srcRect.y = 0;
								break;

							case 'rc':
							case 'right-center':
							case 'right-middle':
								srcRect.x = self.width - srcRect.width;
								srcRect.y = Math.floor((self.height - srcRect.height) / 2);
								break;


							case 'lc':
							case 'left-center':
							case 'left-middle':
								srcRect.x = 0;
								srcRect.y = Math.floor((self.height - srcRect.height) / 2);
								break;

							case 'cc':
							case 'center-center':
							case 'center-middle':
							default:
								srcRect.x = Math.floor((self.width - srcRect.width) / 2);
								srcRect.y = Math.floor((self.height - srcRect.height) / 2);
						}

						// original image might be smaller than requested crop, so - avoid negative values
						srcRect.x = Math.max(srcRect.x, 0);
						srcRect.y = Math.max(srcRect.y, 0);
					} else {
						scale = Math.min(opts.width/self.width, opts.height/self.height);
					}

					this.exec('Image', 'resize', srcRect, scale, opts);
				} catch(ex) {
					// for now simply trigger error event
					self.trigger('error', ex.code);
				}
			},

			/**
			Downsizes the image to fit the specified width/height. If crop is supplied, image will be cropped to exact dimensions.

			@method downsize
			@deprecated use resize()
			*/
			downsize: function(options) {
				var defaults = {
					width: this.width,
					height: this.height,
					type: this.type || 'image/jpeg',
					quality: 90,
					crop: false,
					preserveHeaders: true,
					resample: 'default'
				}, opts;

				if (typeof(options) === 'object') {
					opts = Basic.extend(defaults, options);
				} else {
					// for backward compatibility
					opts = Basic.extend(defaults, {
						width: arguments[0],
						height: arguments[1],
						crop: arguments[2],
						preserveHeaders: arguments[3]
					});
				}

				this.resize(opts);
			},

			/**
			Alias for downsize(width, height, true). (see downsize)
			
			@method crop
			@param {Number} width Resulting width
			@param {Number} [height=width] Resulting height (optional, if not supplied will default to width)
			@param {Boolean} [preserveHeaders=true] Whether to preserve meta headers (on JPEGs after resize)
			*/
			crop: function(width, height, preserveHeaders) {
				this.downsize(width, height, true, preserveHeaders);
			},

			getAsCanvas: function() {
				if (!Env.can('create_canvas')) {
					throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
				}
				return this.exec('Image', 'getAsCanvas');
			},

			/**
			Retrieves image in it's current state as mOxie.Blob object. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsBlob
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {Blob} Image as Blob
			*/
			getAsBlob: function(type, quality) {
				if (!this.size) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}
				return this.exec('Image', 'getAsBlob', type || 'image/jpeg', quality || 90);
			},

			/**
			Retrieves image in it's current state as dataURL string. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsDataURL
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {String} Image as dataURL string
			*/
			getAsDataURL: function(type, quality) {
				if (!this.size) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}
				return this.exec('Image', 'getAsDataURL', type || 'image/jpeg', quality || 90);
			},

			/**
			Retrieves image in it's current state as binary string. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsBinaryString
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {String} Image as binary string
			*/
			getAsBinaryString: function(type, quality) {
				var dataUrl = this.getAsDataURL(type, quality);
				return Encode.atob(dataUrl.substring(dataUrl.indexOf('base64,') + 7));
			},

			/**
			Embeds a visual representation of the image into the specified node. Depending on the runtime, 
			it might be a canvas, an img node or a thrid party shim object (Flash or SilverLight - very rare, 
			can be used in legacy browsers that do not have canvas or proper dataURI support).

			@method embed
			@param {DOMElement} el DOM element to insert the image object into
			@param {Object} [options]
				@param {Number} [options.width] The width of an embed (defaults to the image width)
				@param {Number} [options.height] The height of an embed (defaults to the image height)
				@param {String} [options.type="image/jpeg"] Mime type
				@param {Number} [options.quality=90] Quality of an embed, if mime type is image/jpeg
				@param {Boolean} [options.crop=false] Whether to crop an embed to the specified dimensions
			*/
			embed: function(el, options) {
				var self = this
				, runtime // this has to be outside of all the closures to contain proper runtime
				;

				var opts = Basic.extend({
					width: this.width,
					height: this.height,
					type: this.type || 'image/jpeg',
					quality: 90
				}, options);
				

				function render(type, quality) {
					var img = this;

					// if possible, embed a canvas element directly
					if (Env.can('create_canvas')) {
						var canvas = img.getAsCanvas();
						if (canvas) {
							el.appendChild(canvas);
							canvas = null;
							img.destroy();
							self.trigger('embedded');
							return;
						}
					}

					var dataUrl = img.getAsDataURL(type, quality);
					if (!dataUrl) {
						throw new x.ImageError(x.ImageError.WRONG_FORMAT);
					}

					if (Env.can('use_data_uri_of', dataUrl.length)) {
						el.innerHTML = '<img src="' + dataUrl + '" width="' + img.width + '" height="' + img.height + '" />';
						img.destroy();
						self.trigger('embedded');
					} else {
						var tr = new Transporter();

						tr.bind("TransportingComplete", function() {
							runtime = self.connectRuntime(this.result.ruid);

							self.bind("Embedded", function() {
								// position and size properly
								Basic.extend(runtime.getShimContainer().style, {
									//position: 'relative',
									top: '0px',
									left: '0px',
									width: img.width + 'px',
									height: img.height + 'px'
								});

								// some shims (Flash/SilverLight) reinitialize, if parent element is hidden, reordered or it's
								// position type changes (in Gecko), but since we basically need this only in IEs 6/7 and
								// sometimes 8 and they do not have this problem, we can comment this for now
								/*tr.bind("RuntimeInit", function(e, runtime) {
									tr.destroy();
									runtime.destroy();
									onResize.call(self); // re-feed our image data
								});*/

								runtime = null; // release
							}, 999);

							runtime.exec.call(self, "ImageView", "display", this.result.uid, width, height);
							img.destroy();
						});

						tr.transport(Encode.atob(dataUrl.substring(dataUrl.indexOf('base64,') + 7)), type, {
							required_caps: {
								display_media: true
							},
							runtime_order: 'flash,silverlight',
							container: el
						});
					}
				}

				try {
					if (!(el = Dom.get(el))) {
						throw new x.DOMException(x.DOMException.INVALID_NODE_TYPE_ERR);
					}

					if (!this.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}
					
					// high-resolution images cannot be consistently handled across the runtimes
					if (this.width > Image.MAX_RESIZE_WIDTH || this.height > Image.MAX_RESIZE_HEIGHT) {
						//throw new x.ImageError(x.ImageError.MAX_RESOLUTION_ERR);
					}

					var imgCopy = new Image();

					imgCopy.bind("Resize", function() {
						render.call(this, opts.type, opts.quality);
					});

					imgCopy.bind("Load", function() {
						this.downsize(opts);
					});

					// if embedded thumb data is available and dimensions are big enough, use it
					if (this.meta.thumb && this.meta.thumb.width >= opts.width && this.meta.thumb.height >= opts.height) {
						imgCopy.load(this.meta.thumb.data);
					} else {
						imgCopy.clone(this, false);
					}

					return imgCopy;
				} catch(ex) {
					// for now simply trigger error event
					this.trigger('error', ex.code);
				}
			},

			/**
			Properly destroys the image and frees resources in use. If any. Recommended way to dispose mOxie.Image object.

			@method destroy
			*/
			destroy: function() {
				if (this.ruid) {
					this.getRuntime().exec.call(this, 'Image', 'destroy');
					this.disconnectRuntime();
				}
				if (this.meta && this.meta.thumb) {
					// thumb is blob, make sure we destroy it first
					this.meta.thumb.data.destroy();
				}
				this.unbindAll();
			}
		});


		// this is here, because in order to bind properly, we need uid, which is created above
		this.handleEventProps(dispatches);

		this.bind('Load Resize', function() {
			return _updateInfo.call(this); // if operation fails (e.g. image is neither PNG nor JPEG) cancel all pending events
		}, 999);


		function _updateInfo(info) {
			try {
				if (!info) {
					info = this.exec('Image', 'getInfo');
				}

				this.size = info.size;
				this.width = info.width;
				this.height = info.height;
				this.type = info.type;
				this.meta = info.meta;

				// update file name, only if empty
				if (this.name === '') {
					this.name = info.name;
				}

				return true;
			} catch(ex) {
				this.trigger('error', ex.code);
				return false;
			}
		}


		function _load(src) {
			var srcType = Basic.typeOf(src);

			try {
				// if source is Image
				if (src instanceof Image) {
					if (!src.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}
					_loadFromImage.apply(this, arguments);
				}
				// if source is o.Blob/o.File
				else if (src instanceof Blob) {
					if (!~Basic.inArray(src.type, ['image/jpeg', 'image/png'])) {
						throw new x.ImageError(x.ImageError.WRONG_FORMAT);
					}
					_loadFromBlob.apply(this, arguments);
				}
				// if native blob/file
				else if (Basic.inArray(srcType, ['blob', 'file']) !== -1) {
					_load.call(this, new File(null, src), arguments[1]);
				}
				// if String
				else if (srcType === 'string') {
					// if dataUrl String
					if (src.substr(0, 5) === 'data:') {
						_load.call(this, new Blob(null, { data: src }), arguments[1]);
					}
					// else assume Url, either relative or absolute
					else {
						_loadFromUrl.apply(this, arguments);
					}
				}
				// if source seems to be an img node
				else if (srcType === 'node' && src.nodeName.toLowerCase() === 'img') {
					_load.call(this, src.src, arguments[1]);
				}
				else {
					throw new x.DOMException(x.DOMException.TYPE_MISMATCH_ERR);
				}
			} catch(ex) {
				// for now simply trigger error event
				this.trigger('error', ex.code);
			}
		}


		function _loadFromImage(img, exact) {
			var runtime = this.connectRuntime(img.ruid);
			this.ruid = runtime.uid;
			runtime.exec.call(this, 'Image', 'loadFromImage', img, (Basic.typeOf(exact) === 'undefined' ? true : exact));
		}


		function _loadFromBlob(blob, options) {
			var self = this;

			self.name = blob.name || '';

			function exec(runtime) {
				self.ruid = runtime.uid;
				runtime.exec.call(self, 'Image', 'loadFromBlob', blob);
			}

			if (blob.isDetached()) {
				this.bind('RuntimeInit', function(e, runtime) {
					exec(runtime);
				});

				// convert to object representation
				if (options && typeof(options.required_caps) === 'string') {
					options.required_caps = Runtime.parseCaps(options.required_caps);
				}

				this.connectRuntime(Basic.extend({
					required_caps: {
						access_image_binary: true,
						resize_image: true
					}
				}, options));
			} else {
				exec(this.connectRuntime(blob.ruid));
			}
		}


		function _loadFromUrl(url, options) {
			var self = this, xhr;

			xhr = new XMLHttpRequest();

			xhr.open('get', url);
			xhr.responseType = 'blob';

			xhr.onprogress = function(e) {
				self.trigger(e);
			};

			xhr.onload = function() {
				_loadFromBlob.call(self, xhr.response, true);
			};

			xhr.onerror = function(e) {
				self.trigger(e);
			};

			xhr.onloadend = function() {
				xhr.destroy();
			};

			xhr.bind('RuntimeError', function(e, err) {
				self.trigger('RuntimeError', err);
			});

			xhr.send(null, options);
		}
	}

	// virtual world will crash on you if image has a resolution higher than this:
	Image.MAX_RESIZE_WIDTH = 8192;
	Image.MAX_RESIZE_HEIGHT = 8192; 

	Image.prototype = EventTarget.instance;

	return Image;
});

// Included from: src/javascript/runtime/html5/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global File:true */

/**
Defines constructor for HTML5 runtime.

@class moxie/runtime/html5/Runtime
@private
*/
define("moxie/runtime/html5/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime",
	"moxie/core/utils/Env"
], function(Basic, x, Runtime, Env) {
	
	var type = "html5", extensions = {};
	
	function Html5Runtime(options) {
		var I = this
		, Test = Runtime.capTest
		, True = Runtime.capTrue
		;

		var caps = Basic.extend({
				access_binary: Test(window.FileReader || window.File && window.File.getAsDataURL),
				access_image_binary: function() {
					return I.can('access_binary') && !!extensions.Image;
				},
				display_media: Test(
					(Env.can('create_canvas') || Env.can('use_data_uri_over32kb')) && 
					defined('moxie/image/Image')
				),
				do_cors: Test(window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()),
				drag_and_drop: Test(function() {
					// this comes directly from Modernizr: http://www.modernizr.com/
					var div = document.createElement('div');
					// IE has support for drag and drop since version 5, but doesn't support dropping files from desktop
					return (('draggable' in div) || ('ondragstart' in div && 'ondrop' in div)) && 
						(Env.browser !== 'IE' || Env.verComp(Env.version, 9, '>'));
				}()),
				filter_by_extension: Test(function() { // if you know how to feature-detect this, please suggest
					return !(
						(Env.browser === 'Chrome' && Env.verComp(Env.version, 28, '<')) || 
						(Env.browser === 'IE' && Env.verComp(Env.version, 10, '<')) || 
						(Env.browser === 'Safari' && Env.verComp(Env.version, 7, '<')) ||
						(Env.browser === 'Firefox' && Env.verComp(Env.version, 37, '<'))
					);
				}()),
				return_response_headers: True,
				return_response_type: function(responseType) {
					if (responseType === 'json' && !!window.JSON) { // we can fake this one even if it's not supported
						return true;
					} 
					return Env.can('return_response_type', responseType);
				},
				return_status_code: True,
				report_upload_progress: Test(window.XMLHttpRequest && new XMLHttpRequest().upload),
				resize_image: function() {
					return I.can('access_binary') && Env.can('create_canvas');
				},
				select_file: function() {
					return Env.can('use_fileinput') && window.File;
				},
				select_folder: function() {
					return I.can('select_file') && (
						Env.browser === 'Chrome' && Env.verComp(Env.version, 21, '>=') ||
						Env.browser === 'Firefox' && Env.verComp(Env.version, 42, '>=') // https://developer.mozilla.org/en-US/Firefox/Releases/42
					);
				},
				select_multiple: function() {
					// it is buggy on Safari Windows and iOS
					return I.can('select_file') &&
						!(Env.browser === 'Safari' && Env.os === 'Windows') &&
						!(Env.os === 'iOS' && Env.verComp(Env.osVersion, "7.0.0", '>') && Env.verComp(Env.osVersion, "8.0.0", '<'));
				},
				send_binary_string: Test(window.XMLHttpRequest && (new XMLHttpRequest().sendAsBinary || (window.Uint8Array && window.ArrayBuffer))),
				send_custom_headers: Test(window.XMLHttpRequest),
				send_multipart: function() {
					return !!(window.XMLHttpRequest && new XMLHttpRequest().upload && window.FormData) || I.can('send_binary_string');
				},
				slice_blob: Test(window.File && (File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice)),
				stream_upload: function(){
					return I.can('slice_blob') && I.can('send_multipart');
				},
				summon_file_dialog: function() { // yeah... some dirty sniffing here...
					return I.can('select_file') && (
						(Env.browser === 'Firefox' && Env.verComp(Env.version, 4, '>=')) ||
						(Env.browser === 'Opera' && Env.verComp(Env.version, 12, '>=')) ||
						(Env.browser === 'IE' && Env.verComp(Env.version, 10, '>=')) ||
						!!~Basic.inArray(Env.browser, ['Chrome', 'Safari', 'Edge'])
					);
				},
				upload_filesize: True,
				use_http_method: True
			}, 
			arguments[2]
		);

		Runtime.call(this, options, (arguments[1] || type), caps);


		Basic.extend(this, {

			init : function() {
				this.trigger("Init");
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					destroy = I = null;
				};
			}(this.destroy))
		});

		Basic.extend(this.getShim(), extensions);
	}

	Runtime.addConstructor(type, Html5Runtime);

	return extensions;
});

// Included from: src/javascript/runtime/html5/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/Blob
@private
*/
define("moxie/runtime/html5/file/Blob", [
	"moxie/runtime/html5/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	function HTML5Blob() {
		function w3cBlobSlice(blob, start, end) {
			var blobSlice;

			if (window.File.prototype.slice) {
				try {
					blob.slice();	// depricated version will throw WRONG_ARGUMENTS_ERR exception
					return blob.slice(start, end);
				} catch (e) {
					// depricated slice method
					return blob.slice(start, end - start);
				}
			// slice method got prefixed: https://bugzilla.mozilla.org/show_bug.cgi?id=649672
			} else if ((blobSlice = window.File.prototype.webkitSlice || window.File.prototype.mozSlice)) {
				return blobSlice.call(blob, start, end);
			} else {
				return null; // or throw some exception
			}
		}

		this.slice = function() {
			return new Blob(this.getRuntime().uid, w3cBlobSlice.apply(this, arguments));
		};
	}

	return (extensions.Blob = HTML5Blob);
});

// Included from: src/javascript/core/utils/Events.js

/**
 * Events.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Events', [
	'moxie/core/utils/Basic'
], function(Basic) {
	var eventhash = {}, uid = 'moxie_' + Basic.guid();
	
	// IE W3C like event funcs
	function preventDefault() {
		this.returnValue = false;
	}

	function stopPropagation() {
		this.cancelBubble = true;
	}

	/**
	Adds an event handler to the specified object and store reference to the handler
	in objects internal Plupload registry (@see removeEvent).
	
	@method addEvent
	@for Utils
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Name to add event listener to.
	@param {Function} callback Function to call when event occurs.
	@param {String} [key] that might be used to add specifity to the event record.
	*/
	var addEvent = function(obj, name, callback, key) {
		var func, events;
					
		name = name.toLowerCase();

		// Add event listener
		if (obj.addEventListener) {
			func = callback;
			
			obj.addEventListener(name, func, false);
		} else if (obj.attachEvent) {
			func = function() {
				var evt = window.event;

				if (!evt.target) {
					evt.target = evt.srcElement;
				}

				evt.preventDefault = preventDefault;
				evt.stopPropagation = stopPropagation;

				callback(evt);
			};

			obj.attachEvent('on' + name, func);
		}
		
		// Log event handler to objects internal mOxie registry
		if (!obj[uid]) {
			obj[uid] = Basic.guid();
		}
		
		if (!eventhash.hasOwnProperty(obj[uid])) {
			eventhash[obj[uid]] = {};
		}
		
		events = eventhash[obj[uid]];
		
		if (!events.hasOwnProperty(name)) {
			events[name] = [];
		}
				
		events[name].push({
			func: func,
			orig: callback, // store original callback for IE
			key: key
		});
	};
	
	
	/**
	Remove event handler from the specified object. If third argument (callback)
	is not specified remove all events with the specified name.
	
	@method removeEvent
	@static
	@param {Object} obj DOM element to remove event listener(s) from.
	@param {String} name Name of event listener to remove.
	@param {Function|String} [callback] might be a callback or unique key to match.
	*/
	var removeEvent = function(obj, name, callback) {
		var type, undef;
		
		name = name.toLowerCase();
		
		if (obj[uid] && eventhash[obj[uid]] && eventhash[obj[uid]][name]) {
			type = eventhash[obj[uid]][name];
		} else {
			return;
		}
			
		for (var i = type.length - 1; i >= 0; i--) {
			// undefined or not, key should match
			if (type[i].orig === callback || type[i].key === callback) {
				if (obj.removeEventListener) {
					obj.removeEventListener(name, type[i].func, false);
				} else if (obj.detachEvent) {
					obj.detachEvent('on'+name, type[i].func);
				}
				
				type[i].orig = null;
				type[i].func = null;
				type.splice(i, 1);
				
				// If callback was passed we are done here, otherwise proceed
				if (callback !== undef) {
					break;
				}
			}
		}
		
		// If event array got empty, remove it
		if (!type.length) {
			delete eventhash[obj[uid]][name];
		}
		
		// If mOxie registry has become empty, remove it
		if (Basic.isEmptyObj(eventhash[obj[uid]])) {
			delete eventhash[obj[uid]];
			
			// IE doesn't let you remove DOM object property with - delete
			try {
				delete obj[uid];
			} catch(e) {
				obj[uid] = undef;
			}
		}
	};
	
	
	/**
	Remove all kind of events from the specified object
	
	@method removeAllEvents
	@static
	@param {Object} obj DOM element to remove event listeners from.
	@param {String} [key] unique key to match, when removing events.
	*/
	var removeAllEvents = function(obj, key) {		
		if (!obj || !obj[uid]) {
			return;
		}
		
		Basic.each(eventhash[obj[uid]], function(events, name) {
			removeEvent(obj, name, key);
		});
	};

	return {
		addEvent: addEvent,
		removeEvent: removeEvent,
		removeAllEvents: removeAllEvents
	};
});

// Included from: src/javascript/runtime/html5/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileInput
@private
*/
define("moxie/runtime/html5/file/FileInput", [
	"moxie/runtime/html5/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, File, Basic, Dom, Events, Mime, Env) {
	
	function FileInput() {
		var _options, _browseBtnZIndex; // save original z-index

		Basic.extend(this, {
			init: function(options) {
				var comp = this, I = comp.getRuntime(), input, shimContainer, mimes, browseButton, zIndex, top;

				_options = options;

				// figure out accept string
				mimes = _options.accept.mimes || Mime.extList2mimes(_options.accept, I.can('filter_by_extension'));

				shimContainer = I.getShimContainer();

				shimContainer.innerHTML = '<input id="' + I.uid +'" type="file" style="font-size:999px;opacity:0;"' +
					(_options.multiple && I.can('select_multiple') ? 'multiple' : '') + 
					(_options.directory && I.can('select_folder') ? 'webkitdirectory directory' : '') + // Chrome 11+
					(mimes ? ' accept="' + mimes.join(',') + '"' : '') + ' />';

				input = Dom.get(I.uid);

				// prepare file input to be placed underneath the browse_button element
				Basic.extend(input.style, {
					position: 'absolute',
					top: 0,
					left: 0,
					width: '100%',
					height: '100%'
				});


				browseButton = Dom.get(_options.browse_button);
				_browseBtnZIndex = Dom.getStyle(browseButton, 'z-index') || 'auto';

				// Route click event to the input[type=file] element for browsers that support such behavior
				if (I.can('summon_file_dialog')) {
					if (Dom.getStyle(browseButton, 'position') === 'static') {
						browseButton.style.position = 'relative';
					}

					Events.addEvent(browseButton, 'click', function(e) {
						var input = Dom.get(I.uid);
						if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
							input.click();
						}
						e.preventDefault();
					}, comp.uid);

					comp.bind('Refresh', function() {
						zIndex = parseInt(_browseBtnZIndex, 10) || 1;

						Dom.get(_options.browse_button).style.zIndex = zIndex;
						this.getRuntime().getShimContainer().style.zIndex = zIndex - 1;
					});
				}

				/* Since we have to place input[type=file] on top of the browse_button for some browsers,
				browse_button loses interactivity, so we restore it here */
				top = I.can('summon_file_dialog') ? browseButton : shimContainer;

				Events.addEvent(top, 'mouseover', function() {
					comp.trigger('mouseenter');
				}, comp.uid);

				Events.addEvent(top, 'mouseout', function() {
					comp.trigger('mouseleave');
				}, comp.uid);

				Events.addEvent(top, 'mousedown', function() {
					comp.trigger('mousedown');
				}, comp.uid);

				Events.addEvent(Dom.get(_options.container), 'mouseup', function() {
					comp.trigger('mouseup');
				}, comp.uid);


				input.onchange = function onChange(e) { // there should be only one handler for this
					comp.files = [];

					Basic.each(this.files, function(file) {
						var relativePath = '';

						if (_options.directory) {
							// folders are represented by dots, filter them out (Chrome 11+)
							if (file.name == ".") {
								// if it looks like a folder...
								return true;
							}
						}

						if (file.webkitRelativePath) {
							relativePath = '/' + file.webkitRelativePath.replace(/^\//, '');
						}
						
						file = new File(I.uid, file);
						file.relativePath = relativePath;

						comp.files.push(file);
					});

					// clearing the value enables the user to select the same file again if they want to
					if (Env.browser !== 'IE' && Env.browser !== 'IEMobile') {
						this.value = '';
					} else {
						// in IE input[type="file"] is read-only so the only way to reset it is to re-insert it
						var clone = this.cloneNode(true);
						this.parentNode.replaceChild(clone, this);
						clone.onchange = onChange;
					}

					if (comp.files.length) {
						comp.trigger('change');
					}
				};

				// ready event is perfectly asynchronous
				comp.trigger({
					type: 'ready',
					async: true
				});

				shimContainer = null;
			},


			setOption: function(name, value) {
				var I = this.getRuntime();
				var input = Dom.get(I.uid);

				switch (name) {
					case 'accept':
						if (value) {
							var mimes = value.mimes || Mime.extList2mimes(value, I.can('filter_by_extension'));
							input.setAttribute('accept', mimes.join(','));
						} else {
							input.removeAttribute('accept');
						}
						break;

					case 'directory':
						if (value && I.can('select_folder')) {
							input.setAttribute('directory', '');
							input.setAttribute('webkitdirectory', '');
						} else {
							input.removeAttribute('directory');
							input.removeAttribute('webkitdirectory');
						}
						break;

					case 'multiple':
						if (value && I.can('select_multiple')) {
							input.setAttribute('multiple', '');
						} else {
							input.removeAttribute('multiple');
						}

				}
			},


			disable: function(state) {
				var I = this.getRuntime(), input;

				if ((input = Dom.get(I.uid))) {
					input.disabled = !!state;
				}
			},

			destroy: function() {
				var I = this.getRuntime()
				, shim = I.getShim()
				, shimContainer = I.getShimContainer()
				, container = _options && Dom.get(_options.container)
				, browseButton = _options && Dom.get(_options.browse_button)
				;
				
				if (container) {
					Events.removeAllEvents(container, this.uid);
				}
				
				if (browseButton) {
					Events.removeAllEvents(browseButton, this.uid);
					browseButton.style.zIndex = _browseBtnZIndex; // reset to original value
				}
				
				if (shimContainer) {
					Events.removeAllEvents(shimContainer, this.uid);
					shimContainer.innerHTML = '';
				}

				shim.removeInstance(this.uid);

				_options = shimContainer = container = browseButton = shim = null;
			}
		});
	}

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/html5/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileDrop
@private
*/
define("moxie/runtime/html5/file/FileDrop", [
	"moxie/runtime/html5/Runtime",
	'moxie/file/File',
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime"
], function(extensions, File, Basic, Dom, Events, Mime) {
	
	function FileDrop() {
		var _files = [], _allowedExts = [], _options, _ruid;

		Basic.extend(this, {
			init: function(options) {
				var comp = this, dropZone;

				_options = options;
				_ruid = comp.ruid; // every dropped-in file should have a reference to the runtime
				_allowedExts = _extractExts(_options.accept);
				dropZone = _options.container;

				Events.addEvent(dropZone, 'dragover', function(e) {
					if (!_hasFiles(e)) {
						return;
					}
					e.preventDefault();
					e.dataTransfer.dropEffect = 'copy';
				}, comp.uid);

				Events.addEvent(dropZone, 'drop', function(e) {
					if (!_hasFiles(e)) {
						return;
					}
					e.preventDefault();

					_files = [];

					// Chrome 21+ accepts folders via Drag'n'Drop
					if (e.dataTransfer.items && e.dataTransfer.items[0].webkitGetAsEntry) {
						_readItems(e.dataTransfer.items, function() {
							comp.files = _files;
							comp.trigger("drop");
						});
					} else {
						Basic.each(e.dataTransfer.files, function(file) {
							_addFile(file);
						});
						comp.files = _files;
						comp.trigger("drop");
					}
				}, comp.uid);

				Events.addEvent(dropZone, 'dragenter', function(e) {
					comp.trigger("dragenter");
				}, comp.uid);

				Events.addEvent(dropZone, 'dragleave', function(e) {
					comp.trigger("dragleave");
				}, comp.uid);
			},

			destroy: function() {
				Events.removeAllEvents(_options && Dom.get(_options.container), this.uid);
				_ruid = _files = _allowedExts = _options = null;
			}
		});


		function _hasFiles(e) {
			if (!e.dataTransfer || !e.dataTransfer.types) { // e.dataTransfer.files is not available in Gecko during dragover
				return false;
			}

			var types = Basic.toArray(e.dataTransfer.types || []);

			return Basic.inArray("Files", types) !== -1 ||
				Basic.inArray("public.file-url", types) !== -1 || // Safari < 5
				Basic.inArray("application/x-moz-file", types) !== -1 // Gecko < 1.9.2 (< Firefox 3.6)
				;
		}


		function _addFile(file, relativePath) {
			if (_isAcceptable(file)) {
				var fileObj = new File(_ruid, file);
				fileObj.relativePath = relativePath || '';
				_files.push(fileObj);
			}
		}

		
		function _extractExts(accept) {
			var exts = [];
			for (var i = 0; i < accept.length; i++) {
				[].push.apply(exts, accept[i].extensions.split(/\s*,\s*/));
			}
			return Basic.inArray('*', exts) === -1 ? exts : [];
		}


		function _isAcceptable(file) {
			if (!_allowedExts.length) {
				return true;
			}
			var ext = Mime.getFileExtension(file.name);
			return !ext || Basic.inArray(ext, _allowedExts) !== -1;
		}


		function _readItems(items, cb) {
			var entries = [];
			Basic.each(items, function(item) {
				var entry = item.webkitGetAsEntry();
				// Address #998 (https://code.google.com/p/chromium/issues/detail?id=332579)
				if (entry) {
					// file() fails on OSX when the filename contains a special character (e.g. umlaut): see #61
					if (entry.isFile) {
						_addFile(item.getAsFile(), entry.fullPath);
					} else {
						entries.push(entry);
					}
				}
			});

			if (entries.length) {
				_readEntries(entries, cb);
			} else {
				cb();
			}
		}


		function _readEntries(entries, cb) {
			var queue = [];
			Basic.each(entries, function(entry) {
				queue.push(function(cbcb) {
					_readEntry(entry, cbcb);
				});
			});
			Basic.inSeries(queue, function() {
				cb();
			});
		}


		function _readEntry(entry, cb) {
			if (entry.isFile) {
				entry.file(function(file) {
					_addFile(file, entry.fullPath);
					cb();
				}, function() {
					// fire an error event maybe
					cb();
				});
			} else if (entry.isDirectory) {
				_readDirEntry(entry, cb);
			} else {
				cb(); // not file, not directory? what then?..
			}
		}


		function _readDirEntry(dirEntry, cb) {
			var entries = [], dirReader = dirEntry.createReader();

			// keep quering recursively till no more entries
			function getEntries(cbcb) {
				dirReader.readEntries(function(moreEntries) {
					if (moreEntries.length) {
						[].push.apply(entries, moreEntries);
						getEntries(cbcb);
					} else {
						cbcb();
					}
				}, cbcb);
			}

			// ...and you thought FileReader was crazy...
			getEntries(function() {
				_readEntries(entries, cb);
			}); 
		}
	}

	return (extensions.FileDrop = FileDrop);
});

// Included from: src/javascript/runtime/html5/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileReader
@private
*/
define("moxie/runtime/html5/file/FileReader", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Encode",
	"moxie/core/utils/Basic"
], function(extensions, Encode, Basic) {
	
	function FileReader() {
		var _fr, _convertToBinary = false;

		Basic.extend(this, {

			read: function(op, blob) {
				var comp = this;

				comp.result = '';

				_fr = new window.FileReader();

				_fr.addEventListener('progress', function(e) {
					comp.trigger(e);
				});

				_fr.addEventListener('load', function(e) {
					comp.result = _convertToBinary ? _toBinary(_fr.result) : _fr.result;
					comp.trigger(e);
				});

				_fr.addEventListener('error', function(e) {
					comp.trigger(e, _fr.error);
				});

				_fr.addEventListener('loadend', function(e) {
					_fr = null;
					comp.trigger(e);
				});

				if (Basic.typeOf(_fr[op]) === 'function') {
					_convertToBinary = false;
					_fr[op](blob.getSource());
				} else if (op === 'readAsBinaryString') { // readAsBinaryString is depricated in general and never existed in IE10+
					_convertToBinary = true;
					_fr.readAsDataURL(blob.getSource());
				}
			},

			abort: function() {
				if (_fr) {
					_fr.abort();
				}
			},

			destroy: function() {
				_fr = null;
			}
		});

		function _toBinary(str) {
			return Encode.atob(str.substring(str.indexOf('base64,') + 7));
		}
	}

	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/html5/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
@class moxie/runtime/html5/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/html5/xhr/XMLHttpRequest", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Url",
	"moxie/file/File",
	"moxie/file/Blob",
	"moxie/xhr/FormData",
	"moxie/core/Exceptions",
	"moxie/core/utils/Env"
], function(extensions, Basic, Mime, Url, File, Blob, FormData, x, Env) {
	
	function XMLHttpRequest() {
		var self = this
		, _xhr
		, _filename
		;

		Basic.extend(this, {
			send: function(meta, data) {
				var target = this
				, isGecko2_5_6 = (Env.browser === 'Mozilla' && Env.verComp(Env.version, 4, '>=') && Env.verComp(Env.version, 7, '<'))
				, isAndroidBrowser = Env.browser === 'Android Browser'
				, mustSendAsBinary = false
				;

				// extract file name
				_filename = meta.url.replace(/^.+?\/([\w\-\.]+)$/, '$1').toLowerCase();

				_xhr = _getNativeXHR();
				_xhr.open(meta.method, meta.url, meta.async, meta.user, meta.password);


				// prepare data to be sent
				if (data instanceof Blob) {
					if (data.isDetached()) {
						mustSendAsBinary = true;
					}
					data = data.getSource();
				} else if (data instanceof FormData) {

					if (data.hasBlob()) {
						if (data.getBlob().isDetached()) {
							data = _prepareMultipart.call(target, data); // _xhr must be instantiated and be in OPENED state
							mustSendAsBinary = true;
						} else if ((isGecko2_5_6 || isAndroidBrowser) && Basic.typeOf(data.getBlob().getSource()) === 'blob' && window.FileReader) {
							// Gecko 2/5/6 can't send blob in FormData: https://bugzilla.mozilla.org/show_bug.cgi?id=649150
							// Android browsers (default one and Dolphin) seem to have the same issue, see: #613
							_preloadAndSend.call(target, meta, data);
							return; // _preloadAndSend will reinvoke send() with transmutated FormData =%D
						}	
					}

					// transfer fields to real FormData
					if (data instanceof FormData) { // if still a FormData, e.g. not mangled by _prepareMultipart()
						var fd = new window.FormData();
						data.each(function(value, name) {
							if (value instanceof Blob) {
								fd.append(name, value.getSource());
							} else {
								fd.append(name, value);
							}
						});
						data = fd;
					}
				}


				// if XHR L2
				if (_xhr.upload) {
					if (meta.withCredentials) {
						_xhr.withCredentials = true;
					}

					_xhr.addEventListener('load', function(e) {
						target.trigger(e);
					});

					_xhr.addEventListener('error', function(e) {
						target.trigger(e);
					});

					// additionally listen to progress events
					_xhr.addEventListener('progress', function(e) {
						target.trigger(e);
					});

					_xhr.upload.addEventListener('progress', function(e) {
						target.trigger({
							type: 'UploadProgress',
							loaded: e.loaded,
							total: e.total
						});
					});
				// ... otherwise simulate XHR L2
				} else {
					_xhr.onreadystatechange = function onReadyStateChange() {
						
						// fake Level 2 events
						switch (_xhr.readyState) {
							
							case 1: // XMLHttpRequest.OPENED
								// readystatechanged is fired twice for OPENED state (in IE and Mozilla) - neu
								break;
							
							// looks like HEADERS_RECEIVED (state 2) is not reported in Opera (or it's old versions) - neu
							case 2: // XMLHttpRequest.HEADERS_RECEIVED
								break;
								
							case 3: // XMLHttpRequest.LOADING 
								// try to fire progress event for not XHR L2
								var total, loaded;
								
								try {
									if (Url.hasSameOrigin(meta.url)) { // Content-Length not accessible for cross-domain on some browsers
										total = _xhr.getResponseHeader('Content-Length') || 0; // old Safari throws an exception here
									}

									if (_xhr.responseText) { // responseText was introduced in IE7
										loaded = _xhr.responseText.length;
									}
								} catch(ex) {
									total = loaded = 0;
								}

								target.trigger({
									type: 'progress',
									lengthComputable: !!total,
									total: parseInt(total, 10),
									loaded: loaded
								});
								break;
								
							case 4: // XMLHttpRequest.DONE
								// release readystatechange handler (mostly for IE)
								_xhr.onreadystatechange = function() {};

								// usually status 0 is returned when server is unreachable, but FF also fails to status 0 for 408 timeout
								if (_xhr.status === 0) {
									target.trigger('error');
								} else {
									target.trigger('load');
								}							
								break;
						}
					};
				}
				

				// set request headers
				if (!Basic.isEmptyObj(meta.headers)) {
					Basic.each(meta.headers, function(value, header) {
						_xhr.setRequestHeader(header, value);
					});
				}

				// request response type
				if ("" !== meta.responseType && 'responseType' in _xhr) {
					if ('json' === meta.responseType && !Env.can('return_response_type', 'json')) { // we can fake this one
						_xhr.responseType = 'text';
					} else {
						_xhr.responseType = meta.responseType;
					}
				}

				// send ...
				if (!mustSendAsBinary) {
					_xhr.send(data);
				} else {
					if (_xhr.sendAsBinary) { // Gecko
						_xhr.sendAsBinary(data);
					} else { // other browsers having support for typed arrays
						(function() {
							// mimic Gecko's sendAsBinary
							var ui8a = new Uint8Array(data.length);
							for (var i = 0; i < data.length; i++) {
								ui8a[i] = (data.charCodeAt(i) & 0xff);
							}
							_xhr.send(ui8a.buffer);
						}());
					}
				}

				target.trigger('loadstart');
			},

			getStatus: function() {
				// according to W3C spec it should return 0 for readyState < 3, but instead it throws an exception
				try {
					if (_xhr) {
						return _xhr.status;
					}
				} catch(ex) {}
				return 0;
			},

			getResponse: function(responseType) {
				var I = this.getRuntime();

				try {
					switch (responseType) {
						case 'blob':
							var file = new File(I.uid, _xhr.response);
							
							// try to extract file name from content-disposition if possible (might be - not, if CORS for example)	
							var disposition = _xhr.getResponseHeader('Content-Disposition');
							if (disposition) {
								// extract filename from response header if available
								var match = disposition.match(/filename=([\'\"'])([^\1]+)\1/);
								if (match) {
									_filename = match[2];
								}
							}
							file.name = _filename;

							// pre-webkit Opera doesn't set type property on the blob response
							if (!file.type) {
								file.type = Mime.getFileMime(_filename);
							}
							return file;

						case 'json':
							if (!Env.can('return_response_type', 'json')) {
								return _xhr.status === 200 && !!window.JSON ? JSON.parse(_xhr.responseText) : null;
							}
							return _xhr.response;

						case 'document':
							return _getDocument(_xhr);

						default:
							return _xhr.responseText !== '' ? _xhr.responseText : null; // against the specs, but for consistency across the runtimes
					}
				} catch(ex) {
					return null;
				}				
			},

			getAllResponseHeaders: function() {
				try {
					return _xhr.getAllResponseHeaders();
				} catch(ex) {}
				return '';
			},

			abort: function() {
				if (_xhr) {
					_xhr.abort();
				}
			},

			destroy: function() {
				self = _filename = null;
			}
		});


		// here we go... ugly fix for ugly bug
		function _preloadAndSend(meta, data) {
			var target = this, blob, fr;
				
			// get original blob
			blob = data.getBlob().getSource();
			
			// preload blob in memory to be sent as binary string
			fr = new window.FileReader();
			fr.onload = function() {
				// overwrite original blob
				data.append(data.getBlobName(), new Blob(null, {
					type: blob.type,
					data: fr.result
				}));
				// invoke send operation again
				self.send.call(target, meta, data);
			};
			fr.readAsBinaryString(blob);
		}

		
		function _getNativeXHR() {
			if (window.XMLHttpRequest && !(Env.browser === 'IE' && Env.verComp(Env.version, 8, '<'))) { // IE7 has native XHR but it's buggy
				return new window.XMLHttpRequest();
			} else {
				return (function() {
					var progIDs = ['Msxml2.XMLHTTP.6.0', 'Microsoft.XMLHTTP']; // if 6.0 available, use it, otherwise failback to default 3.0
					for (var i = 0; i < progIDs.length; i++) {
						try {
							return new ActiveXObject(progIDs[i]);
						} catch (ex) {}
					}
				})();
			}
		}
		
		// @credits Sergey Ilinsky	(http://www.ilinsky.com/)
		function _getDocument(xhr) {
			var rXML = xhr.responseXML;
			var rText = xhr.responseText;
			
			// Try parsing responseText (@see: http://www.ilinsky.com/articles/XMLHttpRequest/#bugs-ie-responseXML-content-type)
			if (Env.browser === 'IE' && rText && rXML && !rXML.documentElement && /[^\/]+\/[^\+]+\+xml/.test(xhr.getResponseHeader("Content-Type"))) {
				rXML = new window.ActiveXObject("Microsoft.XMLDOM");
				rXML.async = false;
				rXML.validateOnParse = false;
				rXML.loadXML(rText);
			}
	
			// Check if there is no error in document
			if (rXML) {
				if ((Env.browser === 'IE' && rXML.parseError !== 0) || !rXML.documentElement || rXML.documentElement.tagName === "parsererror") {
					return null;
				}
			}
			return rXML;
		}


		function _prepareMultipart(fd) {
			var boundary = '----moxieboundary' + new Date().getTime()
			, dashdash = '--'
			, crlf = '\r\n'
			, multipart = ''
			, I = this.getRuntime()
			;

			if (!I.can('send_binary_string')) {
				throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
			}

			_xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);

			// append multipart parameters
			fd.each(function(value, name) {
				// Firefox 3.6 failed to convert multibyte characters to UTF-8 in sendAsBinary(), 
				// so we try it here ourselves with: unescape(encodeURIComponent(value))
				if (value instanceof Blob) {
					// Build RFC2388 blob
					multipart += dashdash + boundary + crlf +
						'Content-Disposition: form-data; name="' + name + '"; filename="' + unescape(encodeURIComponent(value.name || 'blob')) + '"' + crlf +
						'Content-Type: ' + (value.type || 'application/octet-stream') + crlf + crlf +
						value.getSource() + crlf;
				} else {
					multipart += dashdash + boundary + crlf +
						'Content-Disposition: form-data; name="' + name + '"' + crlf + crlf +
						unescape(encodeURIComponent(value)) + crlf;
				}
			});

			multipart += dashdash + boundary + dashdash + crlf;

			return multipart;
		}
	}

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/html5/utils/BinaryReader.js

/**
 * BinaryReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/utils/BinaryReader
@private
*/
define("moxie/runtime/html5/utils/BinaryReader", [
	"moxie/core/utils/Basic"
], function(Basic) {

	
	function BinaryReader(data) {
		if (data instanceof ArrayBuffer) {
			ArrayBufferReader.apply(this, arguments);
		} else {
			UTF16StringReader.apply(this, arguments);
		}
	}

	Basic.extend(BinaryReader.prototype, {
		
		littleEndian: false,


		read: function(idx, size) {
			var sum, mv, i;

			if (idx + size > this.length()) {
				throw new Error("You are trying to read outside the source boundaries.");
			}
			
			mv = this.littleEndian 
				? 0 
				: -8 * (size - 1)
			;

			for (i = 0, sum = 0; i < size; i++) {
				sum |= (this.readByteAt(idx + i) << Math.abs(mv + i*8));
			}
			return sum;
		},


		write: function(idx, num, size) {
			var mv, i, str = '';

			if (idx > this.length()) {
				throw new Error("You are trying to write outside the source boundaries.");
			}

			mv = this.littleEndian 
				? 0 
				: -8 * (size - 1)
			;

			for (i = 0; i < size; i++) {
				this.writeByteAt(idx + i, (num >> Math.abs(mv + i*8)) & 255);
			}
		},


		BYTE: function(idx) {
			return this.read(idx, 1);
		},


		SHORT: function(idx) {
			return this.read(idx, 2);
		},


		LONG: function(idx) {
			return this.read(idx, 4);
		},


		SLONG: function(idx) { // 2's complement notation
			var num = this.read(idx, 4);
			return (num > 2147483647 ? num - 4294967296 : num);
		},


		CHAR: function(idx) {
			return String.fromCharCode(this.read(idx, 1));
		},


		STRING: function(idx, count) {
			return this.asArray('CHAR', idx, count).join('');
		},


		asArray: function(type, idx, count) {
			var values = [];

			for (var i = 0; i < count; i++) {
				values[i] = this[type](idx + i);
			}
			return values;
		}
	});


	function ArrayBufferReader(data) {
		var _dv = new DataView(data);

		Basic.extend(this, {
			
			readByteAt: function(idx) {
				return _dv.getUint8(idx);
			},


			writeByteAt: function(idx, value) {
				_dv.setUint8(idx, value);
			},
			

			SEGMENT: function(idx, size, value) {
				switch (arguments.length) {
					case 2:
						return data.slice(idx, idx + size);

					case 1:
						return data.slice(idx);

					case 3:
						if (value === null) {
							value = new ArrayBuffer();
						}

						if (value instanceof ArrayBuffer) {					
							var arr = new Uint8Array(this.length() - size + value.byteLength);
							if (idx > 0) {
								arr.set(new Uint8Array(data.slice(0, idx)), 0);
							}
							arr.set(new Uint8Array(value), idx);
							arr.set(new Uint8Array(data.slice(idx + size)), idx + value.byteLength);

							this.clear();
							data = arr.buffer;
							_dv = new DataView(data);
							break;
						}

					default: return data;
				}
			},


			length: function() {
				return data ? data.byteLength : 0;
			},


			clear: function() {
				_dv = data = null;
			}
		});
	}


	function UTF16StringReader(data) {
		Basic.extend(this, {
			
			readByteAt: function(idx) {
				return data.charCodeAt(idx);
			},


			writeByteAt: function(idx, value) {
				putstr(String.fromCharCode(value), idx, 1);
			},


			SEGMENT: function(idx, length, segment) {
				switch (arguments.length) {
					case 1:
						return data.substr(idx);
					case 2:
						return data.substr(idx, length);
					case 3:
						putstr(segment !== null ? segment : '', idx, length);
						break;
					default: return data;
				}
			},


			length: function() {
				return data ? data.length : 0;
			}, 

			clear: function() {
				data = null;
			}
		});


		function putstr(segment, idx, length) {
			length = arguments.length === 3 ? length : data.length - idx - 1;
			data = data.substr(0, idx) + segment + data.substr(length + idx);
		}
	}


	return BinaryReader;
});

// Included from: src/javascript/runtime/html5/image/JPEGHeaders.js

/**
 * JPEGHeaders.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */
 
/**
@class moxie/runtime/html5/image/JPEGHeaders
@private
*/
define("moxie/runtime/html5/image/JPEGHeaders", [
	"moxie/runtime/html5/utils/BinaryReader",
	"moxie/core/Exceptions"
], function(BinaryReader, x) {
	
	return function JPEGHeaders(data) {
		var headers = [], _br, idx, marker, length = 0;

		_br = new BinaryReader(data);

		// Check if data is jpeg
		if (_br.SHORT(0) !== 0xFFD8) {
			_br.clear();
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}

		idx = 2;

		while (idx <= _br.length()) {
			marker = _br.SHORT(idx);

			// omit RST (restart) markers
			if (marker >= 0xFFD0 && marker <= 0xFFD7) {
				idx += 2;
				continue;
			}

			// no headers allowed after SOS marker
			if (marker === 0xFFDA || marker === 0xFFD9) {
				break;
			}

			length = _br.SHORT(idx + 2) + 2;

			// APPn marker detected
			if (marker >= 0xFFE1 && marker <= 0xFFEF) {
				headers.push({
					hex: marker,
					name: 'APP' + (marker & 0x000F),
					start: idx,
					length: length,
					segment: _br.SEGMENT(idx, length)
				});
			}

			idx += length;
		}

		_br.clear();

		return {
			headers: headers,

			restore: function(data) {
				var max, i, br;

				br = new BinaryReader(data);

				idx = br.SHORT(2) == 0xFFE0 ? 4 + br.SHORT(4) : 2;

				for (i = 0, max = headers.length; i < max; i++) {
					br.SEGMENT(idx, 0, headers[i].segment);
					idx += headers[i].length;
				}

				data = br.SEGMENT();
				br.clear();
				return data;
			},

			strip: function(data) {
				var br, headers, jpegHeaders, i;

				jpegHeaders = new JPEGHeaders(data);
				headers = jpegHeaders.headers;
				jpegHeaders.purge();

				br = new BinaryReader(data);

				i = headers.length;
				while (i--) {
					br.SEGMENT(headers[i].start, headers[i].length, '');
				}
				
				data = br.SEGMENT();
				br.clear();
				return data;
			},

			get: function(name) {
				var array = [];

				for (var i = 0, max = headers.length; i < max; i++) {
					if (headers[i].name === name.toUpperCase()) {
						array.push(headers[i].segment);
					}
				}
				return array;
			},

			set: function(name, segment) {
				var array = [], i, ii, max;

				if (typeof(segment) === 'string') {
					array.push(segment);
				} else {
					array = segment;
				}

				for (i = ii = 0, max = headers.length; i < max; i++) {
					if (headers[i].name === name.toUpperCase()) {
						headers[i].segment = array[ii];
						headers[i].length = array[ii].length;
						ii++;
					}
					if (ii >= array.length) {
						break;
					}
				}
			},

			purge: function() {
				this.headers = headers = [];
			}
		};
	};
});

// Included from: src/javascript/runtime/html5/image/ExifParser.js

/**
 * ExifParser.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/ExifParser
@private
*/
define("moxie/runtime/html5/image/ExifParser", [
	"moxie/core/utils/Basic",
	"moxie/runtime/html5/utils/BinaryReader",
	"moxie/core/Exceptions"
], function(Basic, BinaryReader, x) {
	
	function ExifParser(data) {
		var __super__, tags, tagDescs, offsets, idx, Tiff;
		
		BinaryReader.call(this, data);

		tags = {
			tiff: {
				/*
				The image orientation viewed in terms of rows and columns.

				1 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
				2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
				3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
				4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
				5 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
				6 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
				7 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
				8 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
				*/
				0x0112: 'Orientation',
				0x010E: 'ImageDescription',
				0x010F: 'Make',
				0x0110: 'Model',
				0x0131: 'Software',
				0x8769: 'ExifIFDPointer',
				0x8825:	'GPSInfoIFDPointer'
			},
			exif: {
				0x9000: 'ExifVersion',
				0xA001: 'ColorSpace',
				0xA002: 'PixelXDimension',
				0xA003: 'PixelYDimension',
				0x9003: 'DateTimeOriginal',
				0x829A: 'ExposureTime',
				0x829D: 'FNumber',
				0x8827: 'ISOSpeedRatings',
				0x9201: 'ShutterSpeedValue',
				0x9202: 'ApertureValue'	,
				0x9207: 'MeteringMode',
				0x9208: 'LightSource',
				0x9209: 'Flash',
				0x920A: 'FocalLength',
				0xA402: 'ExposureMode',
				0xA403: 'WhiteBalance',
				0xA406: 'SceneCaptureType',
				0xA404: 'DigitalZoomRatio',
				0xA408: 'Contrast',
				0xA409: 'Saturation',
				0xA40A: 'Sharpness'
			},
			gps: {
				0x0000: 'GPSVersionID',
				0x0001: 'GPSLatitudeRef',
				0x0002: 'GPSLatitude',
				0x0003: 'GPSLongitudeRef',
				0x0004: 'GPSLongitude'
			},

			thumb: {
				0x0201: 'JPEGInterchangeFormat',
				0x0202: 'JPEGInterchangeFormatLength'
			}
		};

		tagDescs = {
			'ColorSpace': {
				1: 'sRGB',
				0: 'Uncalibrated'
			},

			'MeteringMode': {
				0: 'Unknown',
				1: 'Average',
				2: 'CenterWeightedAverage',
				3: 'Spot',
				4: 'MultiSpot',
				5: 'Pattern',
				6: 'Partial',
				255: 'Other'
			},

			'LightSource': {
				1: 'Daylight',
				2: 'Fliorescent',
				3: 'Tungsten',
				4: 'Flash',
				9: 'Fine weather',
				10: 'Cloudy weather',
				11: 'Shade',
				12: 'Daylight fluorescent (D 5700 - 7100K)',
				13: 'Day white fluorescent (N 4600 -5400K)',
				14: 'Cool white fluorescent (W 3900 - 4500K)',
				15: 'White fluorescent (WW 3200 - 3700K)',
				17: 'Standard light A',
				18: 'Standard light B',
				19: 'Standard light C',
				20: 'D55',
				21: 'D65',
				22: 'D75',
				23: 'D50',
				24: 'ISO studio tungsten',
				255: 'Other'
			},

			'Flash': {
				0x0000: 'Flash did not fire',
				0x0001: 'Flash fired',
				0x0005: 'Strobe return light not detected',
				0x0007: 'Strobe return light detected',
				0x0009: 'Flash fired, compulsory flash mode',
				0x000D: 'Flash fired, compulsory flash mode, return light not detected',
				0x000F: 'Flash fired, compulsory flash mode, return light detected',
				0x0010: 'Flash did not fire, compulsory flash mode',
				0x0018: 'Flash did not fire, auto mode',
				0x0019: 'Flash fired, auto mode',
				0x001D: 'Flash fired, auto mode, return light not detected',
				0x001F: 'Flash fired, auto mode, return light detected',
				0x0020: 'No flash function',
				0x0041: 'Flash fired, red-eye reduction mode',
				0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
				0x0047: 'Flash fired, red-eye reduction mode, return light detected',
				0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
				0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
				0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
				0x0059: 'Flash fired, auto mode, red-eye reduction mode',
				0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
				0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
			},

			'ExposureMode': {
				0: 'Auto exposure',
				1: 'Manual exposure',
				2: 'Auto bracket'
			},

			'WhiteBalance': {
				0: 'Auto white balance',
				1: 'Manual white balance'
			},

			'SceneCaptureType': {
				0: 'Standard',
				1: 'Landscape',
				2: 'Portrait',
				3: 'Night scene'
			},

			'Contrast': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			'Saturation': {
				0: 'Normal',
				1: 'Low saturation',
				2: 'High saturation'
			},

			'Sharpness': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			// GPS related
			'GPSLatitudeRef': {
				N: 'North latitude',
				S: 'South latitude'
			},

			'GPSLongitudeRef': {
				E: 'East longitude',
				W: 'West longitude'
			}
		};

		offsets = {
			tiffHeader: 10
		};
		
		idx = offsets.tiffHeader;

		__super__ = {
			clear: this.clear
		};

		// Public functions
		Basic.extend(this, {
			
			read: function() {
				try {
					return ExifParser.prototype.read.apply(this, arguments);
				} catch (ex) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				}
			},


			write: function() {
				try {
					return ExifParser.prototype.write.apply(this, arguments);
				} catch (ex) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				}
			},


			UNDEFINED: function() {
				return this.BYTE.apply(this, arguments);
			},


			RATIONAL: function(idx) {
				return this.LONG(idx) / this.LONG(idx + 4)
			},


			SRATIONAL: function(idx) {
				return this.SLONG(idx) / this.SLONG(idx + 4)
			},

			ASCII: function(idx) {
				return this.CHAR(idx);
			},

			TIFF: function() {
				return Tiff || null;
			},


			EXIF: function() {
				var Exif = null;

				if (offsets.exifIFD) {
					try {
						Exif = extractTags.call(this, offsets.exifIFD, tags.exif);
					} catch(ex) {
						return null;
					}

					// Fix formatting of some tags
					if (Exif.ExifVersion && Basic.typeOf(Exif.ExifVersion) === 'array') {
						for (var i = 0, exifVersion = ''; i < Exif.ExifVersion.length; i++) {
							exifVersion += String.fromCharCode(Exif.ExifVersion[i]);
						}
						Exif.ExifVersion = exifVersion;
					}
				}

				return Exif;
			},


			GPS: function() {
				var GPS = null;

				if (offsets.gpsIFD) {
					try {
						GPS = extractTags.call(this, offsets.gpsIFD, tags.gps);
					} catch (ex) {
						return null;
					}

					// iOS devices (and probably some others) do not put in GPSVersionID tag (why?..)
					if (GPS.GPSVersionID && Basic.typeOf(GPS.GPSVersionID) === 'array') {
						GPS.GPSVersionID = GPS.GPSVersionID.join('.');
					}
				}

				return GPS;
			},


			thumb: function() {
				if (offsets.IFD1) {
					try {
						var IFD1Tags = extractTags.call(this, offsets.IFD1, tags.thumb);
						
						if ('JPEGInterchangeFormat' in IFD1Tags) {
							return this.SEGMENT(offsets.tiffHeader + IFD1Tags.JPEGInterchangeFormat, IFD1Tags.JPEGInterchangeFormatLength);
						}
					} catch (ex) {}
				}
				return null;
			},


			setExif: function(tag, value) {
				// Right now only setting of width/height is possible
				if (tag !== 'PixelXDimension' && tag !== 'PixelYDimension') { return false; }

				return setTag.call(this, 'exif', tag, value);
			},


			clear: function() {
				__super__.clear();
				data = tags = tagDescs = Tiff = offsets = __super__ = null;
			}
		});


		// Check if that's APP1 and that it has EXIF
		if (this.SHORT(0) !== 0xFFE1 || this.STRING(4, 5).toUpperCase() !== "EXIF\0") {
			throw new x.ImageError(x.ImageError.INVALID_META_ERR);
		}

		// Set read order of multi-byte data
		this.littleEndian = (this.SHORT(idx) == 0x4949);

		// Check if always present bytes are indeed present
		if (this.SHORT(idx+=2) !== 0x002A) {
			throw new x.ImageError(x.ImageError.INVALID_META_ERR);
		}

		offsets.IFD0 = offsets.tiffHeader + this.LONG(idx += 2);
		Tiff = extractTags.call(this, offsets.IFD0, tags.tiff);

		if ('ExifIFDPointer' in Tiff) {
			offsets.exifIFD = offsets.tiffHeader + Tiff.ExifIFDPointer;
			delete Tiff.ExifIFDPointer;
		}

		if ('GPSInfoIFDPointer' in Tiff) {
			offsets.gpsIFD = offsets.tiffHeader + Tiff.GPSInfoIFDPointer;
			delete Tiff.GPSInfoIFDPointer;
		}

		if (Basic.isEmptyObj(Tiff)) {
			Tiff = null;
		}

		// check if we have a thumb as well
		var IFD1Offset = this.LONG(offsets.IFD0 + this.SHORT(offsets.IFD0) * 12 + 2);
		if (IFD1Offset) {
			offsets.IFD1 = offsets.tiffHeader + IFD1Offset;
		}


		function extractTags(IFD_offset, tags2extract) {
			var data = this;
			var length, i, tag, type, count, size, offset, value, values = [], hash = {};
			
			var types = {
				1 : 'BYTE',
				7 : 'UNDEFINED',
				2 : 'ASCII',
				3 : 'SHORT',
				4 : 'LONG',
				5 : 'RATIONAL',
				9 : 'SLONG',
				10: 'SRATIONAL'
			};

			var sizes = {
				'BYTE' 		: 1,
				'UNDEFINED'	: 1,
				'ASCII'		: 1,
				'SHORT'		: 2,
				'LONG' 		: 4,
				'RATIONAL' 	: 8,
				'SLONG'		: 4,
				'SRATIONAL'	: 8
			};

			length = data.SHORT(IFD_offset);

			// The size of APP1 including all these elements shall not exceed the 64 Kbytes specified in the JPEG standard.

			for (i = 0; i < length; i++) {
				values = [];

				// Set binary reader pointer to beginning of the next tag
				offset = IFD_offset + 2 + i*12;

				tag = tags2extract[data.SHORT(offset)];

				if (tag === undefined) {
					continue; // Not the tag we requested
				}

				type = types[data.SHORT(offset+=2)];
				count = data.LONG(offset+=2);
				size = sizes[type];

				if (!size) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				}

				offset += 4;

				// tag can only fit 4 bytes of data, if data is larger we should look outside
				if (size * count > 4) {
					// instead of data tag contains an offset of the data
					offset = data.LONG(offset) + offsets.tiffHeader;
				}

				// in case we left the boundaries of data throw an early exception
				if (offset + size * count >= this.length()) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				} 

				// special care for the string
				if (type === 'ASCII') {
					hash[tag] = Basic.trim(data.STRING(offset, count).replace(/\0$/, '')); // strip trailing NULL
					continue;
				} else {
					values = data.asArray(type, offset, count);
					value = (count == 1 ? values[0] : values);

					if (tagDescs.hasOwnProperty(tag) && typeof value != 'object') {
						hash[tag] = tagDescs[tag][value];
					} else {
						hash[tag] = value;
					}
				}
			}

			return hash;
		}

		// At the moment only setting of simple (LONG) values, that do not require offset recalculation, is supported
		function setTag(ifd, tag, value) {
			var offset, length, tagOffset, valueOffset = 0;

			// If tag name passed translate into hex key
			if (typeof(tag) === 'string') {
				var tmpTags = tags[ifd.toLowerCase()];
				for (var hex in tmpTags) {
					if (tmpTags[hex] === tag) {
						tag = hex;
						break;
					}
				}
			}
			offset = offsets[ifd.toLowerCase() + 'IFD'];
			length = this.SHORT(offset);

			for (var i = 0; i < length; i++) {
				tagOffset = offset + 12 * i + 2;

				if (this.SHORT(tagOffset) == tag) {
					valueOffset = tagOffset + 8;
					break;
				}
			}

			if (!valueOffset) {
				return false;
			}

			try {
				this.write(valueOffset, value, 4);
			} catch(ex) {
				return false;
			}

			return true;
		}
	}

	ExifParser.prototype = BinaryReader.prototype;

	return ExifParser;
});

// Included from: src/javascript/runtime/html5/image/JPEG.js

/**
 * JPEG.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/JPEG
@private
*/
define("moxie/runtime/html5/image/JPEG", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/html5/image/JPEGHeaders",
	"moxie/runtime/html5/utils/BinaryReader",
	"moxie/runtime/html5/image/ExifParser"
], function(Basic, x, JPEGHeaders, BinaryReader, ExifParser) {
	
	function JPEG(data) {
		var _br, _hm, _ep, _info;

		_br = new BinaryReader(data);

		// check if it is jpeg
		if (_br.SHORT(0) !== 0xFFD8) {
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}

		// backup headers
		_hm = new JPEGHeaders(data);

		// extract exif info
		try {
			_ep = new ExifParser(_hm.get('app1')[0]);
		} catch(ex) {}

		// get dimensions
		_info = _getDimensions.call(this);

		Basic.extend(this, {
			type: 'image/jpeg',

			size: _br.length(),

			width: _info && _info.width || 0,

			height: _info && _info.height || 0,

			setExif: function(tag, value) {
				if (!_ep) {
					return false; // or throw an exception
				}

				if (Basic.typeOf(tag) === 'object') {
					Basic.each(tag, function(value, tag) {
						_ep.setExif(tag, value);
					});
				} else {
					_ep.setExif(tag, value);
				}

				// update internal headers
				_hm.set('app1', _ep.SEGMENT());
			},

			writeHeaders: function() {
				if (!arguments.length) {
					// if no arguments passed, update headers internally
					return _hm.restore(data);
				}
				return _hm.restore(arguments[0]);
			},

			stripHeaders: function(data) {
				return _hm.strip(data);
			},

			purge: function() {
				_purge.call(this);
			}
		});

		if (_ep) {
			this.meta = {
				tiff: _ep.TIFF(),
				exif: _ep.EXIF(),
				gps: _ep.GPS(),
				thumb: _getThumb()
			};
		}


		function _getDimensions(br) {
			var idx = 0
			, marker
			, length
			;

			if (!br) {
				br = _br;
			}

			// examine all through the end, since some images might have very large APP segments
			while (idx <= br.length()) {
				marker = br.SHORT(idx += 2);

				if (marker >= 0xFFC0 && marker <= 0xFFC3) { // SOFn
					idx += 5; // marker (2 bytes) + length (2 bytes) + Sample precision (1 byte)
					return {
						height: br.SHORT(idx),
						width: br.SHORT(idx += 2)
					};
				}
				length = br.SHORT(idx += 2);
				idx += length - 2;
			}
			return null;
		}


		function _getThumb() {
			var data =  _ep.thumb()
			, br
			, info
			;

			if (data) {
				br = new BinaryReader(data);
				info = _getDimensions(br);
				br.clear();

				if (info) {
					info.data = data;
					return info;
				}
			}
			return null;
		}


		function _purge() {
			if (!_ep || !_hm || !_br) { 
				return; // ignore any repeating purge requests
			}
			_ep.clear();
			_hm.purge();
			_br.clear();
			_info = _hm = _ep = _br = null;
		}
	}

	return JPEG;
});

// Included from: src/javascript/runtime/html5/image/PNG.js

/**
 * PNG.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/PNG
@private
*/
define("moxie/runtime/html5/image/PNG", [
	"moxie/core/Exceptions",
	"moxie/core/utils/Basic",
	"moxie/runtime/html5/utils/BinaryReader"
], function(x, Basic, BinaryReader) {
	
	function PNG(data) {
		var _br, _hm, _ep, _info;

		_br = new BinaryReader(data);

		// check if it's png
		(function() {
			var idx = 0, i = 0
			, signature = [0x8950, 0x4E47, 0x0D0A, 0x1A0A]
			;

			for (i = 0; i < signature.length; i++, idx += 2) {
				if (signature[i] != _br.SHORT(idx)) {
					throw new x.ImageError(x.ImageError.WRONG_FORMAT);
				}
			}
		}());

		function _getDimensions() {
			var chunk, idx;

			chunk = _getChunkAt.call(this, 8);

			if (chunk.type == 'IHDR') {
				idx = chunk.start;
				return {
					width: _br.LONG(idx),
					height: _br.LONG(idx += 4)
				};
			}
			return null;
		}

		function _purge() {
			if (!_br) {
				return; // ignore any repeating purge requests
			}
			_br.clear();
			data = _info = _hm = _ep = _br = null;
		}

		_info = _getDimensions.call(this);

		Basic.extend(this, {
			type: 'image/png',

			size: _br.length(),

			width: _info.width,

			height: _info.height,

			purge: function() {
				_purge.call(this);
			}
		});

		// for PNG we can safely trigger purge automatically, as we do not keep any data for later
		_purge.call(this);

		function _getChunkAt(idx) {
			var length, type, start, CRC;

			length = _br.LONG(idx);
			type = _br.STRING(idx += 4, 4);
			start = idx += 4;
			CRC = _br.LONG(idx + length);

			return {
				length: length,
				type: type,
				start: start,
				CRC: CRC
			};
		}
	}

	return PNG;
});

// Included from: src/javascript/runtime/html5/image/ImageInfo.js

/**
 * ImageInfo.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/ImageInfo
@private
*/
define("moxie/runtime/html5/image/ImageInfo", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/html5/image/JPEG",
	"moxie/runtime/html5/image/PNG"
], function(Basic, x, JPEG, PNG) {
	/**
	Optional image investigation tool for HTML5 runtime. Provides the following features:
	- ability to distinguish image type (JPEG or PNG) by signature
	- ability to extract image width/height directly from it's internals, without preloading in memory (fast)
	- ability to extract APP headers from JPEGs (Exif, GPS, etc)
	- ability to replace width/height tags in extracted JPEG headers
	- ability to restore APP headers, that were for example stripped during image manipulation

	@class ImageInfo
	@constructor
	@param {String} data Image source as binary string
	*/
	return function(data) {
		var _cs = [JPEG, PNG], _img;

		// figure out the format, throw: ImageError.WRONG_FORMAT if not supported
		_img = (function() {
			for (var i = 0; i < _cs.length; i++) {
				try {
					return new _cs[i](data);
				} catch (ex) {
					// console.info(ex);
				}
			}
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}());

		Basic.extend(this, {
			/**
			Image Mime Type extracted from it's depths

			@property type
			@type {String}
			@default ''
			*/
			type: '',

			/**
			Image size in bytes

			@property size
			@type {Number}
			@default 0
			*/
			size: 0,

			/**
			Image width extracted from image source

			@property width
			@type {Number}
			@default 0
			*/
			width: 0,

			/**
			Image height extracted from image source

			@property height
			@type {Number}
			@default 0
			*/
			height: 0,

			/**
			Sets Exif tag. Currently applicable only for width and height tags. Obviously works only with JPEGs.

			@method setExif
			@param {String} tag Tag to set
			@param {Mixed} value Value to assign to the tag
			*/
			setExif: function() {},

			/**
			Restores headers to the source.

			@method writeHeaders
			@param {String} data Image source as binary string
			@return {String} Updated binary string
			*/
			writeHeaders: function(data) {
				return data;
			},

			/**
			Strip all headers from the source.

			@method stripHeaders
			@param {String} data Image source as binary string
			@return {String} Updated binary string
			*/
			stripHeaders: function(data) {
				return data;
			},

			/**
			Dispose resources.

			@method purge
			*/
			purge: function() {
				data = null;
			}
		});

		Basic.extend(this, _img);

		this.purge = function() {
			_img.purge();
			_img = null;
		};
	};
});

// Included from: src/javascript/runtime/html5/image/ResizerCanvas.js

/**
 * ResizerCanvas.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
 * Resizes image/canvas using canvas
 */
define("moxie/runtime/html5/image/ResizerCanvas", [], function() {

    function scale(image, ratio) {
        var sW = image.width;
        var dW = Math.floor(sW * ratio);
        var scaleCapped = false;

        if (ratio < 0.5 || ratio > 2) {
            ratio = ratio < 0.5 ? 0.5 : 2;
            scaleCapped = true;
        }

        var tCanvas = _scale(image, ratio);

        if (scaleCapped) {
            return scale(tCanvas, dW / tCanvas.width);
        } else {
            return tCanvas;
        }
    }


    function _scale(image, ratio) {
        var sW = image.width;
        var sH = image.height;
        var dW = Math.floor(sW * ratio);
        var dH = Math.floor(sH * ratio);

        var canvas = document.createElement('canvas');
        canvas.width = dW;
        canvas.height = dH;
        canvas.getContext("2d").drawImage(image, 0, 0, sW, sH, 0, 0, dW, dH);

        image = null; // just in case
        return canvas;
    }

    return {
        scale: scale
    };

});

// Included from: src/javascript/runtime/html5/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/Image
@private
*/
define("moxie/runtime/html5/image/Image", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/core/utils/Encode",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/runtime/html5/image/ImageInfo",
	"moxie/runtime/html5/image/ResizerCanvas",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, Basic, x, Encode, Blob, File, ImageInfo, ResizerCanvas, Mime, Env) {

	function HTML5Image() {
		var me = this
		, _img, _imgInfo, _canvas, _binStr, _blob
		, _modified = false // is set true whenever image is modified
		, _preserveHeaders = true
		;

		Basic.extend(this, {
			loadFromBlob: function(blob) {
				var I = this.getRuntime()
				, asBinary = arguments.length > 1 ? arguments[1] : true
				;

				if (!I.can('access_binary')) {
					throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
				}

				_blob = blob;

				if (blob.isDetached()) {
					_binStr = blob.getSource();
					_preload.call(this, _binStr);
					return;
				} else {
					_readAsDataUrl.call(this, blob.getSource(), function(dataUrl) {
						if (asBinary) {
							_binStr = _toBinary(dataUrl);
						}
						_preload.call(this, dataUrl);
					});
				}
			},

			loadFromImage: function(img, exact) {
				this.meta = img.meta;

				_blob = new File(null, {
					name: img.name,
					size: img.size,
					type: img.type
				});

				_preload.call(this, exact ? (_binStr = img.getAsBinaryString()) : img.getAsDataURL());
			},

			getInfo: function() {
				var I = this.getRuntime(), info;

				if (!_imgInfo && _binStr && I.can('access_image_binary')) {
					_imgInfo = new ImageInfo(_binStr);
				}

				// this stuff below is definitely having fun with itself
				info = {
					width: _getImg().width || 0,
					height: _getImg().height || 0,
					type: _blob.type || Mime.getFileMime(_blob.name),
					size: _binStr && _binStr.length || _blob.size || 0,
					name: _blob.name || '',
					meta: null
				};

				if (_preserveHeaders) {
					info.meta = _imgInfo && _imgInfo.meta || this.meta || {};

					// if data was taken from ImageInfo it will be a binary string, so we convert it to blob
					if (info.meta && info.meta.thumb && !(info.meta.thumb.data instanceof Blob)) {
						info.meta.thumb.data = new Blob(null, {
							type: 'image/jpeg',
							data: info.meta.thumb.data
						});
					}
				}

				return info;
			},


			resize: function(rect, ratio, options) {
				var canvas = document.createElement('canvas');
				canvas.width = rect.width;
				canvas.height = rect.height;

				canvas.getContext("2d").drawImage(_getImg(), rect.x, rect.y, rect.width, rect.height, 0, 0, canvas.width, canvas.height);

				_canvas = ResizerCanvas.scale(canvas, ratio);

				_preserveHeaders = options.preserveHeaders;

				// rotate if required, according to orientation tag
				if (!_preserveHeaders) {
					var orientation = (this.meta && this.meta.tiff && this.meta.tiff.Orientation) || 1;
					_canvas = _rotateToOrientaion(_canvas, orientation);
				}

				this.width = _canvas.width;
				this.height = _canvas.height;

				_modified = true;

				this.trigger('Resize');
			},

			getAsCanvas: function() {
				if (!_canvas) {
					_canvas = _getCanvas();
				}
				_canvas.id = this.uid + '_canvas';
				return _canvas;
			},

			getAsBlob: function(type, quality) {
				if (type !== this.type) {
					_modified = true; // reconsider the state
					return new File(null, {
						name: _blob.name || '',
						type: type,
						data: me.getAsDataURL(type, quality)
					});
				}
				return new File(null, {
					name: _blob.name || '',
					type: type,
					data: me.getAsBinaryString(type, quality)
				});
			},

			getAsDataURL: function(type) {
				var quality = arguments[1] || 90;

				// if image has not been modified, return the source right away
				if (!_modified) {
					return _img.src;
				}

				// make sure we have a canvas to work with
				_getCanvas();

				if ('image/jpeg' !== type) {
					return _canvas.toDataURL('image/png');
				} else {
					try {
						// older Geckos used to result in an exception on quality argument
						return _canvas.toDataURL('image/jpeg', quality/100);
					} catch (ex) {
						return _canvas.toDataURL('image/jpeg');
					}
				}
			},

			getAsBinaryString: function(type, quality) {
				// if image has not been modified, return the source right away
				if (!_modified) {
					// if image was not loaded from binary string
					if (!_binStr) {
						_binStr = _toBinary(me.getAsDataURL(type, quality));
					}
					return _binStr;
				}

				if ('image/jpeg' !== type) {
					_binStr = _toBinary(me.getAsDataURL(type, quality));
				} else {
					var dataUrl;

					// if jpeg
					if (!quality) {
						quality = 90;
					}

					// make sure we have a canvas to work with
					_getCanvas();

					try {
						// older Geckos used to result in an exception on quality argument
						dataUrl = _canvas.toDataURL('image/jpeg', quality/100);
					} catch (ex) {
						dataUrl = _canvas.toDataURL('image/jpeg');
					}

					_binStr = _toBinary(dataUrl);

					if (_imgInfo) {
						_binStr = _imgInfo.stripHeaders(_binStr);

						if (_preserveHeaders) {
							// update dimensions info in exif
							if (_imgInfo.meta && _imgInfo.meta.exif) {
								_imgInfo.setExif({
									PixelXDimension: this.width,
									PixelYDimension: this.height
								});
							}

							// re-inject the headers
							_binStr = _imgInfo.writeHeaders(_binStr);
						}

						// will be re-created from fresh on next getInfo call
						_imgInfo.purge();
						_imgInfo = null;
					}
				}

				_modified = false;

				return _binStr;
			},

			destroy: function() {
				me = null;
				_purge.call(this);
				this.getRuntime().getShim().removeInstance(this.uid);
			}
		});


		function _getImg() {
			if (!_canvas && !_img) {
				throw new x.ImageError(x.DOMException.INVALID_STATE_ERR);
			}
			return _canvas || _img;
		}


		function _getCanvas() {
			var canvas = _getImg();
			if (canvas.nodeName.toLowerCase() == 'canvas') {
				return canvas;
			}
			_canvas = document.createElement('canvas');
			_canvas.width = canvas.width;
			_canvas.height = canvas.height;
			_canvas.getContext("2d").drawImage(canvas, 0, 0);
			return _canvas;
		}


		function _toBinary(str) {
			return Encode.atob(str.substring(str.indexOf('base64,') + 7));
		}


		function _toDataUrl(str, type) {
			return 'data:' + (type || '') + ';base64,' + Encode.btoa(str);
		}


		function _preload(str) {
			var comp = this;

			_img = new Image();
			_img.onerror = function() {
				_purge.call(this);
				comp.trigger('error', x.ImageError.WRONG_FORMAT);
			};
			_img.onload = function() {
				comp.trigger('load');
			};

			_img.src = str.substr(0, 5) == 'data:' ? str : _toDataUrl(str, _blob.type);
		}


		function _readAsDataUrl(file, callback) {
			var comp = this, fr;

			// use FileReader if it's available
			if (window.FileReader) {
				fr = new FileReader();
				fr.onload = function() {
					callback.call(comp, this.result);
				};
				fr.onerror = function() {
					comp.trigger('error', x.ImageError.WRONG_FORMAT);
				};
				fr.readAsDataURL(file);
			} else {
				return callback.call(this, file.getAsDataURL());
			}
		}

		/**
		* Transform canvas coordination according to specified frame size and orientation
		* Orientation value is from EXIF tag
		* @author Shinichi Tomita <shinichi.tomita@gmail.com>
		*/
		function _rotateToOrientaion(img, orientation) {
			var RADIANS = Math.PI/180;
			var canvas = document.createElement('canvas');
			var ctx = canvas.getContext('2d');
			var width = img.width;
			var height = img.height;

			if (Basic.inArray(orientation, [5,6,7,8]) > -1) {
				canvas.width = height;
				canvas.height = width;
			} else {
				canvas.width = width;
				canvas.height = height;
			}

			/**
			1 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
			2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
			3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
			4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
			5 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
			6 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
			7 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
			8 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
			*/
			switch (orientation) {
				case 2:
					// horizontal flip
					ctx.translate(width, 0);
					ctx.scale(-1, 1);
					break;
				case 3:
					// 180 rotate left
					ctx.translate(width, height);
					ctx.rotate(180 * RADIANS);
					break;
				case 4:
					// vertical flip
					ctx.translate(0, height);
					ctx.scale(1, -1);
					break;
				case 5:
					// vertical flip + 90 rotate right
					ctx.rotate(90 * RADIANS);
					ctx.scale(1, -1);
					break;
				case 6:
					// 90 rotate right
					ctx.rotate(90 * RADIANS);
					ctx.translate(0, -height);
					break;
				case 7:
					// horizontal flip + 90 rotate right
					ctx.rotate(90 * RADIANS);
					ctx.translate(width, -height);
					ctx.scale(-1, 1);
					break;
				case 8:
					// 90 rotate left
					ctx.rotate(-90 * RADIANS);
					ctx.translate(-width, 0);
					break;
			}

			ctx.drawImage(img, 0, 0, width, height);
			return canvas;
		}


		function _purge() {
			if (_imgInfo) {
				_imgInfo.purge();
				_imgInfo = null;
			}

			_binStr = _img = _canvas = _blob = null;
			_modified = false;
		}
	}

	return (extensions.Image = HTML5Image);
});

// Included from: src/javascript/runtime/flash/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
Defines constructor for Flash runtime.

@class moxie/runtime/flash/Runtime
@private
*/
define("moxie/runtime/flash/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Env",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime"
], function(Basic, Env, Dom, x, Runtime) {
	
	var type = 'flash', extensions = {};

	/**
	Get the version of the Flash Player

	@method getShimVersion
	@private
	@return {Number} Flash Player version
	*/
	function getShimVersion() {
		var version;

		try {
			version = navigator.plugins['Shockwave Flash'];
			version = version.description;
		} catch (e1) {
			try {
				version = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
			} catch (e2) {
				version = '0.0';
			}
		}
		version = version.match(/\d+/g);
		return parseFloat(version[0] + '.' + version[1]);
	}


	/**
	Cross-browser SWF removal
    	- Especially needed to safely and completely remove a SWF in Internet Explorer

   	Originated from SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	*/
	function removeSWF(id) {
        var obj = Dom.get(id);
        if (obj && obj.nodeName == "OBJECT") {
            if (Env.browser === 'IE') {
                obj.style.display = "none";
                (function onInit(){
                	// http://msdn.microsoft.com/en-us/library/ie/ms534360(v=vs.85).aspx
                    if (obj.readyState == 4) {
                        removeObjectInIE(id);
                    }
                    else {
                        setTimeout(onInit, 10);
                    }
                })();
            }
            else {
                obj.parentNode.removeChild(obj);
            }
        }
    }


	function removeObjectInIE(id) {
        var obj = Dom.get(id);
        if (obj) {
            for (var i in obj) {
                if (typeof obj[i] == "function") {
                    obj[i] = null;
                }
            }
            obj.parentNode.removeChild(obj);
        }
    }

	/**
	Constructor for the Flash Runtime

	@class FlashRuntime
	@extends Runtime
	*/
	function FlashRuntime(options) {
		var I = this, initTimer;

		options = Basic.extend({ swf_url: Env.swf_url }, options);

		Runtime.call(this, options, type, {
			access_binary: function(value) {
				return value && I.mode === 'browser';
			},
			access_image_binary: function(value) {
				return value && I.mode === 'browser';
			},
			display_media: Runtime.capTest(defined('moxie/image/Image')),
			do_cors: Runtime.capTrue,
			drag_and_drop: false,
			report_upload_progress: function() {
				return I.mode === 'client';
			},
			resize_image: Runtime.capTrue,
			return_response_headers: false,
			return_response_type: function(responseType) {
				if (responseType === 'json' && !!window.JSON) {
					return true;
				} 
				return !Basic.arrayDiff(responseType, ['', 'text', 'document']) || I.mode === 'browser';
			},
			return_status_code: function(code) {
				return I.mode === 'browser' || !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: Runtime.capTrue,
			select_multiple: Runtime.capTrue,
			send_binary_string: function(value) {
				return value && I.mode === 'browser';
			},
			send_browser_cookies: function(value) {
				return value && I.mode === 'browser';
			},
			send_custom_headers: function(value) {
				return value && I.mode === 'browser';
			},
			send_multipart: Runtime.capTrue,
			slice_blob: function(value) {
				return value && I.mode === 'browser';
			},
			stream_upload: function(value) {
				return value && I.mode === 'browser';
			},
			summon_file_dialog: false,
			upload_filesize: function(size) {
				return Basic.parseSizeStr(size) <= 2097152 || I.mode === 'client';
			},
			use_http_method: function(methods) {
				return !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		}, { 
			// capabilities that require specific mode
			access_binary: function(value) {
				return value ? 'browser' : 'client';
			},
			access_image_binary: function(value) {
				return value ? 'browser' : 'client';
			},
			report_upload_progress: function(value) {
				return value ? 'browser' : 'client';
			},
			return_response_type: function(responseType) {
				return Basic.arrayDiff(responseType, ['', 'text', 'json', 'document']) ? 'browser' : ['client', 'browser'];
			},
			return_status_code: function(code) {
				return Basic.arrayDiff(code, [200, 404]) ? 'browser' : ['client', 'browser'];
			},
			send_binary_string: function(value) {
				return value ? 'browser' : 'client';
			},
			send_browser_cookies: function(value) {
				return value ? 'browser' : 'client';
			},
			send_custom_headers: function(value) {
				return value ? 'browser' : 'client';
			},
			slice_blob: function(value) {
				return value ? 'browser' : 'client';
			},
			stream_upload: function(value) {
				return value ? 'client' : 'browser';
			},
			upload_filesize: function(size) {
				return Basic.parseSizeStr(size) >= 2097152 ? 'client' : 'browser';
			}
		}, 'client');


		// minimal requirement for Flash Player version
		if (getShimVersion() < 11.3) {
			if (MXI_DEBUG && Env.debug.runtime) {
				Env.log("\tFlash didn't meet minimal version requirement (11.3).");	
			}

			this.mode = false; // with falsy mode, runtime won't operable, no matter what the mode was before
		}


		Basic.extend(this, {

			getShim: function() {
				return Dom.get(this.uid);
			},

			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return I.getShim().exec(this.uid, component, action, args);
			},

			init: function() {
				var html, el, container;

				container = this.getShimContainer();

				// if not the minimal height, shims are not initialized in older browsers (e.g FF3.6, IE6,7,8, Safari 4.0,5.0, etc)
				Basic.extend(container.style, {
					position: 'absolute',
					top: '-8px',
					left: '-8px',
					width: '9px',
					height: '9px',
					overflow: 'hidden'
				});

				// insert flash object
				html = '<object id="' + this.uid + '" type="application/x-shockwave-flash" data="' +  options.swf_url + '" ';

				if (Env.browser === 'IE') {
					html += 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" ';
				}

				html += 'width="100%" height="100%" style="outline:0">'  +
					'<param name="movie" value="' + options.swf_url + '" />' +
					'<param name="flashvars" value="uid=' + escape(this.uid) + '&target=' + Env.global_event_dispatcher + '" />' +
					'<param name="wmode" value="transparent" />' +
					'<param name="allowscriptaccess" value="always" />' +
				'</object>';

				if (Env.browser === 'IE') {
					el = document.createElement('div');
					container.appendChild(el);
					el.outerHTML = html;
					el = container = null; // just in case
				} else {
					container.innerHTML = html;
				}

				// Init is dispatched by the shim
				initTimer = setTimeout(function() {
					if (I && !I.initialized) { // runtime might be already destroyed by this moment
						I.trigger("Error", new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("\tFlash failed to initialize within a specified period of time (typically 5s).");	
						}
					}
				}, 5000);
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					removeSWF(I.uid); // SWF removal requires special care in IE

					destroy.call(I);
					clearTimeout(initTimer); // initialization check might be still onwait
					options = initTimer = destroy = I = null;
				};
			}(this.destroy))

		}, extensions);
	}

	Runtime.addConstructor(type, FlashRuntime);

	return extensions;
});

// Included from: src/javascript/runtime/flash/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/Blob
@private
*/
define("moxie/runtime/flash/file/Blob", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	var FlashBlob = {
		slice: function(blob, start, end, type) {
			var self = this.getRuntime();

			if (start < 0) {
				start = Math.max(blob.size + start, 0);
			} else if (start > 0) {
				start = Math.min(start, blob.size);
			}

			if (end < 0) {
				end = Math.max(blob.size + end, 0);
			} else if (end > 0) {
				end = Math.min(end, blob.size);
			}

			blob = self.shimExec.call(this, 'Blob', 'slice', start, end, type || '');

			if (blob) {
				blob = new Blob(self.uid, blob);
			}
			return blob;
		}
	};

	return (extensions.Blob = FlashBlob);
});

// Included from: src/javascript/runtime/flash/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileInput
@private
*/
define("moxie/runtime/flash/file/FileInput", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic"
], function(extensions, File, Basic) {
	
	var FileInput = {		
		init: function(options) {
			var comp = this, I = this.getRuntime();

			this.bind("Change", function() {
				var files = I.shimExec.call(comp, 'FileInput', 'getFiles');
				comp.files = [];
				Basic.each(files, function(file) {
					comp.files.push(new File(I.uid, file));
				});
			}, 999);

			this.getRuntime().shimExec.call(this, 'FileInput', 'init', {
				accept: options.accept,
				multiple: options.multiple
			});

			this.trigger('ready');
		}
	};

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/flash/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileReader
@private
*/
define("moxie/runtime/flash/file/FileReader", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Encode"
], function(extensions, Encode) {

	function _formatData(data, op) {
		switch (op) {
			case 'readAsText':
				return Encode.atob(data, 'utf8');
			case 'readAsBinaryString':
				return Encode.atob(data);
			case 'readAsDataURL':
				return data;
		}
		return null;
	}

	var FileReader = {
		read: function(op, blob) {
			var comp = this;

			comp.result = '';

			// special prefix for DataURL read mode
			if (op === 'readAsDataURL') {
				comp.result = 'data:' + (blob.type || '') + ';base64,';
			}

			comp.bind('Progress', function(e, data) {
				if (data) {
					comp.result += _formatData(data, op);
				}
			}, 999);

			return comp.getRuntime().shimExec.call(this, 'FileReader', 'readAsBase64', blob.uid);
		}
	};

	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/flash/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileReaderSync
@private
*/
define("moxie/runtime/flash/file/FileReaderSync", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Encode"
], function(extensions, Encode) {
	
	function _formatData(data, op) {
		switch (op) {
			case 'readAsText':
				return Encode.atob(data, 'utf8');
			case 'readAsBinaryString':
				return Encode.atob(data);
			case 'readAsDataURL':
				return data;
		}
		return null;
	}

	var FileReaderSync = {
		read: function(op, blob) {
			var result, self = this.getRuntime();

			result = self.shimExec.call(this, 'FileReaderSync', 'readAsBase64', blob.uid);
			if (!result) {
				return null; // or throw ex
			}

			// special prefix for DataURL read mode
			if (op === 'readAsDataURL') {
				result = 'data:' + (blob.type || '') + ';base64,' + result;
			}

			return _formatData(result, op, blob.type);
		}
	};

	return (extensions.FileReaderSync = FileReaderSync);
});

// Included from: src/javascript/runtime/flash/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/runtime/Transporter
@private
*/
define("moxie/runtime/flash/runtime/Transporter", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	var Transporter = {
		getAsBlob: function(type) {
			var self = this.getRuntime()
			, blob = self.shimExec.call(this, 'Transporter', 'getAsBlob', type)
			;
			if (blob) {
				return new Blob(self.uid, blob);
			}
			return null;
		}
	};

	return (extensions.Transporter = Transporter);
});

// Included from: src/javascript/runtime/flash/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/flash/xhr/XMLHttpRequest", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Basic",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/file/FileReaderSync",
	"moxie/runtime/flash/file/FileReaderSync",
	"moxie/xhr/FormData",
	"moxie/runtime/Transporter",
	"moxie/runtime/flash/runtime/Transporter"
], function(extensions, Basic, Blob, File, FileReaderSync, FileReaderSyncFlash, FormData, Transporter, TransporterFlash) {
	
	var XMLHttpRequest = {

		send: function(meta, data) {
			var target = this, self = target.getRuntime();

			function send() {
				meta.transport = self.mode;
				self.shimExec.call(target, 'XMLHttpRequest', 'send', meta, data);
			}


			function appendBlob(name, blob) {
				self.shimExec.call(target, 'XMLHttpRequest', 'appendBlob', name, blob.uid);
				data = null;
				send();
			}


			function attachBlob(blob, cb) {
				var tr = new Transporter();

				tr.bind("TransportingComplete", function() {
					cb(this.result);
				});

				tr.transport(blob.getSource(), blob.type, {
					ruid: self.uid
				});
			}

			// copy over the headers if any
			if (!Basic.isEmptyObj(meta.headers)) {
				Basic.each(meta.headers, function(value, header) {
					self.shimExec.call(target, 'XMLHttpRequest', 'setRequestHeader', header, value.toString()); // Silverlight doesn't accept integers into the arguments of type object
				});
			}

			// transfer over multipart params and blob itself
			if (data instanceof FormData) {
				var blobField;
				data.each(function(value, name) {
					if (value instanceof Blob) {
						blobField = name;
					} else {
						self.shimExec.call(target, 'XMLHttpRequest', 'append', name, value);
					}
				});

				if (!data.hasBlob()) {
					data = null;
					send();
				} else {
					var blob = data.getBlob();
					if (blob.isDetached()) {
						attachBlob(blob, function(attachedBlob) {
							blob.destroy();
							appendBlob(blobField, attachedBlob);		
						});
					} else {
						appendBlob(blobField, blob);
					}
				}
			} else if (data instanceof Blob) {
				if (data.isDetached()) {
					attachBlob(data, function(attachedBlob) {
						data.destroy();
						data = attachedBlob.uid;
						send();
					});
				} else {
					data = data.uid;
					send();
				}
			} else {
				send();
			}
		},

		getResponse: function(responseType) {
			var frs, blob, self = this.getRuntime();

			blob = self.shimExec.call(this, 'XMLHttpRequest', 'getResponseAsBlob');

			if (blob) {
				blob = new File(self.uid, blob);

				if ('blob' === responseType) {
					return blob;
				}

				try { 
					frs = new FileReaderSync();

					if (!!~Basic.inArray(responseType, ["", "text"])) {
						return frs.readAsText(blob);
					} else if ('json' === responseType && !!window.JSON) {
						return JSON.parse(frs.readAsText(blob));
					}
				} finally {
					blob.destroy();
				}
			}
			return null;
		},

		abort: function(upload_complete_flag) {
			var self = this.getRuntime();

			self.shimExec.call(this, 'XMLHttpRequest', 'abort');

			this.dispatchEvent('readystatechange');
			// this.dispatchEvent('progress');
			this.dispatchEvent('abort');

			//if (!upload_complete_flag) {
				// this.dispatchEvent('uploadprogress');
			//}
		}
	};

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/flash/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/image/Image
@private
*/
define("moxie/runtime/flash/image/Image", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/Transporter",
	"moxie/file/Blob",
	"moxie/file/FileReaderSync"
], function(extensions, Basic, Transporter, Blob, FileReaderSync) {
	
	var Image = {
		loadFromBlob: function(blob) {
			var comp = this, self = comp.getRuntime();

			function exec(srcBlob) {
				self.shimExec.call(comp, 'Image', 'loadFromBlob', srcBlob.uid);
				comp = self = null;
			}

			if (blob.isDetached()) { // binary string
				var tr = new Transporter();
				tr.bind("TransportingComplete", function() {
					exec(tr.result.getSource());
				});
				tr.transport(blob.getSource(), blob.type, { ruid: self.uid });
			} else {
				exec(blob.getSource());
			}
		},

		loadFromImage: function(img) {
			var self = this.getRuntime();
			return self.shimExec.call(this, 'Image', 'loadFromImage', img.uid);
		},

		getInfo: function() {
			var self = this.getRuntime()
			, info = self.shimExec.call(this, 'Image', 'getInfo')
			;

			if (info.meta && info.meta.thumb && info.meta.thumb.data && !(self.meta.thumb.data instanceof Blob)) {
				info.meta.thumb.data = new Blob(self.uid, info.meta.thumb.data);
			}
			return info;
		},

		getAsBlob: function(type, quality) {
			var self = this.getRuntime()
			, blob = self.shimExec.call(this, 'Image', 'getAsBlob', type, quality)
			;
			if (blob) {
				return new Blob(self.uid, blob);
			}
			return null;
		},

		getAsDataURL: function() {
			var self = this.getRuntime()
			, blob = self.Image.getAsBlob.apply(this, arguments)
			, frs
			;
			if (!blob) {
				return null;
			}
			frs = new FileReaderSync();
			return frs.readAsDataURL(blob);
		}
	};

	return (extensions.Image = Image);
});

// Included from: src/javascript/runtime/silverlight/Runtime.js

/**
 * RunTime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
Defines constructor for Silverlight runtime.

@class moxie/runtime/silverlight/Runtime
@private
*/
define("moxie/runtime/silverlight/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Env",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime"
], function(Basic, Env, Dom, x, Runtime) {
	
	var type = "silverlight", extensions = {};

	function isInstalled(version) {
		var isVersionSupported = false, control = null, actualVer,
			actualVerArray, reqVerArray, requiredVersionPart, actualVersionPart, index = 0;

		try {
			try {
				control = new ActiveXObject('AgControl.AgControl');

				if (control.IsVersionSupported(version)) {
					isVersionSupported = true;
				}

				control = null;
			} catch (e) {
				var plugin = navigator.plugins["Silverlight Plug-In"];

				if (plugin) {
					actualVer = plugin.description;

					if (actualVer === "1.0.30226.2") {
						actualVer = "2.0.30226.2";
					}

					actualVerArray = actualVer.split(".");

					while (actualVerArray.length > 3) {
						actualVerArray.pop();
					}

					while ( actualVerArray.length < 4) {
						actualVerArray.push(0);
					}

					reqVerArray = version.split(".");

					while (reqVerArray.length > 4) {
						reqVerArray.pop();
					}

					do {
						requiredVersionPart = parseInt(reqVerArray[index], 10);
						actualVersionPart = parseInt(actualVerArray[index], 10);
						index++;
					} while (index < reqVerArray.length && requiredVersionPart === actualVersionPart);

					if (requiredVersionPart <= actualVersionPart && !isNaN(requiredVersionPart)) {
						isVersionSupported = true;
					}
				}
			}
		} catch (e2) {
			isVersionSupported = false;
		}

		return isVersionSupported;
	}

	/**
	Constructor for the Silverlight Runtime

	@class SilverlightRuntime
	@extends Runtime
	*/
	function SilverlightRuntime(options) {
		var I = this, initTimer;

		options = Basic.extend({ xap_url: Env.xap_url }, options);

		Runtime.call(this, options, type, {
			access_binary: Runtime.capTrue,
			access_image_binary: Runtime.capTrue,
			display_media: Runtime.capTest(defined('moxie/image/Image')),
			do_cors: Runtime.capTrue,
			drag_and_drop: false,
			report_upload_progress: Runtime.capTrue,
			resize_image: Runtime.capTrue,
			return_response_headers: function(value) {
				return value && I.mode === 'client';
			},
			return_response_type: function(responseType) {
				if (responseType !== 'json') {
					return true;
				} else {
					return !!window.JSON;
				}
			},
			return_status_code: function(code) {
				return I.mode === 'client' || !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: Runtime.capTrue,
			select_multiple: Runtime.capTrue,
			send_binary_string: Runtime.capTrue,
			send_browser_cookies: function(value) {
				return value && I.mode === 'browser';
			},
			send_custom_headers: function(value) {
				return value && I.mode === 'client';
			},
			send_multipart: Runtime.capTrue,
			slice_blob: Runtime.capTrue,
			stream_upload: true,
			summon_file_dialog: false,
			upload_filesize: Runtime.capTrue,
			use_http_method: function(methods) {
				return I.mode === 'client' || !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		}, { 
			// capabilities that require specific mode
			return_response_headers: function(value) {
				return value ? 'client' : 'browser';
			},
			return_status_code: function(code) {
				return Basic.arrayDiff(code, [200, 404]) ? 'client' : ['client', 'browser'];
			},
			send_browser_cookies: function(value) {
				return value ? 'browser' : 'client';
			},
			send_custom_headers: function(value) {
				return value ? 'client' : 'browser';
			},
			use_http_method: function(methods) {
				return Basic.arrayDiff(methods, ['GET', 'POST']) ? 'client' : ['client', 'browser'];
			}
		});


		// minimal requirement
		if (!isInstalled('2.0.31005.0') || Env.browser === 'Opera') {
			if (MXI_DEBUG && Env.debug.runtime) {
				Env.log("\tSilverlight is not installed or minimal version (2.0.31005.0) requirement not met (not likely).");	
			}

			this.mode = false;
		}


		Basic.extend(this, {
			getShim: function() {
				return Dom.get(this.uid).content.Moxie;
			},

			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return I.getShim().exec(this.uid, component, action, args);
			},

			init : function() {
				var container;

				container = this.getShimContainer();

				container.innerHTML = '<object id="' + this.uid + '" data="data:application/x-silverlight," type="application/x-silverlight-2" width="100%" height="100%" style="outline:none;">' +
					'<param name="source" value="' + options.xap_url + '"/>' +
					'<param name="background" value="Transparent"/>' +
					'<param name="windowless" value="true"/>' +
					'<param name="enablehtmlaccess" value="true"/>' +
					'<param name="initParams" value="uid=' + this.uid + ',target=' + Env.global_event_dispatcher + '"/>' +
				'</object>';

				// Init is dispatched by the shim
				initTimer = setTimeout(function() {
					if (I && !I.initialized) { // runtime might be already destroyed by this moment
						I.trigger("Error", new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("\Silverlight failed to initialize within a specified period of time (5-10s).");	
						}
					}
				}, Env.OS !== 'Windows'? 10000 : 5000); // give it more time to initialize in non Windows OS (like Mac)
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					clearTimeout(initTimer); // initialization check might be still onwait
					options = initTimer = destroy = I = null;
				};
			}(this.destroy))

		}, extensions);
	}

	Runtime.addConstructor(type, SilverlightRuntime); 

	return extensions;
});

// Included from: src/javascript/runtime/silverlight/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/Blob
@private
*/
define("moxie/runtime/silverlight/file/Blob", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/Blob"
], function(extensions, Basic, Blob) {
	return (extensions.Blob = Basic.extend({}, Blob));
});

// Included from: src/javascript/runtime/silverlight/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileInput
@private
*/
define("moxie/runtime/silverlight/file/FileInput", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic"
], function(extensions, File, Basic) {

	function toFilters(accept) {
		var filter = '';
		for (var i = 0; i < accept.length; i++) {
			filter += (filter !== '' ? '|' : '') + accept[i].title + " | *." + accept[i].extensions.replace(/,/g, ';*.');
		}
		return filter;
	}

	
	var FileInput = {
		init: function(options) {
			var comp = this, I = this.getRuntime();

			this.bind("Change", function() {
				var files = I.shimExec.call(comp, 'FileInput', 'getFiles');
				comp.files = [];
				Basic.each(files, function(file) {
					comp.files.push(new File(I.uid, file));
				});
			}, 999);
			
			I.shimExec.call(this, 'FileInput', 'init', toFilters(options.accept), options.multiple);
			this.trigger('ready');
		},

		setOption: function(name, value) {
			if (name == 'accept') {
				value = toFilters(value);
			}
			this.getRuntime().shimExec.call(this, 'FileInput', 'setOption', name, value);
		}
	};

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/silverlight/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileDrop
@private
*/
define("moxie/runtime/silverlight/file/FileDrop", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Dom", 
	"moxie/core/utils/Events"
], function(extensions, Dom, Events) {

	// not exactly useful, since works only in safari (...crickets...)
	var FileDrop = {
		init: function() {
			var comp = this, self = comp.getRuntime(), dropZone;

			dropZone = self.getShimContainer();

			Events.addEvent(dropZone, 'dragover', function(e) {
				e.preventDefault();
				e.stopPropagation();
				e.dataTransfer.dropEffect = 'copy';
			}, comp.uid);

			Events.addEvent(dropZone, 'dragenter', function(e) {
				e.preventDefault();
				var flag = Dom.get(self.uid).dragEnter(e);
				// If handled, then stop propagation of event in DOM
				if (flag) {
					e.stopPropagation();
				}
			}, comp.uid);

			Events.addEvent(dropZone, 'drop', function(e) {
				e.preventDefault();
				var flag = Dom.get(self.uid).dragDrop(e);
				// If handled, then stop propagation of event in DOM
				if (flag) {
					e.stopPropagation();
				}
			}, comp.uid);

			return self.shimExec.call(this, 'FileDrop', 'init');
		}
	};

	return (extensions.FileDrop = FileDrop);
});

// Included from: src/javascript/runtime/silverlight/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileReader
@private
*/
define("moxie/runtime/silverlight/file/FileReader", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/FileReader"
], function(extensions, Basic, FileReader) {
	return (extensions.FileReader = Basic.extend({}, FileReader));
});

// Included from: src/javascript/runtime/silverlight/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileReaderSync
@private
*/
define("moxie/runtime/silverlight/file/FileReaderSync", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/FileReaderSync"
], function(extensions, Basic, FileReaderSync) {
	return (extensions.FileReaderSync = Basic.extend({}, FileReaderSync));
});

// Included from: src/javascript/runtime/silverlight/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/runtime/Transporter
@private
*/
define("moxie/runtime/silverlight/runtime/Transporter", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/runtime/Transporter"
], function(extensions, Basic, Transporter) {
	return (extensions.Transporter = Basic.extend({}, Transporter));
});

// Included from: src/javascript/runtime/silverlight/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/silverlight/xhr/XMLHttpRequest", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/xhr/XMLHttpRequest",
	"moxie/runtime/silverlight/file/FileReaderSync",
	"moxie/runtime/silverlight/runtime/Transporter"
], function(extensions, Basic, XMLHttpRequest, FileReaderSyncSilverlight, TransporterSilverlight) {
	return (extensions.XMLHttpRequest = Basic.extend({}, XMLHttpRequest));
});

// Included from: src/javascript/runtime/silverlight/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */
 
/**
@class moxie/runtime/silverlight/image/Image
@private
*/
define("moxie/runtime/silverlight/image/Image", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/file/Blob",
	"moxie/runtime/flash/image/Image"
], function(extensions, Basic, Blob, Image) {
	return (extensions.Image = Basic.extend({}, Image, {

		getInfo: function() {
			var self = this.getRuntime()
			, grps = ['tiff', 'exif', 'gps', 'thumb']
			, info = { meta: {} }
			, rawInfo = self.shimExec.call(this, 'Image', 'getInfo')
			;

			if (rawInfo.meta) {
				Basic.each(grps, function(grp) {
					var meta = rawInfo.meta[grp]
					, tag
					, i
					, length
					, value
					;
					if (meta && meta.keys) {
						info.meta[grp] = {};
						for (i = 0, length = meta.keys.length; i < length; i++) {
							tag = meta.keys[i];
							value = meta[tag];
							if (value) {
								// convert numbers
								if (/^(\d|[1-9]\d+)$/.test(value)) { // integer (make sure doesn't start with zero)
									value = parseInt(value, 10);
								} else if (/^\d*\.\d+$/.test(value)) { // double
									value = parseFloat(value);
								}
								info.meta[grp][tag] = value;
							}
						}
					}
				});

				// save thumb data as blob
				if (info.meta && info.meta.thumb && info.meta.thumb.data && !(self.meta.thumb.data instanceof Blob)) {
					info.meta.thumb.data = new Blob(self.uid, info.meta.thumb.data);
				}
			}

			info.width = parseInt(rawInfo.width, 10);
			info.height = parseInt(rawInfo.height, 10);
			info.size = parseInt(rawInfo.size, 10);
			info.type = rawInfo.type;
			info.name = rawInfo.name;

			return info;
		},

		resize: function(rect, ratio, opts) {
			this.getRuntime().shimExec.call(this, 'Image', 'resize', rect.x, rect.y, rect.width, rect.height, ratio, opts.preserveHeaders, opts.resample);
		}
	}));
});

// Included from: src/javascript/runtime/html4/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global File:true */

/**
Defines constructor for HTML4 runtime.

@class moxie/runtime/html4/Runtime
@private
*/
define("moxie/runtime/html4/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime",
	"moxie/core/utils/Env"
], function(Basic, x, Runtime, Env) {
	
	var type = 'html4', extensions = {};

	function Html4Runtime(options) {
		var I = this
		, Test = Runtime.capTest
		, True = Runtime.capTrue
		;

		Runtime.call(this, options, type, {
			access_binary: Test(window.FileReader || window.File && File.getAsDataURL),
			access_image_binary: false,
			display_media: Test(
				(Env.can('create_canvas') || Env.can('use_data_uri_over32kb')) && 
				defined('moxie/image/Image')
			),
			do_cors: false,
			drag_and_drop: false,
			filter_by_extension: Test(function() { // if you know how to feature-detect this, please suggest
				return !(
					(Env.browser === 'Chrome' && Env.verComp(Env.version, 28, '<')) || 
					(Env.browser === 'IE' && Env.verComp(Env.version, 10, '<')) || 
					(Env.browser === 'Safari' && Env.verComp(Env.version, 7, '<')) ||
					(Env.browser === 'Firefox' && Env.verComp(Env.version, 37, '<'))
				);
			}()),
			resize_image: function() {
				return extensions.Image && I.can('access_binary') && Env.can('create_canvas');
			},
			report_upload_progress: false,
			return_response_headers: false,
			return_response_type: function(responseType) {
				if (responseType === 'json' && !!window.JSON) {
					return true;
				} 
				return !!~Basic.inArray(responseType, ['text', 'document', '']);
			},
			return_status_code: function(code) {
				return !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: function() {
				return Env.can('use_fileinput');
			},
			select_multiple: false,
			send_binary_string: false,
			send_custom_headers: false,
			send_multipart: true,
			slice_blob: false,
			stream_upload: function() {
				return I.can('select_file');
			},
			summon_file_dialog: function() { // yeah... some dirty sniffing here...
				return I.can('select_file') && (
					(Env.browser === 'Firefox' && Env.verComp(Env.version, 4, '>=')) ||
					(Env.browser === 'Opera' && Env.verComp(Env.version, 12, '>=')) ||
					(Env.browser === 'IE' && Env.verComp(Env.version, 10, '>=')) ||
					!!~Basic.inArray(Env.browser, ['Chrome', 'Safari'])
				);
			},
			upload_filesize: True,
			use_http_method: function(methods) {
				return !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		});


		Basic.extend(this, {
			init : function() {
				this.trigger("Init");
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					destroy = I = null;
				};
			}(this.destroy))
		});

		Basic.extend(this.getShim(), extensions);
	}

	Runtime.addConstructor(type, Html4Runtime);

	return extensions;
});

// Included from: src/javascript/runtime/html4/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/file/FileInput
@private
*/
define("moxie/runtime/html4/file/FileInput", [
	"moxie/runtime/html4/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, File, Basic, Dom, Events, Mime, Env) {
	
	function FileInput() {
		var _uid, _mimes = [], _options, _browseBtnZIndex; // save original z-index;

		function addInput() {
			var comp = this, I = comp.getRuntime(), shimContainer, browseButton, currForm, form, input, uid;

			uid = Basic.guid('uid_');

			shimContainer = I.getShimContainer(); // we get new ref every time to avoid memory leaks in IE

			if (_uid) { // move previous form out of the view
				currForm = Dom.get(_uid + '_form');
				if (currForm) {
					Basic.extend(currForm.style, { top: '100%' });
				}
			}

			// build form in DOM, since innerHTML version not able to submit file for some reason
			form = document.createElement('form');
			form.setAttribute('id', uid + '_form');
			form.setAttribute('method', 'post');
			form.setAttribute('enctype', 'multipart/form-data');
			form.setAttribute('encoding', 'multipart/form-data');

			Basic.extend(form.style, {
				overflow: 'hidden',
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
				height: '100%'
			});

			input = document.createElement('input');
			input.setAttribute('id', uid);
			input.setAttribute('type', 'file');
			input.setAttribute('accept', _mimes.join(','));

			Basic.extend(input.style, {
				fontSize: '999px',
				opacity: 0
			});

			form.appendChild(input);
			shimContainer.appendChild(form);

			// prepare file input to be placed underneath the browse_button element
			Basic.extend(input.style, {
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
				height: '100%'
			});

			if (Env.browser === 'IE' && Env.verComp(Env.version, 10, '<')) {
				Basic.extend(input.style, {
					filter : "progid:DXImageTransform.Microsoft.Alpha(opacity=0)"
				});
			}

			input.onchange = function() { // there should be only one handler for this
				var file;

				if (!this.value) {
					return;
				}

				if (this.files) { // check if browser is fresh enough
					file = this.files[0];

					// ignore empty files (IE10 for example hangs if you try to send them via XHR)
					if (file.size === 0) {
						form.parentNode.removeChild(form);
						return;
					}
				} else {
					file = {
						name: this.value
					};
				}

				file = new File(I.uid, file);

				// clear event handler
				this.onchange = function() {}; 
				addInput.call(comp); 

				comp.files = [file];

				// substitute all ids with file uids (consider file.uid read-only - we cannot do it the other way around)
				input.setAttribute('id', file.uid);
				form.setAttribute('id', file.uid + '_form');
				
				comp.trigger('change');

				input = form = null;
			};


			// route click event to the input
			if (I.can('summon_file_dialog')) {
				browseButton = Dom.get(_options.browse_button);
				Events.removeEvent(browseButton, 'click', comp.uid);
				Events.addEvent(browseButton, 'click', function(e) {
					if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
						input.click();
					}
					e.preventDefault();
				}, comp.uid);
			}

			_uid = uid;

			shimContainer = currForm = browseButton = null;
		}

		Basic.extend(this, {
			init: function(options) {
				var comp = this, I = comp.getRuntime(), shimContainer;

				// figure out accept string
				_options = options;
				_mimes = options.accept.mimes || Mime.extList2mimes(options.accept, I.can('filter_by_extension'));

				shimContainer = I.getShimContainer();

				(function() {
					var browseButton, zIndex, top;

					browseButton = Dom.get(options.browse_button);
					_browseBtnZIndex = Dom.getStyle(browseButton, 'z-index') || 'auto';

					// Route click event to the input[type=file] element for browsers that support such behavior
					if (I.can('summon_file_dialog')) {
						if (Dom.getStyle(browseButton, 'position') === 'static') {
							browseButton.style.position = 'relative';
						}						

						comp.bind('Refresh', function() {
							zIndex = parseInt(_browseBtnZIndex, 10) || 1;

							Dom.get(_options.browse_button).style.zIndex = zIndex;
							this.getRuntime().getShimContainer().style.zIndex = zIndex - 1;
						});
					}

					/* Since we have to place input[type=file] on top of the browse_button for some browsers,
					browse_button loses interactivity, so we restore it here */
					top = I.can('summon_file_dialog') ? browseButton : shimContainer;

					Events.addEvent(top, 'mouseover', function() {
						comp.trigger('mouseenter');
					}, comp.uid);

					Events.addEvent(top, 'mouseout', function() {
						comp.trigger('mouseleave');
					}, comp.uid);

					Events.addEvent(top, 'mousedown', function() {
						comp.trigger('mousedown');
					}, comp.uid);

					Events.addEvent(Dom.get(options.container), 'mouseup', function() {
						comp.trigger('mouseup');
					}, comp.uid);

					browseButton = null;
				}());

				addInput.call(this);

				shimContainer = null;

				// trigger ready event asynchronously
				comp.trigger({
					type: 'ready',
					async: true
				});
			},

			setOption: function(name, value) {
				var I = this.getRuntime();
				var input;

				if (name == 'accept') {
					_mimes = value.mimes || Mime.extList2mimes(value, I.can('filter_by_extension'));
				}

				// update current input
				input = Dom.get(_uid)
				if (input) {
					input.setAttribute('accept', _mimes.join(','));
				}
			},


			disable: function(state) {
				var input;

				if ((input = Dom.get(_uid))) {
					input.disabled = !!state;
				}
			},

			destroy: function() {
				var I = this.getRuntime()
				, shim = I.getShim()
				, shimContainer = I.getShimContainer()
				, container = _options && Dom.get(_options.container)
				, browseButton = _options && Dom.get(_options.browse_button)
				;
				
				if (container) {
					Events.removeAllEvents(container, this.uid);
				}
				
				if (browseButton) {
					Events.removeAllEvents(browseButton, this.uid);
					browseButton.style.zIndex = _browseBtnZIndex; // reset to original value
				}
				
				if (shimContainer) {
					Events.removeAllEvents(shimContainer, this.uid);
					shimContainer.innerHTML = '';
				}

				shim.removeInstance(this.uid);

				_uid = _mimes = _options = shimContainer = container = browseButton = shim = null;
			}
		});
	}

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/html4/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/file/FileReader
@private
*/
define("moxie/runtime/html4/file/FileReader", [
	"moxie/runtime/html4/Runtime",
	"moxie/runtime/html5/file/FileReader"
], function(extensions, FileReader) {
	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/html4/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/html4/xhr/XMLHttpRequest", [
	"moxie/runtime/html4/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Url",
	"moxie/core/Exceptions",
	"moxie/core/utils/Events",
	"moxie/file/Blob",
	"moxie/xhr/FormData"
], function(extensions, Basic, Dom, Url, x, Events, Blob, FormData) {
	
	function XMLHttpRequest() {
		var _status, _response, _iframe;

		function cleanup(cb) {
			var target = this, uid, form, inputs, i, hasFile = false;

			if (!_iframe) {
				return;
			}

			uid = _iframe.id.replace(/_iframe$/, '');

			form = Dom.get(uid + '_form');
			if (form) {
				inputs = form.getElementsByTagName('input');
				i = inputs.length;

				while (i--) {
					switch (inputs[i].getAttribute('type')) {
						case 'hidden':
							inputs[i].parentNode.removeChild(inputs[i]);
							break;
						case 'file':
							hasFile = true; // flag the case for later
							break;
					}
				}
				inputs = [];

				if (!hasFile) { // we need to keep the form for sake of possible retries
					form.parentNode.removeChild(form);
				}
				form = null;
			}

			// without timeout, request is marked as canceled (in console)
			setTimeout(function() {
				Events.removeEvent(_iframe, 'load', target.uid);
				if (_iframe.parentNode) { // #382
					_iframe.parentNode.removeChild(_iframe);
				}

				// check if shim container has any other children, if - not, remove it as well
				var shimContainer = target.getRuntime().getShimContainer();
				if (!shimContainer.children.length) {
					shimContainer.parentNode.removeChild(shimContainer);
				}

				shimContainer = _iframe = null;
				cb();
			}, 1);
		}

		Basic.extend(this, {
			send: function(meta, data) {
				var target = this, I = target.getRuntime(), uid, form, input, blob;

				_status = _response = null;

				function createIframe() {
					var container = I.getShimContainer() || document.body
					, temp = document.createElement('div')
					;

					// IE 6 won't be able to set the name using setAttribute or iframe.name
					temp.innerHTML = '<iframe id="' + uid + '_iframe" name="' + uid + '_iframe" src="javascript:&quot;&quot;" style="display:none"></iframe>';
					_iframe = temp.firstChild;
					container.appendChild(_iframe);

					/* _iframe.onreadystatechange = function() {
						console.info(_iframe.readyState);
					};*/

					Events.addEvent(_iframe, 'load', function() { // _iframe.onload doesn't work in IE lte 8
						var el;

						try {
							el = _iframe.contentWindow.document || _iframe.contentDocument || window.frames[_iframe.id].document;

							// try to detect some standard error pages
							if (/^4(0[0-9]|1[0-7]|2[2346])\s/.test(el.title)) { // test if title starts with 4xx HTTP error
								_status = el.title.replace(/^(\d+).*$/, '$1');
							} else {
								_status = 200;
								// get result
								_response = Basic.trim(el.body.innerHTML);

								// we need to fire these at least once
								target.trigger({
									type: 'progress',
									loaded: _response.length,
									total: _response.length
								});

								if (blob) { // if we were uploading a file
									target.trigger({
										type: 'uploadprogress',
										loaded: blob.size || 1025,
										total: blob.size || 1025
									});
								}
							}
						} catch (ex) {
							if (Url.hasSameOrigin(meta.url)) {
								// if response is sent with error code, iframe in IE gets redirected to res://ieframe.dll/http_x.htm
								// which obviously results to cross domain error (wtf?)
								_status = 404;
							} else {
								cleanup.call(target, function() {
									target.trigger('error');
								});
								return;
							}
						}	
					
						cleanup.call(target, function() {
							target.trigger('load');
						});
					}, target.uid);
				} // end createIframe

				// prepare data to be sent and convert if required
				if (data instanceof FormData && data.hasBlob()) {
					blob = data.getBlob();
					uid = blob.uid;
					input = Dom.get(uid);
					form = Dom.get(uid + '_form');
					if (!form) {
						throw new x.DOMException(x.DOMException.NOT_FOUND_ERR);
					}
				} else {
					uid = Basic.guid('uid_');

					form = document.createElement('form');
					form.setAttribute('id', uid + '_form');
					form.setAttribute('method', meta.method);
					form.setAttribute('enctype', 'multipart/form-data');
					form.setAttribute('encoding', 'multipart/form-data');

					I.getShimContainer().appendChild(form);
				}

				// set upload target
				form.setAttribute('target', uid + '_iframe');

				if (data instanceof FormData) {
					data.each(function(value, name) {
						if (value instanceof Blob) {
							if (input) {
								input.setAttribute('name', name);
							}
						} else {
							var hidden = document.createElement('input');

							Basic.extend(hidden, {
								type : 'hidden',
								name : name,
								value : value
							});

							// make sure that input[type="file"], if it's there, comes last
							if (input) {
								form.insertBefore(hidden, input);
							} else {
								form.appendChild(hidden);
							}
						}
					});
				}

				// set destination url
				form.setAttribute("action", meta.url);

				createIframe();
				form.submit();
				target.trigger('loadstart');
			},

			getStatus: function() {
				return _status;
			},

			getResponse: function(responseType) {
				if ('json' === responseType) {
					// strip off <pre>..</pre> tags that might be enclosing the response
					if (Basic.typeOf(_response) === 'string' && !!window.JSON) {
						try {
							return JSON.parse(_response.replace(/^\s*<pre[^>]*>/, '').replace(/<\/pre>\s*$/, ''));
						} catch (ex) {
							return null;
						}
					} 
				} else if ('document' === responseType) {

				}
				return _response;
			},

			abort: function() {
				var target = this;

				if (_iframe && _iframe.contentWindow) {
					if (_iframe.contentWindow.stop) { // FireFox/Safari/Chrome
						_iframe.contentWindow.stop();
					} else if (_iframe.contentWindow.document.execCommand) { // IE
						_iframe.contentWindow.document.execCommand('Stop');
					} else {
						_iframe.src = "about:blank";
					}
				}

				cleanup.call(this, function() {
					// target.dispatchEvent('readystatechange');
					target.dispatchEvent('abort');
				});
			}
		});
	}

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/html4/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/image/Image
@private
*/
define("moxie/runtime/html4/image/Image", [
	"moxie/runtime/html4/Runtime",
	"moxie/runtime/html5/image/Image"
], function(extensions, Image) {
	return (extensions.Image = Image);
});

expose(["moxie/core/utils/Basic","moxie/core/utils/Encode","moxie/core/utils/Env","moxie/core/Exceptions","moxie/core/utils/Dom","moxie/core/EventTarget","moxie/runtime/Runtime","moxie/runtime/RuntimeClient","moxie/file/Blob","moxie/core/I18n","moxie/core/utils/Mime","moxie/file/FileInput","moxie/file/File","moxie/file/FileDrop","moxie/file/FileReader","moxie/core/utils/Url","moxie/runtime/RuntimeTarget","moxie/xhr/FormData","moxie/xhr/XMLHttpRequest","moxie/runtime/Transporter","moxie/image/Image","moxie/core/utils/Events","moxie/runtime/html5/image/ResizerCanvas"]);
})(this);
}));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Plupload - multi-runtime File Uploader
 * v2.3.1
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 *
 * Date: 2017-02-06
 */
;(function (global, factory) {
	var extract = function() {
		var ctx = {};
		factory.apply(ctx, arguments);
		return ctx.plupload;
	};
	
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (extract),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === "object" && module.exports) {
		module.exports = extract(require('../../../js-sdk-master 2/src/moxie'));
	} else {
		global.plupload = extract(global.moxie);
	}
}(this || window, function(moxie) {
/**
 * Plupload.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

;(function(exports, o, undef) {

var delay = window.setTimeout;
var fileFilters = {};
var u = o.core.utils;
var Runtime = o.runtime.Runtime;

// convert plupload features to caps acceptable by mOxie
function normalizeCaps(settings) {
	var features = settings.required_features, caps = {};

	function resolve(feature, value, strict) {
		// Feature notation is deprecated, use caps (this thing here is required for backward compatibility)
		var map = {
			chunks: 'slice_blob',
			jpgresize: 'send_binary_string',
			pngresize: 'send_binary_string',
			progress: 'report_upload_progress',
			multi_selection: 'select_multiple',
			dragdrop: 'drag_and_drop',
			drop_element: 'drag_and_drop',
			headers: 'send_custom_headers',
			urlstream_upload: 'send_binary_string',
			canSendBinary: 'send_binary',
			triggerDialog: 'summon_file_dialog'
		};

		if (map[feature]) {
			caps[map[feature]] = value;
		} else if (!strict) {
			caps[feature] = value;
		}
	}

	if (typeof(features) === 'string') {
		plupload.each(features.split(/\s*,\s*/), function(feature) {
			resolve(feature, true);
		});
	} else if (typeof(features) === 'object') {
		plupload.each(features, function(value, feature) {
			resolve(feature, value);
		});
	} else if (features === true) {
		// check settings for required features
		if (settings.chunk_size && settings.chunk_size > 0) {
			caps.slice_blob = true;
		}

		if (!plupload.isEmptyObj(settings.resize) || settings.multipart === false) {
			caps.send_binary_string = true;
		}

		if (settings.http_method) {
            caps.use_http_method = settings.http_method;
        }

		plupload.each(settings, function(value, feature) {
			resolve(feature, !!value, true); // strict check
		});
	}

	return caps;
}

/**
 * @module plupload
 * @static
 */
var plupload = {
	/**
	 * Plupload version will be replaced on build.
	 *
	 * @property VERSION
	 * @for Plupload
	 * @static
	 * @final
	 */
	VERSION : '2.3.1',

	/**
	 * The state of the queue before it has started and after it has finished
	 *
	 * @property STOPPED
	 * @static
	 * @final
	 */
	STOPPED : 1,

	/**
	 * Upload process is running
	 *
	 * @property STARTED
	 * @static
	 * @final
	 */
	STARTED : 2,

	/**
	 * File is queued for upload
	 *
	 * @property QUEUED
	 * @static
	 * @final
	 */
	QUEUED : 1,

	/**
	 * File is being uploaded
	 *
	 * @property UPLOADING
	 * @static
	 * @final
	 */
	UPLOADING : 2,

	/**
	 * File has failed to be uploaded
	 *
	 * @property FAILED
	 * @static
	 * @final
	 */
	FAILED : 4,

	/**
	 * File has been uploaded successfully
	 *
	 * @property DONE
	 * @static
	 * @final
	 */
	DONE : 5,

	// Error constants used by the Error event

	/**
	 * Generic error for example if an exception is thrown inside Silverlight.
	 *
	 * @property GENERIC_ERROR
	 * @static
	 * @final
	 */
	GENERIC_ERROR : -100,

	/**
	 * HTTP transport error. For example if the server produces a HTTP status other than 200.
	 *
	 * @property HTTP_ERROR
	 * @static
	 * @final
	 */
	HTTP_ERROR : -200,

	/**
	 * Generic I/O error. For example if it wasn't possible to open the file stream on local machine.
	 *
	 * @property IO_ERROR
	 * @static
	 * @final
	 */
	IO_ERROR : -300,

	/**
	 * @property SECURITY_ERROR
	 * @static
	 * @final
	 */
	SECURITY_ERROR : -400,

	/**
	 * Initialization error. Will be triggered if no runtime was initialized.
	 *
	 * @property INIT_ERROR
	 * @static
	 * @final
	 */
	INIT_ERROR : -500,

	/**
	 * File size error. If the user selects a file that is too large it will be blocked and an error of this type will be triggered.
	 *
	 * @property FILE_SIZE_ERROR
	 * @static
	 * @final
	 */
	FILE_SIZE_ERROR : -600,

	/**
	 * File extension error. If the user selects a file that isn't valid according to the filters setting.
	 *
	 * @property FILE_EXTENSION_ERROR
	 * @static
	 * @final
	 */
	FILE_EXTENSION_ERROR : -601,

	/**
	 * Duplicate file error. If prevent_duplicates is set to true and user selects the same file again.
	 *
	 * @property FILE_DUPLICATE_ERROR
	 * @static
	 * @final
	 */
	FILE_DUPLICATE_ERROR : -602,

	/**
	 * Runtime will try to detect if image is proper one. Otherwise will throw this error.
	 *
	 * @property IMAGE_FORMAT_ERROR
	 * @static
	 * @final
	 */
	IMAGE_FORMAT_ERROR : -700,

	/**
	 * While working on files runtime may run out of memory and will throw this error.
	 *
	 * @since 2.1.2
	 * @property MEMORY_ERROR
	 * @static
	 * @final
	 */
	MEMORY_ERROR : -701,

	/**
	 * Each runtime has an upper limit on a dimension of the image it can handle. If bigger, will throw this error.
	 *
	 * @property IMAGE_DIMENSIONS_ERROR
	 * @static
	 * @final
	 */
	IMAGE_DIMENSIONS_ERROR : -702,

	/**
	 * Mime type lookup table.
	 *
	 * @property mimeTypes
	 * @type Object
	 * @final
	 */
	mimeTypes : u.Mime.mimes,

	/**
	 * In some cases sniffing is the only way around :(
	 */
	ua: u.Env,

	/**
	 * Gets the true type of the built-in object (better version of typeof).
	 * @credits Angus Croll (http://javascriptweblog.wordpress.com/)
	 *
	 * @method typeOf
	 * @static
	 * @param {Object} o Object to check.
	 * @return {String} Object [[Class]]
	 */
	typeOf: u.Basic.typeOf,

	/**
	 * Extends the specified object with another object.
	 *
	 * @method extend
	 * @static
	 * @param {Object} target Object to extend.
	 * @param {Object..} obj Multiple objects to extend with.
	 * @return {Object} Same as target, the extended object.
	 */
	extend : u.Basic.extend,

	/**
	 * Generates an unique ID. This is 99.99% unique since it takes the current time and 5 random numbers.
	 * The only way a user would be able to get the same ID is if the two persons at the same exact millisecond manages
	 * to get 5 the same random numbers between 0-65535 it also uses a counter so each call will be guaranteed to be page unique.
	 * It's more probable for the earth to be hit with an asteriod. You can also if you want to be 100% sure set the plupload.guidPrefix property
	 * to an user unique key.
	 *
	 * @method guid
	 * @static
	 * @return {String} Virtually unique id.
	 */
	guid : u.Basic.guid,

	/**
	 * Get array of DOM Elements by their ids.
	 *
	 * @method get
	 * @param {String} id Identifier of the DOM Element
	 * @return {Array}
	*/
	getAll : function get(ids) {
		var els = [], el;

		if (plupload.typeOf(ids) !== 'array') {
			ids = [ids];
		}

		var i = ids.length;
		while (i--) {
			el = plupload.get(ids[i]);
			if (el) {
				els.push(el);
			}
		}

		return els.length ? els : null;
	},

	/**
	Get DOM element by id

	@method get
	@param {String} id Identifier of the DOM Element
	@return {Node}
	*/
	get: u.Dom.get,

	/**
	 * Executes the callback function for each item in array/object. If you return false in the
	 * callback it will break the loop.
	 *
	 * @method each
	 * @static
	 * @param {Object} obj Object to iterate.
	 * @param {function} callback Callback function to execute for each item.
	 */
	each : u.Basic.each,

	/**
	 * Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.
	 *
	 * @method getPos
	 * @static
	 * @param {Element} node HTML element or element id to get x, y position from.
	 * @param {Element} root Optional root element to stop calculations at.
	 * @return {object} Absolute position of the specified element object with x, y fields.
	 */
	getPos : u.Dom.getPos,

	/**
	 * Returns the size of the specified node in pixels.
	 *
	 * @method getSize
	 * @static
	 * @param {Node} node Node to get the size of.
	 * @return {Object} Object with a w and h property.
	 */
	getSize : u.Dom.getSize,

	/**
	 * Encodes the specified string.
	 *
	 * @method xmlEncode
	 * @static
	 * @param {String} s String to encode.
	 * @return {String} Encoded string.
	 */
	xmlEncode : function(str) {
		var xmlEncodeChars = {'<' : 'lt', '>' : 'gt', '&' : 'amp', '"' : 'quot', '\'' : '#39'}, xmlEncodeRegExp = /[<>&\"\']/g;

		return str ? ('' + str).replace(xmlEncodeRegExp, function(chr) {
			return xmlEncodeChars[chr] ? '&' + xmlEncodeChars[chr] + ';' : chr;
		}) : str;
	},

	/**
	 * Forces anything into an array.
	 *
	 * @method toArray
	 * @static
	 * @param {Object} obj Object with length field.
	 * @return {Array} Array object containing all items.
	 */
	toArray : u.Basic.toArray,

	/**
	 * Find an element in array and return its index if present, otherwise return -1.
	 *
	 * @method inArray
	 * @static
	 * @param {mixed} needle Element to find
	 * @param {Array} array
	 * @return {Int} Index of the element, or -1 if not found
	 */
	inArray : u.Basic.inArray,

	/**
	Recieve an array of functions (usually async) to call in sequence, each  function
	receives a callback as first argument that it should call, when it completes. Finally,
	after everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the sequence and invoke main callback
	immediately.

	@method inSeries
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of error
	*/
	inSeries: u.Basic.inSeries,

	/**
	 * Extends the language pack object with new items.
	 *
	 * @method addI18n
	 * @static
	 * @param {Object} pack Language pack items to add.
	 * @return {Object} Extended language pack object.
	 */
	addI18n : o.core.I18n.addI18n,

	/**
	 * Translates the specified string by checking for the english string in the language pack lookup.
	 *
	 * @method translate
	 * @static
	 * @param {String} str String to look for.
	 * @return {String} Translated string or the input string if it wasn't found.
	 */
	translate : o.core.I18n.translate,

	/**
	 * Pseudo sprintf implementation - simple way to replace tokens with specified values.
	 *
	 * @param {String} str String with tokens
	 * @return {String} String with replaced tokens
	 */
	sprintf : u.Basic.sprintf,

	/**
	 * Checks if object is empty.
	 *
	 * @method isEmptyObj
	 * @static
	 * @param {Object} obj Object to check.
	 * @return {Boolean}
	 */
	isEmptyObj : u.Basic.isEmptyObj,

	/**
	 * Checks if specified DOM element has specified class.
	 *
	 * @method hasClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	hasClass : u.Dom.hasClass,

	/**
	 * Adds specified className to specified DOM element.
	 *
	 * @method addClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	addClass : u.Dom.addClass,

	/**
	 * Removes specified className from specified DOM element.
	 *
	 * @method removeClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	removeClass : u.Dom.removeClass,

	/**
	 * Returns a given computed style of a DOM element.
	 *
	 * @method getStyle
	 * @static
	 * @param {Object} obj DOM element like object.
	 * @param {String} name Style you want to get from the DOM element
	 */
	getStyle : u.Dom.getStyle,

	/**
	 * Adds an event handler to the specified object and store reference to the handler
	 * in objects internal Plupload registry (@see removeEvent).
	 *
	 * @method addEvent
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Name to add event listener to.
	 * @param {Function} callback Function to call when event occurs.
	 * @param {String} (optional) key that might be used to add specifity to the event record.
	 */
	addEvent : u.Events.addEvent,

	/**
	 * Remove event handler from the specified object. If third argument (callback)
	 * is not specified remove all events with the specified name.
	 *
	 * @method removeEvent
	 * @static
	 * @param {Object} obj DOM element to remove event listener(s) from.
	 * @param {String} name Name of event listener to remove.
	 * @param {Function|String} (optional) might be a callback or unique key to match.
	 */
	removeEvent: u.Events.removeEvent,

	/**
	 * Remove all kind of events from the specified object
	 *
	 * @method removeAllEvents
	 * @static
	 * @param {Object} obj DOM element to remove event listeners from.
	 * @param {String} (optional) unique key to match, when removing events.
	 */
	removeAllEvents: u.Events.removeAllEvents,

	/**
	 * Cleans the specified name from national characters (diacritics). The result will be a name with only a-z, 0-9 and _.
	 *
	 * @method cleanName
	 * @static
	 * @param {String} s String to clean up.
	 * @return {String} Cleaned string.
	 */
	cleanName : function(name) {
		var i, lookup;

		// Replace diacritics
		lookup = [
			/[\300-\306]/g, 'A', /[\340-\346]/g, 'a',
			/\307/g, 'C', /\347/g, 'c',
			/[\310-\313]/g, 'E', /[\350-\353]/g, 'e',
			/[\314-\317]/g, 'I', /[\354-\357]/g, 'i',
			/\321/g, 'N', /\361/g, 'n',
			/[\322-\330]/g, 'O', /[\362-\370]/g, 'o',
			/[\331-\334]/g, 'U', /[\371-\374]/g, 'u'
		];

		for (i = 0; i < lookup.length; i += 2) {
			name = name.replace(lookup[i], lookup[i + 1]);
		}

		// Replace whitespace
		name = name.replace(/\s+/g, '_');

		// Remove anything else
		name = name.replace(/[^a-z0-9_\-\.]+/gi, '');

		return name;
	},

	/**
	 * Builds a full url out of a base URL and an object with items to append as query string items.
	 *
	 * @method buildUrl
	 * @static
	 * @param {String} url Base URL to append query string items to.
	 * @param {Object} items Name/value object to serialize as a querystring.
	 * @return {String} String with url + serialized query string items.
	 */
	buildUrl: function(url, items) {
		var query = '';

		plupload.each(items, function(value, name) {
			query += (query ? '&' : '') + encodeURIComponent(name) + '=' + encodeURIComponent(value);
		});

		if (query) {
			url += (url.indexOf('?') > 0 ? '&' : '?') + query;
		}

		return url;
	},

	/**
	 * Formats the specified number as a size string for example 1024 becomes 1 KB.
	 *
	 * @method formatSize
	 * @static
	 * @param {Number} size Size to format as string.
	 * @return {String} Formatted size string.
	 */
	formatSize : function(size) {

		if (size === undef || /\D/.test(size)) {
			return plupload.translate('N/A');
		}

		function round(num, precision) {
			return Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);
		}

		var boundary = Math.pow(1024, 4);

		// TB
		if (size > boundary) {
			return round(size / boundary, 1) + " " + plupload.translate('tb');
		}

		// GB
		if (size > (boundary/=1024)) {
			return round(size / boundary, 1) + " " + plupload.translate('gb');
		}

		// MB
		if (size > (boundary/=1024)) {
			return round(size / boundary, 1) + " " + plupload.translate('mb');
		}

		// KB
		if (size > 1024) {
			return Math.round(size / 1024) + " " + plupload.translate('kb');
		}

		return size + " " + plupload.translate('b');
	},


	/**
	 * Parses the specified size string into a byte value. For example 10kb becomes 10240.
	 *
	 * @method parseSize
	 * @static
	 * @param {String|Number} size String to parse or number to just pass through.
	 * @return {Number} Size in bytes.
	 */
	parseSize : u.Basic.parseSizeStr,


	/**
	 * A way to predict what runtime will be choosen in the current environment with the
	 * specified settings.
	 *
	 * @method predictRuntime
	 * @static
	 * @param {Object|String} config Plupload settings to check
	 * @param {String} [runtimes] Comma-separated list of runtimes to check against
	 * @return {String} Type of compatible runtime
	 */
	predictRuntime : function(config, runtimes) {
		var up, runtime;

		up = new plupload.Uploader(config);
		runtime = Runtime.thatCan(up.getOption().required_features, runtimes || config.runtimes);
		up.destroy();
		return runtime;
	},

	/**
	 * Registers a filter that will be executed for each file added to the queue.
	 * If callback returns false, file will not be added.
	 *
	 * Callback receives two arguments: a value for the filter as it was specified in settings.filters
	 * and a file to be filtered. Callback is executed in the context of uploader instance.
	 *
	 * @method addFileFilter
	 * @static
	 * @param {String} name Name of the filter by which it can be referenced in settings.filters
	 * @param {String} cb Callback - the actual routine that every added file must pass
	 */
	addFileFilter: function(name, cb) {
		fileFilters[name] = cb;
	}
};


plupload.addFileFilter('mime_types', function(filters, file, cb) {
	if (filters.length && !filters.regexp.test(file.name)) {
		this.trigger('Error', {
			code : plupload.FILE_EXTENSION_ERROR,
			message : plupload.translate('File extension error.'),
			file : file
		});
		cb(false);
	} else {
		cb(true);
	}
});


plupload.addFileFilter('max_file_size', function(maxSize, file, cb) {
	var undef;

	maxSize = plupload.parseSize(maxSize);

	// Invalid file size
	if (file.size !== undef && maxSize && file.size > maxSize) {
		this.trigger('Error', {
			code : plupload.FILE_SIZE_ERROR,
			message : plupload.translate('File size error.'),
			file : file
		});
		cb(false);
	} else {
		cb(true);
	}
});


plupload.addFileFilter('prevent_duplicates', function(value, file, cb) {
	if (value) {
		var ii = this.files.length;
		while (ii--) {
			// Compare by name and size (size might be 0 or undefined, but still equivalent for both)
			if (file.name === this.files[ii].name && file.size === this.files[ii].size) {
				this.trigger('Error', {
					code : plupload.FILE_DUPLICATE_ERROR,
					message : plupload.translate('Duplicate file error.'),
					file : file
				});
				cb(false);
				return;
			}
		}
	}
	cb(true);
});


/**
@class Uploader
@constructor

@param {Object} settings For detailed information about each option check documentation.
	@param {String|DOMElement} settings.browse_button id of the DOM element or DOM element itself to use as file dialog trigger.
	@param {Number|String} [settings.chunk_size=0] Chunk size in bytes to slice the file into. Shorcuts with b, kb, mb, gb, tb suffixes also supported. `e.g. 204800 or "204800b" or "200kb"`. By default - disabled.
	@param {String|DOMElement} [settings.container] id of the DOM element or DOM element itself that will be used to wrap uploader structures. Defaults to immediate parent of the `browse_button` element.
	@param {String|DOMElement} [settings.drop_element] id of the DOM element or DOM element itself to use as a drop zone for Drag-n-Drop.
	@param {String} [settings.file_data_name="file"] Name for the file field in Multipart formated message.
	@param {Object} [settings.filters={}] Set of file type filters.
		@param {String|Number} [settings.filters.max_file_size=0] Maximum file size that the user can pick, in bytes. Optionally supports b, kb, mb, gb, tb suffixes. `e.g. "10mb" or "1gb"`. By default - not set. Dispatches `plupload.FILE_SIZE_ERROR`.
		@param {Array} [settings.filters.mime_types=[]] List of file types to accept, each one defined by title and list of extensions. `e.g. {title : "Image files", extensions : "jpg,jpeg,gif,png"}`. Dispatches `plupload.FILE_EXTENSION_ERROR`
		@param {Boolean} [settings.filters.prevent_duplicates=false] Do not let duplicates into the queue. Dispatches `plupload.FILE_DUPLICATE_ERROR`.
	@param {String} [settings.flash_swf_url] URL of the Flash swf.
	@param {Object} [settings.headers] Custom headers to send with the upload. Hash of name/value pairs.
	@param {String} [settings.http_method="POST"] HTTP method to use during upload (only PUT or POST allowed).
	@param {Number} [settings.max_retries=0] How many times to retry the chunk or file, before triggering Error event.
	@param {Boolean} [settings.multipart=true] Whether to send file and additional parameters as Multipart formated message.
	@param {Object} [settings.multipart_params] Hash of key/value pairs to send with every file upload.
	@param {Boolean} [settings.multi_selection=true] Enable ability to select multiple files at once in file dialog.
	@param {String|Object} [settings.required_features] Either comma-separated list or hash of required features that chosen runtime should absolutely possess.
	@param {Object} [settings.resize] Enable resizng of images on client-side. Applies to `image/jpeg` and `image/png` only. `e.g. {width : 200, height : 200, quality : 90, crop: true}`
		@param {Number} [settings.resize.width] If image is bigger, it will be resized.
		@param {Number} [settings.resize.height] If image is bigger, it will be resized.
		@param {Number} [settings.resize.quality=90] Compression quality for jpegs (1-100).
		@param {Boolean} [settings.resize.crop=false] Whether to crop images to exact dimensions. By default they will be resized proportionally.
	@param {String} [settings.runtimes="html5,flash,silverlight,html4"] Comma separated list of runtimes, that Plupload will try in turn, moving to the next if previous fails.
	@param {String} [settings.silverlight_xap_url] URL of the Silverlight xap.
	@param {Boolean} [settings.send_chunk_number=true] Whether to send chunks and chunk numbers, or total and offset bytes.
	@param {Boolean} [settings.send_file_name=true] Whether to send file name as additional argument - 'name' (required for chunked uploads and some other cases where file name cannot be sent via normal ways).
	@param {String} settings.url URL of the server-side upload handler.
	@param {Boolean} [settings.unique_names=false] If true will generate unique filenames for uploaded files.

*/
plupload.Uploader = function(options) {
	/**
	Fires when the current RunTime has been initialized.

	@event Init
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires after the init event incase you need to perform actions there.

	@event PostInit
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires when the option is changed in via uploader.setOption().

	@event OptionChanged
	@since 2.1
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {String} name Name of the option that was changed
	@param {Mixed} value New value for the specified option
	@param {Mixed} oldValue Previous value of the option
	 */

	/**
	Fires when the silverlight/flash or other shim needs to move.

	@event Refresh
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires when the overall state is being changed for the upload queue.

	@event StateChanged
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires when browse_button is clicked and browse dialog shows.

	@event Browse
	@since 2.1.2
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires for every filtered file before it is added to the queue.

	@event FileFiltered
	@since 2.1
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file Another file that has to be added to the queue.
	 */

	/**
	Fires when the file queue is changed. In other words when files are added/removed to the files array of the uploader instance.

	@event QueueChanged
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires after files were filtered and added to the queue.

	@event FilesAdded
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Array} files Array of file objects that were added to queue by the user.
	 */

	/**
	Fires when file is removed from the queue.

	@event FilesRemoved
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Array} files Array of files that got removed.
	 */

	/**
	Fires just before a file is uploaded. Can be used to cancel the upload for the specified file
	by returning false from the handler.

	@event BeforeUpload
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File to be uploaded.
	 */

	/**
	Fires when a file is to be uploaded by the runtime.

	@event UploadFile
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File to be uploaded.
	 */

	/**
	Fires while a file is being uploaded. Use this event to update the current file upload progress.

	@event UploadProgress
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File that is currently being uploaded.
	 */

	/**
	* Fires just before a chunk is uploaded. This event enables you to override settings
	* on the uploader instance before the chunk is uploaded.
	*
	* @event BeforeChunkUpload
	* @param {plupload.Uploader} uploader Uploader instance sending the event.
	* @param {plupload.File} file File to be uploaded.
	* @param {Object} args POST params to be sent.
	* @param {Blob} chunkBlob Current blob.
	* @param {offset} offset Current offset.
	*/

	/**
	Fires when file chunk is uploaded.

	@event ChunkUploaded
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File that the chunk was uploaded for.
	@param {Object} result Object with response properties.
		@param {Number} result.offset The amount of bytes the server has received so far, including this chunk.
		@param {Number} result.total The size of the file.
		@param {String} result.response The response body sent by the server.
		@param {Number} result.status The HTTP status code sent by the server.
		@param {String} result.responseHeaders All the response headers as a single string.
	 */

	/**
	Fires when a file is successfully uploaded.

	@event FileUploaded
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File that was uploaded.
	@param {Object} result Object with response properties.
		@param {String} result.response The response body sent by the server.
		@param {Number} result.status The HTTP status code sent by the server.
		@param {String} result.responseHeaders All the response headers as a single string.
	 */

	/**
	Fires when all files in a queue are uploaded.

	@event UploadComplete
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Array} files Array of file objects that was added to queue/selected by the user.
	 */

	/**
	Fires when a error occurs.

	@event Error
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Object} error Contains code, message and sometimes file and other details.
		@param {Number} error.code The plupload error code.
		@param {String} error.message Description of the error (uses i18n).
	 */

	/**
	Fires when destroy method is called.

	@event Destroy
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */
	var uid = plupload.guid()
	, settings
	, files = []
	, preferred_caps = {}
	, fileInputs = []
	, fileDrops = []
	, startTime
	, total
	, disabled = false
	, xhr
	;


	// Private methods
	function uploadNext() {
		var file, count = 0, i;

		if (this.state == plupload.STARTED) {
			// Find first QUEUED file
			for (i = 0; i < files.length; i++) {
				if (!file && files[i].status == plupload.QUEUED) {
					file = files[i];
					if (this.trigger("BeforeUpload", file)) {
						file.status = plupload.UPLOADING;
						this.trigger("UploadFile", file);
					}
				} else {
					count++;
				}
			}

			// All files are DONE or FAILED
			if (count == files.length) {
				if (this.state !== plupload.STOPPED) {
					this.state = plupload.STOPPED;
					this.trigger("StateChanged");
				}
				this.trigger("UploadComplete", files);
			}
		}
	}


	function calcFile(file) {
		file.percent = file.size > 0 ? Math.ceil(file.loaded / file.size * 100) : 100;
		calc();
	}


	function calc() {
		var i, file;
		var loaded;
		var loadedDuringCurrentSession = 0;

		// Reset stats
		total.reset();

		// Check status, size, loaded etc on all files
		for (i = 0; i < files.length; i++) {
			file = files[i];

			if (file.size !== undef) {
				// We calculate totals based on original file size
				total.size += file.origSize;

				// Since we cannot predict file size after resize, we do opposite and
				// interpolate loaded amount to match magnitude of total
				loaded = file.loaded * file.origSize / file.size;

				if (!file.completeTimestamp || file.completeTimestamp > startTime) {
					loadedDuringCurrentSession += loaded;
				}

				total.loaded += loaded;
			} else {
				total.size = undef;
			}

			if (file.status == plupload.DONE) {
				total.uploaded++;
			} else if (file.status == plupload.FAILED) {
				total.failed++;
			} else {
				total.queued++;
			}
		}

		// If we couldn't calculate a total file size then use the number of files to calc percent
		if (total.size === undef) {
			total.percent = files.length > 0 ? Math.ceil(total.uploaded / files.length * 100) : 0;
		} else {
			total.bytesPerSec = Math.ceil(loadedDuringCurrentSession / ((+new Date() - startTime || 1) / 1000.0));
			total.percent = total.size > 0 ? Math.ceil(total.loaded / total.size * 100) : 0;
		}
	}


	function getRUID() {
		var ctrl = fileInputs[0] || fileDrops[0];
		if (ctrl) {
			return ctrl.getRuntime().uid;
		}
		return false;
	}


	function runtimeCan(file, cap) {
		if (file.ruid) {
			var info = Runtime.getInfo(file.ruid);
			if (info) {
				return info.can(cap);
			}
		}
		return false;
	}


	function bindEventListeners() {
		this.bind('FilesAdded FilesRemoved', function(up) {
			up.trigger('QueueChanged');
			up.refresh();
		});

		this.bind('CancelUpload', onCancelUpload);

		this.bind('BeforeUpload', onBeforeUpload);

		this.bind('UploadFile', onUploadFile);

		this.bind('UploadProgress', onUploadProgress);

		this.bind('StateChanged', onStateChanged);

		this.bind('QueueChanged', calc);

		this.bind('Error', onError);

		this.bind('FileUploaded', onFileUploaded);

		this.bind('Destroy', onDestroy);
	}


	function initControls(settings, cb) {
		var self = this, inited = 0, queue = [];

		// common settings
		var options = {
			runtime_order: settings.runtimes,
			required_caps: settings.required_features,
			preferred_caps: preferred_caps,
			swf_url: settings.flash_swf_url,
			xap_url: settings.silverlight_xap_url
		};

		// add runtime specific options if any
		plupload.each(settings.runtimes.split(/\s*,\s*/), function(runtime) {
			if (settings[runtime]) {
				options[runtime] = settings[runtime];
			}
		});

		// initialize file pickers - there can be many
		if (settings.browse_button) {
			plupload.each(settings.browse_button, function(el) {
				queue.push(function(cb) {
					var fileInput = new o.file.FileInput(plupload.extend({}, options, {
						accept: settings.filters.mime_types,
						name: settings.file_data_name,
						multiple: settings.multi_selection,
						container: settings.container,
						browse_button: el
					}));

					fileInput.onready = function() {
						var info = Runtime.getInfo(this.ruid);

						// for backward compatibility
						plupload.extend(self.features, {
							chunks: info.can('slice_blob'),
							multipart: info.can('send_multipart'),
							multi_selection: info.can('select_multiple')
						});

						inited++;
						fileInputs.push(this);
						cb();
					};

					fileInput.onchange = function() {
						self.addFile(this.files);
					};

					fileInput.bind('mouseenter mouseleave mousedown mouseup', function(e) {
						if (!disabled) {
							if (settings.browse_button_hover) {
								if ('mouseenter' === e.type) {
									plupload.addClass(el, settings.browse_button_hover);
								} else if ('mouseleave' === e.type) {
									plupload.removeClass(el, settings.browse_button_hover);
								}
							}

							if (settings.browse_button_active) {
								if ('mousedown' === e.type) {
									plupload.addClass(el, settings.browse_button_active);
								} else if ('mouseup' === e.type) {
									plupload.removeClass(el, settings.browse_button_active);
								}
							}
						}
					});

					fileInput.bind('mousedown', function() {
						self.trigger('Browse');
					});

					fileInput.bind('error runtimeerror', function() {
						fileInput = null;
						cb();
					});

					fileInput.init();
				});
			});
		}

		// initialize drop zones
		if (settings.drop_element) {
			plupload.each(settings.drop_element, function(el) {
				queue.push(function(cb) {
					var fileDrop = new o.file.FileDrop(plupload.extend({}, options, {
						drop_zone: el
					}));

					fileDrop.onready = function() {
						var info = Runtime.getInfo(this.ruid);

						// for backward compatibility
						plupload.extend(self.features, {
							chunks: info.can('slice_blob'),
							multipart: info.can('send_multipart'),
							dragdrop: info.can('drag_and_drop')
						});

						inited++;
						fileDrops.push(this);
						cb();
					};

					fileDrop.ondrop = function() {
						self.addFile(this.files);
					};

					fileDrop.bind('error runtimeerror', function() {
						fileDrop = null;
						cb();
					});

					fileDrop.init();
				});
			});
		}


		plupload.inSeries(queue, function() {
			if (typeof(cb) === 'function') {
				cb(inited);
			}
		});
	}


	function resizeImage(blob, params, cb) {
		var img = new o.image.Image();

		try {
			img.onload = function() {
				// no manipulation required if...
				if (params.width > this.width &&
					params.height > this.height &&
					params.quality === undef &&
					params.preserve_headers &&
					!params.crop
				) {
					this.destroy();
					return cb(blob);
				}
				// otherwise downsize
				img.downsize(params.width, params.height, params.crop, params.preserve_headers);
			};

			img.onresize = function() {
				cb(this.getAsBlob(blob.type, params.quality));
				this.destroy();
			};

			img.onerror = function() {
				cb(blob);
			};

			img.load(blob);
		} catch(ex) {
			cb(blob);
		}
	}


	function setOption(option, value, init) {
		var self = this, reinitRequired = false;

		function _setOption(option, value, init) {
			var oldValue = settings[option];

			switch (option) {
				case 'max_file_size':
					if (option === 'max_file_size') {
						settings.max_file_size = settings.filters.max_file_size = value;
					}
					break;

				case 'chunk_size':
					if (value = plupload.parseSize(value)) {
						settings[option] = value;
						settings.send_file_name = true;
					}
					break;

				case 'multipart':
					settings[option] = value;
					if (!value) {
						settings.send_file_name = true;
					}
					break;

				case 'http_method':
					settings[option] = value.toUpperCase() === 'PUT' ? 'PUT' : 'POST';
					break;

				case 'unique_names':
					settings[option] = value;
					if (value) {
						settings.send_file_name = true;
					}
					break;

				case 'filters':
					// for sake of backward compatibility
					if (plupload.typeOf(value) === 'array') {
						value = {
							mime_types: value
						};
					}

					if (init) {
						plupload.extend(settings.filters, value);
					} else {
						settings.filters = value;
					}

					// if file format filters are being updated, regenerate the matching expressions
					if (value.mime_types) {
						if (plupload.typeOf(value.mime_types) === 'string') {
							value.mime_types = o.core.utils.Mime.mimes2extList(value.mime_types);
						}

						value.mime_types.regexp = (function(filters) {
							var extensionsRegExp = [];

							plupload.each(filters, function(filter) {
								plupload.each(filter.extensions.split(/,/), function(ext) {
									if (/^\s*\*\s*$/.test(ext)) {
										extensionsRegExp.push('\\.*');
									} else {
										extensionsRegExp.push('\\.' + ext.replace(new RegExp('[' + ('/^$.*+?|()[]{}\\'.replace(/./g, '\\$&')) + ']', 'g'), '\\$&'));
									}
								});
							});

							return new RegExp('(' + extensionsRegExp.join('|') + ')$', 'i');
						}(value.mime_types));

						settings.filters.mime_types = value.mime_types;
					}
					break;

				case 'resize':
					if (value) {
						settings.resize = plupload.extend({
							preserve_headers: true,
							crop: false
						}, value);
					} else {
						settings.resize = false;
					}
					break;

				case 'prevent_duplicates':
					settings.prevent_duplicates = settings.filters.prevent_duplicates = !!value;
					break;

				// options that require reinitialisation
				case 'container':
				case 'browse_button':
				case 'drop_element':
						value = 'container' === option
							? plupload.get(value)
							: plupload.getAll(value)
							;

				case 'runtimes':
				case 'multi_selection':
				case 'flash_swf_url':
				case 'silverlight_xap_url':
					settings[option] = value;
					if (!init) {
						reinitRequired = true;
					}
					break;

				default:
					settings[option] = value;
			}

			if (!init) {
				self.trigger('OptionChanged', option, value, oldValue);
			}
		}

		if (typeof(option) === 'object') {
			plupload.each(option, function(value, option) {
				_setOption(option, value, init);
			});
		} else {
			_setOption(option, value, init);
		}

		if (init) {
			// Normalize the list of required capabilities
			settings.required_features = normalizeCaps(plupload.extend({}, settings));

			// Come up with the list of capabilities that can affect default mode in a multi-mode runtimes
			preferred_caps = normalizeCaps(plupload.extend({}, settings, {
				required_features: true
			}));
		} else if (reinitRequired) {
			self.trigger('Destroy');

			initControls.call(self, settings, function(inited) {
				if (inited) {
					self.runtime = Runtime.getInfo(getRUID()).type;
					self.trigger('Init', { runtime: self.runtime });
					self.trigger('PostInit');
				} else {
					self.trigger('Error', {
						code : plupload.INIT_ERROR,
						message : plupload.translate('Init error.')
					});
				}
			});
		}
	}


	// Internal event handlers
	function onBeforeUpload(up, file) {
		// Generate unique target filenames
		if (up.settings.unique_names) {
			var matches = file.name.match(/\.([^.]+)$/), ext = "part";
			if (matches) {
				ext = matches[1];
			}
			file.target_name = file.id + '.' + ext;
		}
	}


	function onUploadFile(up, file) {
		var url = up.settings.url
		, chunkSize = up.settings.chunk_size
		, retries = up.settings.max_retries
		, features = up.features
		, offset = 0
		, blob
		;

		// make sure we start at a predictable offset
		if (file.loaded) {
			offset = file.loaded = chunkSize ? chunkSize * Math.floor(file.loaded / chunkSize) : 0;
		}

		function handleError() {
			if (retries-- > 0) {
				delay(uploadNextChunk, 1000);
			} else {
				file.loaded = offset; // reset all progress

				up.trigger('Error', {
					code : plupload.HTTP_ERROR,
					message : plupload.translate('HTTP Error.'),
					file : file,
					response : xhr.responseText,
					status : xhr.status,
					responseHeaders: xhr.getAllResponseHeaders()
				});
			}
		}

		function uploadNextChunk() {
			var chunkBlob, args = {}, curChunkSize;

			// make sure that file wasn't cancelled and upload is not stopped in general
			if (file.status !== plupload.UPLOADING || up.state === plupload.STOPPED) {
				return;
			}

			// send additional 'name' parameter only if required
			if (up.settings.send_file_name) {
				args.name = file.target_name || file.name;
			}

			if (chunkSize && features.chunks && blob.size > chunkSize) { // blob will be of type string if it was loaded in memory
				curChunkSize = Math.min(chunkSize, blob.size - offset);
				chunkBlob = blob.slice(offset, offset + curChunkSize);
			} else {
				curChunkSize = blob.size;
				chunkBlob = blob;
			}

			// If chunking is enabled add corresponding args, no matter if file is bigger than chunk or smaller
			if (chunkSize && features.chunks) {
				// Setup query string arguments
				if (up.settings.send_chunk_number) {
					args.chunk = Math.ceil(offset / chunkSize);
					args.chunks = Math.ceil(blob.size / chunkSize);
				} else { // keep support for experimental chunk format, just in case
					args.offset = offset;
					args.total = blob.size;
				}
			}

			if (up.trigger('BeforeChunkUpload', file, args, chunkBlob, offset)) {
				uploadChunk(args, chunkBlob, curChunkSize);
			}
		}

		function uploadChunk(args, chunkBlob, curChunkSize) {
			var formData;

			xhr = new o.xhr.XMLHttpRequest();

			// Do we have upload progress support
			if (xhr.upload) {
				xhr.upload.onprogress = function(e) {
					file.loaded = Math.min(file.size, offset + e.loaded);
					up.trigger('UploadProgress', file);
				};
			}

			xhr.onload = function() {
				// check if upload made itself through
				if (xhr.status >= 400) {
					handleError();
					return;
				}

				retries = up.settings.max_retries; // reset the counter

				// Handle chunk response
				if (curChunkSize < blob.size) {
					chunkBlob.destroy();

					offset += curChunkSize;
					file.loaded = Math.min(offset, blob.size);

					up.trigger('ChunkUploaded', file, {
						offset : file.loaded,
						total : blob.size,
						response : xhr.responseText,
						status : xhr.status,
						responseHeaders: xhr.getAllResponseHeaders()
					});

					// stock Android browser doesn't fire upload progress events, but in chunking mode we can fake them
					if (plupload.ua.browser === 'Android Browser') {
						// doesn't harm in general, but is not required anywhere else
						up.trigger('UploadProgress', file);
					}
				} else {
					file.loaded = file.size;
				}

				chunkBlob = formData = null; // Free memory

				// Check if file is uploaded
				if (!offset || offset >= blob.size) {
					// If file was modified, destory the copy
					if (file.size != file.origSize) {
						blob.destroy();
						blob = null;
					}

					up.trigger('UploadProgress', file);

					file.status = plupload.DONE;
					file.completeTimestamp = +new Date();

					up.trigger('FileUploaded', file, {
						response : xhr.responseText,
						status : xhr.status,
						responseHeaders: xhr.getAllResponseHeaders()
					});
				} else {
					// Still chunks left
					delay(uploadNextChunk, 1); // run detached, otherwise event handlers interfere
				}
			};

			xhr.onerror = function() {
				handleError();
			};

			xhr.onloadend = function() {
				this.destroy();
				xhr = null;
			};

			// Build multipart request
			if (up.settings.multipart && features.multipart) {
				xhr.open(up.settings.http_method, url, true);

				// Set custom headers
				plupload.each(up.settings.headers, function(value, name) {
					xhr.setRequestHeader(name, value);
				});

				formData = new o.xhr.FormData();

				// Add multipart params
				plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
					formData.append(name, value);
				});

				// Add file and send it
				formData.append(up.settings.file_data_name, chunkBlob);
				xhr.send(formData, {
					runtime_order: up.settings.runtimes,
					required_caps: up.settings.required_features,
					preferred_caps: preferred_caps,
					swf_url: up.settings.flash_swf_url,
					xap_url: up.settings.silverlight_xap_url
				});
			} else {
				// if no multipart, send as binary stream
				url = plupload.buildUrl(up.settings.url, plupload.extend(args, up.settings.multipart_params));

				xhr.open(up.settings.http_method, url, true);

				// Set custom headers
				plupload.each(up.settings.headers, function(value, name) {
					xhr.setRequestHeader(name, value);
				});

				// do not set Content-Type, if it was defined previously (see #1203)
				if (!xhr.hasRequestHeader('Content-Type')) {
					xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // Binary stream header
				}

				xhr.send(chunkBlob, {
					runtime_order: up.settings.runtimes,
					required_caps: up.settings.required_features,
					preferred_caps: preferred_caps,
					swf_url: up.settings.flash_swf_url,
					xap_url: up.settings.silverlight_xap_url
				});
			}
		}


		blob = file.getSource();

		// Start uploading chunks
		if (!plupload.isEmptyObj(up.settings.resize) && runtimeCan(blob, 'send_binary_string') && plupload.inArray(blob.type, ['image/jpeg', 'image/png']) !== -1) {
			// Resize if required
			resizeImage.call(this, blob, up.settings.resize, function(resizedBlob) {
				blob = resizedBlob;
				file.size = resizedBlob.size;
				uploadNextChunk();
			});
		} else {
			uploadNextChunk();
		}
	}


	function onUploadProgress(up, file) {
		calcFile(file);
	}


	function onStateChanged(up) {
		if (up.state == plupload.STARTED) {
			// Get start time to calculate bps
			startTime = (+new Date());
		} else if (up.state == plupload.STOPPED) {
			// Reset currently uploading files
			for (var i = up.files.length - 1; i >= 0; i--) {
				if (up.files[i].status == plupload.UPLOADING) {
					up.files[i].status = plupload.QUEUED;
					calc();
				}
			}
		}
	}


	function onCancelUpload() {
		if (xhr) {
			xhr.abort();
		}
	}


	function onFileUploaded(up) {
		calc();

		// Upload next file but detach it from the error event
		// since other custom listeners might want to stop the queue
		delay(function() {
			uploadNext.call(up);
		}, 1);
	}


	function onError(up, err) {
		if (err.code === plupload.INIT_ERROR) {
			up.destroy();
		}
		// Set failed status if an error occured on a file
		else if (err.code === plupload.HTTP_ERROR) {
			err.file.status = plupload.FAILED;
			err.file.completeTimestamp = +new Date();
			calcFile(err.file);

			// Upload next file but detach it from the error event
			// since other custom listeners might want to stop the queue
			if (up.state == plupload.STARTED) { // upload in progress
				up.trigger('CancelUpload');
				delay(function() {
					uploadNext.call(up);
				}, 1);
			}
		}
	}


	function onDestroy(up) {
		up.stop();

		// Purge the queue
		plupload.each(files, function(file) {
			file.destroy();
		});
		files = [];

		if (fileInputs.length) {
			plupload.each(fileInputs, function(fileInput) {
				fileInput.destroy();
			});
			fileInputs = [];
		}

		if (fileDrops.length) {
			plupload.each(fileDrops, function(fileDrop) {
				fileDrop.destroy();
			});
			fileDrops = [];
		}

		preferred_caps = {};
		disabled = false;
		startTime = xhr = null;
		total.reset();
	}


	// Default settings
	settings = {
		chunk_size: 0,
		file_data_name: 'file',
		filters: {
			mime_types: [],
			prevent_duplicates: false,
			max_file_size: 0
		},
		flash_swf_url: 'js/Moxie.swf',
		http_method: 'POST',
		max_retries: 0,
		multipart: true,
		multi_selection: true,
		resize: false,
		runtimes: Runtime.order,
		send_file_name: true,
		send_chunk_number: true,
		silverlight_xap_url: 'js/Moxie.xap'
	};


	setOption.call(this, options, null, true);

	// Inital total state
	total = new plupload.QueueProgress();

	// Add public methods
	plupload.extend(this, {

		/**
		 * Unique id for the Uploader instance.
		 *
		 * @property id
		 * @type String
		 */
		id : uid,
		uid : uid, // mOxie uses this to differentiate between event targets

		/**
		 * Current state of the total uploading progress. This one can either be plupload.STARTED or plupload.STOPPED.
		 * These states are controlled by the stop/start methods. The default value is STOPPED.
		 *
		 * @property state
		 * @type Number
		 */
		state : plupload.STOPPED,

		/**
		 * Map of features that are available for the uploader runtime. Features will be filled
		 * before the init event is called, these features can then be used to alter the UI for the end user.
		 * Some of the current features that might be in this map is: dragdrop, chunks, jpgresize, pngresize.
		 *
		 * @property features
		 * @type Object
		 */
		features : {},

		/**
		 * Current runtime name.
		 *
		 * @property runtime
		 * @type String
		 */
		runtime : null,

		/**
		 * Current upload queue, an array of File instances.
		 *
		 * @property files
		 * @type Array
		 * @see plupload.File
		 */
		files : files,

		/**
		 * Object with name/value settings.
		 *
		 * @property settings
		 * @type Object
		 */
		settings : settings,

		/**
		 * Total progess information. How many files has been uploaded, total percent etc.
		 *
		 * @property total
		 * @type plupload.QueueProgress
		 */
		total : total,


		/**
		 * Initializes the Uploader instance and adds internal event listeners.
		 *
		 * @method init
		 */
		init : function() {
			var self = this, opt, preinitOpt, err;

			preinitOpt = self.getOption('preinit');
			if (typeof(preinitOpt) == "function") {
				preinitOpt(self);
			} else {
				plupload.each(preinitOpt, function(func, name) {
					self.bind(name, func);
				});
			}

			bindEventListeners.call(self);

			// Check for required options
			plupload.each(['container', 'browse_button', 'drop_element'], function(el) {
				if (self.getOption(el) === null) {
					err = {
						code : plupload.INIT_ERROR,
						message : plupload.sprintf(plupload.translate("%s specified, but cannot be found."), el)
					}
					return false;
				}
			});

			if (err) {
				return self.trigger('Error', err);
			}


			if (!settings.browse_button && !settings.drop_element) {
				return self.trigger('Error', {
					code : plupload.INIT_ERROR,
					message : plupload.translate("You must specify either browse_button or drop_element.")
				});
			}


			initControls.call(self, settings, function(inited) {
				var initOpt = self.getOption('init');
				if (typeof(initOpt) == "function") {
					initOpt(self);
				} else {
					plupload.each(initOpt, function(func, name) {
						self.bind(name, func);
					});
				}

				if (inited) {
					self.runtime = Runtime.getInfo(getRUID()).type;
					self.trigger('Init', { runtime: self.runtime });
					self.trigger('PostInit');
				} else {
					self.trigger('Error', {
						code : plupload.INIT_ERROR,
						message : plupload.translate('Init error.')
					});
				}
			});
		},

		/**
		 * Set the value for the specified option(s).
		 *
		 * @method setOption
		 * @since 2.1
		 * @param {String|Object} option Name of the option to change or the set of key/value pairs
		 * @param {Mixed} [value] Value for the option (is ignored, if first argument is object)
		 */
		setOption: function(option, value) {
			setOption.call(this, option, value, !this.runtime); // until runtime not set we do not need to reinitialize
		},

		/**
		 * Get the value for the specified option or the whole configuration, if not specified.
		 *
		 * @method getOption
		 * @since 2.1
		 * @param {String} [option] Name of the option to get
		 * @return {Mixed} Value for the option or the whole set
		 */
		getOption: function(option) {
			if (!option) {
				return settings;
			}
			return settings[option];
		},

		/**
		 * Refreshes the upload instance by dispatching out a refresh event to all runtimes.
		 * This would for example reposition flash/silverlight shims on the page.
		 *
		 * @method refresh
		 */
		refresh : function() {
			if (fileInputs.length) {
				plupload.each(fileInputs, function(fileInput) {
					fileInput.trigger('Refresh');
				});
			}
			this.trigger('Refresh');
		},

		/**
		 * Starts uploading the queued files.
		 *
		 * @method start
		 */
		start : function() {
			if (this.state != plupload.STARTED) {
				this.state = plupload.STARTED;
				this.trigger('StateChanged');

				uploadNext.call(this);
			}
		},

		/**
		 * Stops the upload of the queued files.
		 *
		 * @method stop
		 */
		stop : function() {
			if (this.state != plupload.STOPPED) {
				this.state = plupload.STOPPED;
				this.trigger('StateChanged');
				this.trigger('CancelUpload');
			}
		},


		/**
		 * Disables/enables browse button on request.
		 *
		 * @method disableBrowse
		 * @param {Boolean} disable Whether to disable or enable (default: true)
		 */
		disableBrowse : function() {
			disabled = arguments[0] !== undef ? arguments[0] : true;

			if (fileInputs.length) {
				plupload.each(fileInputs, function(fileInput) {
					fileInput.disable(disabled);
				});
			}

			this.trigger('DisableBrowse', disabled);
		},

		/**
		 * Returns the specified file object by id.
		 *
		 * @method getFile
		 * @param {String} id File id to look for.
		 * @return {plupload.File} File object or undefined if it wasn't found;
		 */
		getFile : function(id) {
			var i;
			for (i = files.length - 1; i >= 0; i--) {
				if (files[i].id === id) {
					return files[i];
				}
			}
		},

		/**
		 * Adds file to the queue programmatically. Can be native file, instance of Plupload.File,
		 * instance of mOxie.File, input[type="file"] element, or array of these. Fires FilesAdded,
		 * if any files were added to the queue. Otherwise nothing happens.
		 *
		 * @method addFile
		 * @since 2.0
		 * @param {plupload.File|mOxie.File|File|Node|Array} file File or files to add to the queue.
		 * @param {String} [fileName] If specified, will be used as a name for the file
		 */
		addFile : function(file, fileName) {
			var self = this
			, queue = []
			, filesAdded = []
			, ruid
			;

			function filterFile(file, cb) {
				var queue = [];
				plupload.each(self.settings.filters, function(rule, name) {
					if (fileFilters[name]) {
						queue.push(function(cb) {
							fileFilters[name].call(self, rule, file, function(res) {
								cb(!res);
							});
						});
					}
				});
				plupload.inSeries(queue, cb);
			}

			/**
			 * @method resolveFile
			 * @private
			 * @param {moxie.file.File|moxie.file.Blob|plupload.File|File|Blob|input[type="file"]} file
			 */
			function resolveFile(file) {
				var type = plupload.typeOf(file);

				// moxie.file.File
				if (file instanceof o.file.File) {
					if (!file.ruid && !file.isDetached()) {
						if (!ruid) { // weird case
							return false;
						}
						file.ruid = ruid;
						file.connectRuntime(ruid);
					}
					resolveFile(new plupload.File(file));
				}
				// moxie.file.Blob
				else if (file instanceof o.file.Blob) {
					resolveFile(file.getSource());
					file.destroy();
				}
				// plupload.File - final step for other branches
				else if (file instanceof plupload.File) {
					if (fileName) {
						file.name = fileName;
					}

					queue.push(function(cb) {
						// run through the internal and user-defined filters, if any
						filterFile(file, function(err) {
							if (!err) {
								// make files available for the filters by updating the main queue directly
								files.push(file);
								// collect the files that will be passed to FilesAdded event
								filesAdded.push(file);

								self.trigger("FileFiltered", file);
							}
							delay(cb, 1); // do not build up recursions or eventually we might hit the limits
						});
					});
				}
				// native File or blob
				else if (plupload.inArray(type, ['file', 'blob']) !== -1) {
					resolveFile(new o.file.File(null, file));
				}
				// input[type="file"]
				else if (type === 'node' && plupload.typeOf(file.files) === 'filelist') {
					// if we are dealing with input[type="file"]
					plupload.each(file.files, resolveFile);
				}
				// mixed array of any supported types (see above)
				else if (type === 'array') {
					fileName = null; // should never happen, but unset anyway to avoid funny situations
					plupload.each(file, resolveFile);
				}
			}

			ruid = getRUID();

			resolveFile(file);

			if (queue.length) {
				plupload.inSeries(queue, function() {
					// if any files left after filtration, trigger FilesAdded
					if (filesAdded.length) {
						self.trigger("FilesAdded", filesAdded);
					}
				});
			}
		},

		/**
		 * Removes a specific file.
		 *
		 * @method removeFile
		 * @param {plupload.File|String} file File to remove from queue.
		 */
		removeFile : function(file) {
			var id = typeof(file) === 'string' ? file : file.id;

			for (var i = files.length - 1; i >= 0; i--) {
				if (files[i].id === id) {
					return this.splice(i, 1)[0];
				}
			}
		},

		/**
		 * Removes part of the queue and returns the files removed. This will also trigger the FilesRemoved and QueueChanged events.
		 *
		 * @method splice
		 * @param {Number} start (Optional) Start index to remove from.
		 * @param {Number} length (Optional) Lengh of items to remove.
		 * @return {Array} Array of files that was removed.
		 */
		splice : function(start, length) {
			// Splice and trigger events
			var removed = files.splice(start === undef ? 0 : start, length === undef ? files.length : length);

			// if upload is in progress we need to stop it and restart after files are removed
			var restartRequired = false;
			if (this.state == plupload.STARTED) { // upload in progress
				plupload.each(removed, function(file) {
					if (file.status === plupload.UPLOADING) {
						restartRequired = true; // do not restart, unless file that is being removed is uploading
						return false;
					}
				});

				if (restartRequired) {
					this.stop();
				}
			}

			this.trigger("FilesRemoved", removed);

			// Dispose any resources allocated by those files
			plupload.each(removed, function(file) {
				file.destroy();
			});

			if (restartRequired) {
				this.start();
			}

			return removed;
		},

		/**
		Dispatches the specified event name and its arguments to all listeners.

		@method trigger
		@param {String} name Event name to fire.
		@param {Object..} Multiple arguments to pass along to the listener functions.
		*/

		// override the parent method to match Plupload-like event logic
		dispatchEvent: function(type) {
			var list, args, result;

			type = type.toLowerCase();

			list = this.hasEventListener(type);

			if (list) {
				// sort event list by priority
				list.sort(function(a, b) { return b.priority - a.priority; });

				// first argument should be current plupload.Uploader instance
				args = [].slice.call(arguments);
				args.shift();
				args.unshift(this);

				for (var i = 0; i < list.length; i++) {
					// Fire event, break chain if false is returned
					if (list[i].fn.apply(list[i].scope, args) === false) {
						return false;
					}
				}
			}
			return true;
		},

		/**
		Check whether uploader has any listeners to the specified event.

		@method hasEventListener
		@param {String} name Event name to check for.
		*/


		/**
		Adds an event listener by name.

		@method bind
		@param {String} name Event name to listen for.
		@param {function} fn Function to call ones the event gets fired.
		@param {Object} [scope] Optional scope to execute the specified function in.
		@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first
		*/
		bind: function(name, fn, scope, priority) {
			// adapt moxie EventTarget style to Plupload-like
			plupload.Uploader.prototype.bind.call(this, name, fn, priority, scope);
		},

		/**
		Removes the specified event listener.

		@method unbind
		@param {String} name Name of event to remove.
		@param {function} fn Function to remove from listener.
		*/

		/**
		Removes all event listeners.

		@method unbindAll
		*/


		/**
		 * Destroys Plupload instance and cleans after itself.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.trigger('Destroy');
			settings = total = null; // purge these exclusively
			this.unbindAll();
		}
	});
};

plupload.Uploader.prototype = o.core.EventTarget.instance;

/**
 * Constructs a new file instance.
 *
 * @class File
 * @constructor
 *
 * @param {Object} file Object containing file properties
 * @param {String} file.name Name of the file.
 * @param {Number} file.size File size.
 */
plupload.File = (function() {
	var filepool = {};

	function PluploadFile(file) {

		plupload.extend(this, {

			/**
			 * File id this is a globally unique id for the specific file.
			 *
			 * @property id
			 * @type String
			 */
			id: plupload.guid(),

			/**
			 * File name for example "myfile.gif".
			 *
			 * @property name
			 * @type String
			 */
			name: file.name || file.fileName,

			/**
			 * File type, `e.g image/jpeg`
			 *
			 * @property type
			 * @type String
			 */
			type: file.type || '',

			/**
			 * File size in bytes (may change after client-side manupilation).
			 *
			 * @property size
			 * @type Number
			 */
			size: file.size || file.fileSize,

			/**
			 * Original file size in bytes.
			 *
			 * @property origSize
			 * @type Number
			 */
			origSize: file.size || file.fileSize,

			/**
			 * Number of bytes uploaded of the files total size.
			 *
			 * @property loaded
			 * @type Number
			 */
			loaded: 0,

			/**
			 * Number of percentage uploaded of the file.
			 *
			 * @property percent
			 * @type Number
			 */
			percent: 0,

			/**
			 * Status constant matching the plupload states QUEUED, UPLOADING, FAILED, DONE.
			 *
			 * @property status
			 * @type Number
			 * @see plupload
			 */
			status: plupload.QUEUED,

			/**
			 * Date of last modification.
			 *
			 * @property lastModifiedDate
			 * @type {String}
			 */
			lastModifiedDate: file.lastModifiedDate || (new Date()).toLocaleString(), // Thu Aug 23 2012 19:40:00 GMT+0400 (GET)


			/**
			 * Set when file becomes plupload.DONE or plupload.FAILED. Is used to calculate proper plupload.QueueProgress.bytesPerSec.
			 * @private
			 * @property completeTimestamp
			 * @type {Number}
			 */
			completeTimestamp: 0,

			/**
			 * Returns native window.File object, when it's available.
			 *
			 * @method getNative
			 * @return {window.File} or null, if plupload.File is of different origin
			 */
			getNative: function() {
				var file = this.getSource().getSource();
				return plupload.inArray(plupload.typeOf(file), ['blob', 'file']) !== -1 ? file : null;
			},

			/**
			 * Returns mOxie.File - unified wrapper object that can be used across runtimes.
			 *
			 * @method getSource
			 * @return {mOxie.File} or null
			 */
			getSource: function() {
				if (!filepool[this.id]) {
					return null;
				}
				return filepool[this.id];
			},

			/**
			 * Destroys plupload.File object.
			 *
			 * @method destroy
			 */
			destroy: function() {
				var src = this.getSource();
				if (src) {
					src.destroy();
					delete filepool[this.id];
				}
			}
		});

		filepool[this.id] = file;
	}

	return PluploadFile;
}());


/**
 * Constructs a queue progress.
 *
 * @class QueueProgress
 * @constructor
 */
 plupload.QueueProgress = function() {
	var self = this; // Setup alias for self to reduce code size when it's compressed

	/**
	 * Total queue file size.
	 *
	 * @property size
	 * @type Number
	 */
	self.size = 0;

	/**
	 * Total bytes uploaded.
	 *
	 * @property loaded
	 * @type Number
	 */
	self.loaded = 0;

	/**
	 * Number of files uploaded.
	 *
	 * @property uploaded
	 * @type Number
	 */
	self.uploaded = 0;

	/**
	 * Number of files failed to upload.
	 *
	 * @property failed
	 * @type Number
	 */
	self.failed = 0;

	/**
	 * Number of files yet to be uploaded.
	 *
	 * @property queued
	 * @type Number
	 */
	self.queued = 0;

	/**
	 * Total percent of the uploaded bytes.
	 *
	 * @property percent
	 * @type Number
	 */
	self.percent = 0;

	/**
	 * Bytes uploaded per second.
	 *
	 * @property bytesPerSec
	 * @type Number
	 */
	self.bytesPerSec = 0;

	/**
	 * Resets the progress to its initial values.
	 *
	 * @method reset
	 */
	self.reset = function() {
		self.size = self.loaded = self.uploaded = self.failed = self.queued = self.percent = self.bytesPerSec = 0;
	};
};

exports.plupload = plupload;

}(this, moxie));

}));

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * qiniu-js-sdk v@VERSION
 *
 * Copyright 2015 by Qiniu
 * Released under GPL V2 License.
 *
 * GitHub: http://github.com/qiniu/js-sdk
 *
 * Date: @DATE
 */
//version 1.1.0
/*global plupload ,moxie*/
/*global ActiveXObject */
/*exported Qiniu */
/*exported QiniuJsSDK */

;(function (global) {


    /**
     * Creates new cookie or removes cookie with negative expiration
     * @param  key       The key or identifier for the store
     * @param  value     Contents of the store
     * @param  exp       Expiration - creation defaults to 30 days
     */
    function createCookie(key, value, exp) {
        var date = new Date();
        date.setTime(date.getTime() + (exp * 24 * 60 * 60 * 1000));
        var expires = "; expires=" + date.toGMTString();
        document.cookie = key + "=" + value + expires + "; path=/";
    }

    /**
     * Returns contents of cookie
     * @param  key       The key or identifier for the store
     */
    function readCookie(key) {
        var nameEQ = key + "=";
        var ca = document.cookie.split(';');
        for (var i = 0, max = ca.length; i < max; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    }

    // if current browser is not support localStorage
    // use cookie to make a polyfill
    if (!window.localStorage) {
        window.localStorage = {
            setItem: function (key, value) {
                createCookie(key, value, 30);
            },
            getItem: function (key) {
                return readCookie(key);
            },
            removeItem: function (key) {
                createCookie(key, '', -1);
            }
        };
    }

    function QiniuJsSDK() {
        var moxie = __webpack_require__(0);
        window.moxie = moxie;
        var plupload = __webpack_require__(1);
        window.plupload = plupload;


        var that = this;

        /**
         * detect IE version
         * if current browser is not IE
         *     it will return false
         * else
         *     it will return version of current IE browser
         * @return {Number|Boolean} IE version or false
         */
        this.detectIEVersion = function () {
            var v = 4,
                div = document.createElement('div'),
                all = div.getElementsByTagName('i');
            while (
                div.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->',
                    all[0]
                ) {
                v++;
            }
            return v > 4 ? v : false;
        };

        var logger = {
            MUTE: 0,
            FATA: 1,
            ERROR: 2,
            WARN: 3,
            INFO: 4,
            DEBUG: 5,
            TRACE: 6,
            level: 0
        };

        function log(type, args) {
            var header = "[qiniu-js-sdk][" + type + "]";
            var msg = header;
            for (var i = 0; i < args.length; i++) {
                if (typeof args[i] === "string") {
                    msg += " " + args[i];
                } else {
                    msg += " " + that.stringifyJSON(args[i]);
                }
            }
            if (that.detectIEVersion()) {
                // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9
                //var log = Function.prototype.bind.call(console.log, console);
                //log.apply(console, args);
                console.log(msg);
            } else {
                args.unshift(header);
                console.log.apply(console, args);
            }
            if (document.getElementById('qiniu-js-sdk-log')) {
                document.getElementById('qiniu-js-sdk-log').innerHTML += '<p>' + msg + '</p>';
            }
        }

        function makeLogFunc(code) {
            var func = code.toLowerCase();
            logger[func] = function () {
                // logger[func].history = logger[func].history || [];
                // logger[func].history.push(arguments);
                if (window.console && window.console.log && logger.level >= logger[code]) {
                    var args = Array.prototype.slice.call(arguments);
                    log(func, args);
                }
            };
        }

        for (var property in logger) {
            if (logger.hasOwnProperty(property) && (typeof logger[property]) === "number" && !logger.hasOwnProperty(property.toLowerCase())) {
                makeLogFunc(property);
            }
        }


        var qiniuUploadUrl;
        if (window.location.protocol === 'https:') {
            qiniuUploadUrl = 'https://upload.qiniup.com';
        } else {
            qiniuUploadUrl = 'http://upload.qiniup.com';
        }

        /**
         * qiniu upload urls
         * 'qiniuUploadUrls' is used to change target when current url is not avaliable
         * @type {Array}
         */
        var qiniuUploadUrls = [
            "http://upload.qiniup.com",
            "http://up.qiniup.com"
        ];

        var qiniuUpHosts = {
            "http": [
                "http://upload.qiniup.com",
                "http://up.qiniup.com"
            ],
            "https": [
                "https://upload.qiniup.com"
            ]
        };

        var changeUrlTimes = 0;

        /**
         * reset upload url
         * if current page protocal is https
         *     it will always return 'https://up.qbox.me'
         * else
         *     it will set 'qiniuUploadUrl' value with 'qiniuUploadUrls' looply
         */
        this.resetUploadUrl = function (num) {
            logger.debug('num: ' + num);
            if( num == 0) {
                logger.debug("use main uphost");
                var hosts = qiniuUpHosts.main;
                qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[0] : "http://" + hosts[0];
            } else {
                logger.debug("use backup uphost");
                var hosts = qiniuUpHosts.backup;
                if( num % 2 == 0) {
                    qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[1] : "http://" + hosts[1];
                } else {
                    qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[0] : "http://" + hosts[0];
                }
            }
            //qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[0] : "http://" + hosts[0];
            logger.debug('resetUploadUrl: ' + qiniuUploadUrl);
        };
        // this.resetUploadUrl();


        /**
         * is image
         * @param  {String}  url of a file
         * @return {Boolean} file is a image or not
         */
        this.isImage = function (url) {
            url = url.split(/[?#]/)[0];
            return (/\.(png|jpg|jpeg|gif|bmp)$/i).test(url);
        };

        /**
         * get file extension
         * @param  {String} filename
         * @return {String} file extension
         * @example
         *     input: test.txt
         *     output: txt
         */
        this.getFileExtension = function (filename) {
            var tempArr = filename.split(".");
            var ext;
            if (tempArr.length === 1 || (tempArr[0] === "" && tempArr.length === 2)) {
                ext = "";
            } else {
                ext = tempArr.pop().toLowerCase(); //get the extension and make it lower-case
            }
            return ext;
        };

        /**
         * encode string by utf8
         * @param  {String} string to encode
         * @return {String} encoded string
         */
        this.utf8_encode = function (argString) {
            // http://kevin.vanzonneveld.net
            // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: sowberry
            // +    tweaked by: Jack
            // +   bugfixed by: Onno Marsman
            // +   improved by: Yves Sucaet
            // +   bugfixed by: Onno Marsman
            // +   bugfixed by: Ulrich
            // +   bugfixed by: Rafal Kukawski
            // +   improved by: kirilloid
            // +   bugfixed by: kirilloid
            // *     example 1: this.utf8_encode('Kevin van Zonneveld');
            // *     returns 1: 'Kevin van Zonneveld'

            if (argString === null || typeof argString === 'undefined') {
                return '';
            }

            var string = (argString + ''); // .replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            var utftext = '',
                start, end, stringl = 0;

            start = end = 0;
            stringl = string.length;
            for (var n = 0; n < stringl; n++) {
                var c1 = string.charCodeAt(n);
                var enc = null;

                if (c1 < 128) {
                    end++;
                } else if (c1 > 127 && c1 < 2048) {
                    enc = String.fromCharCode(
                        (c1 >> 6) | 192, (c1 & 63) | 128
                    );
                } else if (c1 & 0xF800 ^ 0xD800 > 0) {
                    enc = String.fromCharCode(
                        (c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128
                    );
                } else { // surrogate pairs
                    if (c1 & 0xFC00 ^ 0xD800 > 0) {
                        throw new RangeError('Unmatched trail surrogate at ' + n);
                    }
                    var c2 = string.charCodeAt(++n);
                    if (c2 & 0xFC00 ^ 0xDC00 > 0) {
                        throw new RangeError('Unmatched lead surrogate at ' + (n - 1));
                    }
                    c1 = ((c1 & 0x3FF) << 10) + (c2 & 0x3FF) + 0x10000;
                    enc = String.fromCharCode(
                        (c1 >> 18) | 240, ((c1 >> 12) & 63) | 128, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128
                    );
                }
                if (enc !== null) {
                    if (end > start) {
                        utftext += string.slice(start, end);
                    }
                    utftext += enc;
                    start = end = n + 1;
                }
            }

            if (end > start) {
                utftext += string.slice(start, stringl);
            }

            return utftext;
        };

        this.base64_decode = function (data) {
            // http://kevin.vanzonneveld.net
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Thunder.m
            // +      input by: Aman Gupta
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Onno Marsman
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +      input by: Brett Zamir (http://brett-zamir.me)
            // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
            // *     returns 1: 'Kevin van Zonneveld'
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window['atob'] == 'function') {
            //    return atob(data);
            //}
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                dec = "",
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data += '';

            do { // unpack four hexets into three octets using index points in b64
                h1 = b64.indexOf(data.charAt(i++));
                h2 = b64.indexOf(data.charAt(i++));
                h3 = b64.indexOf(data.charAt(i++));
                h4 = b64.indexOf(data.charAt(i++));

                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                o1 = bits >> 16 & 0xff;
                o2 = bits >> 8 & 0xff;
                o3 = bits & 0xff;

                if (h3 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1);
                } else if (h4 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2);
                } else {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
                }
            } while (i < data.length);

            dec = tmp_arr.join('');

            return dec;
        };

        /**
         * encode data by base64
         * @param  {String} data to encode
         * @return {String} encoded data
         */
        this.base64_encode = function (data) {
            // http://kevin.vanzonneveld.net
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // -    depends on: this.utf8_encode
            // *     example 1: this.base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window['atob'] == 'function') {
            //    return atob(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data = this.utf8_encode(data + '');

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            switch (data.length % 3) {
                case 1:
                    enc = enc.slice(0, -2) + '==';
                    break;
                case 2:
                    enc = enc.slice(0, -1) + '=';
                    break;
            }

            return enc;
        };

        /**
         * encode string in url by base64
         * @param {String} string in url
         * @return {String} encoded string
         */
        this.URLSafeBase64Encode = function (v) {
            v = this.base64_encode(v);
            return v.replace(/\//g, '_').replace(/\+/g, '-');
        };

        this.URLSafeBase64Decode = function (v) {
            v = v.replace(/_/g, '/').replace(/-/g, '+');
            return this.base64_decode(v);
        };

        // TODO: use mOxie
        /**
         * craete object used to AJAX
         * @return {Object}
         */
        this.createAjax = function (argument) {
            var xmlhttp = {};
            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            } else {
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            }
            return xmlhttp;
        };

        // TODO: enhance IE compatibility
        /**
         * parse json string to javascript object
         * @param  {String} json string
         * @return {Object} object
         */
        this.parseJSON = function (data) {
            // Attempt to parse using the native JSON parser first
            if (window.JSON && window.JSON.parse) {
                return window.JSON.parse(data);
            }

            //var rx_one = /^[\],:{}\s]*$/,
            //    rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
            //    rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            //    rx_four = /(?:^|:|,)(?:\s*\[)+/g,
            var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

            //var json;

            var text = String(data);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

            // todo 使用一下判断,增加安全性
            //if (
            //    rx_one.test(
            //        text
            //            .replace(rx_two, '@')
            //            .replace(rx_three, ']')
            //            .replace(rx_four, '')
            //    )
            //) {
            //    return eval('(' + text + ')');
            //}

            return eval('(' + text + ')');
        };

        /**
         * parse javascript object to json string
         * @param  {Object} object
         * @return {String} json string
         */
        this.stringifyJSON = function (obj) {
            // Attempt to parse using the native JSON parser first
            if (window.JSON && window.JSON.stringify) {
                return window.JSON.stringify(obj);
            }
            switch (typeof (obj)) {
                case 'string':
                    return '"' + obj.replace(/(["\\])/g, '\\$1') + '"';
                case 'array':
                    return '[' + obj.map(that.stringifyJSON).join(',') + ']';
                case 'object':
                    if (obj instanceof Array) {
                        var strArr = [];
                        var len = obj.length;
                        for (var i = 0; i < len; i++) {
                            strArr.push(that.stringifyJSON(obj[i]));
                        }
                        return '[' + strArr.join(',') + ']';
                    } else if (obj === null) {
                        return 'null';
                    } else {
                        var string = [];
                        for (var property in obj) {
                            if (obj.hasOwnProperty(property)) {
                                string.push(that.stringifyJSON(property) + ':' + that.stringifyJSON(obj[property]));
                            }
                        }
                        return '{' + string.join(',') + '}';
                    }
                    break;
                case 'number':
                    return obj;
                case false:
                    return obj;
                case 'boolean':
                    return obj;
            }
        };

        /**
         * trim space beside text
         * @param  {String} untrimed string
         * @return {String} trimed string
         */
        this.trim = function (text) {
            return text === null ? "" : text.replace(/^\s+|\s+$/g, '');
        };

        /**
         * create a uploader by QiniuJsSDK
         * @param  {object} options to create a new uploader
         * @return {object} uploader
         */
        this.uploader = function (op) {

            /********** inner function define start **********/

                // according the different condition to reset chunk size
                // and the upload strategy according with the chunk size
                // when chunk size is zero will cause to direct upload
                // see the statement binded on 'BeforeUpload' event
            var reset_chunk_size = function () {
                    var ie = that.detectIEVersion();
                    var BLOCK_BITS, MAX_CHUNK_SIZE, chunk_size;
                    // case Safari 5、Windows 7、iOS 7 set isSpecialSafari to true
                    var isSpecialSafari = (moxie.core.utils.Env.browser === "Safari" && moxie.core.utils.Env.version <= 5 && moxie.core.utils.Env.os === "Windows" && moxie.core.utils.Env.osVersion === "7") || (moxie.core.utils.Env.browser === "Safari" && moxie.core.utils.Env.os === "iOS" && moxie.core.utils.Env.osVersion === "7");
                    // case IE 9-，chunk_size is not empty and flash is included in runtimes
                    // set op.chunk_size to zero
                    //if (ie && ie < 9 && op.chunk_size && op.runtimes.indexOf('flash') >= 0) {
                    if (ie && ie < 9 && op.chunk_size && op.runtimes.indexOf('flash') >= 0) {
                        //  link: http://www.plupload.com/docs/Frequently-Asked-Questions#when-to-use-chunking-and-when-not
                        //  when plupload chunk_size setting is't null ,it cause bug in ie8/9  which runs  flash runtimes (not support html5) .
                        op.chunk_size = 0;
                    } else if (isSpecialSafari) {
                        // win7 safari / iOS7 safari have bug when in chunk upload mode
                        // reset chunk_size to 0
                        // disable chunk in special version safari
                        op.chunk_size = 0;
                    } else {
                        BLOCK_BITS = 20;
                        MAX_CHUNK_SIZE = 4 << BLOCK_BITS; //4M

                        chunk_size = plupload.parseSize(op.chunk_size);
                        if (chunk_size > MAX_CHUNK_SIZE) {
                            op.chunk_size = MAX_CHUNK_SIZE;
                        }
                        // qiniu service  max_chunk_size is 4m
                        // reset chunk_size to max_chunk_size(4m) when chunk_size > 4m
                    }
                    // if op.chunk_size set 0 will be cause to direct upload
                };

            var getHosts = function (hosts) {
                var result = [];
                var uploadIndex = -1;
                for (var i = 0; i < hosts.length; i++) {
                    var host = hosts[i];
                    if (host.indexOf("upload") !== -1) {
                        uploadIndex = i;
                    }
                    if (host.indexOf('-H') === 0) {
                        result.push(host.split(' ')[2]);
                    } else {
                        result.push(host);
                    }
                }

                if (uploadIndex !== -1) {
                    //make upload domains first
                    var uploadDomain = result[uploadIndex];
                    result[uploadIndex] = result[0];
                    result[0] = uploadDomain;
                }
                return result;
            };

            var getPutPolicy = function (uptoken) {
                var segments = uptoken.split(":");
                var ak = segments[0];
                var putPolicy = that.parseJSON(that.URLSafeBase64Decode(segments[2]));
                putPolicy.ak = ak;
                if (putPolicy.scope.indexOf(":") >= 0) {
                    putPolicy.bucket = putPolicy.scope.split(":")[0];
                    putPolicy.key = putPolicy.scope.split(":")[1];
                } else {
                    putPolicy.bucket = putPolicy.scope;
                }
                return putPolicy;
            };

            var getUpHosts = function (uptoken) {
                var putPolicy = getPutPolicy(uptoken);
                var uphosts_url = window.location.protocol === 'https:' ? "https://" + "api.qiniu.com/v2/query?ak=" + putPolicy.ak + "&bucket=" + putPolicy.bucket : "http://" + "api.qiniu.com/v2/query?ak=" + putPolicy.ak + "&bucket=" + putPolicy.bucket;
                logger.debug("putPolicy: ", putPolicy);
                logger.debug("get uphosts from: ", uphosts_url);
                var ie = that.detectIEVersion();
                var ajax;
                if (ie && ie <= 9) {
                    ajax = new moxie.xhr.XMLHttpRequest();
                    moxie.core.utils.Env.swf_url = op.flash_swf_url;
                } else {
                    ajax = that.createAjax();
                }
                ajax.open('GET', uphosts_url, false);
                var onreadystatechange = function () {
                    logger.debug("ajax.readyState: ", ajax.readyState);
                    if (ajax.readyState === 4) {
                        logger.debug("ajax.status: ", ajax.status);
                        if (ajax.status < 400) {
                            var res = that.parseJSON(ajax.responseText);
                            qiniuUpHosts.main = res.up.acc.main;
                            qiniuUpHosts.backup = res.up.acc.backup;
                            logger.debug("get new uphosts: ", qiniuUpHosts);
                            that.resetUploadUrl(0);
                        } else {
                            logger.error("get uphosts error: ", ajax.responseText);
                        }
                    }
                };
                if (ie && ie <= 9) {
                    ajax.bind('readystatechange', onreadystatechange);
                } else {
                    ajax.onreadystatechange = onreadystatechange;
                }
                ajax.send();
                // ajax.send();
                // if (ajax.status < 400) {
                //     var res = that.parseJSON(ajax.responseText);
                //     qiniuUpHosts.http = getHosts(res.http.up);
                //     qiniuUpHosts.https = getHosts(res.https.up);
                //     logger.debug("get new uphosts: ", qiniuUpHosts);
                //     that.resetUploadUrl();
                // } else {
                //     logger.error("get uphosts error: ", ajax.responseText);
                // }
                return;
            };

            var getUptoken = function (file) {
                if (!that.token || (op.uptoken_url && that.tokenInfo.isExpired())) {
                    return getNewUpToken(file);
                } else {
                    return that.token;
                }
            };

            // getNewUptoken maybe called at Init Event or BeforeUpload Event
            // case Init Event, the file param of getUptken will be set a null value
            // if op.uptoken has value, set uptoken with op.uptoken
            // else if op.uptoken_url has value, set uptoken from op.uptoken_url
            // else if op.uptoken_func has value, set uptoken by result of op.uptoken_func
            var getNewUpToken = function (file) {
                if (op.uptoken) {
                    that.token = op.uptoken;
                } else if (op.uptoken_url) {
                    logger.debug("get uptoken from: ", that.uptoken_url);
                    // TODO: use mOxie
                    var ajax = that.createAjax();
                    ajax.open('GET', that.uptoken_url, false);
                    // ajax.setRequestHeader("If-Modified-Since", "0");
                    // ajax.onreadystatechange = function() {
                    //     if (ajax.readyState === 4 && ajax.status === 200) {
                    //         var res = that.parseJSON(ajax.responseText);
                    //         that.token = res.uptoken;
                    //     }
                    // };
                    ajax.send();
                    if (ajax.status === 200) {
                        var res = that.parseJSON(ajax.responseText);
                        that.token = res.uptoken;
                        var segments = that.token.split(":");
                        var putPolicy = that.parseJSON(that.URLSafeBase64Decode(segments[2]));
                        if (!that.tokenMap) {
                            that.tokenMap = {};
                        }
                        var getTimestamp = function (time) {
                            return Math.ceil(time.getTime() / 1000);
                        };
                        var serverTime = getTimestamp(new Date(ajax.getResponseHeader("date")));
                        var clientTime = getTimestamp(new Date());
                        that.tokenInfo = {
                            serverDelay: clientTime - serverTime,
                            deadline: putPolicy.deadline,
                            isExpired: function () {
                                var leftTime = this.deadline - getTimestamp(new Date()) + this.serverDelay;
                                return leftTime < 600;
                            }
                        };
                        logger.debug("get new uptoken: ", that.token);
                        logger.debug("get token info: ", that.tokenInfo);
                    } else {
                        logger.error("get uptoken error: ", ajax.responseText);
                    }
                } else if (op.uptoken_func) {
                    logger.debug("get uptoken from uptoken_func");
                    that.token = op.uptoken_func(file);
                    logger.debug("get new uptoken: ", that.token);
                } else {
                    logger.error("one of [uptoken, uptoken_url, uptoken_func] settings in options is required!");
                }
                if (that.token) {
                    getUpHosts(that.token);
                }
                return that.token;
            };

            // get file key according with the user passed options
            var getFileKey = function (up, file, func) {
                // WARNING
                // When you set the key in putPolicy by "scope": "bucket:key"
                // You should understand the risk of override a file in the bucket
                // So the code below that automatically get key from uptoken has been commented
                // var putPolicy = getPutPolicy(that.token)
                // if (putPolicy.key) {
                //     logger.debug("key is defined in putPolicy.scope: ", putPolicy.key)
                //     return putPolicy.key
                // }
                var key = '',
                    unique_names = false;
                if (!op.save_key) {
                    unique_names = up.getOption && up.getOption('unique_names');
                    unique_names = unique_names || (up.settings && up.settings.unique_names);
                    if (unique_names) {
                        var ext = that.getFileExtension(file.name);
                        key = ext ? file.id + '.' + ext : file.id;
                    } else if (typeof func === 'function') {
                        key = func(up, file);
                    } else {
                        key = file.name;
                    }
                }
                return key;
            };

            var getDomainFromUrl = function (url) {
                if (url && url.match) {
                    var groups = url.match(/^https?:\/\/([^:^/]*)/);
                    return groups ? groups[1] : "";
                }
                return "";
            };

            var getPortFromUrl = function (url) {
                if (url && url.match) {
                    var groups = url.match(/(^https?)/);
                    if (!groups) {
                        return "";
                    }
                    var type = groups[1];
                    groups = url.match(/^https?:\/\/([^:^/]*):(\d*)/);
                    if (groups) {
                        return groups[2];
                    } else if (type === "http") {
                        return "80";
                    } else {
                        return "443";
                    }
                }
                return "";
            };

            /********** inner function define end **********/

            if (op.log_level) {
                logger.level = op.log_level;
            }

            if (!op.domain) {
                throw 'domain setting in options is required!';
            }

            if (!op.browse_button) {
                throw 'browse_button setting in options is required!';
            }

            if (!op.uptoken && !op.uptoken_url && !op.uptoken_func) {
                throw 'one of [uptoken, uptoken_url, uptoken_func] settings in options is required!';
            }

            logger.debug("init uploader start");

            logger.debug("environment: ", moxie.core.utils.Env);

            logger.debug("userAgent: ", navigator.userAgent);

            var option = {};

            // hold the handler from user passed options
            var _Error_Handler = op.init && op.init.Error;
            var _FileUploaded_Handler = op.init && op.init.FileUploaded;

            // replace the handler for intercept
            op.init.Error = function () {};
            op.init.FileUploaded = function () {};

            that.uptoken_url = op.uptoken_url;
            that.token = '';
            that.key_handler = typeof op.init.Key === 'function' ? op.init.Key : '';
            this.domain = op.domain;
            // TODO: ctx is global in scope of a uploader instance
            // this maybe cause error
            var ctx = '';
            var speedCalInfo = {
                isResumeUpload: false,
                resumeFilesize: 0,
                startTime: '',
                currentTime: ''
            };

            reset_chunk_size();
            logger.debug("invoke reset_chunk_size()");
            logger.debug("op.chunk_size: ", op.chunk_size);

            var defaultSetting = {
                url: qiniuUploadUrl,
                multipart_params: {
                    token: ''
                }
            };
            var ie = that.detectIEVersion();
            // case IE 9-
            // add accept in multipart params
            if (ie && ie <= 9) {
                defaultSetting.multipart_params.accept = 'text/plain; charset=utf-8';
                logger.debug("add accept text/plain in multipart params");
            }

            // compose options with user passed options and default setting
            plupload.extend(option, op, defaultSetting);

            logger.debug("option: ", option);

            // create a new uploader with composed options
            var uploader = new plupload.Uploader(option);

            logger.debug("new plupload.Uploader(option)");

            // bind getNewUpToken to 'Init' event
            uploader.bind('Init', function (up, params) {
                logger.debug("Init event activated");
                // if op.get_new_uptoken is not true
                //      invoke getNewUptoken when uploader init
                // else
                //      getNewUptoken everytime before a new file upload
                if (!op.get_new_uptoken) {
                    getNewUpToken(null);
                }
                //getNewUpToken(null);
            });

            logger.debug("bind Init event");

            // bind 'FilesAdded' event
            // when file be added and auto_start has set value
            // uploader will auto start upload the file
            uploader.bind('FilesAdded', function (up, files) {
                logger.debug("FilesAdded event activated");
                var auto_start = up.getOption && up.getOption('auto_start');
                auto_start = auto_start || (up.settings && up.settings.auto_start);
                logger.debug("auto_start: ", auto_start);
                logger.debug("files: ", files);

                // detect is iOS
                var is_ios = function () {
                    if (moxie.core.utils.Env.OS.toLowerCase() === "ios") {
                        return true;
                    } else {
                        return false;
                    }
                };

                // if current env os is iOS change file name to [time].[ext]
                if (is_ios()) {
                    for (var i = 0; i < files.length; i++) {
                        var file = files[i];
                        var ext = that.getFileExtension(file.name);
                        file.name = file.id + "." + ext;
                    }
                }

                if (auto_start) {
                    setTimeout(function () {
                        up.start();
                        logger.debug("invoke up.start()");
                    }, 0);
                    // up.start();
                    // plupload.each(files, function(i, file) {
                    //     up.start();
                    //     logger.debug("invoke up.start()")
                    //     logger.debug("file: ", file);
                    // });
                }
                up.refresh(); // Reposition Flash/Silverlight
            });

            logger.debug("bind FilesAdded event");

            // bind 'BeforeUpload' event
            // intercept the process of upload
            // - prepare uptoken
            // - according the chunk size to make differnt upload strategy
            // - resume upload with the last breakpoint of file
            uploader.bind('BeforeUpload', function (up, file) {
                logger.debug("BeforeUpload event activated");
                file._start_at = new Date();
                // add a key named speed for file object
                file.speed = file.speed || 0;
                ctx = '';

                if (op.get_new_uptoken) {
                    getNewUpToken(file);
                }

                var directUpload = function (up, file, func) {
                    speedCalInfo.startTime = new Date().getTime();
                    var multipart_params_obj;
                    if (op.save_key) {
                        multipart_params_obj = {
                            'token': that.token
                        };
                    } else {
                        multipart_params_obj = {
                            'key': getFileKey(up, file, func),
                            'token': that.token
                        };
                    }
                    var ie = that.detectIEVersion();
                    // case IE 9-
                    // add accept in multipart params
                    if (ie && ie <= 9) {
                        multipart_params_obj.accept = 'text/plain; charset=utf-8';
                        logger.debug("add accept text/plain in multipart params");
                    }

                    logger.debug("directUpload multipart_params_obj: ", multipart_params_obj);

                    var x_vars = op.x_vars;
                    if (x_vars !== undefined && typeof x_vars === 'object') {
                        for (var x_key in x_vars) {
                            if (x_vars.hasOwnProperty(x_key)) {
                                if (typeof x_vars[x_key] === 'function') {
                                    multipart_params_obj['x:' + x_key] = x_vars[x_key](up, file);
                                } else if (typeof x_vars[x_key] !== 'object') {
                                    multipart_params_obj['x:' + x_key] = x_vars[x_key];
                                }
                            }
                        }
                    }

                    up.setOption({
                        'url': qiniuUploadUrl,
                        'multipart': true,
                        'chunk_size': is_android_weixin_or_qq() ? op.max_file_size : undefined,
                        'multipart_params': multipart_params_obj
                    });
                };

                // detect is weixin or qq inner browser
                var is_android_weixin_or_qq = function () {
                    var ua = navigator.userAgent.toLowerCase();
                    if ((ua.match(/MicroMessenger/i) || moxie.core.utils.Env.browser === "QQBrowser" || ua.match(/V1_AND_SQ/i)) && moxie.core.utils.Env.OS.toLowerCase() === "android") {
                        return true;
                    } else {
                        return false;
                    }
                };

                var chunk_size = up.getOption && up.getOption('chunk_size');
                chunk_size = chunk_size || (up.settings && up.settings.chunk_size);

                logger.debug("uploader.runtime: ", uploader.runtime);
                logger.debug("chunk_size: ", chunk_size);

                // TODO: flash support chunk upload
                if ((uploader.runtime === 'html5' || uploader.runtime === 'flash') && chunk_size) {
                    if (file.size < chunk_size || is_android_weixin_or_qq()) {
                        logger.debug("directUpload because file.size < chunk_size || is_android_weixin_or_qq()");
                        // direct upload if file size is less then the chunk size
                        directUpload(up, file, that.key_handler);
                    } else {
                        // TODO: need a polifill to make it work in IE 9-
                        // ISSUE: if file.name is existed in localStorage
                        // but not the same file maybe cause error
                        var localFileInfo = localStorage.getItem(file.name);
                        var blockSize = chunk_size;
                        if (localFileInfo) {
                            // TODO: although only the html5 runtime will enter this statement
                            // but need uniform way to make convertion between string and json
                            localFileInfo = that.parseJSON(localFileInfo);
                            var now = (new Date()).getTime();
                            var before = localFileInfo.time || 0;
                            var aDay = 24 * 60 * 60 * 1000; //  milliseconds of one day
                            // if the last upload time is within one day
                            //      will upload continuously follow the last breakpoint
                            // else
                            //      will reupload entire file
                            if (now - before < aDay) {

                                if (localFileInfo.percent !== 100) {
                                    if (file.size === localFileInfo.total) {
                                        // TODO: if file.name and file.size is the same
                                        // but not the same file will cause error
                                        file.percent = localFileInfo.percent;
                                        file.loaded = localFileInfo.offset;
                                        ctx = localFileInfo.ctx;

                                        // set speed info
                                        speedCalInfo.isResumeUpload = true;
                                        speedCalInfo.resumeFilesize = localFileInfo.offset;

                                        // set block size
                                        if (localFileInfo.offset + blockSize > file.size) {
                                            blockSize = file.size - localFileInfo.offset;
                                        }
                                    } else {
                                        // remove file info when file.size is conflict with file info
                                        localStorage.removeItem(file.name);
                                    }

                                } else {
                                    // remove file info when upload percent is 100%
                                    // avoid 499 bug
                                    localStorage.removeItem(file.name);
                                }
                            } else {
                                // remove file info when last upload time is over one day
                                localStorage.removeItem(file.name);
                            }
                        }
                        speedCalInfo.startTime = new Date().getTime();
                        var multipart_params_obj = {};
                        var ie = that.detectIEVersion();
                        // case IE 9-
                        // add accept in multipart params
                        if (ie && ie <= 9) {
                            multipart_params_obj.accept = 'text/plain; charset=utf-8';
                            logger.debug("add accept text/plain in multipart params");
                        }
                        // TODO: to support bput
                        // http://developer.qiniu.com/docs/v6/api/reference/up/bput.html
                        up.setOption({
                            'url': qiniuUploadUrl + '/mkblk/' + blockSize,
                            'multipart': false,
                            'chunk_size': chunk_size,
                            'required_features': "chunks",
                            'headers': {
                                'Authorization': 'UpToken ' + getUptoken(file)
                            },
                            'multipart_params': multipart_params_obj
                        });
                    }
                } else {
                    logger.debug("directUpload because uploader.runtime !== 'html5' || uploader.runtime !== 'flash' || !chunk_size");
                    // direct upload if runtime is not html5
                    directUpload(up, file, that.key_handler);
                }
            });

            logger.debug("bind BeforeUpload event");

            // bind 'UploadProgress' event
            // calculate upload speed
            uploader.bind('UploadProgress', function (up, file) {
                logger.trace("UploadProgress event activated");
                speedCalInfo.currentTime = new Date().getTime();
                var timeUsed = speedCalInfo.currentTime - speedCalInfo.startTime; // ms
                var fileUploaded = file.loaded || 0;
                if (speedCalInfo.isResumeUpload) {
                    fileUploaded = file.loaded - speedCalInfo.resumeFilesize;
                }
                file.speed = (fileUploaded / timeUsed * 1000).toFixed(0) || 0; // unit: byte/s
            });

            logger.debug("bind UploadProgress event");

            // bind 'ChunkUploaded' event
            // store the chunk upload info and set next chunk upload url
            uploader.bind('ChunkUploaded', function (up, file, info) {
                logger.debug("ChunkUploaded event activated");
                logger.debug("ChunkUploaded file: ", file);
                logger.debug("ChunkUploaded info: ", info);
                var res = that.parseJSON(info.response);
                logger.debug("ChunkUploaded res: ", res);
                // ctx should look like '[chunk01_ctx],[chunk02_ctx],[chunk03_ctx],...'
                ctx = ctx ? ctx + ',' + res.ctx : res.ctx;
                var leftSize = info.total - info.offset;
                var chunk_size = up.getOption && up.getOption('chunk_size');
                chunk_size = chunk_size || (up.settings && up.settings.chunk_size);
                if (leftSize < chunk_size) {
                    up.setOption({
                        'url': qiniuUploadUrl + '/mkblk/' + leftSize
                    });
                    logger.debug("up.setOption url: ", qiniuUploadUrl + '/mkblk/' + leftSize);
                }
                up.setOption({
                    'headers': {
                        'Authorization': 'UpToken ' + getUptoken(file)
                    }
                });
                localStorage.setItem(file.name, that.stringifyJSON({
                    ctx: ctx,
                    percent: file.percent,
                    total: info.total,
                    offset: info.offset,
                    time: (new Date()).getTime()
                }));
            });

            logger.debug("bind ChunkUploaded event");

            var retries = op.max_retries;

            // if error is unkown switch upload url and retry
            var unknow_error_retry = function (file) {
                if (retries-- > 0) {
                    setTimeout(function () {
                        that.resetUploadUrl(retries);
                        file.status = plupload.QUEUED;
                        uploader.stop();
                        uploader.start();
                    }, 0);
                    return true;
                } else {
                    retries = qiniuUploadUrls.length;
                    return false;
                }
            };

            // bind 'Error' event
            // check the err.code and return the errTip
            uploader.bind('Error', (function (_Error_Handler) {
                return function (up, err) {
                    logger.error("Error event activated");
                    logger.error("err: ", err);
                    var nowTime = new Date();
                    var errTip = '';
                    var file = err.file;
                    if (file) {
                        switch (err.code) {
                            case plupload.FAILED:
                                errTip = '上传失败。请稍后再试。';
                                break;
                            case plupload.FILE_SIZE_ERROR:
                                var max_file_size = up.getOption && up.getOption('max_file_size');
                                max_file_size = max_file_size || (up.settings && up.settings.max_file_size);
                                errTip = '浏览器最大可上传' + max_file_size + '。更大文件请使用命令行工具。';
                                break;
                            case plupload.FILE_EXTENSION_ERROR:
                                errTip = '文件验证失败。请稍后重试。';
                                break;
                            case plupload.HTTP_ERROR:
                                if (err.response === '') {
                                    // Fix parseJSON error ,when http error is like net::ERR_ADDRESS_UNREACHABLE
                                    errTip = err.message || '未知网络错误。';
                                    if (!unknow_error_retry(file)) {
                                        return;
                                    }
                                    break;
                                }
                                var errorObj = that.parseJSON(err.response);
                                var errorText = errorObj.error;
                                switch (err.status) {
                                    case 400:
                                        errTip = "请求报文格式错误。";
                                        break;
                                    case 401:
                                        errTip = "客户端认证授权失败。请重试或提交反馈。";
                                        break;
                                    case 405:
                                        errTip = "客户端请求错误。请重试或提交反馈。";
                                        break;
                                    case 579:
                                        errTip = "资源上传成功，但回调失败。";
                                        break;
                                    case 599:
                                        errTip = "网络连接异常。请重试或提交反馈。";
                                        if (!unknow_error_retry(file)) {
                                            return;
                                        }
                                        break;
                                    case 614:
                                        errTip = "文件已存在。";
                                        try {
                                            errorObj = that.parseJSON(errorObj.error);
                                            errorText = errorObj.error || 'file exists';
                                        } catch (e) {
                                            errorText = errorObj.error || 'file exists';
                                        }
                                        break;
                                    case 631:
                                        errTip = "指定空间不存在。";
                                        break;
                                    case 701:
                                        errTip = "上传数据块校验出错。请重试或提交反馈。";
                                        break;
                                    default:
                                        errTip = "未知错误。";
                                        if (!unknow_error_retry(file)) {
                                            return;
                                        }
                                        break;
                                }
                                errTip = errTip + '(' + err.status + '：' + errorText + ')';
                                break;
                            case plupload.SECURITY_ERROR:
                                errTip = '安全配置错误。请联系网站管理员。';
                                break;
                            case plupload.GENERIC_ERROR:
                                errTip = '上传失败。请稍后再试。';
                                break;
                            case plupload.IO_ERROR:
                                errTip = '上传失败。请稍后再试。';
                                break;
                            case plupload.INIT_ERROR:
                                errTip = '网站配置错误。请联系网站管理员。';
                                uploader.destroy();
                                break;
                            default:
                                errTip = err.message + err.details;
                                if (!unknow_error_retry(file)) {
                                    return;
                                }
                                break;
                        }
                        if (_Error_Handler) {
                            _Error_Handler(up, err, errTip);
                        }
                    }
                    up.refresh(); // Reposition Flash/Silverlight
                };
            })(_Error_Handler));

            logger.debug("bind Error event");

            // bind 'FileUploaded' event
            // intercept the complete of upload
            // - get downtoken from downtoken_url if bucket is private
            // - invoke mkfile api to compose chunks if upload strategy is chunk upload
            uploader.bind('FileUploaded', (function (_FileUploaded_Handler) {
                return function (up, file, info) {
                    logger.debug("FileUploaded event activated");
                    logger.debug("FileUploaded file: ", file);
                    logger.debug("FileUploaded info: ", info);
                    var nowTime = new Date();
                    var last_step = function (up, file, info) {
                        logger.debug("FileUploaded last step:", info);
                        if (op.downtoken_url) {
                            // if op.dowontoken_url is not empty
                            // need get downtoken before invoke the _FileUploaded_Handler
                            var ajax_downtoken = that.createAjax();
                            ajax_downtoken.open('POST', op.downtoken_url, true);
                            ajax_downtoken.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
                            ajax_downtoken.onreadystatechange = function () {
                                if (ajax_downtoken.readyState === 4) {
                                    if (ajax_downtoken.status === 200) {
                                        var res_downtoken;
                                        try {
                                            res_downtoken = that.parseJSON(ajax_downtoken.responseText);
                                        } catch (e) {
                                            throw ('invalid json format');
                                        }
                                        var info_extended = {};
                                        plupload.extend(info_extended, that.parseJSON(info.response), res_downtoken);
                                        info.response = that.stringifyJSON(info_extended);
                                        if (_FileUploaded_Handler) {
                                            _FileUploaded_Handler(up, file, info);
                                        }
                                    } else {
                                        uploader.trigger('Error', {
                                            status: ajax_downtoken.status,
                                            response: ajax_downtoken.responseText,
                                            file: file,
                                            code: plupload.HTTP_ERROR
                                        });
                                    }
                                }
                            };
                            ajax_downtoken.send('key=' + that.parseJSON(info.response).key + '&domain=' + op.domain);
                        } else if (_FileUploaded_Handler) {
                            _FileUploaded_Handler(up, file, info);
                        }
                    };

                    var res = that.parseJSON(info.response);
                    ctx = ctx ? ctx : res.ctx;
                    // if ctx is not empty
                    //      that means the upload strategy is chunk upload
                    //      before the invoke the last_step
                    //      we need request the mkfile to compose all uploaded chunks
                    // else
                    //      invoke the last_step
                    logger.debug("ctx: ", ctx);
                    if (ctx) {
                        var key = '';
                        logger.debug("save_key: ", op.save_key);
                        if (!op.save_key) {
                            key = getFileKey(up, file, that.key_handler);
                            key = key ? '/key/' + that.URLSafeBase64Encode(key) : '';
                        }

                        var fname = '/fname/' + that.URLSafeBase64Encode(file.name);

                        logger.debug("op.x_vars: ", op.x_vars);
                        var x_vars = op.x_vars,
                            x_val = '',
                            x_vars_url = '';
                        if (x_vars !== undefined && typeof x_vars === 'object') {
                            for (var x_key in x_vars) {
                                if (x_vars.hasOwnProperty(x_key)) {
                                    if (typeof x_vars[x_key] === 'function') {
                                        x_val = that.URLSafeBase64Encode(x_vars[x_key](up, file));
                                    } else if (typeof x_vars[x_key] !== 'object') {
                                        x_val = that.URLSafeBase64Encode(x_vars[x_key]);
                                    }
                                    x_vars_url += '/x:' + x_key + '/' + x_val;
                                }
                            }
                        }

                        var url = qiniuUploadUrl + '/mkfile/' + file.size + key + fname + x_vars_url;

                        var ie = that.detectIEVersion();
                        var ajax;
                        if (ie && ie <= 9) {
                            ajax = new moxie.xhr.XMLHttpRequest();
                            moxie.core.utils.Env.swf_url = op.flash_swf_url;
                        } else {
                            ajax = that.createAjax();
                        }
                        ajax.open('POST', url, true);
                        ajax.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
                        console.log('uptoken:'+that.token);
                        ajax.setRequestHeader('Authorization', 'UpToken ' + that.token);
                        var onreadystatechange = function () {
                            logger.debug("ajax.readyState: ", ajax.readyState);
                            if (ajax.readyState === 4) {
                                localStorage.removeItem(file.name);
                                var ajaxInfo;
                                if (ajax.status === 200) {
                                    ajaxInfo = {
                                        status: ajax.status,
                                        response: ajax.responseText,
                                        responseHeaders: ajax.getAllResponseHeaders(),
                                    };
                                    logger.debug("mkfile is success: ", ajaxInfo);
                                    last_step(up, file, ajaxInfo);
                                } else {
                                    ajaxInfo = {
                                        status: ajax.status,
                                        response: ajax.responseText,
                                        file: file,
                                        code: -200,
                                        responseHeaders: ajax.getAllResponseHeaders()
                                    };
                                    logger.debug("mkfile is error: ", ajaxInfo);
                                    uploader.trigger('Error', ajaxInfo);
                                }
                            }
                        };
                        if (ie && ie <= 9) {
                            ajax.bind('readystatechange', onreadystatechange);
                        } else {
                            ajax.onreadystatechange = onreadystatechange;
                        }
                        ajax.send(ctx);
                        logger.debug("mkfile: ", url);
                    } else {
                        last_step(up, file, info);
                    }
                };
            })(_FileUploaded_Handler));

            logger.debug("bind FileUploaded event");

            // init uploader
            uploader.init();
            logger.debug("invoke uploader.init()");

            logger.debug("init uploader end");

            return uploader;
        };

        /**
         * get url by key
         * @param  {String} key of file
         * @return {String} url of file
         */
        this.getUrl = function (key) {
            if (!key) {
                return false;
            }
            key = encodeURI(key);
            var domain = this.domain;
            if (domain.slice(domain.length - 1) !== '/') {
                domain = domain + '/';
            }
            return domain + key;
        };
    }

    var Qiniu = new QiniuJsSDK();

    global.Qiniu = Qiniu;
    global.QiniuJsSDK = QiniuJsSDK;
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = QiniuJsSDK;
    } else if (true) {
        // register as 'qiniu-js', consistent with npm package name
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return QiniuJsSDK;
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        global.QiniuJsSDK = QiniuJsSDK;
    }
})(window);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNGViMmViMjNmOWU4NjYwZjA3MWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdXBsb2FkL21veGllLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVwbG9hZC9wbHVwbG9hZC5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Fpbml1LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQSxpR0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNI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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSxrRkFBa0YsaUJBQWlCOztBQUVuRztBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEIsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQixTQUFTLFFBQVE7QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZCxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7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Q0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUF1QjtBQUN2QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQzs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FB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O0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscUNBQXFDO0FBQ3JDOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHVCQUF1Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHLEc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsdUU7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLGlHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEcsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQztBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtDQUErQyxpQkFBaUI7QUFDaEUsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtB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Q2pCLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFBQTtBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJxaW5pdS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDRlYjJlYjIzZjllODY2MGYwNzFmIiwiO3ZhciBNWElfREVCVUcgPSB0cnVlO1xuLyoqXG4gKiBtT3hpZSAtIG11bHRpLXJ1bnRpbWUgRmlsZSBBUEkgJiBYTUxIdHRwUmVxdWVzdCBMMiBQb2x5ZmlsbFxuICogdjEuNS4zXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICpcbiAqIERhdGU6IDIwMTctMDItMDJcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHZhciBleHRyYWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHt9O1xuXHRcdGZhY3RvcnkuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBjdHgubW94aWU7XG5cdH07XG5cdFxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoXCJtb3hpZVwiLCBbXSwgZXh0cmFjdCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXh0cmFjdCgpO1xuXHR9IGVsc2Uge1xuXHRcdGdsb2JhbC5tb3hpZSA9IGV4dHJhY3QoKTtcblx0fVxufSh0aGlzIHx8IHdpbmRvdywgZnVuY3Rpb24oKSB7XG4vKipcbiAqIENvbXBpbGVkIGlubGluZSB2ZXJzaW9uLiAoTGlicmFyeSBtb2RlKVxuICovXG5cbi8qanNoaW50IHNtYXJ0dGFiczp0cnVlLCB1bmRlZjp0cnVlLCBsYXRlZGVmOnRydWUsIGN1cmx5OnRydWUsIGJpdHdpc2U6dHJ1ZSwgY2FtZWxjYXNlOnRydWUgKi9cbi8qZ2xvYmFscyAkY29kZSAqL1xuXG4oZnVuY3Rpb24oZXhwb3J0cywgdW5kZWZpbmVkKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBtb2R1bGVzID0ge307XG5cblx0ZnVuY3Rpb24gcmVxdWlyZShpZHMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIG1vZHVsZSwgZGVmcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdG1vZHVsZSA9IG1vZHVsZXNbaWRzW2ldXSB8fCByZXNvbHZlKGlkc1tpXSk7XG5cdFx0XHRpZiAoIW1vZHVsZSkge1xuXHRcdFx0XHR0aHJvdyAnbW9kdWxlIGRlZmluaXRpb24gZGVwZW5kZWN5IG5vdCBmb3VuZDogJyArIGlkc1tpXTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmcy5wdXNoKG1vZHVsZSk7XG5cdFx0fVxuXG5cdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgZGVmcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWZpbmUoaWQsIGRlcGVuZGVuY2llcywgZGVmaW5pdGlvbikge1xuXHRcdGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyAnaW52YWxpZCBtb2R1bGUgZGVmaW5pdGlvbiwgbW9kdWxlIGlkIG11c3QgYmUgZGVmaW5lZCBhbmQgYmUgYSBzdHJpbmcnO1xuXHRcdH1cblxuXHRcdGlmIChkZXBlbmRlbmNpZXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgJ2ludmFsaWQgbW9kdWxlIGRlZmluaXRpb24sIGRlcGVuZGVuY2llcyBtdXN0IGJlIHNwZWNpZmllZCc7XG5cdFx0fVxuXG5cdFx0aWYgKGRlZmluaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgJ2ludmFsaWQgbW9kdWxlIGRlZmluaXRpb24sIGRlZmluaXRpb24gZnVuY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQnO1xuXHRcdH1cblxuXHRcdHJlcXVpcmUoZGVwZW5kZW5jaWVzLCBmdW5jdGlvbigpIHtcblx0XHRcdG1vZHVsZXNbaWRdID0gZGVmaW5pdGlvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVmaW5lZChpZCkge1xuXHRcdHJldHVybiAhIW1vZHVsZXNbaWRdO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZShpZCkge1xuXHRcdHZhciB0YXJnZXQgPSBleHBvcnRzO1xuXHRcdHZhciBmcmFnbWVudHMgPSBpZC5zcGxpdCgvWy5cXC9dLyk7XG5cblx0XHRmb3IgKHZhciBmaSA9IDA7IGZpIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytmaSkge1xuXHRcdFx0aWYgKCF0YXJnZXRbZnJhZ21lbnRzW2ZpXV0pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQgPSB0YXJnZXRbZnJhZ21lbnRzW2ZpXV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9zZShpZHMpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHRhcmdldCA9IGV4cG9ydHM7XG5cdFx0XHR2YXIgaWQgPSBpZHNbaV07XG5cdFx0XHR2YXIgZnJhZ21lbnRzID0gaWQuc3BsaXQoL1suXFwvXS8pO1xuXG5cdFx0XHRmb3IgKHZhciBmaSA9IDA7IGZpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7ICsrZmkpIHtcblx0XHRcdFx0aWYgKHRhcmdldFtmcmFnbWVudHNbZmldXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2ZyYWdtZW50c1tmaV1dID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXQgPSB0YXJnZXRbZnJhZ21lbnRzW2ZpXV07XG5cdFx0XHR9XG5cblx0XHRcdHRhcmdldFtmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdXSA9IG1vZHVsZXNbaWRdO1xuXHRcdH1cblx0fVxuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL3V0aWxzL0Jhc2ljLmpzXG5cbi8qKlxuICogQmFzaWMuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvY29yZS91dGlscy9CYXNpY1xuQHB1YmxpY1xuQHN0YXRpY1xuKi9cbmRlZmluZSgnbW94aWUvY29yZS91dGlscy9CYXNpYycsIFtdLCBmdW5jdGlvbigpIHtcblx0LyoqXG5cdEdldHMgdGhlIHRydWUgdHlwZSBvZiB0aGUgYnVpbHQtaW4gb2JqZWN0IChiZXR0ZXIgdmVyc2lvbiBvZiB0eXBlb2YpLlxuXHRAYXV0aG9yIEFuZ3VzIENyb2xsIChodHRwOi8vamF2YXNjcmlwdHdlYmxvZy53b3JkcHJlc3MuY29tLylcblxuXHRAbWV0aG9kIHR5cGVPZlxuXHRAZm9yIFV0aWxzXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG8gT2JqZWN0IHRvIGNoZWNrLlxuXHRAcmV0dXJuIHtTdHJpbmd9IE9iamVjdCBbW0NsYXNzXV1cblx0Ki9cblx0ZnVuY3Rpb24gdHlwZU9mKG8pIHtcblx0XHR2YXIgdW5kZWY7XG5cblx0XHRpZiAobyA9PT0gdW5kZWYpIHtcblx0XHRcdHJldHVybiAndW5kZWZpbmVkJztcblx0XHR9IGVsc2UgaWYgKG8gPT09IG51bGwpIHtcblx0XHRcdHJldHVybiAnbnVsbCc7XG5cdFx0fSBlbHNlIGlmIChvLm5vZGVUeXBlKSB7XG5cdFx0XHRyZXR1cm4gJ25vZGUnO1xuXHRcdH1cblxuXHRcdC8vIHRoZSBzbmlwcGV0IGJlbG93IGlzIGF3ZXNvbWUsIGhvd2V2ZXIgaXQgZmFpbHMgdG8gZGV0ZWN0IG51bGwsIHVuZGVmaW5lZCBhbmQgYXJndW1lbnRzIHR5cGVzIGluIElFIGx0ZSA4XG5cdFx0cmV0dXJuICh7fSkudG9TdHJpbmcuY2FsbChvKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0udG9Mb3dlckNhc2UoKTtcblx0fVxuXG5cdC8qKlxuXHRFeHRlbmRzIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHdpdGggYW5vdGhlciBvYmplY3QocykuXG5cblx0QG1ldGhvZCBleHRlbmRcblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0byBleHRlbmQuXG5cdEBwYXJhbSB7T2JqZWN0fSBbb2JqXSogTXVsdGlwbGUgb2JqZWN0cyB0byBleHRlbmQgd2l0aC5cblx0QHJldHVybiB7T2JqZWN0fSBTYW1lIGFzIHRhcmdldCwgdGhlIGV4dGVuZGVkIG9iamVjdC5cblx0Ki9cblx0ZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdHJldHVybiBtZXJnZShmYWxzZSwgZmFsc2UsIGFyZ3VtZW50cyk7XG5cdH1cblxuXG5cdC8qKlxuXHRFeHRlbmRzIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHdpdGggYW5vdGhlciBvYmplY3QocyksIGJ1dCBvbmx5IGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgaW4gdGhlIHRhcmdldC5cblxuXHRAbWV0aG9kIGV4dGVuZElmXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgdG8gZXh0ZW5kLlxuXHRAcGFyYW0ge09iamVjdH0gW29ial0qIE11bHRpcGxlIG9iamVjdHMgdG8gZXh0ZW5kIHdpdGguXG5cdEByZXR1cm4ge09iamVjdH0gU2FtZSBhcyB0YXJnZXQsIHRoZSBleHRlbmRlZCBvYmplY3QuXG5cdCovXG5cdGZ1bmN0aW9uIGV4dGVuZElmKCkge1xuXHRcdHJldHVybiBtZXJnZSh0cnVlLCBmYWxzZSwgYXJndW1lbnRzKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZXh0ZW5kSW1tdXRhYmxlKCkge1xuXHRcdHJldHVybiBtZXJnZShmYWxzZSwgdHJ1ZSwgYXJndW1lbnRzKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZXh0ZW5kSW1tdXRhYmxlSWYoKSB7XG5cdFx0cmV0dXJuIG1lcmdlKHRydWUsIHRydWUsIGFyZ3VtZW50cyk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iaikge1xuXHRcdHN3aXRjaCAodHlwZU9mKG9iaikpIHtcblx0XHRcdGNhc2UgJ2FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG5cblx0XHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRcdHJldHVybiBleHRlbmQoe30sIG9iaik7XG5cdFx0fVxuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIG1lcmdlKHN0cmljdCwgaW1tdXRhYmxlLCBhcmdzKSB7XG5cdFx0dmFyIHVuZGVmO1xuXHRcdHZhciB0YXJnZXQgPSBhcmdzWzBdO1xuXG5cdFx0ZWFjaChhcmdzLCBmdW5jdGlvbihhcmcsIGkpIHtcblx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRlYWNoKGFyZywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHRcdHZhciBpc0NvbXBsZXggPSBpbkFycmF5KHR5cGVPZih2YWx1ZSksIFsnYXJyYXknLCAnb2JqZWN0J10pICE9PSAtMTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWYgfHwgc3RyaWN0ICYmIHRhcmdldFtrZXldID09PSB1bmRlZikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGlzQ29tcGxleCAmJiBpbW11dGFibGUpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gc2hhbGxvd0NvcHkodmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlT2YodGFyZ2V0W2tleV0pID09PSB0eXBlT2YodmFsdWUpICYmIGlzQ29tcGxleCkge1xuXHRcdFx0XHRcdFx0bWVyZ2Uoc3RyaWN0LCBpbW11dGFibGUsIFt0YXJnZXRba2V5XSwgdmFsdWVdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cblx0LyoqXG5cdEEgd2F5IHRvIGluaGVyaXQgb25lIGBjbGFzc2AgZnJvbSBhbm90aGVyIGluIGEgY29uc2lzc3RlbnQgd2F5IChtb3JlIG9yIGxlc3MpXG5cblx0QG1ldGhvZCBpbmhlcml0XG5cdEBzdGF0aWNcblx0QHNpbmNlID4xLjQuMVxuXHRAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuXHRAcGFyYW0ge0Z1bmN0aW9ufSBwYXJlbnRcblx0QHJldHVybiB7RnVuY3Rpb259IFByZXBhcmVkIGNvbnN0cnVjdG9yXG5cdCovXG5cdGZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIHBhcmVudCkge1xuXHRcdC8vIGNvcHkgb3ZlciBhbGwgcGFyZW50IHByb3BlcnRpZXNcblx0XHRmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG5cdFx0XHRpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnQsIGtleSkpIHtcblx0XHRcdFx0Y2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGdpdmUgY2hpbGQgYGNsYXNzYCBhIHBsYWNlIHRvIGRlZmluZSBpdHMgb3duIG1ldGhvZHNcblx0XHRmdW5jdGlvbiBjdG9yKCkge1xuXHRcdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuXHRcdH1cblx0XHRjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG5cdFx0Y2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcblxuXHRcdC8vIGtlZXAgYSB3YXkgdG8gcmVmZXJlbmNlIHBhcmVudCBtZXRob2RzXG5cdFx0Y2hpbGQuX19wYXJlbnRfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9XG5cblxuXHQvKipcblx0RXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0gaW4gYXJyYXkvb2JqZWN0LiBJZiB5b3UgcmV0dXJuIGZhbHNlIGluIHRoZVxuXHRjYWxsYmFjayBpdCB3aWxsIGJyZWFrIHRoZSBsb29wLlxuXG5cdEBtZXRob2QgZWFjaFxuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIGl0ZXJhdGUuXG5cdEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggaXRlbS5cblx0Ki9cblx0ZnVuY3Rpb24gZWFjaChvYmosIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGxlbmd0aCwga2V5LCBpLCB1bmRlZjtcblxuXHRcdGlmIChvYmopIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdGxlbmd0aCA9IHVuZGVmO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGVuZ3RoID09PSB1bmRlZiB8fCB0eXBlb2YobGVuZ3RoKSAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0Ly8gTG9vcCBvYmplY3QgaXRlbXNcblx0XHRcdFx0Zm9yIChrZXkgaW4gb2JqKSB7XG5cdFx0XHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2sob2JqW2tleV0sIGtleSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIExvb3AgYXJyYXkgaXRlbXNcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGNhbGxiYWNrKG9ialtpXSwgaSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdENoZWNrcyBpZiBvYmplY3QgaXMgZW1wdHkuXG5cblx0QG1ldGhvZCBpc0VtcHR5T2JqXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG8gT2JqZWN0IHRvIGNoZWNrLlxuXHRAcmV0dXJuIHtCb29sZWFufVxuXHQqL1xuXHRmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuXHRcdHZhciBwcm9wO1xuXG5cdFx0aWYgKCFvYmogfHwgdHlwZU9mKG9iaikgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmb3IgKHByb3AgaW4gb2JqKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0UmVjaWV2ZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMgKHVzdWFsbHkgYXN5bmMpIHRvIGNhbGwgaW4gc2VxdWVuY2UsIGVhY2ggIGZ1bmN0aW9uXG5cdHJlY2VpdmVzIGEgY2FsbGJhY2sgYXMgZmlyc3QgYXJndW1lbnQgdGhhdCBpdCBzaG91bGQgY2FsbCwgd2hlbiBpdCBjb21wbGV0ZXMuIEZpbmFsbHksXG5cdGFmdGVyIGV2ZXJ5dGhpbmcgaXMgY29tcGxldGUsIG1haW4gY2FsbGJhY2sgaXMgY2FsbGVkLiBQYXNzaW5nIHRydXRoeSB2YWx1ZSB0byB0aGVcblx0Y2FsbGJhY2sgYXMgYSBmaXJzdCBhcmd1bWVudCB3aWxsIGludGVycnVwdCB0aGUgc2VxdWVuY2UgYW5kIGludm9rZSBtYWluIGNhbGxiYWNrXG5cdGltbWVkaWF0ZWx5LlxuXG5cdEBtZXRob2QgaW5TZXJpZXNcblx0QHN0YXRpY1xuXHRAcGFyYW0ge0FycmF5fSBxdWV1ZSBBcnJheSBvZiBmdW5jdGlvbnMgdG8gY2FsbCBpbiBzZXF1ZW5jZVxuXHRAcGFyYW0ge0Z1bmN0aW9ufSBjYiBNYWluIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIGluIHRoZSBlbmQsIG9yIGluIGNhc2Ugb2YgZXJyb3Jcblx0Ki9cblx0ZnVuY3Rpb24gaW5TZXJpZXMocXVldWUsIGNiKSB7XG5cdFx0dmFyIGkgPSAwLCBsZW5ndGggPSBxdWV1ZS5sZW5ndGg7XG5cblx0XHRpZiAodHlwZU9mKGNiKSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2IgPSBmdW5jdGlvbigpIHt9O1xuXHRcdH1cblxuXHRcdGlmICghcXVldWUgfHwgIXF1ZXVlLmxlbmd0aCkge1xuXHRcdFx0Y2IoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYWxsTmV4dChpKSB7XG5cdFx0XHRpZiAodHlwZU9mKHF1ZXVlW2ldKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRxdWV1ZVtpXShmdW5jdGlvbihlcnJvcikge1xuXHRcdFx0XHRcdC8qanNoaW50IGV4cHI6dHJ1ZSAqL1xuXHRcdFx0XHRcdCsraSA8IGxlbmd0aCAmJiAhZXJyb3IgPyBjYWxsTmV4dChpKSA6IGNiKGVycm9yKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhbGxOZXh0KGkpO1xuXHR9XG5cblxuXHQvKipcblx0UmVjaWV2ZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMgKHVzdWFsbHkgYXN5bmMpIHRvIGNhbGwgaW4gcGFyYWxsZWwsIGVhY2ggIGZ1bmN0aW9uXG5cdHJlY2VpdmVzIGEgY2FsbGJhY2sgYXMgZmlyc3QgYXJndW1lbnQgdGhhdCBpdCBzaG91bGQgY2FsbCwgd2hlbiBpdCBjb21wbGV0ZXMuIEFmdGVyXG5cdGV2ZXJ5dGhpbmcgaXMgY29tcGxldGUsIG1haW4gY2FsbGJhY2sgaXMgY2FsbGVkLiBQYXNzaW5nIHRydXRoeSB2YWx1ZSB0byB0aGVcblx0Y2FsbGJhY2sgYXMgYSBmaXJzdCBhcmd1bWVudCB3aWxsIGludGVycnVwdCB0aGUgcHJvY2VzcyBhbmQgaW52b2tlIG1haW4gY2FsbGJhY2tcblx0aW1tZWRpYXRlbHkuXG5cblx0QG1ldGhvZCBpblBhcmFsbGVsXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtBcnJheX0gcXVldWUgQXJyYXkgb2YgZnVuY3Rpb25zIHRvIGNhbGwgaW4gc2VxdWVuY2Vcblx0QHBhcmFtIHtGdW5jdGlvbn0gY2IgTWFpbiBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBpbiB0aGUgZW5kLCBvciBpbiBjYXNlIG9mIGVycm9cblx0Ki9cblx0ZnVuY3Rpb24gaW5QYXJhbGxlbChxdWV1ZSwgY2IpIHtcblx0XHR2YXIgY291bnQgPSAwLCBudW0gPSBxdWV1ZS5sZW5ndGgsIGNiQXJncyA9IG5ldyBBcnJheShudW0pO1xuXG5cdFx0ZWFjaChxdWV1ZSwgZnVuY3Rpb24oZm4sIGkpIHtcblx0XHRcdGZuKGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdHJldHVybiBjYihlcnJvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdFx0YXJncy5zaGlmdCgpOyAvLyBzdHJpcCBlcnJvciAtIHVuZGVmaW5lZCBvciBub3RcblxuXHRcdFx0XHRjYkFyZ3NbaV0gPSBhcmdzO1xuXHRcdFx0XHRjb3VudCsrO1xuXG5cdFx0XHRcdGlmIChjb3VudCA9PT0gbnVtKSB7XG5cdFx0XHRcdFx0Y2JBcmdzLnVuc2hpZnQobnVsbCk7XG5cdFx0XHRcdFx0Y2IuYXBwbHkodGhpcywgY2JBcmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXG5cdC8qKlxuXHRGaW5kIGFuIGVsZW1lbnQgaW4gYXJyYXkgYW5kIHJldHVybiBpdCdzIGluZGV4IGlmIHByZXNlbnQsIG90aGVyd2lzZSByZXR1cm4gLTEuXG5cblx0QG1ldGhvZCBpbkFycmF5XG5cdEBzdGF0aWNcblx0QHBhcmFtIHtNaXhlZH0gbmVlZGxlIEVsZW1lbnQgdG8gZmluZFxuXHRAcGFyYW0ge0FycmF5fSBhcnJheVxuXHRAcmV0dXJuIHtJbnR9IEluZGV4IG9mIHRoZSBlbGVtZW50LCBvciAtMSBpZiBub3QgZm91bmRcblx0Ki9cblx0ZnVuY3Rpb24gaW5BcnJheShuZWVkbGUsIGFycmF5KSB7XG5cdFx0aWYgKGFycmF5KSB7XG5cdFx0XHRpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0XHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJyYXksIG5lZWRsZSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyYXlbaV0gPT09IG5lZWRsZSkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fVxuXG5cblx0LyoqXG5cdFJldHVybnMgZWxlbWVudHMgb2YgZmlyc3QgYXJyYXkgaWYgdGhleSBhcmUgbm90IHByZXNlbnQgaW4gc2Vjb25kLiBBbmQgZmFsc2UgLSBvdGhlcndpc2UuXG5cblx0QHByaXZhdGVcblx0QG1ldGhvZCBhcnJheURpZmZcblx0QHBhcmFtIHtBcnJheX0gbmVlZGxlc1xuXHRAcGFyYW0ge0FycmF5fSBhcnJheVxuXHRAcmV0dXJuIHtBcnJheXxCb29sZWFufVxuXHQqL1xuXHRmdW5jdGlvbiBhcnJheURpZmYobmVlZGxlcywgYXJyYXkpIHtcblx0XHR2YXIgZGlmZiA9IFtdO1xuXG5cdFx0aWYgKHR5cGVPZihuZWVkbGVzKSAhPT0gJ2FycmF5Jykge1xuXHRcdFx0bmVlZGxlcyA9IFtuZWVkbGVzXTtcblx0XHR9XG5cblx0XHRpZiAodHlwZU9mKGFycmF5KSAhPT0gJ2FycmF5Jykge1xuXHRcdFx0YXJyYXkgPSBbYXJyYXldO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgaW4gbmVlZGxlcykge1xuXHRcdFx0aWYgKGluQXJyYXkobmVlZGxlc1tpXSwgYXJyYXkpID09PSAtMSkge1xuXHRcdFx0XHRkaWZmLnB1c2gobmVlZGxlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkaWZmLmxlbmd0aCA/IGRpZmYgOiBmYWxzZTtcblx0fVxuXG5cblx0LyoqXG5cdEZpbmQgaW50ZXJzZWN0aW9uIG9mIHR3byBhcnJheXMuXG5cblx0QHByaXZhdGVcblx0QG1ldGhvZCBhcnJheUludGVyc2VjdFxuXHRAcGFyYW0ge0FycmF5fSBhcnJheTFcblx0QHBhcmFtIHtBcnJheX0gYXJyYXkyXG5cdEByZXR1cm4ge0FycmF5fSBJbnRlcnNlY3Rpb24gb2YgdHdvIGFycmF5cyBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmVcblx0Ki9cblx0ZnVuY3Rpb24gYXJyYXlJbnRlcnNlY3QoYXJyYXkxLCBhcnJheTIpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0ZWFjaChhcnJheTEsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmIChpbkFycmF5KGl0ZW0sIGFycmF5MikgIT09IC0xKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiByZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcblx0fVxuXG5cblx0LyoqXG5cdEZvcmNlcyBhbnl0aGluZyBpbnRvIGFuIGFycmF5LlxuXG5cdEBtZXRob2QgdG9BcnJheVxuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHdpdGggbGVuZ3RoIGZpZWxkLlxuXHRAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGl0ZW1zLlxuXHQqL1xuXHRmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuXHRcdHZhciBpLCBhcnIgPSBbXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0XHRcdGFycltpXSA9IG9ialtpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblxuXHQvKipcblx0R2VuZXJhdGVzIGFuIHVuaXF1ZSBJRC4gVGhlIG9ubHkgd2F5IGEgdXNlciB3b3VsZCBiZSBhYmxlIHRvIGdldCB0aGUgc2FtZSBJRCBpcyBpZiB0aGUgdHdvIHBlcnNvbnNcblx0YXQgdGhlIHNhbWUgZXhhY3QgbWlsbGlzZWNvbmQgbWFuYWdlIHRvIGdldCB0aGUgc2FtZSA1IHJhbmRvbSBudW1iZXJzIGJldHdlZW4gMC02NTUzNTsgaXQgYWxzbyB1c2VzXG5cdGEgY291bnRlciBzbyBlYWNoIElEIGlzIGd1YXJhbnRlZWQgdG8gYmUgdW5pcXVlIGZvciB0aGUgZ2l2ZW4gcGFnZS4gSXQgaXMgbW9yZSBwcm9iYWJsZSBmb3IgdGhlIGVhcnRoXG5cdHRvIGJlIGhpdCB3aXRoIGFuIGFzdGVyb2lkLlxuXG5cdEBtZXRob2QgZ3VpZFxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggdG8gcHJlcGVuZCAoYnkgZGVmYXVsdCAnbycgd2lsbCBiZSBwcmVwZW5kZWQpLlxuXHRAbWV0aG9kIGd1aWRcblx0QHJldHVybiB7U3RyaW5nfSBWaXJ0dWFsbHkgdW5pcXVlIGlkLlxuXHQqL1xuXHR2YXIgZ3VpZCA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24ocHJlZml4KSB7XG5cdFx0XHR2YXIgZ3VpZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKDMyKSwgaTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuXHRcdFx0XHRndWlkICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY1NTM1KS50b1N0cmluZygzMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAocHJlZml4IHx8ICdvXycpICsgZ3VpZCArIChjb3VudGVyKyspLnRvU3RyaW5nKDMyKTtcblx0XHR9O1xuXHR9KCkpO1xuXG5cblx0LyoqXG5cdFRyaW1zIHdoaXRlIHNwYWNlcyBhcm91bmQgdGhlIHN0cmluZ1xuXG5cdEBtZXRob2QgdHJpbVxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0QHJldHVybiB7U3RyaW5nfVxuXHQqL1xuXHRmdW5jdGlvbiB0cmltKHN0cikge1xuXHRcdGlmICghc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH1cblx0XHRyZXR1cm4gU3RyaW5nLnByb3RvdHlwZS50cmltID8gU3RyaW5nLnByb3RvdHlwZS50cmltLmNhbGwoc3RyKSA6IHN0ci50b1N0cmluZygpLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xuXHR9XG5cblxuXHQvKipcblx0UGFyc2VzIHRoZSBzcGVjaWZpZWQgc2l6ZSBzdHJpbmcgaW50byBhIGJ5dGUgdmFsdWUuIEZvciBleGFtcGxlIDEwa2IgYmVjb21lcyAxMDI0MC5cblxuXHRAbWV0aG9kIHBhcnNlU2l6ZVN0clxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nL051bWJlcn0gc2l6ZSBTdHJpbmcgdG8gcGFyc2Ugb3IgbnVtYmVyIHRvIGp1c3QgcGFzcyB0aHJvdWdoLlxuXHRAcmV0dXJuIHtOdW1iZXJ9IFNpemUgaW4gYnl0ZXMuXG5cdCovXG5cdGZ1bmN0aW9uIHBhcnNlU2l6ZVN0cihzaXplKSB7XG5cdFx0aWYgKHR5cGVvZihzaXplKSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBzaXplO1xuXHRcdH1cblxuXHRcdHZhciBtdWxzID0ge1xuXHRcdFx0XHR0OiAxMDk5NTExNjI3Nzc2LFxuXHRcdFx0XHRnOiAxMDczNzQxODI0LFxuXHRcdFx0XHRtOiAxMDQ4NTc2LFxuXHRcdFx0XHRrOiAxMDI0XG5cdFx0XHR9LFxuXHRcdFx0bXVsO1xuXG5cdFx0c2l6ZSA9IC9eKFswLTlcXC5dKykoW3RtZ2tdPykkLy5leGVjKHNpemUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXjAtOVxcLnRta2ddL2csICcnKSk7XG5cdFx0bXVsID0gc2l6ZVsyXTtcblx0XHRzaXplID0gK3NpemVbMV07XG5cblx0XHRpZiAobXVscy5oYXNPd25Qcm9wZXJ0eShtdWwpKSB7XG5cdFx0XHRzaXplICo9IG11bHNbbXVsXTtcblx0XHR9XG5cdFx0cmV0dXJuIE1hdGguZmxvb3Ioc2l6ZSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBQc2V1ZG8gc3ByaW50ZiBpbXBsZW1lbnRhdGlvbiAtIHNpbXBsZSB3YXkgdG8gcmVwbGFjZSB0b2tlbnMgd2l0aCBzcGVjaWZpZWQgdmFsdWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB3aXRoIHRva2Vuc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyB3aXRoIHJlcGxhY2VkIHRva2Vuc1xuXHQgKi9cblx0ZnVuY3Rpb24gc3ByaW50ZihzdHIpIHtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvJVthLXpdL2csIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHZhbHVlID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0cmV0dXJuIHR5cGVPZih2YWx1ZSkgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAnJztcblx0XHR9KTtcblx0fVxuXG5cblxuXHRmdW5jdGlvbiBkZWxheShjYiwgdGltZW91dCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2IuY2FsbChzZWxmKTtcblx0XHR9LCB0aW1lb3V0IHx8IDEpO1xuXHR9XG5cblxuXHRyZXR1cm4ge1xuXHRcdGd1aWQ6IGd1aWQsXG5cdFx0dHlwZU9mOiB0eXBlT2YsXG5cdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0ZXh0ZW5kSWY6IGV4dGVuZElmLFxuXHRcdGV4dGVuZEltbXV0YWJsZTogZXh0ZW5kSW1tdXRhYmxlLFxuXHRcdGV4dGVuZEltbXV0YWJsZUlmOiBleHRlbmRJbW11dGFibGVJZixcblx0XHRpbmhlcml0OiBpbmhlcml0LFxuXHRcdGVhY2g6IGVhY2gsXG5cdFx0aXNFbXB0eU9iajogaXNFbXB0eU9iaixcblx0XHRpblNlcmllczogaW5TZXJpZXMsXG5cdFx0aW5QYXJhbGxlbDogaW5QYXJhbGxlbCxcblx0XHRpbkFycmF5OiBpbkFycmF5LFxuXHRcdGFycmF5RGlmZjogYXJyYXlEaWZmLFxuXHRcdGFycmF5SW50ZXJzZWN0OiBhcnJheUludGVyc2VjdCxcblx0XHR0b0FycmF5OiB0b0FycmF5LFxuXHRcdHRyaW06IHRyaW0sXG5cdFx0c3ByaW50Zjogc3ByaW50Zixcblx0XHRwYXJzZVNpemVTdHI6IHBhcnNlU2l6ZVN0cixcblx0XHRkZWxheTogZGVsYXlcblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL3V0aWxzL0VuY29kZS5qc1xuXG4vKipcbiAqIEVuY29kZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL2NvcmUvdXRpbHMvRW5jb2RlJywgW10sIGZ1bmN0aW9uKCkge1xuXG5cdC8qKlxuXHRAY2xhc3MgbW94aWUvY29yZS91dGlscy9FbmNvZGVcblx0Ki9cblxuXHQvKipcblx0RW5jb2RlIHN0cmluZyB3aXRoIFVURi04XG5cblx0QG1ldGhvZCB1dGY4X2VuY29kZVxuXHRAZm9yIFV0aWxzXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gZW5jb2RlXG5cdEByZXR1cm4ge1N0cmluZ30gVVRGLTggZW5jb2RlZCBzdHJpbmdcblx0Ki9cblx0dmFyIHV0ZjhfZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcblx0fTtcblx0XG5cdC8qKlxuXHREZWNvZGUgVVRGLTggZW5jb2RlZCBzdHJpbmdcblxuXHRAbWV0aG9kIHV0ZjhfZGVjb2RlXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXG5cdEByZXR1cm4ge1N0cmluZ30gRGVjb2RlZCBzdHJpbmdcblx0Ki9cblx0dmFyIHV0ZjhfZGVjb2RlID0gZnVuY3Rpb24oc3RyX2RhdGEpIHtcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHJfZGF0YSkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdERlY29kZSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcgKHVzZXMgYnJvd3NlcidzIGRlZmF1bHQgbWV0aG9kIGlmIGF2YWlsYWJsZSksXG5cdGZyb206IGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20va3Z6L3BocGpzL21hc3Rlci9mdW5jdGlvbnMvdXJsL2Jhc2U2NF9kZWNvZGUuanNcblxuXHRAbWV0aG9kIGF0b2Jcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gZGF0YSBTdHJpbmcgdG8gZGVjb2RlXG5cdEByZXR1cm4ge1N0cmluZ30gRGVjb2RlZCBzdHJpbmdcblx0Ki9cblx0dmFyIGF0b2IgPSBmdW5jdGlvbihkYXRhLCB1dGY4KSB7XG5cdFx0aWYgKHR5cGVvZih3aW5kb3cuYXRvYikgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiB1dGY4ID8gdXRmOF9kZWNvZGUod2luZG93LmF0b2IoZGF0YSkpIDogd2luZG93LmF0b2IoZGF0YSk7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcblx0XHQvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcblx0XHQvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuXHRcdC8vICsgICAgICBpbnB1dCBieTogQW1hbiBHdXB0YVxuXHRcdC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG5cdFx0Ly8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cblx0XHQvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcblx0XHQvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuXHRcdC8vICsgICAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcblx0XHQvLyArICAgYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuXHRcdC8vICogICAgIGV4YW1wbGUgMTogYmFzZTY0X2RlY29kZSgnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PScpO1xuXHRcdC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG5cdFx0Ly8gbW96aWxsYSBoYXMgdGhpcyBuYXRpdmVcblx0XHQvLyAtIGJ1dCBicmVha3MgaW4gMi4wLjAuMTIhXG5cdFx0Ly9pZiAodHlwZW9mIHRoaXMud2luZG93LmF0b2IgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vICAgIHJldHVybiBhdG9iKGRhdGEpO1xuXHRcdC8vfVxuXHRcdHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cdFx0dmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcblx0XHRcdGFjID0gMCxcblx0XHRcdGRlYyA9IFwiXCIsXG5cdFx0XHR0bXBfYXJyID0gW107XG5cblx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGRhdGEgKz0gJyc7XG5cblx0XHRkbyB7IC8vIHVucGFjayBmb3VyIGhleGV0cyBpbnRvIHRocmVlIG9jdGV0cyB1c2luZyBpbmRleCBwb2ludHMgaW4gYjY0XG5cdFx0XHRoMSA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXHRcdFx0aDIgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcblx0XHRcdGgzID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cdFx0XHRoNCA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXG5cdFx0XHRiaXRzID0gaDEgPDwgMTggfCBoMiA8PCAxMiB8IGgzIDw8IDYgfCBoNDtcblxuXHRcdFx0bzEgPSBiaXRzID4+IDE2ICYgMHhmZjtcblx0XHRcdG8yID0gYml0cyA+PiA4ICYgMHhmZjtcblx0XHRcdG8zID0gYml0cyAmIDB4ZmY7XG5cblx0XHRcdGlmIChoMyA9PSA2NCkge1xuXHRcdFx0XHR0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSk7XG5cdFx0XHR9IGVsc2UgaWYgKGg0ID09IDY0KSB7XG5cdFx0XHRcdHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIsIG8zKTtcblx0XHRcdH1cblx0XHR9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG5cdFx0ZGVjID0gdG1wX2Fyci5qb2luKCcnKTtcblxuXHRcdHJldHVybiB1dGY4ID8gdXRmOF9kZWNvZGUoZGVjKSA6IGRlYztcblx0fTtcblx0XG5cdC8qKlxuXHRCYXNlNjQgZW5jb2RlIHN0cmluZyAodXNlcyBicm93c2VyJ3MgZGVmYXVsdCBtZXRob2QgaWYgYXZhaWxhYmxlKSxcblx0ZnJvbTogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9rdnovcGhwanMvbWFzdGVyL2Z1bmN0aW9ucy91cmwvYmFzZTY0X2VuY29kZS5qc1xuXG5cdEBtZXRob2QgYnRvYVxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSBkYXRhIFN0cmluZyB0byBlbmNvZGVcblx0QHJldHVybiB7U3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcblx0Ki9cblx0dmFyIGJ0b2EgPSBmdW5jdGlvbihkYXRhLCB1dGY4KSB7XG5cdFx0aWYgKHV0ZjgpIHtcblx0XHRcdGRhdGEgPSB1dGY4X2VuY29kZShkYXRhKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mKHdpbmRvdy5idG9hKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIHdpbmRvdy5idG9hKGRhdGEpO1xuXHRcdH1cblxuXHRcdC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG5cdFx0Ly8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG5cdFx0Ly8gKyAgIGltcHJvdmVkIGJ5OiBCYXlyb24gR3VldmFyYVxuXHRcdC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG5cdFx0Ly8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcblx0XHQvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcblx0XHQvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuXHRcdC8vICsgICBpbXByb3ZlZCBieTogUmFmYcWCIEt1a2F3c2tpIChodHRwOi8va3VrYXdza2kucGwpXG5cdFx0Ly8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZW5jb2RlKCdLZXZpbiB2YW4gWm9ubmV2ZWxkJyk7XG5cdFx0Ly8gKiAgICAgcmV0dXJucyAxOiAnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PSdcblx0XHQvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuXHRcdC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcblx0XHR2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuXHRcdHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG5cdFx0XHRhYyA9IDAsXG5cdFx0XHRlbmMgPSBcIlwiLFxuXHRcdFx0dG1wX2FyciA9IFtdO1xuXG5cdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcblx0XHRcdG8xID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cdFx0XHRvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXHRcdFx0bzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuXHRcdFx0Yml0cyA9IG8xIDw8IDE2IHwgbzIgPDwgOCB8IG8zO1xuXG5cdFx0XHRoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuXHRcdFx0aDIgPSBiaXRzID4+IDEyICYgMHgzZjtcblx0XHRcdGgzID0gYml0cyA+PiA2ICYgMHgzZjtcblx0XHRcdGg0ID0gYml0cyAmIDB4M2Y7XG5cblx0XHRcdC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG5cdFx0XHR0bXBfYXJyW2FjKytdID0gYjY0LmNoYXJBdChoMSkgKyBiNjQuY2hhckF0KGgyKSArIGI2NC5jaGFyQXQoaDMpICsgYjY0LmNoYXJBdChoNCk7XG5cdFx0fSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuXHRcdGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cblx0XHR2YXIgciA9IGRhdGEubGVuZ3RoICUgMztcblxuXHRcdHJldHVybiAociA/IGVuYy5zbGljZSgwLCByIC0gMykgOiBlbmMpICsgJz09PScuc2xpY2UociB8fCAzKTtcblx0fTtcblxuXG5cdHJldHVybiB7XG5cdFx0dXRmOF9lbmNvZGU6IHV0ZjhfZW5jb2RlLFxuXHRcdHV0ZjhfZGVjb2RlOiB1dGY4X2RlY29kZSxcblx0XHRhdG9iOiBhdG9iLFxuXHRcdGJ0b2E6IGJ0b2Fcblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL3V0aWxzL0Vudi5qc1xuXG4vKipcbiAqIEVudi5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoXCJtb3hpZS9jb3JlL3V0aWxzL0VudlwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiXG5dLCBmdW5jdGlvbihCYXNpYykge1xuXHRcblx0LyoqXG5cdCAqIFVBUGFyc2VyLmpzIHYwLjcuN1xuXHQgKiBMaWdodHdlaWdodCBKYXZhU2NyaXB0LWJhc2VkIFVzZXItQWdlbnQgc3RyaW5nIHBhcnNlclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vZmFpc2FsbWFuL3VhLXBhcnNlci1qc1xuXHQgKlxuXHQgKiBDb3B5cmlnaHQgwqkgMjAxMi0yMDE1IEZhaXNhbCBTYWxtYW4gPGZ5emxtYW5AZ21haWwuY29tPlxuXHQgKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIEdQTHYyICYgTUlUXG5cdCAqL1xuXHR2YXIgVUFQYXJzZXIgPSAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXG5cdCAgICAvLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gQ29uc3RhbnRzXG5cdCAgICAvLy8vLy8vLy8vLy8vXG5cblxuXHQgICAgdmFyIEVNUFRZICAgICAgID0gJycsXG5cdCAgICAgICAgVU5LTk9XTiAgICAgPSAnPycsXG5cdCAgICAgICAgRlVOQ19UWVBFICAgPSAnZnVuY3Rpb24nLFxuXHQgICAgICAgIFVOREVGX1RZUEUgID0gJ3VuZGVmaW5lZCcsXG5cdCAgICAgICAgT0JKX1RZUEUgICAgPSAnb2JqZWN0Jyxcblx0ICAgICAgICBNQUpPUiAgICAgICA9ICdtYWpvcicsXG5cdCAgICAgICAgTU9ERUwgICAgICAgPSAnbW9kZWwnLFxuXHQgICAgICAgIE5BTUUgICAgICAgID0gJ25hbWUnLFxuXHQgICAgICAgIFRZUEUgICAgICAgID0gJ3R5cGUnLFxuXHQgICAgICAgIFZFTkRPUiAgICAgID0gJ3ZlbmRvcicsXG5cdCAgICAgICAgVkVSU0lPTiAgICAgPSAndmVyc2lvbicsXG5cdCAgICAgICAgQVJDSElURUNUVVJFPSAnYXJjaGl0ZWN0dXJlJyxcblx0ICAgICAgICBDT05TT0xFICAgICA9ICdjb25zb2xlJyxcblx0ICAgICAgICBNT0JJTEUgICAgICA9ICdtb2JpbGUnLFxuXHQgICAgICAgIFRBQkxFVCAgICAgID0gJ3RhYmxldCc7XG5cblxuXHQgICAgLy8vLy8vLy8vLy9cblx0ICAgIC8vIEhlbHBlclxuXHQgICAgLy8vLy8vLy8vL1xuXG5cblx0ICAgIHZhciB1dGlsID0ge1xuXHQgICAgICAgIGhhcyA6IGZ1bmN0aW9uIChzdHIxLCBzdHIyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzdHIyLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIxLnRvTG93ZXJDYXNlKCkpICE9PSAtMTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGxvd2VyaXplIDogZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAvLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIE1hcCBoZWxwZXJcblx0ICAgIC8vLy8vLy8vLy8vLy8vXG5cblxuXHQgICAgdmFyIG1hcHBlciA9IHtcblxuXHQgICAgICAgIHJneCA6IGZ1bmN0aW9uICgpIHtcblxuXHQgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIHJlZ2V4ZXMgbWFwc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByZXN1bHQsIGkgPSAwLCBqLCBrLCBwLCBxLCBtYXRjaGVzLCBtYXRjaCwgYXJncyA9IGFyZ3VtZW50czsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gYXJnc1tpXSwgICAgICAgLy8gZXZlbiBzZXF1ZW5jZSAoMCwyLDQsLi4pXG5cdCAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBhcmdzW2kgKyAxXTsgICAvLyBvZGQgc2VxdWVuY2UgKDEsMyw1LC4uKVxuXG5cdCAgICAgICAgICAgICAgICAvLyBjb25zdHJ1Y3Qgb2JqZWN0IGJhcmVib25lc1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihyZXN1bHQpID09PSBVTkRFRl9UWVBFKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChwIGluIHByb3BzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcm9wc1twXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihxKSA9PT0gT0JKX1RZUEUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxWzBdXSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxXSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gdHJ5IG1hdGNoaW5nIHVhc3RyaW5nIHdpdGggcmVnZXhlc1xuXHQgICAgICAgICAgICAgICAgZm9yIChqID0gayA9IDA7IGogPCByZWdleC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSByZWdleFtqXS5leGVjKHRoaXMuZ2V0VUEoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEhbWF0Y2hlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1srK2tdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgYWN0dWFsbHkgYXJyYXlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocSkgPT09IE9CSl9UWVBFICYmIHEubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA9PSAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocVsxXSkgPT0gRlVOQ19UWVBFKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gbW9kaWZpZWQgbWF0Y2hcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxWzBdXSA9IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gZ2l2ZW4gdmFsdWUsIGlnbm9yZSByZWdleCBtYXRjaFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gcVsxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocS5sZW5ndGggPT0gMykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocVsxXSkgPT09IEZVTkNfVFlQRSAmJiAhKHFbMV0uZXhlYyAmJiBxWzFdLnRlc3QpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGZ1bmN0aW9uICh1c3VhbGx5IHN0cmluZyBtYXBwZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcVswXV0gPSBtYXRjaCA/IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCwgcVsyXSkgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYW5pdGl6ZSBtYXRjaCB1c2luZyBnaXZlbiByZWdleFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gbWF0Y2ggPyBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcVswXV0gPSBtYXRjaCA/IHFbM10uY2FsbCh0aGlzLCBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pKSA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxXSA9IG1hdGNoID8gbWF0Y2ggOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZighIW1hdGNoZXMpIGJyZWFrOyAvLyBicmVhayB0aGUgbG9vcCBpbW1lZGlhdGVseSBpZiBtYXRjaCBmb3VuZFxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHN0ciA6IGZ1bmN0aW9uIChzdHIsIG1hcCkge1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhcnJheVxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihtYXBbaV0pID09PSBPQkpfVFlQRSAmJiBtYXBbaV0ubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwW2ldLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmhhcyhtYXBbaV1bal0sIHN0cikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQgOiBpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmhhcyhtYXBbaV0sIHN0cikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGkgPT09IFVOS05PV04pID8gdW5kZWZpbmVkIDogaTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gc3RyO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblxuXHQgICAgLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBTdHJpbmcgbWFwXG5cdCAgICAvLy8vLy8vLy8vLy8vL1xuXG5cblx0ICAgIHZhciBtYXBzID0ge1xuXG5cdCAgICAgICAgYnJvd3NlciA6IHtcblx0ICAgICAgICAgICAgb2xkc2FmYXJpIDoge1xuXHQgICAgICAgICAgICAgICAgbWFqb3IgOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgJzEnIDogWycvOCcsICcvMScsICcvMyddLFxuXHQgICAgICAgICAgICAgICAgICAgICcyJyA6ICcvNCcsXG5cdCAgICAgICAgICAgICAgICAgICAgJz8nIDogJy8nXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgdmVyc2lvbiA6IHtcblx0ICAgICAgICAgICAgICAgICAgICAnMS4wJyAgIDogJy84Jyxcblx0ICAgICAgICAgICAgICAgICAgICAnMS4yJyAgIDogJy8xJyxcblx0ICAgICAgICAgICAgICAgICAgICAnMS4zJyAgIDogJy8zJyxcblx0ICAgICAgICAgICAgICAgICAgICAnMi4wJyAgIDogJy80MTInLFxuXHQgICAgICAgICAgICAgICAgICAgICcyLjAuMicgOiAnLzQxNicsXG5cdCAgICAgICAgICAgICAgICAgICAgJzIuMC4zJyA6ICcvNDE3Jyxcblx0ICAgICAgICAgICAgICAgICAgICAnMi4wLjQnIDogJy80MTknLFxuXHQgICAgICAgICAgICAgICAgICAgICc/JyAgICAgOiAnLydcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZXZpY2UgOiB7XG5cdCAgICAgICAgICAgIHNwcmludCA6IHtcblx0ICAgICAgICAgICAgICAgIG1vZGVsIDoge1xuXHQgICAgICAgICAgICAgICAgICAgICdFdm8gU2hpZnQgNEcnIDogJzczNzNLVCdcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB2ZW5kb3IgOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgJ0hUQycgICAgICAgOiAnQVBBJyxcblx0ICAgICAgICAgICAgICAgICAgICAnU3ByaW50JyAgICA6ICdTcHJpbnQnXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgb3MgOiB7XG5cdCAgICAgICAgICAgIHdpbmRvd3MgOiB7XG5cdCAgICAgICAgICAgICAgICB2ZXJzaW9uIDoge1xuXHQgICAgICAgICAgICAgICAgICAgICdNRScgICAgICAgIDogJzQuOTAnLFxuXHQgICAgICAgICAgICAgICAgICAgICdOVCAzLjExJyAgIDogJ05UMy41MScsXG5cdCAgICAgICAgICAgICAgICAgICAgJ05UIDQuMCcgICAgOiAnTlQ0LjAnLFxuXHQgICAgICAgICAgICAgICAgICAgICcyMDAwJyAgICAgIDogJ05UIDUuMCcsXG5cdCAgICAgICAgICAgICAgICAgICAgJ1hQJyAgICAgICAgOiBbJ05UIDUuMScsICdOVCA1LjInXSxcblx0ICAgICAgICAgICAgICAgICAgICAnVmlzdGEnICAgICA6ICdOVCA2LjAnLFxuXHQgICAgICAgICAgICAgICAgICAgICc3JyAgICAgICAgIDogJ05UIDYuMScsXG5cdCAgICAgICAgICAgICAgICAgICAgJzgnICAgICAgICAgOiAnTlQgNi4yJyxcblx0ICAgICAgICAgICAgICAgICAgICAnOC4xJyAgICAgICA6ICdOVCA2LjMnLFxuXHQgICAgICAgICAgICAgICAgICAgICdSVCcgICAgICAgIDogJ0FSTSdcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblxuXHQgICAgLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFJlZ2V4IG1hcFxuXHQgICAgLy8vLy8vLy8vLy8vL1xuXG5cblx0ICAgIHZhciByZWdleGVzID0ge1xuXG5cdCAgICAgICAgYnJvd3NlciA6IFtbXG5cdCAgICAgICAgXG5cdCAgICAgICAgICAgIC8vIFByZXN0byBiYXNlZFxuXHQgICAgICAgICAgICAvKG9wZXJhXFxzbWluaSlcXC8oW1xcd1xcLi1dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBNaW5pXG5cdCAgICAgICAgICAgIC8ob3BlcmFcXHNbbW9iaWxldGFiXSspLit2ZXJzaW9uXFwvKFtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1vYmkvVGFibGV0XG5cdCAgICAgICAgICAgIC8ob3BlcmEpLit2ZXJzaW9uXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgPiA5LjgwXG5cdCAgICAgICAgICAgIC8ob3BlcmEpW1xcL1xcc10rKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIDwgOS44MFxuXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC9cXHMob3ByKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFdlYmtpdFxuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdPcGVyYSddLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC8vIE1peGVkXG5cdCAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG5cdCAgICAgICAgICAgIC8obHVuYXNjYXBlfG1heHRob258bmV0ZnJvbnR8amFzbWluZXxibGF6ZXIpW1xcL1xcc10/KFtcXHdcXC5dKykqL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTHVuYXNjYXBlL01heHRob24vTmV0ZnJvbnQvSmFzbWluZS9CbGF6ZXJcblxuXHQgICAgICAgICAgICAvLyBUcmlkZW50IGJhc2VkXG5cdCAgICAgICAgICAgIC8oYXZhbnRcXHN8aWVtb2JpbGV8c2xpbXxiYWlkdSkoPzpicm93c2VyKT9bXFwvXFxzXT8oW1xcd1xcLl0qKS9pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2YW50L0lFTW9iaWxlL1NsaW1Ccm93c2VyL0JhaWR1XG5cdCAgICAgICAgICAgIC8oPzptc3xcXCgpKGllKVxccyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyXG5cblx0ICAgICAgICAgICAgLy8gV2Via2l0L0tIVE1MIGJhc2VkXG5cdCAgICAgICAgICAgIC8ocmVrb25xKVxcLyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVrb25xXG5cdCAgICAgICAgICAgIC8oY2hyb21pdW18ZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxvdmlicm93c2VyfGJvbHR8aXJvbnx2aXZhbGRpKVxcLyhbXFx3XFwuLV0rKS9pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0vRmxvY2svUm9ja01lbHQvTWlkb3JpL0VwaXBoYW55L1NpbGsvU2t5ZmlyZS9Cb2x0L0lyb25cblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLyh0cmlkZW50KS4rcnZbOlxcc10oW1xcd1xcLl0rKS4rbGlrZVxcc2dlY2tvL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUxMVxuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdJRSddLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC8oZWRnZSlcXC8oKFxcZCspP1tcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBFZGdlXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC8oeWFicm93c2VyKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWWFuZGV4XG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1lhbmRleCddLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC8oY29tb2RvX2RyYWdvbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tb2RvIERyYWdvblxuXHQgICAgICAgICAgICBdLCBbW05BTUUsIC9fL2csICcgJ10sIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLyhjaHJvbWV8b21uaXdlYnxhcm9yYXxbdGl6ZW5va2FdezV9XFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl0rKS9pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZS9PbW5pV2ViL0Fyb3JhL1RpemVuL05va2lhXG5cdCAgICAgICAgICAgIC8odWNcXHM/YnJvd3NlcnxxcWJyb3dzZXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVDQnJvd3Nlci9RUUJyb3dzZXJcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLyhkb2xmaW4pXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2xwaGluXG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0RvbHBoaW4nXSwgVkVSU0lPTl0sIFtcblxuXHQgICAgICAgICAgICAvKCg/OmFuZHJvaWQuKyljcm1vfGNyaW9zKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBmb3IgQW5kcm9pZC9pT1Ncblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21lJ10sIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgL1hpYW9NaVxcL01pdWlCcm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTUlVSSBCcm93c2VyXG5cdCAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01JVUkgQnJvd3NlciddXSwgW1xuXG5cdCAgICAgICAgICAgIC9hbmRyb2lkLit2ZXJzaW9uXFwvKFtcXHdcXC5dKylcXHMrKD86bW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpL2kgICAgICAgICAvLyBBbmRyb2lkIEJyb3dzZXJcblx0ICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQW5kcm9pZCBCcm93c2VyJ11dLCBbXG5cblx0ICAgICAgICAgICAgL0ZCQVZcXC8oW1xcd1xcLl0rKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWNlYm9vayBBcHAgZm9yIGlPU1xuXHQgICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdGYWNlYm9vayddXSwgW1xuXG5cdCAgICAgICAgICAgIC92ZXJzaW9uXFwvKFtcXHdcXC5dKykuKz9tb2JpbGVcXC9cXHcrXFxzKHNhZmFyaSkvaSAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9iaWxlIFNhZmFyaVxuXHQgICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNb2JpbGUgU2FmYXJpJ11dLCBbXG5cblx0ICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLl0rKS4rPyhtb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkvaSAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpICYgU2FmYXJpIE1vYmlsZVxuXHQgICAgICAgICAgICBdLCBbVkVSU0lPTiwgTkFNRV0sIFtcblxuXHQgICAgICAgICAgICAvd2Via2l0Lis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPCAzLjBcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLmJyb3dzZXIub2xkc2FmYXJpLnZlcnNpb25dXSwgW1xuXG5cdCAgICAgICAgICAgIC8oa29ucXVlcm9yKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS29ucXVlcm9yXG5cdCAgICAgICAgICAgIC8od2Via2l0fGtodG1sKVxcLyhbXFx3XFwuXSspL2lcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLy8gR2Vja28gYmFzZWRcblx0ICAgICAgICAgICAgLyhuYXZpZ2F0b3J8bmV0c2NhcGUpXFwvKFtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXRzY2FwZVxuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdOZXRzY2FwZSddLCBWRVJTSU9OXSwgW1xuXHQgICAgICAgICAgICAvKHN3aWZ0Zm94KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aWZ0Zm94XG5cdCAgICAgICAgICAgIC8oaWNlZHJhZ29ufGljZXdlYXNlbHxjYW1pbm98Y2hpbWVyYXxmZW5uZWN8bWFlbW9cXHNicm93c2VyfG1pbmltb3xjb25rZXJvcilbXFwvXFxzXT8oW1xcd1xcLlxcK10rKS9pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEljZURyYWdvbi9JY2V3ZWFzZWwvQ2FtaW5vL0NoaW1lcmEvRmVubmVjL01hZW1vL01pbmltby9Db25rZXJvclxuXHQgICAgICAgICAgICAvKGZpcmVmb3h8c2VhbW9ua2V5fGstbWVsZW9ufGljZWNhdHxpY2VhcGV8ZmlyZWJpcmR8cGhvZW5peClcXC8oW1xcd1xcLi1dKykvaSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94L1NlYU1vbmtleS9LLU1lbGVvbi9JY2VDYXQvSWNlQXBlL0ZpcmViaXJkL1Bob2VuaXhcblx0ICAgICAgICAgICAgLyhtb3ppbGxhKVxcLyhbXFx3XFwuXSspLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ppbGxhXG5cblx0ICAgICAgICAgICAgLy8gT3RoZXJcblx0ICAgICAgICAgICAgLyhwb2xhcmlzfGx5bnh8ZGlsbG98aWNhYnxkb3Jpc3xhbWF5YXx3M218bmV0c3VyZilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvbGFyaXMvTHlueC9EaWxsby9pQ2FiL0RvcmlzL0FtYXlhL3czbS9OZXRTdXJmXG5cdCAgICAgICAgICAgIC8obGlua3MpXFxzXFwoKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmtzXG5cdCAgICAgICAgICAgIC8oZ29icm93c2VyKVxcLz8oW1xcd1xcLl0rKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29Ccm93c2VyXG5cdCAgICAgICAgICAgIC8oaWNlXFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl9dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElDRSBCcm93c2VyXG5cdCAgICAgICAgICAgIC8obW9zYWljKVtcXC9cXHNdKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vc2FpY1xuXHQgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cblx0ICAgICAgICBdLFxuXG5cdCAgICAgICAgZW5naW5lIDogW1tcblxuXHQgICAgICAgICAgICAvd2luZG93cy4rXFxzZWRnZVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFZGdlSFRNTFxuXHQgICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdFZGdlSFRNTCddXSwgW1xuXG5cdCAgICAgICAgICAgIC8ocHJlc3RvKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc3RvXG5cdCAgICAgICAgICAgIC8od2Via2l0fHRyaWRlbnR8bmV0ZnJvbnR8bmV0c3VyZnxhbWF5YXxseW54fHczbSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgLy8gV2ViS2l0L1RyaWRlbnQvTmV0RnJvbnQvTmV0U3VyZi9BbWF5YS9MeW54L3czbVxuXHQgICAgICAgICAgICAvKGtodG1sfHRhc21hbnxsaW5rcylbXFwvXFxzXVxcKD8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS0hUTUwvVGFzbWFuL0xpbmtzXG5cdCAgICAgICAgICAgIC8oaWNhYilbXFwvXFxzXShbMjNdXFwuW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpQ2FiXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC9ydlxcOihbXFx3XFwuXSspLiooZ2Vja28pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja29cblx0ICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdXG5cdCAgICAgICAgXSxcblxuXHQgICAgICAgIG9zIDogW1tcblxuXHQgICAgICAgICAgICAvLyBXaW5kb3dzIGJhc2VkXG5cdCAgICAgICAgICAgIC9taWNyb3NvZnRcXHMod2luZG93cylcXHModmlzdGF8eHApL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIChpVHVuZXMpXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXHQgICAgICAgICAgICAvKHdpbmRvd3MpXFxzbnRcXHM2XFwuMjtcXHMoYXJtKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIFJUXG5cdCAgICAgICAgICAgIC8od2luZG93c1xcc3Bob25lKD86XFxzb3MpKnx3aW5kb3dzXFxzbW9iaWxlfHdpbmRvd3MpW1xcc1xcL10/KFtudGNlXFxkXFwuXFxzXStcXHcpL2lcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLm9zLndpbmRvd3MudmVyc2lvbl1dLCBbXG5cdCAgICAgICAgICAgIC8od2luKD89M3w5fG4pfHdpblxcczl4XFxzKShbbnRcXGRcXC5dKykvaVxuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdXaW5kb3dzJ10sIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLm9zLndpbmRvd3MudmVyc2lvbl1dLCBbXG5cblx0ICAgICAgICAgICAgLy8gTW9iaWxlL0VtYmVkZGVkIE9TXG5cdCAgICAgICAgICAgIC9cXCgoYmIpKDEwKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgMTBcblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnQmxhY2tCZXJyeSddLCBWRVJTSU9OXSwgW1xuXHQgICAgICAgICAgICAvKGJsYWNrYmVycnkpXFx3KlxcLz8oW1xcd1xcLl0rKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja2JlcnJ5XG5cdCAgICAgICAgICAgIC8odGl6ZW4pW1xcL1xcc10oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRpemVuXG5cdCAgICAgICAgICAgIC8oYW5kcm9pZHx3ZWJvc3xwYWxtXFxvc3xxbnh8YmFkYXxyaW1cXHN0YWJsZXRcXHNvc3xtZWVnb3xjb250aWtpKVtcXC9cXHMtXT8oW1xcd1xcLl0rKSovaSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkL1dlYk9TL1BhbG0vUU5YL0JhZGEvUklNL01lZUdvL0NvbnRpa2lcblx0ICAgICAgICAgICAgL2xpbnV4Oy4rKHNhaWxmaXNoKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWlsZmlzaCBPU1xuXHQgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblx0ICAgICAgICAgICAgLyhzeW1iaWFuXFxzP29zfHN5bWJvc3xzNjAoPz07KSlbXFwvXFxzLV0/KFtcXHdcXC5dKykqL2kgICAgICAgICAgICAgICAgIC8vIFN5bWJpYW5cblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnU3ltYmlhbiddLCBWRVJTSU9OXSwgW1xuXHQgICAgICAgICAgICAvXFwoKHNlcmllczQwKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJpZXMgNDBcblx0ICAgICAgICAgICAgXSwgW05BTUVdLCBbXG5cdCAgICAgICAgICAgIC9tb3ppbGxhLitcXChtb2JpbGU7LitnZWNrby4rZmlyZWZveC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggT1Ncblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnRmlyZWZveCBPUyddLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC8vIENvbnNvbGVcblx0ICAgICAgICAgICAgLyhuaW50ZW5kb3xwbGF5c3RhdGlvbilcXHMoW3dpZHMzcG9ydGFibGV2dV0rKS9pLCAgICAgICAgICAgICAgICAgICAgLy8gTmludGVuZG8vUGxheXN0YXRpb25cblxuXHQgICAgICAgICAgICAvLyBHTlUvTGludXggYmFzZWRcblx0ICAgICAgICAgICAgLyhtaW50KVtcXC9cXHNcXChdPyhcXHcrKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWludFxuXHQgICAgICAgICAgICAvKG1hZ2VpYXx2ZWN0b3JsaW51eClbO1xcc10vaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWdlaWEvVmVjdG9yTGludXhcblx0ICAgICAgICAgICAgLyhqb2xpfFtreGxuXT91YnVudHV8ZGViaWFufFtvcGVuXSpzdXNlfGdlbnRvb3xhcmNofHNsYWNrd2FyZXxmZWRvcmF8bWFuZHJpdmF8Y2VudG9zfHBjbGludXhvc3xyZWRoYXR8emVud2Fsa3xsaW5wdXMpW1xcL1xccy1dPyhbXFx3XFwuLV0rKSovaSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xpL1VidW50dS9EZWJpYW4vU1VTRS9HZW50b28vQXJjaC9TbGFja3dhcmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGZWRvcmEvTWFuZHJpdmEvQ2VudE9TL1BDTGludXhPUy9SZWRIYXQvWmVud2Fsay9MaW5wdXNcblx0ICAgICAgICAgICAgLyhodXJkfGxpbnV4KVxccz8oW1xcd1xcLl0rKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIdXJkL0xpbnV4XG5cdCAgICAgICAgICAgIC8oZ251KVxccz8oW1xcd1xcLl0rKSovaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR05VXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC8oY3JvcylcXHNbXFx3XStcXHMoW1xcd1xcLl0rXFx3KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0gT1Ncblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21pdW0gT1MnXSwgVkVSU0lPTl0sW1xuXG5cdCAgICAgICAgICAgIC8vIFNvbGFyaXNcblx0ICAgICAgICAgICAgLyhzdW5vcylcXHM/KFtcXHdcXC5dK1xcZCkqL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdTb2xhcmlzJ10sIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLy8gQlNEIGJhc2VkXG5cdCAgICAgICAgICAgIC9cXHMoW2ZyZW50b3BjLV17MCw0fWJzZHxkcmFnb25mbHkpXFxzPyhbXFx3XFwuXSspKi9pICAgICAgICAgICAgICAgICAgIC8vIEZyZWVCU0QvTmV0QlNEL09wZW5CU0QvUEMtQlNEL0RyYWdvbkZseVxuXHQgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sW1xuXG5cdCAgICAgICAgICAgIC8oaXBbaG9uZWFkXSspKD86Lipvc1xccyooW1xcd10rKSpcXHNsaWtlXFxzbWFjfDtcXHNvcGVyYSkvaSAgICAgICAgICAgICAvLyBpT1Ncblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnaU9TJ10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgW1xuXG5cdCAgICAgICAgICAgIC8obWFjXFxzb3NcXHN4KVxccz8oW1xcd1xcc1xcLl0rXFx3KSovaSxcblx0ICAgICAgICAgICAgLyhtYWNpbnRvc2h8bWFjKD89X3Bvd2VycGMpXFxzKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjIE9TXG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ01hYyBPUyddLCBbVkVSU0lPTiwgL18vZywgJy4nXV0sIFtcblxuXHQgICAgICAgICAgICAvLyBPdGhlclxuXHQgICAgICAgICAgICAvKCg/Om9wZW4pP3NvbGFyaXMpW1xcL1xccy1dPyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2xhcmlzXG5cdCAgICAgICAgICAgIC8oaGFpa3UpXFxzKFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYWlrdVxuXHQgICAgICAgICAgICAvKGFpeClcXHMoKFxcZCkoPz1cXC58XFwpfFxccylbXFx3XFwuXSopKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBSVhcblx0ICAgICAgICAgICAgLyhwbGFuXFxzOXxtaW5peHxiZW9zfG9zXFwvMnxhbWlnYW9zfG1vcnBob3N8cmlzY1xcc29zfG9wZW52bXMpL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhbjkvTWluaXgvQmVPUy9PUzIvQW1pZ2FPUy9Nb3JwaE9TL1JJU0NPUy9PcGVuVk1TXG5cdCAgICAgICAgICAgIC8odW5peClcXHM/KFtcXHdcXC5dKykqL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVU5JWFxuXHQgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cblx0ICAgICAgICBdXG5cdCAgICB9O1xuXG5cblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBDb25zdHJ1Y3RvclxuXHQgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG5cblx0ICAgIHZhciBVQVBhcnNlciA9IGZ1bmN0aW9uICh1YXN0cmluZykge1xuXG5cdCAgICAgICAgdmFyIHVhID0gdWFzdHJpbmcgfHwgKCh3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IEVNUFRZKTtcblxuXHQgICAgICAgIHRoaXMuZ2V0QnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG1hcHBlci5yZ3guYXBwbHkodGhpcywgcmVnZXhlcy5icm93c2VyKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuZ2V0RW5naW5lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFwcGVyLnJneC5hcHBseSh0aGlzLCByZWdleGVzLmVuZ2luZSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmdldE9TID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFwcGVyLnJneC5hcHBseSh0aGlzLCByZWdleGVzLm9zKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICB1YSAgICAgIDogdGhpcy5nZXRVQSgpLFxuXHQgICAgICAgICAgICAgICAgYnJvd3NlciA6IHRoaXMuZ2V0QnJvd3NlcigpLFxuXHQgICAgICAgICAgICAgICAgZW5naW5lICA6IHRoaXMuZ2V0RW5naW5lKCksXG5cdCAgICAgICAgICAgICAgICBvcyAgICAgIDogdGhpcy5nZXRPUygpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmdldFVBID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdWE7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLnNldFVBID0gZnVuY3Rpb24gKHVhc3RyaW5nKSB7XG5cdCAgICAgICAgICAgIHVhID0gdWFzdHJpbmc7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5zZXRVQSh1YSk7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gVUFQYXJzZXI7XG5cdH0pKCk7XG5cblxuXHRmdW5jdGlvbiB2ZXJzaW9uX2NvbXBhcmUodjEsIHYyLCBvcGVyYXRvcikge1xuXHQgIC8vIEZyb206IGh0dHA6Ly9waHBqcy5vcmcvZnVuY3Rpb25zXG5cdCAgLy8gKyAgICAgIG9yaWdpbmFsIGJ5OiBQaGlsaXBwZSBKYXVzaW9ucyAoaHR0cDovL3BlYXIucGhwLm5ldC91c2VyL2phdXNpb25zKVxuXHQgIC8vICsgICAgICBvcmlnaW5hbCBieTogQWlkYW4gTGlzdGVyIChodHRwOi8vYWlkYW5saXN0ZXIuY29tLylcblx0ICAvLyArIHJlaW1wbGVtZW50ZWQgYnk6IEthbmtyZWx1bmUgKGh0dHA6Ly93d3cud2ViZmFrdG9yeS5pbmZvLylcblx0ICAvLyArICAgICAgaW1wcm92ZWQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG5cdCAgLy8gKyAgICAgIGltcHJvdmVkIGJ5OiBTY290dCBCYWtlclxuXHQgIC8vICsgICAgICBpbXByb3ZlZCBieTogVGhlcmlhdWx0XG5cdCAgLy8gKiAgICAgICAgZXhhbXBsZSAxOiB2ZXJzaW9uX2NvbXBhcmUoJzguMi41cmMnLCAnOC4yLjVhJyk7XG5cdCAgLy8gKiAgICAgICAgcmV0dXJucyAxOiAxXG5cdCAgLy8gKiAgICAgICAgZXhhbXBsZSAyOiB2ZXJzaW9uX2NvbXBhcmUoJzguMi41MCcsICc4LjIuNTInLCAnPCcpO1xuXHQgIC8vICogICAgICAgIHJldHVybnMgMjogdHJ1ZVxuXHQgIC8vICogICAgICAgIGV4YW1wbGUgMzogdmVyc2lvbl9jb21wYXJlKCc1LjMuMC1kZXYnLCAnNS4zLjAnKTtcblx0ICAvLyAqICAgICAgICByZXR1cm5zIDM6IC0xXG5cdCAgLy8gKiAgICAgICAgZXhhbXBsZSA0OiB2ZXJzaW9uX2NvbXBhcmUoJzQuMS4wLjUyJywnNC4wMS4wLjUxJyk7XG5cdCAgLy8gKiAgICAgICAgcmV0dXJucyA0OiAxXG5cblx0ICAvLyBJbXBvcnRhbnQ6IGNvbXBhcmUgbXVzdCBiZSBpbml0aWFsaXplZCBhdCAwLlxuXHQgIHZhciBpID0gMCxcblx0ICAgIHggPSAwLFxuXHQgICAgY29tcGFyZSA9IDAsXG5cdCAgICAvLyB2bSBtYXBzIHRleHR1YWwgUEhQIHZlcnNpb25zIHRvIG5lZ2F0aXZlcyBzbyB0aGV5J3JlIGxlc3MgdGhhbiAwLlxuXHQgICAgLy8gUEhQIGN1cnJlbnRseSBkZWZpbmVzIHRoZXNlIGFzIENBU0UtU0VOU0lUSVZFLiBJdCBpcyBpbXBvcnRhbnQgdG9cblx0ICAgIC8vIGxlYXZlIHRoZXNlIGFzIG5lZ2F0aXZlcyBzbyB0aGF0IHRoZXkgY2FuIGNvbWUgYmVmb3JlIG51bWVyaWNhbCB2ZXJzaW9uc1xuXHQgICAgLy8gYW5kIGFzIGlmIG5vIGxldHRlcnMgd2VyZSB0aGVyZSB0byBiZWdpbiB3aXRoLlxuXHQgICAgLy8gKDFhbHBoYSBpcyA8IDEgYW5kIDwgMS4xIGJ1dCA+IDFkZXYxKVxuXHQgICAgLy8gSWYgYSBub24tbnVtZXJpY2FsIHZhbHVlIGNhbid0IGJlIG1hcHBlZCB0byB0aGlzIHRhYmxlLCBpdCByZWNlaXZlc1xuXHQgICAgLy8gLTcgYXMgaXRzIHZhbHVlLlxuXHQgICAgdm0gPSB7XG5cdCAgICAgICdkZXYnOiAtNixcblx0ICAgICAgJ2FscGhhJzogLTUsXG5cdCAgICAgICdhJzogLTUsXG5cdCAgICAgICdiZXRhJzogLTQsXG5cdCAgICAgICdiJzogLTQsXG5cdCAgICAgICdSQyc6IC0zLFxuXHQgICAgICAncmMnOiAtMyxcblx0ICAgICAgJyMnOiAtMixcblx0ICAgICAgJ3AnOiAxLFxuXHQgICAgICAncGwnOiAxXG5cdCAgICB9LFxuXHQgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBwcmVwYXJlIGVhY2ggdmVyc2lvbiBhcmd1bWVudC5cblx0ICAgIC8vIEl0IHJlcGxhY2VzIGV2ZXJ5IF8sIC0sIGFuZCArIHdpdGggYSBkb3QuXG5cdCAgICAvLyBJdCBzdXJyb3VuZHMgYW55IG5vbnNlcXVlbmNlIG9mIG51bWJlcnMvZG90cyB3aXRoIGRvdHMuXG5cdCAgICAvLyBJdCByZXBsYWNlcyBzZXF1ZW5jZXMgb2YgZG90cyB3aXRoIGEgc2luZ2xlIGRvdC5cblx0ICAgIC8vICAgIHZlcnNpb25fY29tcGFyZSgnNC4uMCcsICc0LjAnKSA9PSAwXG5cdCAgICAvLyBJbXBvcnRhbnQ6IEEgc3RyaW5nIG9mIDAgbGVuZ3RoIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCBpbnRvIGEgdmFsdWVcblx0ICAgIC8vIGV2ZW4gbGVzcyB0aGFuIGFuIHVuZXhpc3RpbmcgdmFsdWUgaW4gdm0gKC03KSwgaGVuY2UgWy04XS5cblx0ICAgIC8vIEl0J3MgYWxzbyBpbXBvcnRhbnQgdG8gbm90IHN0cmlwIHNwYWNlcyBiZWNhdXNlIG9mIHRoaXMuXG5cdCAgICAvLyAgIHZlcnNpb25fY29tcGFyZSgnJywgJyAnKSA9PSAxXG5cdCAgICBwcmVwVmVyc2lvbiA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgICAgIHYgPSAoJycgKyB2KS5yZXBsYWNlKC9bX1xcLStdL2csICcuJyk7XG5cdCAgICAgIHYgPSB2LnJlcGxhY2UoLyhbXi5cXGRdKykvZywgJy4kMS4nKS5yZXBsYWNlKC9cXC57Mix9L2csICcuJyk7XG5cdCAgICAgIHJldHVybiAoIXYubGVuZ3RoID8gWy04XSA6IHYuc3BsaXQoJy4nKSk7XG5cdCAgICB9LFxuXHQgICAgLy8gVGhpcyBjb252ZXJ0cyBhIHZlcnNpb24gY29tcG9uZW50IHRvIGEgbnVtYmVyLlxuXHQgICAgLy8gRW1wdHkgY29tcG9uZW50IGJlY29tZXMgMC5cblx0ICAgIC8vIE5vbi1udW1lcmljYWwgY29tcG9uZW50IGJlY29tZXMgYSBuZWdhdGl2ZSBudW1iZXIuXG5cdCAgICAvLyBOdW1lcmljYWwgY29tcG9uZW50IGJlY29tZXMgaXRzZWxmIGFzIGFuIGludGVnZXIuXG5cdCAgICBudW1WZXJzaW9uID0gZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgcmV0dXJuICF2ID8gMCA6IChpc05hTih2KSA/IHZtW3ZdIHx8IC03IDogcGFyc2VJbnQodiwgMTApKTtcblx0ICAgIH07XG5cblx0ICB2MSA9IHByZXBWZXJzaW9uKHYxKTtcblx0ICB2MiA9IHByZXBWZXJzaW9uKHYyKTtcblx0ICB4ID0gTWF0aC5tYXgodjEubGVuZ3RoLCB2Mi5sZW5ndGgpO1xuXHQgIGZvciAoaSA9IDA7IGkgPCB4OyBpKyspIHtcblx0ICAgIGlmICh2MVtpXSA9PSB2MltpXSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblx0ICAgIHYxW2ldID0gbnVtVmVyc2lvbih2MVtpXSk7XG5cdCAgICB2MltpXSA9IG51bVZlcnNpb24odjJbaV0pO1xuXHQgICAgaWYgKHYxW2ldIDwgdjJbaV0pIHtcblx0ICAgICAgY29tcGFyZSA9IC0xO1xuXHQgICAgICBicmVhaztcblx0ICAgIH0gZWxzZSBpZiAodjFbaV0gPiB2MltpXSkge1xuXHQgICAgICBjb21wYXJlID0gMTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICghb3BlcmF0b3IpIHtcblx0ICAgIHJldHVybiBjb21wYXJlO1xuXHQgIH1cblxuXHQgIC8vIEltcG9ydGFudDogb3BlcmF0b3IgaXMgQ0FTRS1TRU5TSVRJVkUuXG5cdCAgLy8gXCJObyBvcGVyYXRvclwiIHNlZW1zIHRvIGJlIHRyZWF0ZWQgYXMgXCI8LlwiXG5cdCAgLy8gQW55IG90aGVyIHZhbHVlcyBzZWVtIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIHJldHVybiBudWxsLlxuXHQgIHN3aXRjaCAob3BlcmF0b3IpIHtcblx0ICBjYXNlICc+Jzpcblx0ICBjYXNlICdndCc6XG5cdCAgICByZXR1cm4gKGNvbXBhcmUgPiAwKTtcblx0ICBjYXNlICc+PSc6XG5cdCAgY2FzZSAnZ2UnOlxuXHQgICAgcmV0dXJuIChjb21wYXJlID49IDApO1xuXHQgIGNhc2UgJzw9Jzpcblx0ICBjYXNlICdsZSc6XG5cdCAgICByZXR1cm4gKGNvbXBhcmUgPD0gMCk7XG5cdCAgY2FzZSAnPT0nOlxuXHQgIGNhc2UgJz0nOlxuXHQgIGNhc2UgJ2VxJzpcblx0ICAgIHJldHVybiAoY29tcGFyZSA9PT0gMCk7XG5cdCAgY2FzZSAnPD4nOlxuXHQgIGNhc2UgJyE9Jzpcblx0ICBjYXNlICduZSc6XG5cdCAgICByZXR1cm4gKGNvbXBhcmUgIT09IDApO1xuXHQgIGNhc2UgJyc6XG5cdCAgY2FzZSAnPCc6XG5cdCAgY2FzZSAnbHQnOlxuXHQgICAgcmV0dXJuIChjb21wYXJlIDwgMCk7XG5cdCAgZGVmYXVsdDpcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblx0fVxuXG5cblx0dmFyIGNhbiA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FwcyA9IHtcblx0XHRcdFx0ZGVmaW5lX3Byb3BlcnR5OiAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0LyogLy8gY3VycmVudGx5IHRvbyBtdWNoIGV4dHJhIGNvZGUgcmVxdWlyZWQsIG5vdCBleGFjdGx5IHdvcnRoIGl0XG5cdFx0XHRcdFx0dHJ5IHsgLy8gYXMgb2YgSUU4LCBnZXR0ZXJzL3NldHRlcnMgYXJlIHN1cHBvcnRlZCBvbmx5IG9uIERPTSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0dmFyIG9iaiA9IHt9O1xuXHRcdFx0XHRcdFx0aWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAncHJvcCcsIHtcblx0XHRcdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaChleCkge31cblxuXHRcdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18gJiYgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9Ki9cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0oKSksXG5cblx0XHRcdFx0Y3JlYXRlX2NhbnZhczogKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIE9uIHRoZSBTNjAgYW5kIEJCIFN0b3JtLCBnZXRDb250ZXh0IGV4aXN0cywgYnV0IGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZFxuXHRcdFx0XHRcdC8vIHNvIHdlIGFjdHVhbGx5IGhhdmUgdG8gY2FsbCBnZXRDb250ZXh0KCkgdG8gdmVyaWZ5XG5cdFx0XHRcdFx0Ly8gZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2lzc3Vlcy9pc3N1ZS85Ny9cblx0XHRcdFx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdFx0XHRyZXR1cm4gISEoZWwuZ2V0Q29udGV4dCAmJiBlbC5nZXRDb250ZXh0KCcyZCcpKTtcblx0XHRcdFx0fSgpKSxcblxuXHRcdFx0XHRyZXR1cm5fcmVzcG9uc2VfdHlwZTogZnVuY3Rpb24ocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmIChCYXNpYy5pbkFycmF5KHJlc3BvbnNlVHlwZSwgWycnLCAndGV4dCcsICdkb2N1bWVudCddKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHRcdFx0XHRcdHhoci5vcGVuKCdnZXQnLCAnLycpOyAvLyBvdGhlcndpc2UgR2Vja28gdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcblx0XHRcdFx0XHRcdFx0XHQvLyBhcyBvZiAyMy4wLjEyNzEuNjQsIENocm9tZSBzd2l0Y2hlZCBmcm9tIHRocm93aW5nIGV4Y2VwdGlvbiB0byBtZXJlbHkgbG9nZ2luZyBpdCB0byB0aGUgY29uc29sZSAod2h5PyBvIHdoeT8pXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHhoci5yZXNwb25zZVR5cGUgIT09IHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4KSB7fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBpZGVhcyBmb3IgdGhpcyBoZWF2aWx5IGNvbWUgZnJvbSBNb2Rlcm5penIgKGh0dHA6Ly9tb2Rlcm5penIuY29tLylcblx0XHRcdFx0dXNlX2RhdGFfdXJpOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGR1ID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdFx0XHRkdS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGNhcHMudXNlX2RhdGFfdXJpID0gKGR1LndpZHRoID09PSAxICYmIGR1LmhlaWdodCA9PT0gMSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZHUuc3JjID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFQOEFBQUFBQUNINUJBQUFBQUFBTEFBQUFBQUJBQUVBQUFJQ1JBRUFPdz09XCI7XG5cdFx0XHRcdFx0fSwgMSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9KCkpLFxuXG5cdFx0XHRcdHVzZV9kYXRhX3VyaV9vdmVyMzJrYjogZnVuY3Rpb24oKSB7IC8vIElFOFxuXHRcdFx0XHRcdHJldHVybiBjYXBzLnVzZV9kYXRhX3VyaSAmJiAoRW52LmJyb3dzZXIgIT09ICdJRScgfHwgRW52LnZlcnNpb24gPj0gOSk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dXNlX2RhdGFfdXJpX29mOiBmdW5jdGlvbihieXRlcykge1xuXHRcdFx0XHRcdHJldHVybiAoY2Fwcy51c2VfZGF0YV91cmkgJiYgYnl0ZXMgPCAzMzAwMCB8fCBjYXBzLnVzZV9kYXRhX3VyaV9vdmVyMzJrYigpKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1c2VfZmlsZWlucHV0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKEFuZHJvaWQgKDEuMHwxLjF8MS41fDEuNnwyLjB8Mi4xKSl8KFdpbmRvd3MgUGhvbmUgKE9TIDd8OC4wKSl8KFhCTFdQKXwoWnVuZVdQKXwodyhlYik/T1NCcm93c2VyKXwod2ViT1MpfChLaW5kbGVcXC8oMS4wfDIuMHwyLjV8My4wKSkvKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcblx0XHRcdFx0XHRyZXR1cm4gIWVsLmRpc2FibGVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGNhcCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRhcmdzLnNoaWZ0KCk7IC8vIHNoaWZ0IG9mIGNhcFxuXHRcdFx0cmV0dXJuIEJhc2ljLnR5cGVPZihjYXBzW2NhcF0pID09PSAnZnVuY3Rpb24nID8gY2Fwc1tjYXBdLmFwcGx5KHRoaXMsIGFyZ3MpIDogISFjYXBzW2NhcF07XG5cdFx0fTtcblx0fSgpKTtcblxuXG5cdHZhciB1YVJlc3VsdCA9IG5ldyBVQVBhcnNlcigpLmdldFJlc3VsdCgpO1xuXG5cblx0dmFyIEVudiA9IHtcblx0XHRjYW46IGNhbixcblxuXHRcdHVhUGFyc2VyOiBVQVBhcnNlcixcblx0XHRcblx0XHRicm93c2VyOiB1YVJlc3VsdC5icm93c2VyLm5hbWUsXG5cdFx0dmVyc2lvbjogdWFSZXN1bHQuYnJvd3Nlci52ZXJzaW9uLFxuXHRcdG9zOiB1YVJlc3VsdC5vcy5uYW1lLCAvLyBldmVyeWJvZHkgaW50dWl0aXZlbHkgdHlwZXMgaXQgaW4gYSBsb3dlcmNhc2UgZm9yIHNvbWUgcmVhc29uXG5cdFx0b3NWZXJzaW9uOiB1YVJlc3VsdC5vcy52ZXJzaW9uLFxuXG5cdFx0dmVyQ29tcDogdmVyc2lvbl9jb21wYXJlLFxuXHRcdFxuXHRcdHN3Zl91cmw6IFwiLi4vZmxhc2gvTW94aWUuc3dmXCIsXG5cdFx0eGFwX3VybDogXCIuLi9zaWx2ZXJsaWdodC9Nb3hpZS54YXBcIixcblx0XHRnbG9iYWxfZXZlbnRfZGlzcGF0Y2hlcjogXCJtb3hpZS5jb3JlLkV2ZW50VGFyZ2V0Lmluc3RhbmNlLmRpc3BhdGNoRXZlbnRcIlxuXHR9O1xuXG5cdC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdC8vIEBkZXByZWNhdGVkIFVzZSBgRW52Lm9zYCBpbnN0ZWFkXG5cdEVudi5PUyA9IEVudi5vcztcblxuXHRpZiAoTVhJX0RFQlVHKSB7XG5cdFx0RW52LmRlYnVnID0ge1xuXHRcdFx0cnVudGltZTogdHJ1ZSxcblx0XHRcdGV2ZW50czogZmFsc2Vcblx0XHR9O1xuXG5cdFx0RW52LmxvZyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiBsb2dPYmooZGF0YSkge1xuXHRcdFx0XHQvLyBUT0RPOiB0aGlzIHNob3VsZCByZWN1cnNpdmVseSBwcmludCBvdXQgdGhlIG9iamVjdCBpbiBhIHByZXR0eSB3YXlcblx0XHRcdFx0Y29uc29sZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhICsgXCJcXG5cIikpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF0YSA9IGFyZ3VtZW50c1swXTtcblxuXHRcdFx0aWYgKEJhc2ljLnR5cGVPZihkYXRhKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZGF0YSA9IEJhc2ljLnNwcmludGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHdpbmRvdyAmJiB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcblx0XHRcdFx0d2luZG93LmNvbnNvbGUubG9nKGRhdGEpO1xuXHRcdFx0fSBlbHNlIGlmIChkb2N1bWVudCkge1xuXHRcdFx0XHR2YXIgY29uc29sZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb3hpZS1jb25zb2xlJyk7XG5cdFx0XHRcdGlmICghY29uc29sZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcblx0XHRcdFx0XHRjb25zb2xlLmlkID0gJ21veGllLWNvbnNvbGUnO1xuXHRcdFx0XHRcdC8vY29uc29sZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29uc29sZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoQmFzaWMuaW5BcnJheShCYXNpYy50eXBlT2YoZGF0YSksIFsnb2JqZWN0JywgJ2FycmF5J10pICE9PSAtMSkge1xuXHRcdFx0XHRcdGxvZ09iaihkYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEgKyBcIlxcblwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIEVudjtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL0V4Y2VwdGlvbnMuanNcblxuLyoqXG4gKiBFeGNlcHRpb25zLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvY29yZS9FeGNlcHRpb25zJywgW1xuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYydcbl0sIGZ1bmN0aW9uKEJhc2ljKSB7XG5cdFxuXHRmdW5jdGlvbiBfZmluZEtleShvYmosIHZhbHVlKSB7XG5cdFx0dmFyIGtleTtcblx0XHRmb3IgKGtleSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpba2V5XSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIGtleTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0QGNsYXNzIG1veGllL2NvcmUvRXhjZXB0aW9uXG5cdCovXG5cdHJldHVybiB7XG5cdFx0UnVudGltZUVycm9yOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmFtZWNvZGVzID0ge1xuXHRcdFx0XHROT1RfSU5JVF9FUlI6IDEsXG5cdFx0XHRcdEVYQ0VQVElPTl9FUlI6IDMsXG5cdFx0XHRcdE5PVF9TVVBQT1JURURfRVJSOiA5LFxuXHRcdFx0XHRKU19FUlI6IDRcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihjb2RlLCBtZXNzYWdlKSB7XG5cdFx0XHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0XHRcdHRoaXMubmFtZSA9IF9maW5kS2V5KG5hbWVjb2RlcywgY29kZSk7XG5cdFx0XHRcdHRoaXMubWVzc2FnZSA9IHRoaXMubmFtZSArIChtZXNzYWdlIHx8IFwiOiBSdW50aW1lRXJyb3IgXCIgKyB0aGlzLmNvZGUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRCYXNpYy5leHRlbmQoUnVudGltZUVycm9yLCBuYW1lY29kZXMpO1xuXHRcdFx0UnVudGltZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblx0XHRcdHJldHVybiBSdW50aW1lRXJyb3I7XG5cdFx0fSgpKSxcblx0XHRcblx0XHRPcGVyYXRpb25Ob3RBbGxvd2VkRXhjZXB0aW9uOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uIE9wZXJhdGlvbk5vdEFsbG93ZWRFeGNlcHRpb24oY29kZSkge1xuXHRcdFx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdFx0XHR0aGlzLm5hbWUgPSAnT3BlcmF0aW9uTm90QWxsb3dlZEV4Y2VwdGlvbic7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdEJhc2ljLmV4dGVuZChPcGVyYXRpb25Ob3RBbGxvd2VkRXhjZXB0aW9uLCB7XG5cdFx0XHRcdE5PVF9BTExPV0VEX0VSUjogMVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdE9wZXJhdGlvbk5vdEFsbG93ZWRFeGNlcHRpb24ucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gT3BlcmF0aW9uTm90QWxsb3dlZEV4Y2VwdGlvbjtcblx0XHR9KCkpLFxuXG5cdFx0SW1hZ2VFcnJvcjogKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5hbWVjb2RlcyA9IHtcblx0XHRcdFx0V1JPTkdfRk9STUFUOiAxLFxuXHRcdFx0XHRNQVhfUkVTT0xVVElPTl9FUlI6IDIsXG5cdFx0XHRcdElOVkFMSURfTUVUQV9FUlI6IDNcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIEltYWdlRXJyb3IoY29kZSkge1xuXHRcdFx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdFx0XHR0aGlzLm5hbWUgPSBfZmluZEtleShuYW1lY29kZXMsIGNvZGUpO1xuXHRcdFx0XHR0aGlzLm1lc3NhZ2UgPSB0aGlzLm5hbWUgKyBcIjogSW1hZ2VFcnJvciBcIiArIHRoaXMuY29kZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0QmFzaWMuZXh0ZW5kKEltYWdlRXJyb3IsIG5hbWVjb2Rlcyk7XG5cdFx0XHRJbWFnZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuXHRcdFx0cmV0dXJuIEltYWdlRXJyb3I7XG5cdFx0fSgpKSxcblxuXHRcdEZpbGVFeGNlcHRpb246IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuYW1lY29kZXMgPSB7XG5cdFx0XHRcdE5PVF9GT1VORF9FUlI6IDEsXG5cdFx0XHRcdFNFQ1VSSVRZX0VSUjogMixcblx0XHRcdFx0QUJPUlRfRVJSOiAzLFxuXHRcdFx0XHROT1RfUkVBREFCTEVfRVJSOiA0LFxuXHRcdFx0XHRFTkNPRElOR19FUlI6IDUsXG5cdFx0XHRcdE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUjogNixcblx0XHRcdFx0SU5WQUxJRF9TVEFURV9FUlI6IDcsXG5cdFx0XHRcdFNZTlRBWF9FUlI6IDhcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIEZpbGVFeGNlcHRpb24oY29kZSkge1xuXHRcdFx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdFx0XHR0aGlzLm5hbWUgPSBfZmluZEtleShuYW1lY29kZXMsIGNvZGUpO1xuXHRcdFx0XHR0aGlzLm1lc3NhZ2UgPSB0aGlzLm5hbWUgKyBcIjogRmlsZUV4Y2VwdGlvbiBcIiArIHRoaXMuY29kZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0QmFzaWMuZXh0ZW5kKEZpbGVFeGNlcHRpb24sIG5hbWVjb2Rlcyk7XG5cdFx0XHRGaWxlRXhjZXB0aW9uLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblx0XHRcdHJldHVybiBGaWxlRXhjZXB0aW9uO1xuXHRcdH0oKSksXG5cdFx0XG5cdFx0RE9NRXhjZXB0aW9uOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmFtZWNvZGVzID0ge1xuXHRcdFx0XHRJTkRFWF9TSVpFX0VSUjogMSxcblx0XHRcdFx0RE9NU1RSSU5HX1NJWkVfRVJSOiAyLFxuXHRcdFx0XHRISUVSQVJDSFlfUkVRVUVTVF9FUlI6IDMsXG5cdFx0XHRcdFdST05HX0RPQ1VNRU5UX0VSUjogNCxcblx0XHRcdFx0SU5WQUxJRF9DSEFSQUNURVJfRVJSOiA1LFxuXHRcdFx0XHROT19EQVRBX0FMTE9XRURfRVJSOiA2LFxuXHRcdFx0XHROT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI6IDcsXG5cdFx0XHRcdE5PVF9GT1VORF9FUlI6IDgsXG5cdFx0XHRcdE5PVF9TVVBQT1JURURfRVJSOiA5LFxuXHRcdFx0XHRJTlVTRV9BVFRSSUJVVEVfRVJSOiAxMCxcblx0XHRcdFx0SU5WQUxJRF9TVEFURV9FUlI6IDExLFxuXHRcdFx0XHRTWU5UQVhfRVJSOiAxMixcblx0XHRcdFx0SU5WQUxJRF9NT0RJRklDQVRJT05fRVJSOiAxMyxcblx0XHRcdFx0TkFNRVNQQUNFX0VSUjogMTQsXG5cdFx0XHRcdElOVkFMSURfQUNDRVNTX0VSUjogMTUsXG5cdFx0XHRcdFZBTElEQVRJT05fRVJSOiAxNixcblx0XHRcdFx0VFlQRV9NSVNNQVRDSF9FUlI6IDE3LFxuXHRcdFx0XHRTRUNVUklUWV9FUlI6IDE4LFxuXHRcdFx0XHRORVRXT1JLX0VSUjogMTksXG5cdFx0XHRcdEFCT1JUX0VSUjogMjAsXG5cdFx0XHRcdFVSTF9NSVNNQVRDSF9FUlI6IDIxLFxuXHRcdFx0XHRRVU9UQV9FWENFRURFRF9FUlI6IDIyLFxuXHRcdFx0XHRUSU1FT1VUX0VSUjogMjMsXG5cdFx0XHRcdElOVkFMSURfTk9ERV9UWVBFX0VSUjogMjQsXG5cdFx0XHRcdERBVEFfQ0xPTkVfRVJSOiAyNVxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gRE9NRXhjZXB0aW9uKGNvZGUpIHtcblx0XHRcdFx0dGhpcy5jb2RlID0gY29kZTtcblx0XHRcdFx0dGhpcy5uYW1lID0gX2ZpbmRLZXkobmFtZWNvZGVzLCBjb2RlKTtcblx0XHRcdFx0dGhpcy5tZXNzYWdlID0gdGhpcy5uYW1lICsgXCI6IERPTUV4Y2VwdGlvbiBcIiArIHRoaXMuY29kZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0QmFzaWMuZXh0ZW5kKERPTUV4Y2VwdGlvbiwgbmFtZWNvZGVzKTtcblx0XHRcdERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFx0XHRyZXR1cm4gRE9NRXhjZXB0aW9uO1xuXHRcdH0oKSksXG5cdFx0XG5cdFx0RXZlbnRFeGNlcHRpb246IChmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmN0aW9uIEV2ZW50RXhjZXB0aW9uKGNvZGUpIHtcblx0XHRcdFx0dGhpcy5jb2RlID0gY29kZTtcblx0XHRcdFx0dGhpcy5uYW1lID0gJ0V2ZW50RXhjZXB0aW9uJztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0QmFzaWMuZXh0ZW5kKEV2ZW50RXhjZXB0aW9uLCB7XG5cdFx0XHRcdFVOU1BFQ0lGSUVEX0VWRU5UX1RZUEVfRVJSOiAwXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0RXZlbnRFeGNlcHRpb24ucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gRXZlbnRFeGNlcHRpb247XG5cdFx0fSgpKVxuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvdXRpbHMvRG9tLmpzXG5cbi8qKlxuICogRG9tLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvY29yZS91dGlscy9Eb20nLCBbJ21veGllL2NvcmUvdXRpbHMvRW52J10sIGZ1bmN0aW9uKEVudikge1xuXG5cdC8qKlxuXHRHZXQgRE9NIEVsZW1lbnQgYnkgaXQncyBpZC5cblxuXHRAbWV0aG9kIGdldFxuXHRAZm9yIFV0aWxzXG5cdEBwYXJhbSB7U3RyaW5nfSBpZCBJZGVudGlmaWVyIG9mIHRoZSBET00gRWxlbWVudFxuXHRAcmV0dXJuIHtET01FbGVtZW50fVxuXHQqL1xuXHR2YXIgZ2V0ID0gZnVuY3Rpb24oaWQpIHtcblx0XHRpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGlkO1xuXHRcdH1cblx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHR9O1xuXG5cdC8qKlxuXHRDaGVja3MgaWYgc3BlY2lmaWVkIERPTSBlbGVtZW50IGhhcyBzcGVjaWZpZWQgY2xhc3MuXG5cblx0QG1ldGhvZCBoYXNDbGFzc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWVcblx0Ki9cblx0dmFyIGhhc0NsYXNzID0gZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG5cdFx0aWYgKCFvYmouY2xhc3NOYW1lKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIrbmFtZStcIihcXFxccyt8JClcIik7XG5cdFx0cmV0dXJuIHJlZ0V4cC50ZXN0KG9iai5jbGFzc05hbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHRBZGRzIHNwZWNpZmllZCBjbGFzc05hbWUgdG8gc3BlY2lmaWVkIERPTSBlbGVtZW50LlxuXG5cdEBtZXRob2QgYWRkQ2xhc3Ncblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IGxpa2Ugb2JqZWN0IHRvIGFkZCBoYW5kbGVyIHRvLlxuXHRAcGFyYW0ge1N0cmluZ30gbmFtZSBDbGFzcyBuYW1lXG5cdCovXG5cdHZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuXHRcdGlmICghaGFzQ2xhc3Mob2JqLCBuYW1lKSkge1xuXHRcdFx0b2JqLmNsYXNzTmFtZSA9ICFvYmouY2xhc3NOYW1lID8gbmFtZSA6IG9iai5jbGFzc05hbWUucmVwbGFjZSgvXFxzKyQvLCAnJykgKyAnICcgKyBuYW1lO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0UmVtb3ZlcyBzcGVjaWZpZWQgY2xhc3NOYW1lIGZyb20gc3BlY2lmaWVkIERPTSBlbGVtZW50LlxuXG5cdEBtZXRob2QgcmVtb3ZlQ2xhc3Ncblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IGxpa2Ugb2JqZWN0IHRvIGFkZCBoYW5kbGVyIHRvLlxuXHRAcGFyYW0ge1N0cmluZ30gbmFtZSBDbGFzcyBuYW1lXG5cdCovXG5cdHZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuXHRcdGlmIChvYmouY2xhc3NOYW1lKSB7XG5cdFx0XHR2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKylcIituYW1lK1wiKFxcXFxzK3wkKVwiKTtcblx0XHRcdG9iai5jbGFzc05hbWUgPSBvYmouY2xhc3NOYW1lLnJlcGxhY2UocmVnRXhwLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7XG5cdFx0XHRcdHJldHVybiAkMSA9PT0gJyAnICYmICQyID09PSAnICcgPyAnICcgOiAnJztcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0UmV0dXJucyBhIGdpdmVuIGNvbXB1dGVkIHN0eWxlIG9mIGEgRE9NIGVsZW1lbnQuXG5cblx0QG1ldGhvZCBnZXRTdHlsZVxuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QuXG5cdEBwYXJhbSB7U3RyaW5nfSBuYW1lIFN0eWxlIHlvdSB3YW50IHRvIGdldCBmcm9tIHRoZSBET00gZWxlbWVudFxuXHQqL1xuXHR2YXIgZ2V0U3R5bGUgPSBmdW5jdGlvbihvYmosIG5hbWUpIHtcblx0XHRpZiAob2JqLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0cmV0dXJuIG9iai5jdXJyZW50U3R5bGVbbmFtZV07XG5cdFx0fSBlbHNlIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHRcdFx0cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG9iaiwgbnVsbClbbmFtZV07XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdFJldHVybnMgdGhlIGFic29sdXRlIHgsIHkgcG9zaXRpb24gb2YgYW4gRWxlbWVudC4gVGhlIHBvc2l0aW9uIHdpbGwgYmUgcmV0dXJuZWQgaW4gYSBvYmplY3Qgd2l0aCB4LCB5IGZpZWxkcy5cblxuXHRAbWV0aG9kIGdldFBvc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7RWxlbWVudH0gbm9kZSBIVE1MIGVsZW1lbnQgb3IgZWxlbWVudCBpZCB0byBnZXQgeCwgeSBwb3NpdGlvbiBmcm9tLlxuXHRAcGFyYW0ge0VsZW1lbnR9IHJvb3QgT3B0aW9uYWwgcm9vdCBlbGVtZW50IHRvIHN0b3AgY2FsY3VsYXRpb25zIGF0LlxuXHRAcmV0dXJuIHtvYmplY3R9IEFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBvYmplY3Qgd2l0aCB4LCB5IGZpZWxkcy5cblx0Ki9cblx0dmFyIGdldFBvcyA9IGZ1bmN0aW9uKG5vZGUsIHJvb3QpIHtcblx0XHR2YXIgeCA9IDAsIHkgPSAwLCBwYXJlbnQsIGRvYyA9IGRvY3VtZW50LCBub2RlUmVjdCwgcm9vdFJlY3Q7XG5cblx0XHRub2RlID0gbm9kZTtcblx0XHRyb290ID0gcm9vdCB8fCBkb2MuYm9keTtcblxuXHRcdC8vIFJldHVybnMgdGhlIHgsIHkgY29yZGluYXRlIGZvciBhbiBlbGVtZW50IG9uIElFIDYgYW5kIElFIDdcblx0XHRmdW5jdGlvbiBnZXRJRVBvcyhub2RlKSB7XG5cdFx0XHR2YXIgYm9keUVsbSwgcmVjdCwgeCA9IDAsIHkgPSAwO1xuXG5cdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRyZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0Ym9keUVsbSA9IGRvYy5jb21wYXRNb2RlID09PSBcIkNTUzFDb21wYXRcIiA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBkb2MuYm9keTtcblx0XHRcdFx0eCA9IHJlY3QubGVmdCArIGJvZHlFbG0uc2Nyb2xsTGVmdDtcblx0XHRcdFx0eSA9IHJlY3QudG9wICsgYm9keUVsbS5zY3JvbGxUb3A7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHggOiB4LFxuXHRcdFx0XHR5IDogeVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIElFIDYgYW5kIElFIDcgYnV0IG5vdCBvbiBJRSA4IGluIHN0YW5kYXJkcyBtb2RlXG5cdFx0aWYgKG5vZGUgJiYgbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgRW52LmJyb3dzZXIgPT09ICdJRScgJiYgKCFkb2MuZG9jdW1lbnRNb2RlIHx8IGRvYy5kb2N1bWVudE1vZGUgPCA4KSkge1xuXHRcdFx0bm9kZVJlY3QgPSBnZXRJRVBvcyhub2RlKTtcblx0XHRcdHJvb3RSZWN0ID0gZ2V0SUVQb3Mocm9vdCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHggOiBub2RlUmVjdC54IC0gcm9vdFJlY3QueCxcblx0XHRcdFx0eSA6IG5vZGVSZWN0LnkgLSByb290UmVjdC55XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHBhcmVudCA9IG5vZGU7XG5cdFx0d2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT0gcm9vdCAmJiBwYXJlbnQubm9kZVR5cGUpIHtcblx0XHRcdHggKz0gcGFyZW50Lm9mZnNldExlZnQgfHwgMDtcblx0XHRcdHkgKz0gcGFyZW50Lm9mZnNldFRvcCB8fCAwO1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHR9XG5cblx0XHRwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0d2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT0gcm9vdCAmJiBwYXJlbnQubm9kZVR5cGUpIHtcblx0XHRcdHggLT0gcGFyZW50LnNjcm9sbExlZnQgfHwgMDtcblx0XHRcdHkgLT0gcGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHggOiB4LFxuXHRcdFx0eSA6IHlcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHRSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBzcGVjaWZpZWQgbm9kZSBpbiBwaXhlbHMuXG5cblx0QG1ldGhvZCBnZXRTaXplXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gZ2V0IHRoZSBzaXplIG9mLlxuXHRAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGEgdyBhbmQgaCBwcm9wZXJ0eS5cblx0Ki9cblx0dmFyIGdldFNpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHcgOiBub2RlLm9mZnNldFdpZHRoIHx8IG5vZGUuY2xpZW50V2lkdGgsXG5cdFx0XHRoIDogbm9kZS5vZmZzZXRIZWlnaHQgfHwgbm9kZS5jbGllbnRIZWlnaHRcblx0XHR9O1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0aGFzQ2xhc3M6IGhhc0NsYXNzLFxuXHRcdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0XHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdFx0Z2V0U3R5bGU6IGdldFN0eWxlLFxuXHRcdGdldFBvczogZ2V0UG9zLFxuXHRcdGdldFNpemU6IGdldFNpemVcblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL0V2ZW50VGFyZ2V0LmpzXG5cbi8qKlxuICogRXZlbnRUYXJnZXQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0JywgW1xuXHQnbW94aWUvY29yZS91dGlscy9FbnYnLFxuXHQnbW94aWUvY29yZS9FeGNlcHRpb25zJyxcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnXG5dLCBmdW5jdGlvbihFbnYsIHgsIEJhc2ljKSB7XG5cblx0Ly8gaGFzaCBvZiBldmVudCBsaXN0ZW5lcnMgYnkgb2JqZWN0IHVpZFxuXHR2YXIgZXZlbnRwb29sID0ge307XG5cblx0LyoqXG5cdFBhcmVudCBvYmplY3QgZm9yIGFsbCBldmVudCBkaXNwYXRjaGluZyBjb21wb25lbnRzIGFuZCBvYmplY3RzXG5cblx0QGNsYXNzIG1veGllL2NvcmUvRXZlbnRUYXJnZXRcblx0QGNvbnN0cnVjdG9yIEV2ZW50VGFyZ2V0XG5cdCovXG5cdGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuXHRcdC8qKlxuXHRcdFVuaXF1ZSBpZCBvZiB0aGUgZXZlbnQgZGlzcGF0Y2hlciwgdXN1YWxseSBvdmVycmlkZW4gYnkgY2hpbGRyZW5cblxuXHRcdEBwcm9wZXJ0eSB1aWRcblx0XHRAdHlwZSBTdHJpbmdcblx0XHQqL1xuXHRcdHRoaXMudWlkID0gQmFzaWMuZ3VpZCgpO1xuXHR9XG5cblxuXHRCYXNpYy5leHRlbmQoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG5cblx0XHQvKipcblx0XHRDYW4gYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgY2hpbGQgIGluIG9yZGVyIHRvIGFjcXVpcmUgdW5pcWllIGlkIGluIGF1dG9tYXRlZCBtYW5uZXJcblxuXHRcdEBtZXRob2QgaW5pdFxuXHRcdCovXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMudWlkKSB7XG5cdFx0XHRcdHRoaXMudWlkID0gQmFzaWMuZ3VpZCgndWlkXycpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHRSZWdpc3RlciBhIGhhbmRsZXIgdG8gYSBzcGVjaWZpYyBldmVudCBkaXNwYXRjaGVkIGJ5IHRoZSBvYmplY3RcblxuXHRcdEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxuXHRcdEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb3IgYmFzaWNhbGx5IGEgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXG5cdFx0QHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGV2ZW50IGhhcHBlbnNcblx0XHRAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5PTBdIFByaW9yaXR5IG9mIHRoZSBldmVudCBoYW5kbGVyIC0gaGFuZGxlcnMgd2l0aCBoaWdoZXIgcHJpb3JpdGllcyB3aWxsIGJlIGNhbGxlZCBmaXJzdFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBbc2NvcGU9dGhpc10gQSBzY29wZSB0byBpbnZva2UgZXZlbnQgaGFuZGxlciBpblxuXHRcdCovXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24odHlwZSwgZm4sIHByaW9yaXR5LCBzY29wZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBsaXN0O1xuXG5cdFx0XHQvLyB3aXRob3V0IHVpZCBubyBldmVudCBoYW5kbGVycyBjYW4gYmUgYWRkZWQsIHNvIG1ha2Ugc3VyZSB3ZSBnb3Qgb25lXG5cdFx0XHRpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ3VpZCcpKSB7XG5cdFx0XHRcdHRoaXMudWlkID0gQmFzaWMuZ3VpZCgndWlkXycpO1xuXHRcdFx0fVxuXG5cdFx0XHR0eXBlID0gQmFzaWMudHJpbSh0eXBlKTtcblxuXHRcdFx0aWYgKC9cXHMvLnRlc3QodHlwZSkpIHtcblx0XHRcdFx0Ly8gbXVsdGlwbGUgZXZlbnQgdHlwZXMgd2VyZSBwYXNzZWQgZm9yIG9uZSBoYW5kbGVyXG5cdFx0XHRcdEJhc2ljLmVhY2godHlwZS5zcGxpdCgvXFxzKy8pLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0c2VsZi5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBwcmlvcml0eSwgc2NvcGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cHJpb3JpdHkgPSBwYXJzZUludChwcmlvcml0eSwgMTApIHx8IDA7XG5cblx0XHRcdGxpc3QgPSBldmVudHBvb2xbdGhpcy51aWRdICYmIGV2ZW50cG9vbFt0aGlzLnVpZF1bdHlwZV0gfHwgW107XG5cdFx0XHRsaXN0LnB1c2goe2ZuIDogZm4sIHByaW9yaXR5IDogcHJpb3JpdHksIHNjb3BlIDogc2NvcGUgfHwgdGhpc30pO1xuXG5cdFx0XHRpZiAoIWV2ZW50cG9vbFt0aGlzLnVpZF0pIHtcblx0XHRcdFx0ZXZlbnRwb29sW3RoaXMudWlkXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0ZXZlbnRwb29sW3RoaXMudWlkXVt0eXBlXSA9IGxpc3Q7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdENoZWNrIGlmIGFueSBoYW5kbGVycyB3ZXJlIHJlZ2lzdGVyZWQgdG8gdGhlIHNwZWNpZmllZCBldmVudFxuXG5cdFx0QG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXG5cdFx0QHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUeXBlIG9yIGJhc2ljYWxseSBhIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGNoZWNrXG5cdFx0QHJldHVybiB7TWl4ZWR9IFJldHVybnMgYSBoYW5kbGVyIGlmIGl0IHdhcyBmb3VuZCBhbmQgZmFsc2UsIGlmIC0gbm90XG5cdFx0Ki9cblx0XHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgbGlzdDtcblx0XHRcdGlmICh0eXBlKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGxpc3QgPSBldmVudHBvb2xbdGhpcy51aWRdICYmIGV2ZW50cG9vbFt0aGlzLnVpZF1bdHlwZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaXN0ID0gZXZlbnRwb29sW3RoaXMudWlkXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsaXN0ID8gbGlzdCA6IGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHRVbnJlZ2lzdGVyIHRoZSBoYW5kbGVyIGZyb20gdGhlIGV2ZW50LCBvciBpZiBmb3JtZXIgd2FzIG5vdCBzcGVjaWZpZWQgLSB1bnJlZ2lzdGVyIGFsbCBoYW5kbGVyc1xuXG5cdFx0QG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG5cdFx0QHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvciBiYXNpY2FsbHkgYSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gSGFuZGxlciB0byB1bnJlZ2lzdGVyXG5cdFx0Ki9cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBmbikge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBsaXN0LCBpO1xuXG5cdFx0XHR0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoL1xccy8udGVzdCh0eXBlKSkge1xuXHRcdFx0XHQvLyBtdWx0aXBsZSBldmVudCB0eXBlcyB3ZXJlIHBhc3NlZCBmb3Igb25lIGhhbmRsZXJcblx0XHRcdFx0QmFzaWMuZWFjaCh0eXBlLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHRzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRsaXN0ID0gZXZlbnRwb29sW3RoaXMudWlkXSAmJiBldmVudHBvb2xbdGhpcy51aWRdW3R5cGVdO1xuXG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpZiAoZm4pIHtcblx0XHRcdFx0XHRmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRpZiAobGlzdFtpXS5mbiA9PT0gZm4pIHtcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkZWxldGUgZXZlbnQgbGlzdCBpZiBpdCBoYXMgYmVjb21lIGVtcHR5XG5cdFx0XHRcdGlmICghbGlzdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRkZWxldGUgZXZlbnRwb29sW3RoaXMudWlkXVt0eXBlXTtcblxuXHRcdFx0XHRcdC8vIGFuZCBvYmplY3Qgc3BlY2lmaWMgZW50cnkgaW4gYSBoYXNoIGlmIGl0IGhhcyBubyBtb3JlIGxpc3RlbmVycyBhdHRhY2hlZFxuXHRcdFx0XHRcdGlmIChCYXNpYy5pc0VtcHR5T2JqKGV2ZW50cG9vbFt0aGlzLnVpZF0pKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgZXZlbnRwb29sW3RoaXMudWlkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0UmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyBmcm9tIHRoZSBvYmplY3RcblxuXHRcdEBtZXRob2QgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcblx0XHQqL1xuXHRcdHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChldmVudHBvb2xbdGhpcy51aWRdKSB7XG5cdFx0XHRcdGRlbGV0ZSBldmVudHBvb2xbdGhpcy51aWRdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHREaXNwYXRjaCB0aGUgZXZlbnRcblxuXHRcdEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuXHRcdEBwYXJhbSB7U3RyaW5nL09iamVjdH0gVHlwZSBvZiBldmVudCBvciBldmVudCBvYmplY3QgdG8gZGlzcGF0Y2hcblx0XHRAcGFyYW0ge01peGVkfSBbLi4uXSBWYXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBhIGhhbmRsZXJzXG5cdFx0QHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBieSBkZWZhdWx0IGFuZCBmYWxzZSBpZiBhbnkgaGFuZGxlciByZXR1cm5lZCBmYWxzZVxuXHRcdCovXG5cdFx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIHVpZCwgbGlzdCwgYXJncywgdG1wRXZ0LCBldnQgPSB7fSwgcmVzdWx0ID0gdHJ1ZSwgdW5kZWY7XG5cblx0XHRcdGlmIChCYXNpYy50eXBlT2YodHlwZSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIHdlIGNhbid0IHVzZSBvcmlnaW5hbCBvYmplY3QgZGlyZWN0bHkgKGJlY2F1c2Ugb2YgU2lsdmVybGlnaHQpXG5cdFx0XHRcdHRtcEV2dCA9IHR5cGU7XG5cblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZih0bXBFdnQudHlwZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dHlwZSA9IHRtcEV2dC50eXBlO1xuXG5cdFx0XHRcdFx0aWYgKHRtcEV2dC50b3RhbCAhPT0gdW5kZWYgJiYgdG1wRXZ0LmxvYWRlZCAhPT0gdW5kZWYpIHsgLy8gcHJvZ3Jlc3MgZXZlbnRcblx0XHRcdFx0XHRcdGV2dC50b3RhbCA9IHRtcEV2dC50b3RhbDtcblx0XHRcdFx0XHRcdGV2dC5sb2FkZWQgPSB0bXBFdnQubG9hZGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRldnQuYXN5bmMgPSB0bXBFdnQuYXN5bmMgfHwgZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRXZlbnRFeGNlcHRpb24oeC5FdmVudEV4Y2VwdGlvbi5VTlNQRUNJRklFRF9FVkVOVF9UWVBFX0VSUik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaWYgZXZlbnQgaXMgbWVhbnQgdG8gYmUgZGlzcGF0Y2hlZCBvbiBhbiBvYmplY3QgaGF2aW5nIHNwZWNpZmljIHVpZFxuXHRcdFx0aWYgKHR5cGUuaW5kZXhPZignOjonKSAhPT0gLTEpIHtcblx0XHRcdFx0KGZ1bmN0aW9uKGFycikge1xuXHRcdFx0XHRcdHVpZCA9IGFyclswXTtcblx0XHRcdFx0XHR0eXBlID0gYXJyWzFdO1xuXHRcdFx0XHR9KHR5cGUuc3BsaXQoJzo6JykpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVpZCA9IHRoaXMudWlkO1xuXHRcdFx0fVxuXG5cdFx0XHR0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRsaXN0ID0gZXZlbnRwb29sW3VpZF0gJiYgZXZlbnRwb29sW3VpZF1bdHlwZV07XG5cblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdC8vIHNvcnQgZXZlbnQgbGlzdCBieSBwcm9yaXR5XG5cdFx0XHRcdGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTsgfSk7XG5cblx0XHRcdFx0YXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBmaXJzdCBhcmd1bWVudCB3aWxsIGJlIHBzZXVkby1ldmVudCBvYmplY3Rcblx0XHRcdFx0YXJncy5zaGlmdCgpO1xuXHRcdFx0XHRldnQudHlwZSA9IHR5cGU7XG5cdFx0XHRcdGFyZ3MudW5zaGlmdChldnQpO1xuXG5cdFx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLmV2ZW50cykge1xuXHRcdFx0XHRcdEVudi5sb2coXCJFdmVudCAnJXMnIGZpcmVkIG9uICV1XCIsIGV2dC50eXBlLCB1aWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGlzcGF0Y2ggZXZlbnQgdG8gYWxsIGxpc3RlbmVyc1xuXHRcdFx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHRcdFx0QmFzaWMuZWFjaChsaXN0LCBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRcdFx0Ly8gZXhwbGljaXRseSBzZXQgdGhlIHRhcmdldCwgb3RoZXJ3aXNlIGV2ZW50cyBmaXJlZCBmcm9tIHNoaW1zIGRvIG5vdCBnZXQgaXRcblx0XHRcdFx0XHRhcmdzWzBdLnRhcmdldCA9IGhhbmRsZXIuc2NvcGU7XG5cdFx0XHRcdFx0Ly8gaWYgZXZlbnQgaXMgbWFya2VkIGFzIGFzeW5jLCBkZXRhY2ggdGhlIGhhbmRsZXJcblx0XHRcdFx0XHRpZiAoZXZ0LmFzeW5jKSB7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2IoaGFuZGxlci5mbi5hcHBseShoYW5kbGVyLnNjb3BlLCBhcmdzKSA9PT0gZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHR9LCAxKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdFx0XHRcdGNiKGhhbmRsZXIuZm4uYXBwbHkoaGFuZGxlci5zY29wZSwgYXJncykgPT09IGZhbHNlKTsgLy8gaWYgaGFuZGxlciByZXR1cm5zIGZhbHNlIHN0b3AgcHJvcGFnYXRpb25cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChxdWV1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRCYXNpYy5pblNlcmllcyhxdWV1ZSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSAhZXJyO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHRSZWdpc3RlciBhIGhhbmRsZXIgdG8gdGhlIGV2ZW50IHR5cGUgdGhhdCB3aWxsIHJ1biBvbmx5IG9uY2VcblxuXHRcdEBtZXRob2QgYmluZE9uY2Vcblx0XHRAc2luY2UgPjEuNC4xXG5cdFx0QHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvciBiYXNpY2FsbHkgYSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG9cblx0XHRAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gZXZlbnQgaGFwcGVuc1xuXHRcdEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHk9MF0gUHJpb3JpdHkgb2YgdGhlIGV2ZW50IGhhbmRsZXIgLSBoYW5kbGVycyB3aXRoIGhpZ2hlciBwcmlvcml0aWVzIHdpbGwgYmUgY2FsbGVkIGZpcnN0XG5cdFx0QHBhcmFtIHtPYmplY3R9IFtzY29wZT10aGlzXSBBIHNjb3BlIHRvIGludm9rZSBldmVudCBoYW5kbGVyIGluXG5cdFx0Ki9cblx0XHRiaW5kT25jZTogZnVuY3Rpb24odHlwZSwgZm4sIHByaW9yaXR5LCBzY29wZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0c2VsZi5iaW5kLmNhbGwodGhpcywgdHlwZSwgZnVuY3Rpb24gY2IoKSB7XG5cdFx0XHRcdHNlbGYudW5iaW5kKHR5cGUsIGNiKTtcblx0XHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LCBwcmlvcml0eSwgc2NvcGUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHRBbGlhcyBmb3IgYWRkRXZlbnRMaXN0ZW5lclxuXG5cdFx0QG1ldGhvZCBiaW5kXG5cdFx0QHByb3RlY3RlZFxuXHRcdCovXG5cdFx0YmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0QWxpYXMgZm9yIHJlbW92ZUV2ZW50TGlzdGVuZXJcblxuXHRcdEBtZXRob2QgdW5iaW5kXG5cdFx0QHByb3RlY3RlZFxuXHRcdCovXG5cdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHRBbGlhcyBmb3IgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcblxuXHRcdEBtZXRob2QgdW5iaW5kQWxsXG5cdFx0QHByb3RlY3RlZFxuXHRcdCovXG5cdFx0dW5iaW5kQWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0QWxpYXMgZm9yIGRpc3BhdGNoRXZlbnRcblxuXHRcdEBtZXRob2QgdHJpZ2dlclxuXHRcdEBwcm90ZWN0ZWRcblx0XHQqL1xuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdEhhbmRsZSBwcm9wZXJ0aWVzIG9mIG9uW2V2ZW50XSB0eXBlLlxuXG5cdFx0QG1ldGhvZCBoYW5kbGVFdmVudFByb3BzXG5cdFx0QHByaXZhdGVcblx0XHQqL1xuXHRcdGhhbmRsZUV2ZW50UHJvcHM6IGZ1bmN0aW9uKGRpc3BhdGNoZXMpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0dGhpcy5iaW5kKGRpc3BhdGNoZXMuam9pbignICcpLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHZhciBwcm9wID0gJ29uJyArIGUudHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKHRoaXNbcHJvcF0pID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhpc1twcm9wXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gb2JqZWN0IG11c3QgaGF2ZSBkZWZpbmVkIGV2ZW50IHByb3BlcnRpZXMsIGV2ZW4gaWYgaXQgZG9lc24ndCBtYWtlIHVzZSBvZiB0aGVtXG5cdFx0XHRCYXNpYy5lYWNoKGRpc3BhdGNoZXMsIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0cHJvcCA9ICdvbicgKyBwcm9wLnRvTG93ZXJDYXNlKHByb3ApO1xuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKHNlbGZbcHJvcF0pID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHNlbGZbcHJvcF0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0fSk7XG5cblxuXHRFdmVudFRhcmdldC5pbnN0YW5jZSA9IG5ldyBFdmVudFRhcmdldCgpO1xuXG5cdHJldHVybiBFdmVudFRhcmdldDtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL1J1bnRpbWUuanNcblxuLyoqXG4gKiBSdW50aW1lLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvcnVudGltZS9SdW50aW1lJywgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRG9tXCIsXG5cdFwibW94aWUvY29yZS9FdmVudFRhcmdldFwiXG5dLCBmdW5jdGlvbihFbnYsIEJhc2ljLCBEb20sIEV2ZW50VGFyZ2V0KSB7XG5cdHZhciBydW50aW1lQ29uc3RydWN0b3JzID0ge30sIHJ1bnRpbWVzID0ge307XG5cblx0LyoqXG5cdENvbW1vbiBzZXQgb2YgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBmb3IgZXZlcnkgcnVudGltZSBpbnN0YW5jZVxuXG5cdEBjbGFzcyBtb3hpZS9ydW50aW1lL1J1bnRpbWVcblxuXHRAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRAcGFyYW0ge1N0cmluZ30gdHlwZSBTYW5pdGl6ZWQgbmFtZSBvZiB0aGUgcnVudGltZVxuXHRAcGFyYW0ge09iamVjdH0gW2NhcHNdIFNldCBvZiBjYXBhYmlsaXRpZXMgdGhhdCBkaWZmZXJlbnRpYXRlIHNwZWNpZmllZCBydW50aW1lXG5cdEBwYXJhbSB7T2JqZWN0fSBbbW9kZUNhcHNdIFNldCBvZiBjYXBhYmlsaXRpZXMgdGhhdCBkbyByZXF1aXJlIHNwZWNpZmljIG9wZXJhdGlvbmFsIG1vZGVcblx0QHBhcmFtIHtTdHJpbmd9IFtwcmVmZXJyZWRNb2RlPSdicm93c2VyJ10gUHJlZmVycmVkIG9wZXJhdGlvbmFsIG1vZGUgdG8gY2hvb3NlIGlmIG5vIHJlcXVpcmVkIGNhcGFiaWxpdGllcyB3ZXJlIHJlcXVlc3RlZFxuXHQqL1xuXHRmdW5jdGlvbiBSdW50aW1lKG9wdGlvbnMsIHR5cGUsIGNhcHMsIG1vZGVDYXBzLCBwcmVmZXJyZWRNb2RlKSB7XG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIHJ1bnRpbWUgaXMgaW5pdGlhbGl6ZWQgYW5kIHJlYWR5LlxuXHRcdFJlc3VsdHMgaW4gUnVudGltZUluaXQgb24gYSBjb25uZWN0ZWQgY29tcG9uZW50LlxuXG5cdFx0QGV2ZW50IEluaXRcblx0XHQqL1xuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIHJ1bnRpbWUgZmFpbHMgdG8gaW5pdGlhbGl6ZS5cblx0XHRSZXN1bHRzIGluIFJ1bnRpbWVFcnJvciBvbiBhIGNvbm5lY3RlZCBjb21wb25lbnQuXG5cblx0XHRAZXZlbnQgRXJyb3Jcblx0XHQqL1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0LCBfc2hpbVxuXHRcdCwgX3VpZCA9IEJhc2ljLmd1aWQodHlwZSArICdfJylcblx0XHQsIGRlZmF1bHRNb2RlID0gcHJlZmVycmVkTW9kZSB8fCAnYnJvd3Nlcidcblx0XHQ7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIHJlZ2lzdGVyIHJ1bnRpbWUgaW4gcHJpdmF0ZSBoYXNoXG5cdFx0cnVudGltZXNbX3VpZF0gPSB0aGlzO1xuXG5cdFx0LyoqXG5cdFx0RGVmYXVsdCBzZXQgb2YgY2FwYWJpbGl0aWVzLCB3aGljaCBjYW4gYmUgcmVkaWZpbmVkIGxhdGVyIGJ5IHNwZWNpZmljIHJ1bnRpbWVcblxuXHRcdEBwcml2YXRlXG5cdFx0QHByb3BlcnR5IGNhcHNcblx0XHRAdHlwZSBPYmplY3Rcblx0XHQqL1xuXHRcdGNhcHMgPSBCYXNpYy5leHRlbmQoe1xuXHRcdFx0Ly8gUnVudGltZSBjYW46IFxuXHRcdFx0Ly8gcHJvdmlkZSBhY2Nlc3MgdG8gcmF3IGJpbmFyeSBkYXRhIG9mIHRoZSBmaWxlXG5cdFx0XHRhY2Nlc3NfYmluYXJ5OiBmYWxzZSxcblx0XHRcdC8vIHByb3ZpZGUgYWNjZXNzIHRvIHJhdyBiaW5hcnkgZGF0YSBvZiB0aGUgaW1hZ2UgKGltYWdlIGV4dGVuc2lvbiBpcyBvcHRpb25hbCkgXG5cdFx0XHRhY2Nlc3NfaW1hZ2VfYmluYXJ5OiBmYWxzZSxcblx0XHRcdC8vIGRpc3BsYXkgYmluYXJ5IGRhdGEgYXMgdGh1bWJzIGZvciBleGFtcGxlXG5cdFx0XHRkaXNwbGF5X21lZGlhOiBmYWxzZSxcblx0XHRcdC8vIG1ha2UgY3Jvc3MtZG9tYWluIHJlcXVlc3RzXG5cdFx0XHRkb19jb3JzOiBmYWxzZSxcblx0XHRcdC8vIGFjY2VwdCBmaWxlcyBkcmFnZ2VkIGFuZCBkcm9wcGVkIGZyb20gdGhlIGRlc2t0b3Bcblx0XHRcdGRyYWdfYW5kX2Ryb3A6IGZhbHNlLFxuXHRcdFx0Ly8gZmlsdGVyIGZpbGVzIGluIHNlbGVjdGlvbiBkaWFsb2cgYnkgdGhlaXIgZXh0ZW5zaW9uc1xuXHRcdFx0ZmlsdGVyX2J5X2V4dGVuc2lvbjogdHJ1ZSxcblx0XHRcdC8vIHJlc2l6ZSBpbWFnZSAoYW5kIG1hbmlwdWxhdGUgaXQgcmF3IGRhdGEgb2YgYW55IGZpbGUgaW4gZ2VuZXJhbClcblx0XHRcdHJlc2l6ZV9pbWFnZTogZmFsc2UsXG5cdFx0XHQvLyBwZXJpb2RpY2FsbHkgcmVwb3J0IGhvdyBtYW55IGJ5dGVzIG9mIHRvdGFsIGluIHRoZSBmaWxlIHdlcmUgdXBsb2FkZWQgKGxvYWRlZClcblx0XHRcdHJlcG9ydF91cGxvYWRfcHJvZ3Jlc3M6IGZhbHNlLFxuXHRcdFx0Ly8gcHJvdmlkZSBhY2Nlc3MgdG8gdGhlIGhlYWRlcnMgb2YgaHR0cCByZXNwb25zZSBcblx0XHRcdHJldHVybl9yZXNwb25zZV9oZWFkZXJzOiBmYWxzZSxcblx0XHRcdC8vIHN1cHBvcnQgcmVzcG9uc2Ugb2Ygc3BlY2lmaWMgdHlwZSwgd2hpY2ggc2hvdWxkIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudFxuXHRcdFx0Ly8gZS5nLiBydW50aW1lLmNhbigncmV0dXJuX3Jlc3BvbnNlX3R5cGUnLCAnYmxvYicpXG5cdFx0XHRyZXR1cm5fcmVzcG9uc2VfdHlwZTogZmFsc2UsXG5cdFx0XHQvLyByZXR1cm4gaHR0cCBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2Vcblx0XHRcdHJldHVybl9zdGF0dXNfY29kZTogdHJ1ZSxcblx0XHRcdC8vIHNlbmQgY3VzdG9tIGh0dHAgaGVhZGVyIHdpdGggdGhlIHJlcXVlc3Rcblx0XHRcdHNlbmRfY3VzdG9tX2hlYWRlcnM6IGZhbHNlLFxuXHRcdFx0Ly8gcGljayB1cCB0aGUgZmlsZXMgZnJvbSBhIGRpYWxvZ1xuXHRcdFx0c2VsZWN0X2ZpbGU6IGZhbHNlLFxuXHRcdFx0Ly8gc2VsZWN0IHdob2xlIGZvbGRlciBpbiBmaWxlIGJyb3dzZSBkaWFsb2dcblx0XHRcdHNlbGVjdF9mb2xkZXI6IGZhbHNlLFxuXHRcdFx0Ly8gc2VsZWN0IG11bHRpcGxlIGZpbGVzIGF0IG9uY2UgaW4gZmlsZSBicm93c2UgZGlhbG9nXG5cdFx0XHRzZWxlY3RfbXVsdGlwbGU6IHRydWUsXG5cdFx0XHQvLyBzZW5kIHJhdyBiaW5hcnkgZGF0YSwgdGhhdCBpcyBnZW5lcmF0ZWQgYWZ0ZXIgaW1hZ2UgcmVzaXppbmcgb3IgbWFuaXB1bGF0aW9uIG9mIG90aGVyIGtpbmRcblx0XHRcdHNlbmRfYmluYXJ5X3N0cmluZzogZmFsc2UsXG5cdFx0XHQvLyBzZW5kIGNvb2tpZXMgd2l0aCBodHRwIHJlcXVlc3QgYW5kIHRoZXJlZm9yZSByZXRhaW4gc2Vzc2lvblxuXHRcdFx0c2VuZF9icm93c2VyX2Nvb2tpZXM6IHRydWUsXG5cdFx0XHQvLyBzZW5kIGRhdGEgZm9ybWF0dGVkIGFzIG11bHRpcGFydC9mb3JtLWRhdGFcblx0XHRcdHNlbmRfbXVsdGlwYXJ0OiB0cnVlLFxuXHRcdFx0Ly8gc2xpY2UgdGhlIGZpbGUgb3IgYmxvYiB0byBzbWFsbGVyIHBhcnRzXG5cdFx0XHRzbGljZV9ibG9iOiBmYWxzZSxcblx0XHRcdC8vIHVwbG9hZCBmaWxlIHdpdGhvdXQgcHJlbG9hZGluZyBpdCB0byBtZW1vcnksIHN0cmVhbSBpdCBvdXQgZGlyZWN0bHkgZnJvbSBkaXNrXG5cdFx0XHRzdHJlYW1fdXBsb2FkOiBmYWxzZSxcblx0XHRcdC8vIHByb2dyYW1tYXRpY2FsbHkgdHJpZ2dlciBmaWxlIGJyb3dzZSBkaWFsb2dcblx0XHRcdHN1bW1vbl9maWxlX2RpYWxvZzogZmFsc2UsXG5cdFx0XHQvLyB1cGxvYWQgZmlsZSBvZiBzcGVjaWZpYyBzaXplLCBzaXplIHNob3VsZCBiZSBwYXNzZWQgYXMgYXJndW1lbnRcblx0XHRcdC8vIGUuZy4gcnVudGltZS5jYW4oJ3VwbG9hZF9maWxlc2l6ZScsICc1MDBtYicpXG5cdFx0XHR1cGxvYWRfZmlsZXNpemU6IHRydWUsXG5cdFx0XHQvLyBpbml0aWF0ZSBodHRwIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBodHRwIG1ldGhvZCwgbWV0aG9kIHNob3VsZCBiZSBwYXNzZWQgYXMgYXJndW1lbnRcblx0XHRcdC8vIGUuZy4gcnVudGltZS5jYW4oJ3VzZV9odHRwX21ldGhvZCcsICdwdXQnKVxuXHRcdFx0dXNlX2h0dHBfbWV0aG9kOiB0cnVlXG5cdFx0fSwgY2Fwcyk7XG5cdFx0XHRcblx0XG5cdFx0Ly8gZGVmYXVsdCB0byB0aGUgbW9kZSB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBwcmVmZXJyZWQgY2Fwc1xuXHRcdGlmIChvcHRpb25zLnByZWZlcnJlZF9jYXBzKSB7XG5cdFx0XHRkZWZhdWx0TW9kZSA9IFJ1bnRpbWUuZ2V0TW9kZShtb2RlQ2Fwcywgb3B0aW9ucy5wcmVmZXJyZWRfY2FwcywgZGVmYXVsdE1vZGUpO1xuXHRcdH1cblxuXHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdEVudi5sb2coXCJcXHRkZWZhdWx0IG1vZGU6ICVzXCIsIGRlZmF1bHRNb2RlKTtcdFxuXHRcdH1cblx0XHRcblx0XHQvLyBzbWFsbCBleHRlbnNpb24gZmFjdG9yeSBoZXJlIChpcyBtZWFudCB0byBiZSBleHRlbmRlZCB3aXRoIGFjdHVhbCBleHRlbnNpb25zIGNvbnN0cnVjdG9ycylcblx0XHRfc2hpbSA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvYmpwb29sID0ge307XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleGVjOiBmdW5jdGlvbih1aWQsIGNvbXAsIGZuLCBhcmdzKSB7XG5cdFx0XHRcdFx0aWYgKF9zaGltW2NvbXBdKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW9ianBvb2xbdWlkXSkge1xuXHRcdFx0XHRcdFx0XHRvYmpwb29sW3VpZF0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGV4dDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRpbnN0YW5jZTogbmV3IF9zaGltW2NvbXBdKClcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChvYmpwb29sW3VpZF0uaW5zdGFuY2VbZm5dKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBvYmpwb29sW3VpZF0uaW5zdGFuY2VbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRyZW1vdmVJbnN0YW5jZTogZnVuY3Rpb24odWlkKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG9ianBvb2xbdWlkXTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRyZW1vdmVBbGxJbnN0YW5jZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0XHRCYXNpYy5lYWNoKG9ianBvb2wsIGZ1bmN0aW9uKG9iaiwgdWlkKSB7XG5cdFx0XHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKG9iai5pbnN0YW5jZS5kZXN0cm95KSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRvYmouaW5zdGFuY2UuZGVzdHJveS5jYWxsKG9iai5jb250ZXh0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlSW5zdGFuY2UodWlkKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9KCkpO1xuXG5cblx0XHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHQvKipcblx0XHRcdFNwZWNpZmllcyB3aGV0aGVyIHJ1bnRpbWUgaW5zdGFuY2Ugd2FzIGluaXRpYWxpemVkIG9yIG5vdFxuXG5cdFx0XHRAcHJvcGVydHkgaW5pdGlhbGl6ZWRcblx0XHRcdEB0eXBlIHtCb29sZWFufVxuXHRcdFx0QGRlZmF1bHQgZmFsc2Vcblx0XHRcdCovXG5cdFx0XHRpbml0aWFsaXplZDogZmFsc2UsIC8vIHNoaW1zIHJlcXVpcmUgdGhpcyBmbGFnIHRvIHN0b3AgaW5pdGlhbGl6YXRpb24gcmV0cmllc1xuXG5cdFx0XHQvKipcblx0XHRcdFVuaXF1ZSBJRCBvZiB0aGUgcnVudGltZVxuXG5cdFx0XHRAcHJvcGVydHkgdWlkXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0Ki9cblx0XHRcdHVpZDogX3VpZCxcblxuXHRcdFx0LyoqXG5cdFx0XHRSdW50aW1lIHR5cGUgKGUuZy4gZmxhc2gsIGh0bWw1LCBldGMpXG5cblx0XHRcdEBwcm9wZXJ0eSB0eXBlXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0Ki9cblx0XHRcdHR5cGU6IHR5cGUsXG5cblx0XHRcdC8qKlxuXHRcdFx0UnVudGltZSAobm90IG5hdGl2ZSBvbmUpIG1heSBvcGVyYXRlIGluIGJyb3dzZXIgb3IgY2xpZW50IG1vZGUuXG5cblx0XHRcdEBwcm9wZXJ0eSBtb2RlXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHR5cGUge1N0cmluZ3xCb29sZWFufSBjdXJyZW50IG1vZGUgb3IgZmFsc2UsIGlmIG5vbmUgcG9zc2libGVcblx0XHRcdCovXG5cdFx0XHRtb2RlOiBSdW50aW1lLmdldE1vZGUobW9kZUNhcHMsIChvcHRpb25zLnJlcXVpcmVkX2NhcHMpLCBkZWZhdWx0TW9kZSksXG5cblx0XHRcdC8qKlxuXHRcdFx0aWQgb2YgdGhlIERPTSBjb250YWluZXIgZm9yIHRoZSBydW50aW1lIChpZiBhdmFpbGFibGUpXG5cblx0XHRcdEBwcm9wZXJ0eSBzaGltaWRcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0c2hpbWlkOiBfdWlkICsgJ19jb250YWluZXInLFxuXG5cdFx0XHQvKipcblx0XHRcdE51bWJlciBvZiBjb25uZWN0ZWQgY2xpZW50cy4gSWYgZXF1YWwgdG8gemVybywgcnVudGltZSBjYW4gYmUgZGVzdHJveWVkXG5cblx0XHRcdEBwcm9wZXJ0eSBjbGllbnRzXG5cdFx0XHRAdHlwZSB7TnVtYmVyfVxuXHRcdFx0Ki9cblx0XHRcdGNsaWVudHM6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0UnVudGltZSBpbml0aWFsaXphdGlvbiBvcHRpb25zXG5cblx0XHRcdEBwcm9wZXJ0eSBvcHRpb25zXG5cdFx0XHRAdHlwZSB7T2JqZWN0fVxuXHRcdFx0Ki9cblx0XHRcdG9wdGlvbnM6IG9wdGlvbnMsXG5cblx0XHRcdC8qKlxuXHRcdFx0Q2hlY2tzIGlmIHRoZSBydW50aW1lIGhhcyBzcGVjaWZpYyBjYXBhYmlsaXR5XG5cblx0XHRcdEBtZXRob2QgY2FuXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gY2FwIE5hbWUgb2YgY2FwYWJpbGl0eSB0byBjaGVja1xuXHRcdFx0QHBhcmFtIHtNaXhlZH0gW3ZhbHVlXSBJZiBwYXNzZWQsIGNhcGFiaWxpdHkgc2hvdWxkIHNvbWVob3cgY29ycmVsYXRlIHRvIHRoZSB2YWx1ZVxuXHRcdFx0QHBhcmFtIHtPYmplY3R9IFtyZWZDYXBzXSBTZXQgb2YgY2FwYWJpbGl0aWVzIHRvIGNoZWNrIHRoZSBzcGVjaWZpZWQgY2FwIGFnYWluc3QgKGRlZmF1bHRzIHRvIGludGVybmFsIHNldClcblx0XHRcdEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcnVudGltZSBoYXMgc3VjaCBjYXBhYmlsaXR5IGFuZCBmYWxzZSwgaWYgLSBub3Rcblx0XHRcdCovXG5cdFx0XHRjYW46IGZ1bmN0aW9uKGNhcCwgdmFsdWUpIHtcblx0XHRcdFx0dmFyIHJlZkNhcHMgPSBhcmd1bWVudHNbMl0gfHwgY2FwcztcblxuXHRcdFx0XHQvLyBpZiBjYXAgdmFyIGlzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgY2FwcywgY29udmVydCBpdCB0byBvYmplY3QgKGtleS92YWx1ZSlcblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZihjYXApID09PSAnc3RyaW5nJyAmJiBCYXNpYy50eXBlT2YodmFsdWUpID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdGNhcCA9IFJ1bnRpbWUucGFyc2VDYXBzKGNhcCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKGNhcCkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGNhcCkge1xuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmNhbihrZXksIGNhcFtrZXldLCByZWZDYXBzKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgdGhlIGluZGl2aWR1YWwgY2FwXG5cdFx0XHRcdGlmIChCYXNpYy50eXBlT2YocmVmQ2Fwc1tjYXBdKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybiByZWZDYXBzW2NhcF0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICh2YWx1ZSA9PT0gcmVmQ2Fwc1tjYXBdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXR1cm5zIGNvbnRhaW5lciBmb3IgdGhlIHJ1bnRpbWUgYXMgRE9NIGVsZW1lbnRcblxuXHRcdFx0QG1ldGhvZCBnZXRTaGltQ29udGFpbmVyXG5cdFx0XHRAcmV0dXJuIHtET01FbGVtZW50fVxuXHRcdFx0Ki9cblx0XHRcdGdldFNoaW1Db250YWluZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY29udGFpbmVyLCBzaGltQ29udGFpbmVyID0gRG9tLmdldCh0aGlzLnNoaW1pZCk7XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGFpbmVyIGZvciBzaGltLCBjcmVhdGUgb25lXG5cdFx0XHRcdGlmICghc2hpbUNvbnRhaW5lcikge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IERvbS5nZXQodGhpcy5vcHRpb25zLmNvbnRhaW5lcikgfHwgZG9jdW1lbnQuYm9keTtcblxuXHRcdFx0XHRcdC8vIGNyZWF0ZSBzaGltIGNvbnRhaW5lciBhbmQgaW5zZXJ0IGl0IGF0IGFuIGFic29sdXRlIHBvc2l0aW9uIGludG8gdGhlIG91dGVyIGNvbnRhaW5lclxuXHRcdFx0XHRcdHNoaW1Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0XHRzaGltQ29udGFpbmVyLmlkID0gdGhpcy5zaGltaWQ7XG5cdFx0XHRcdFx0c2hpbUNvbnRhaW5lci5jbGFzc05hbWUgPSAnbW94aWUtc2hpbSBtb3hpZS1zaGltLScgKyB0aGlzLnR5cGU7XG5cblx0XHRcdFx0XHRCYXNpYy5leHRlbmQoc2hpbUNvbnRhaW5lci5zdHlsZSwge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0XHR0b3A6ICcwcHgnLFxuXHRcdFx0XHRcdFx0bGVmdDogJzBweCcsXG5cdFx0XHRcdFx0XHR3aWR0aDogJzFweCcsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6ICcxcHgnLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2hpbUNvbnRhaW5lcik7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzaGltQ29udGFpbmVyO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXR1cm5zIHJ1bnRpbWUgYXMgRE9NIGVsZW1lbnQgKGlmIGFwcHJvcHJpYXRlKVxuXG5cdFx0XHRAbWV0aG9kIGdldFNoaW1cblx0XHRcdEByZXR1cm4ge0RPTUVsZW1lbnR9XG5cdFx0XHQqL1xuXHRcdFx0Z2V0U2hpbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfc2hpbTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0SW52b2tlcyBhIG1ldGhvZCB3aXRoaW4gdGhlIHJ1bnRpbWUgaXRzZWxmIChtaWdodCBkaWZmZXIgYWNyb3NzIHRoZSBydW50aW1lcylcblxuXHRcdFx0QG1ldGhvZCBzaGltRXhlY1xuXHRcdFx0QHBhcmFtIHtNaXhlZH0gW11cblx0XHRcdEBwcm90ZWN0ZWRcblx0XHRcdEByZXR1cm4ge01peGVkfSBEZXBlbmRzIG9uIHRoZSBhY3Rpb24gYW5kIGNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdHNoaW1FeGVjOiBmdW5jdGlvbihjb21wb25lbnQsIGFjdGlvbikge1xuXHRcdFx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZ2V0U2hpbSgpLmV4ZWMuY2FsbCh0aGlzLCB0aGlzLnVpZCwgY29tcG9uZW50LCBhY3Rpb24sIGFyZ3MpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRPcGVyYWlvbmFsIGludGVyZmFjZSB0aGF0IGlzIHVzZWQgYnkgY29tcG9uZW50cyB0byBpbnZva2Ugc3BlY2lmaWMgYWN0aW9ucyBvbiB0aGUgcnVudGltZVxuXHRcdFx0KGlzIGludm9rZWQgaW4gdGhlIHNjb3BlIG9mIGNvbXBvbmVudClcblxuXHRcdFx0QG1ldGhvZCBleGVjXG5cdFx0XHRAcGFyYW0ge01peGVkfSBbXSpcblx0XHRcdEBwcm90ZWN0ZWRcblx0XHRcdEByZXR1cm4ge01peGVkfSBEZXBlbmRzIG9uIHRoZSBhY3Rpb24gYW5kIGNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdGV4ZWM6IGZ1bmN0aW9uKGNvbXBvbmVudCwgYWN0aW9uKSB7IC8vIHRoaXMgaXMgY2FsbGVkIGluIHRoZSBjb250ZXh0IG9mIGNvbXBvbmVudCwgbm90IHJ1bnRpbWVcblx0XHRcdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cblx0XHRcdFx0aWYgKHNlbGZbY29tcG9uZW50XSAmJiBzZWxmW2NvbXBvbmVudF1bYWN0aW9uXSkge1xuXHRcdFx0XHRcdHJldHVybiBzZWxmW2NvbXBvbmVudF1bYWN0aW9uXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2VsZi5zaGltRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHREZXN0cm95cyB0aGUgcnVudGltZSAocmVtb3ZlcyBhbGwgZXZlbnRzIGFuZCBkZWxldGVzIERPTSBzdHJ1Y3R1cmVzKVxuXG5cdFx0XHRAbWV0aG9kIGRlc3Ryb3lcblx0XHRcdCovXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCFzZWxmKSB7XG5cdFx0XHRcdFx0cmV0dXJuOyAvLyBvYnZpb3VzbHkgYWxyZWFkeSBkZXN0cm95ZWRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzaGltQ29udGFpbmVyID0gRG9tLmdldCh0aGlzLnNoaW1pZCk7XG5cdFx0XHRcdGlmIChzaGltQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0c2hpbUNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNoaW1Db250YWluZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF9zaGltKSB7XG5cdFx0XHRcdFx0X3NoaW0ucmVtb3ZlQWxsSW5zdGFuY2VzKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnVuYmluZEFsbCgpO1xuXHRcdFx0XHRkZWxldGUgcnVudGltZXNbdGhpcy51aWRdO1xuXHRcdFx0XHR0aGlzLnVpZCA9IG51bGw7IC8vIG1hcmsgdGhpcyBydW50aW1lIGFzIGRlc3Ryb3llZFxuXHRcdFx0XHRfdWlkID0gc2VsZiA9IF9zaGltID0gc2hpbUNvbnRhaW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBvbmNlIHdlIGdvdCB0aGUgbW9kZSwgdGVzdCBhZ2FpbnN0IGFsbCBjYXBzXG5cdFx0aWYgKHRoaXMubW9kZSAmJiBvcHRpb25zLnJlcXVpcmVkX2NhcHMgJiYgIXRoaXMuY2FuKG9wdGlvbnMucmVxdWlyZWRfY2FwcykpIHtcblx0XHRcdHRoaXMubW9kZSA9IGZhbHNlO1xuXHRcdH1cdFxuXHR9XG5cblxuXHQvKipcblx0RGVmYXVsdCBvcmRlciB0byB0cnkgZGlmZmVyZW50IHJ1bnRpbWUgdHlwZXNcblxuXHRAcHJvcGVydHkgb3JkZXJcblx0QHR5cGUgU3RyaW5nXG5cdEBzdGF0aWNcblx0Ki9cblx0UnVudGltZS5vcmRlciA9ICdodG1sNSxmbGFzaCxzaWx2ZXJsaWdodCxodG1sNCc7XG5cblxuXHQvKipcblx0UmV0cmlldmVzIHJ1bnRpbWUgZnJvbSBwcml2YXRlIGhhc2ggYnkgaXQncyB1aWRcblxuXHRAbWV0aG9kIGdldFJ1bnRpbWVcblx0QHByaXZhdGVcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gdWlkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydW50aW1lXG5cdEByZXR1cm4ge1J1bnRpbWV8Qm9vbGVhbn0gUmV0dXJucyBydW50aW1lLCBpZiBpdCBleGlzdHMgYW5kIGZhbHNlLCBpZiAtIG5vdFxuXHQqL1xuXHRSdW50aW1lLmdldFJ1bnRpbWUgPSBmdW5jdGlvbih1aWQpIHtcblx0XHRyZXR1cm4gcnVudGltZXNbdWlkXSA/IHJ1bnRpbWVzW3VpZF0gOiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHRSZWdpc3RlciBjb25zdHJ1Y3RvciBmb3IgdGhlIFJ1bnRpbWUgb2YgbmV3IChvciBwZXJoYXBzIG1vZGlmaWVkKSB0eXBlXG5cblx0QG1ldGhvZCBhZGRDb25zdHJ1Y3RvclxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSB0eXBlIFJ1bnRpbWUgdHlwZSAoZS5nLiBmbGFzaCwgaHRtbDUsIGV0Yylcblx0QHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0IENvbnN0cnVjdG9yIGZvciB0aGUgUnVudGltZSB0eXBlXG5cdCovXG5cdFJ1bnRpbWUuYWRkQ29uc3RydWN0b3IgPSBmdW5jdGlvbih0eXBlLCBjb25zdHJ1Y3Rvcikge1xuXHRcdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEV2ZW50VGFyZ2V0Lmluc3RhbmNlO1xuXHRcdHJ1bnRpbWVDb25zdHJ1Y3RvcnNbdHlwZV0gPSBjb25zdHJ1Y3Rvcjtcblx0fTtcblxuXG5cdC8qKlxuXHRHZXQgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUuXG5cblx0bWV0aG9kIGdldENvbnN0cnVjdG9yXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHR5cGUgUnVudGltZSB0eXBlIChlLmcuIGZsYXNoLCBodG1sNSwgZXRjKVxuXHRAcmV0dXJuIHtGdW5jdGlvbn0gQ29uc3RydWN0b3IgZm9yIHRoZSBSdW50aW1lIHR5cGVcblx0Ki9cblx0UnVudGltZS5nZXRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gcnVudGltZUNvbnN0cnVjdG9yc1t0eXBlXSB8fCBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdEdldCBpbmZvIGFib3V0IHRoZSBydW50aW1lICh1aWQsIHR5cGUsIGNhcGFiaWxpdGllcylcblxuXHRAbWV0aG9kIGdldEluZm9cblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gdWlkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydW50aW1lXG5cdEByZXR1cm4ge01peGVkfSBJbmZvIG9iamVjdCBvciBudWxsIGlmIHJ1bnRpbWUgZG9lc24ndCBleGlzdFxuXHQqL1xuXHRSdW50aW1lLmdldEluZm8gPSBmdW5jdGlvbih1aWQpIHtcblx0XHR2YXIgcnVudGltZSA9IFJ1bnRpbWUuZ2V0UnVudGltZSh1aWQpO1xuXG5cdFx0aWYgKHJ1bnRpbWUpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHVpZDogcnVudGltZS51aWQsXG5cdFx0XHRcdHR5cGU6IHJ1bnRpbWUudHlwZSxcblx0XHRcdFx0bW9kZTogcnVudGltZS5tb2RlLFxuXHRcdFx0XHRjYW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBydW50aW1lLmNhbi5hcHBseShydW50aW1lLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXG5cdC8qKlxuXHRDb252ZXJ0IGNhcHMgcmVwcmVzZW50ZWQgYnkgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIHRvIHRoZSBvYmplY3QgcmVwcmVzZW50YXRpb24uXG5cblx0QG1ldGhvZCBwYXJzZUNhcHNcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gY2FwU3RyIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGNhcGFiaWxpdGllc1xuXHRAcmV0dXJuIHtPYmplY3R9XG5cdCovXG5cdFJ1bnRpbWUucGFyc2VDYXBzID0gZnVuY3Rpb24oY2FwU3RyKSB7XG5cdFx0dmFyIGNhcE9iaiA9IHt9O1xuXG5cdFx0aWYgKEJhc2ljLnR5cGVPZihjYXBTdHIpICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGNhcFN0ciB8fCB7fTtcblx0XHR9XG5cblx0XHRCYXNpYy5lYWNoKGNhcFN0ci5zcGxpdCgnLCcpLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdGNhcE9ialtrZXldID0gdHJ1ZTsgLy8gd2UgYXNzdW1lIGl0IHRvIGJlIC0gdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNhcE9iajtcblx0fTtcblxuXHQvKipcblx0VGVzdCB0aGUgc3BlY2lmaWVkIHJ1bnRpbWUgZm9yIHNwZWNpZmljIGNhcGFiaWxpdGllcy5cblxuXHRAbWV0aG9kIGNhblxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSB0eXBlIFJ1bnRpbWUgdHlwZSAoZS5nLiBmbGFzaCwgaHRtbDUsIGV0Yylcblx0QHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjYXBzIFNldCBvZiBjYXBhYmlsaXRpZXMgdG8gY2hlY2tcblx0QHJldHVybiB7Qm9vbGVhbn0gUmVzdWx0IG9mIHRoZSB0ZXN0XG5cdCovXG5cdFJ1bnRpbWUuY2FuID0gZnVuY3Rpb24odHlwZSwgY2Fwcykge1xuXHRcdHZhciBydW50aW1lXG5cdFx0LCBjb25zdHJ1Y3RvciA9IFJ1bnRpbWUuZ2V0Q29uc3RydWN0b3IodHlwZSlcblx0XHQsIG1vZGVcblx0XHQ7XG5cdFx0aWYgKGNvbnN0cnVjdG9yKSB7XG5cdFx0XHRydW50aW1lID0gbmV3IGNvbnN0cnVjdG9yKHtcblx0XHRcdFx0cmVxdWlyZWRfY2FwczogY2Fwc1xuXHRcdFx0fSk7XG5cdFx0XHRtb2RlID0gcnVudGltZS5tb2RlO1xuXHRcdFx0cnVudGltZS5kZXN0cm95KCk7XG5cdFx0XHRyZXR1cm4gISFtb2RlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0RmlndXJlIG91dCBhIHJ1bnRpbWUgdGhhdCBzdXBwb3J0cyBzcGVjaWZpZWQgY2FwYWJpbGl0aWVzLlxuXG5cdEBtZXRob2QgdGhhdENhblxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY2FwcyBTZXQgb2YgY2FwYWJpbGl0aWVzIHRvIGNoZWNrXG5cdEBwYXJhbSB7U3RyaW5nfSBbcnVudGltZU9yZGVyXSBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBydW50aW1lcyB0byBjaGVjayBhZ2FpbnN0XG5cdEByZXR1cm4ge1N0cmluZ30gVXNhYmxlIHJ1bnRpbWUgaWRlbnRpZmllciBvciBudWxsXG5cdCovXG5cdFJ1bnRpbWUudGhhdENhbiA9IGZ1bmN0aW9uKGNhcHMsIHJ1bnRpbWVPcmRlcikge1xuXHRcdHZhciB0eXBlcyA9IChydW50aW1lT3JkZXIgfHwgUnVudGltZS5vcmRlcikuc3BsaXQoL1xccyosXFxzKi8pO1xuXHRcdGZvciAodmFyIGkgaW4gdHlwZXMpIHtcblx0XHRcdGlmIChSdW50aW1lLmNhbih0eXBlc1tpXSwgY2FwcykpIHtcblx0XHRcdFx0cmV0dXJuIHR5cGVzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXG5cdC8qKlxuXHRGaWd1cmUgb3V0IGFuIG9wZXJhdGlvbmFsIG1vZGUgZm9yIHRoZSBzcGVjaWZpZWQgc2V0IG9mIGNhcGFiaWxpdGllcy5cblxuXHRAbWV0aG9kIGdldE1vZGVcblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gbW9kZUNhcHMgU2V0IG9mIGNhcGFiaWxpdGllcyB0aGF0IGRlcGVuZCBvbiBwYXJ0aWN1bGFyIHJ1bnRpbWUgbW9kZVxuXHRAcGFyYW0ge09iamVjdH0gW3JlcXVpcmVkQ2Fwc10gU3VwcGxpZWQgc2V0IG9mIGNhcGFiaWxpdGllcyB0byBmaW5kIG9wZXJhdGlvbmFsIG1vZGUgZm9yXG5cdEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtkZWZhdWx0TW9kZT0nYnJvd3NlciddIERlZmF1bHQgbW9kZSB0byB1c2UgXG5cdEByZXR1cm4ge1N0cmluZ3xCb29sZWFufSBDb21wYXRpYmxlIG9wZXJhdGlvbmFsIG1vZGVcblx0Ki9cblx0UnVudGltZS5nZXRNb2RlID0gZnVuY3Rpb24obW9kZUNhcHMsIHJlcXVpcmVkQ2FwcywgZGVmYXVsdE1vZGUpIHtcblx0XHR2YXIgbW9kZSA9IG51bGw7XG5cblx0XHRpZiAoQmFzaWMudHlwZU9mKGRlZmF1bHRNb2RlKSA9PT0gJ3VuZGVmaW5lZCcpIHsgLy8gb25seSBpZiBub3Qgc3BlY2lmaWVkXG5cdFx0XHRkZWZhdWx0TW9kZSA9ICdicm93c2VyJztcblx0XHR9XG5cblx0XHRpZiAocmVxdWlyZWRDYXBzICYmICFCYXNpYy5pc0VtcHR5T2JqKG1vZGVDYXBzKSkge1xuXHRcdFx0Ly8gbG9vcCBvdmVyIHJlcXVpcmVkIGNhcHMgYW5kIGNoZWNrIGlmIHRoZXkgZG8gcmVxdWlyZSB0aGUgc2FtZSBtb2RlXG5cdFx0XHRCYXNpYy5lYWNoKHJlcXVpcmVkQ2FwcywgZnVuY3Rpb24odmFsdWUsIGNhcCkge1xuXHRcdFx0XHRpZiAobW9kZUNhcHMuaGFzT3duUHJvcGVydHkoY2FwKSkge1xuXHRcdFx0XHRcdHZhciBjYXBNb2RlID0gbW9kZUNhcHNbY2FwXSh2YWx1ZSk7XG5cblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYW4gYXJyYXlcblx0XHRcdFx0XHRpZiAodHlwZW9mKGNhcE1vZGUpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0Y2FwTW9kZSA9IFtjYXBNb2RlXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFtb2RlKSB7XG5cdFx0XHRcdFx0XHRtb2RlID0gY2FwTW9kZTtcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCEobW9kZSA9IEJhc2ljLmFycmF5SW50ZXJzZWN0KG1vZGUsIGNhcE1vZGUpKSkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgY2FwIHJlcXVpcmVzIGNvbmZsaWN0aW5nIG1vZGUgLSBydW50aW1lIGNhbm5vdCBmdWxmaWxsIHJlcXVpcmVkIGNhcHNcblxuXHRcdFx0XHRcdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcucnVudGltZSkge1xuXHRcdFx0XHRcdFx0XHRFbnYubG9nKFwiXFx0XFx0JWM6ICV2IChjb25mbGljdGluZyBtb2RlIHJlcXVlc3RlZDogJXMpXCIsIGNhcCwgdmFsdWUsIGNhcE1vZGUpO1x0XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiAobW9kZSA9IGZhbHNlKTtcblx0XHRcdFx0XHR9XHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcucnVudGltZSkge1xuXHRcdFx0XHRcdEVudi5sb2coXCJcXHRcXHQlYzogJXYgKGNvbXBhdGlibGUgbW9kZXM6ICVzKVwiLCBjYXAsIHZhbHVlLCBtb2RlKTtcdFxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKG1vZGUpIHtcblx0XHRcdFx0cmV0dXJuIEJhc2ljLmluQXJyYXkoZGVmYXVsdE1vZGUsIG1vZGUpICE9PSAtMSA/IGRlZmF1bHRNb2RlIDogbW9kZVswXTtcblx0XHRcdH0gZWxzZSBpZiAobW9kZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVmYXVsdE1vZGU7IFxuXHR9O1xuXG5cblx0LyoqXG5cdENhcGFiaWxpdHkgY2hlY2sgdGhhdCBhbHdheXMgcmV0dXJucyB0cnVlXG5cblx0QHByaXZhdGVcblx0QHN0YXRpY1xuXHRAcmV0dXJuIHtUcnVlfVxuXHQqL1xuXHRSdW50aW1lLmNhcFRydWUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0Q2FwYWJpbGl0eSBjaGVjayB0aGF0IGFsd2F5cyByZXR1cm5zIGZhbHNlXG5cblx0QHByaXZhdGVcblx0QHN0YXRpY1xuXHRAcmV0dXJuIHtGYWxzZX1cblx0Ki9cblx0UnVudGltZS5jYXBGYWxzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0RXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gdG8gYm9vbGVhbiB2YWx1ZSBhbmQgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBpdC5cblxuXHRAcHJpdmF0ZVxuXHRAc3RhdGljXG5cdEBwYXJhbSB7TWl4ZWR9IGV4cHIgRXhwcmVzc2lvbiB0byBldmFsdWF0ZVxuXHRAcmV0dXJuIHtGdW5jdGlvbn0gRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgZXZhbHVhdGlvblxuXHQqL1xuXHRSdW50aW1lLmNhcFRlc3QgPSBmdW5jdGlvbihleHByKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICEhZXhwcjtcblx0XHR9O1xuXHR9O1xuXG5cdHJldHVybiBSdW50aW1lO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvUnVudGltZUNsaWVudC5qc1xuXG4vKipcbiAqIFJ1bnRpbWVDbGllbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9ydW50aW1lL1J1bnRpbWVDbGllbnQnLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0VudicsXG5cdCdtb3hpZS9jb3JlL0V4Y2VwdGlvbnMnLFxuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYycsXG5cdCdtb3hpZS9ydW50aW1lL1J1bnRpbWUnXG5dLCBmdW5jdGlvbihFbnYsIHgsIEJhc2ljLCBSdW50aW1lKSB7XG5cdC8qKlxuXHRTZXQgb2YgbWV0aG9kcyBhbmQgcHJvcGVydGllcywgcmVxdWlyZWQgYnkgYSBjb21wb25lbnQgdG8gYWNxdWlyZSBhYmlsaXR5IHRvIGNvbm5lY3QgdG8gYSBydW50aW1lXG5cblx0QGNsYXNzIG1veGllL3J1bnRpbWUvUnVudGltZUNsaWVudFxuXHQqL1xuXHRyZXR1cm4gZnVuY3Rpb24gUnVudGltZUNsaWVudCgpIHtcblx0XHR2YXIgcnVudGltZTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHQvKipcblx0XHRcdENvbm5lY3RzIHRvIHRoZSBydW50aW1lIHNwZWNpZmllZCBieSB0aGUgb3B0aW9ucy4gV2lsbCBlaXRoZXIgY29ubmVjdCB0byBleGlzdGluZyBydW50aW1lIG9yIGNyZWF0ZSBhIG5ldyBvbmUuXG5cdFx0XHRJbmNyZW1lbnRzIG51bWJlciBvZiBjbGllbnRzIGNvbm5lY3RlZCB0byB0aGUgc3BlY2lmaWVkIHJ1bnRpbWUuXG5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAbWV0aG9kIGNvbm5lY3RSdW50aW1lXG5cdFx0XHRAcGFyYW0ge01peGVkfSBvcHRpb25zIENhbiBiZSBhIHJ1bnRtZSB1aWQgb3IgYSBzZXQgb2Yga2V5LXZhbHVlIHBhaXJzIGRlZmluaW5nIHJlcXVpcmVtZW50cyBhbmQgcHJlLXJlcXVpc2l0ZXNcblx0XHRcdCovXG5cdFx0XHRjb25uZWN0UnVudGltZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgY29tcCA9IHRoaXMsIHJ1aWQ7XG5cblx0XHRcdFx0ZnVuY3Rpb24gaW5pdGlhbGl6ZShpdGVtcykge1xuXHRcdFx0XHRcdHZhciB0eXBlLCBjb25zdHJ1Y3RvcjtcblxuXHRcdFx0XHRcdC8vIGlmIHdlIHJhbiBvdXQgb2YgcnVudGltZXNcblx0XHRcdFx0XHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdSdW50aW1lRXJyb3InLCBuZXcgeC5SdW50aW1lRXJyb3IoeC5SdW50aW1lRXJyb3IuTk9UX0lOSVRfRVJSKSk7XG5cdFx0XHRcdFx0XHRydW50aW1lID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0eXBlID0gaXRlbXMuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGNvbnN0cnVjdG9yID0gUnVudGltZS5nZXRDb25zdHJ1Y3Rvcih0eXBlKTtcblx0XHRcdFx0XHRpZiAoIWNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRcdEVudi5sb2coXCJDb25zdHJ1Y3RvciBmb3IgJyVzJyBydW50aW1lIGlzIG5vdCBhdmFpbGFibGUuXCIsIHR5cGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW5pdGlhbGl6ZShpdGVtcyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcucnVudGltZSkge1xuXHRcdFx0XHRcdFx0RW52LmxvZyhcIlRyeWluZyBydW50aW1lOiAlc1wiLCB0eXBlKTtcblx0XHRcdFx0XHRcdEVudi5sb2cob3B0aW9ucyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdHJ5IGluaXRpYWxpemluZyB0aGUgcnVudGltZVxuXHRcdFx0XHRcdHJ1bnRpbWUgPSBuZXcgY29uc3RydWN0b3Iob3B0aW9ucyk7XG5cblx0XHRcdFx0XHRydW50aW1lLmJpbmQoJ0luaXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdC8vIG1hcmsgcnVudGltZSBhcyBpbml0aWFsaXplZFxuXHRcdFx0XHRcdFx0cnVudGltZS5pbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdFx0RW52LmxvZyhcIlJ1bnRpbWUgJyVzJyBpbml0aWFsaXplZFwiLCBydW50aW1lLnR5cGUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBqYWlsYnJlYWsgLi4uXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRydW50aW1lLmNsaWVudHMrKztcblx0XHRcdFx0XHRcdFx0Y29tcC5ydWlkID0gcnVudGltZS51aWQ7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgb24gY29tcG9uZW50XG5cdFx0XHRcdFx0XHRcdGNvbXAudHJpZ2dlcignUnVudGltZUluaXQnLCBydW50aW1lKTtcblx0XHRcdFx0XHRcdH0sIDEpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cnVudGltZS5iaW5kKCdFcnJvcicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcucnVudGltZSkge1xuXHRcdFx0XHRcdFx0XHRFbnYubG9nKFwiUnVudGltZSAnJXMnIGZhaWxlZCB0byBpbml0aWFsaXplXCIsIHJ1bnRpbWUudHlwZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJ1bnRpbWUuZGVzdHJveSgpOyAvLyBydW50aW1lIGNhbm5vdCBkZXN0cm95IGl0c2VsZiBmcm9tIGluc2lkZSBhdCBhIHJpZ2h0IG1vbWVudCwgdGh1cyB3ZSBkbyBpdCBoZXJlXG5cdFx0XHRcdFx0XHRpbml0aWFsaXplKGl0ZW1zKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHJ1bnRpbWUuYmluZCgnRXhjZXB0aW9uJywgZnVuY3Rpb24oZSwgZXJyKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWVzc2FnZSA9IGVyci5uYW1lICsgXCIoI1wiICsgZXJyLmNvZGUgKyBcIilcIiArIChlcnIubWVzc2FnZSA/IFwiLCBmcm9tOiBcIiArIGVyci5tZXNzYWdlIDogJycpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRcdEVudi5sb2coXCJSdW50aW1lICclcycgaGFzIHRocm93biBhbiBleGNlcHRpb246ICVzXCIsIHRoaXMudHlwZSwgbWVzc2FnZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb21wLnRyaWdnZXIoJ1J1bnRpbWVFcnJvcicsIG5ldyB4LlJ1bnRpbWVFcnJvcih4LlJ1bnRpbWVFcnJvci5FWENFUFRJT05fRVJSLCBtZXNzYWdlKSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRFbnYubG9nKFwiXFx0c2VsZWN0ZWQgbW9kZTogJXNcIiwgcnVudGltZS5tb2RlKTtcdFxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIHJ1bnRpbWUgbWFuYWdlZCB0byBwaWNrLXVwIG9wZXJhdGlvbmFsIG1vZGVcblx0XHRcdFx0XHRpZiAoIXJ1bnRpbWUubW9kZSkge1xuXHRcdFx0XHRcdFx0cnVudGltZS50cmlnZ2VyKCdFcnJvcicpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJ1bnRpbWUuaW5pdCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgYSBwYXJ0aWN1bGFyIHJ1bnRpbWUgd2FzIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHJ1aWQgPSBvcHRpb25zO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEJhc2ljLnR5cGVPZihvcHRpb25zLnJ1aWQpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHJ1aWQgPSBvcHRpb25zLnJ1aWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocnVpZCkge1xuXHRcdFx0XHRcdHJ1bnRpbWUgPSBSdW50aW1lLmdldFJ1bnRpbWUocnVpZCk7XG5cdFx0XHRcdFx0aWYgKHJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdGNvbXAucnVpZCA9IHJ1aWQ7XG5cdFx0XHRcdFx0XHRydW50aW1lLmNsaWVudHMrKztcblx0XHRcdFx0XHRcdHJldHVybiBydW50aW1lO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB0aGVyZSBzaG91bGQgYmUgYSBydW50aW1lIGFuZCB0aGVyZSdzIG5vbmUgLSB3ZWlyZCBjYXNlXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5SdW50aW1lRXJyb3IoeC5SdW50aW1lRXJyb3IuTk9UX0lOSVRfRVJSKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpbml0aWFsaXplIGEgZnJlc2ggb25lLCB0aGF0IGZpdHMgcnVudGltZSBsaXN0IGFuZCByZXF1aXJlZCBmZWF0dXJlcyBiZXN0XG5cdFx0XHRcdGluaXRpYWxpemUoKG9wdGlvbnMucnVudGltZV9vcmRlciB8fCBSdW50aW1lLm9yZGVyKS5zcGxpdCgvXFxzKixcXHMqLykpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdERpc2Nvbm5lY3RzIGZyb20gdGhlIHJ1bnRpbWUuIERlY3JlbWVudHMgbnVtYmVyIG9mIGNsaWVudHMgY29ubmVjdGVkIHRvIHRoZSBzcGVjaWZpZWQgcnVudGltZS5cblxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBtZXRob2QgZGlzY29ubmVjdFJ1bnRpbWVcblx0XHRcdCovXG5cdFx0XHRkaXNjb25uZWN0UnVudGltZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChydW50aW1lICYmIC0tcnVudGltZS5jbGllbnRzIDw9IDApIHtcblx0XHRcdFx0XHRydW50aW1lLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG9uY2UgdGhlIGNvbXBvbmVudCBpcyBkaXNjb25uZWN0ZWQsIGl0IHNob3VsZG4ndCBoYXZlIGFjY2VzcyB0byB0aGUgcnVudGltZVxuXHRcdFx0XHRydW50aW1lID0gbnVsbDtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHRSZXR1cm5zIHRoZSBydW50aW1lIHRvIHdoaWNoIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGNvbm5lY3RlZC5cblxuXHRcdFx0QG1ldGhvZCBnZXRSdW50aW1lXG5cdFx0XHRAcmV0dXJuIHtSdW50aW1lfSBSdW50aW1lIG9yIG51bGwgaWYgY2xpZW50IGlzIG5vdCBjb25uZWN0ZWRcblx0XHRcdCovXG5cdFx0XHRnZXRSdW50aW1lOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHJ1bnRpbWUgJiYgcnVudGltZS51aWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcnVudGltZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcnVudGltZSA9IG51bGw7IC8vIG1ha2Ugc3VyZSB3ZSBkbyBub3QgbGVhdmUgem9tYmllcyByYW1ibGluZyBhcm91bmRcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHRIYW5keSBzaG9ydGN1dCB0byBzYWZlbHkgaW52b2tlIHJ1bnRpbWUgZXh0ZW5zaW9uIG1ldGhvZHMuXG5cdFx0XHRcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAbWV0aG9kIGV4ZWNcblx0XHRcdEByZXR1cm4ge01peGVkfSBXaGF0ZXZlciBydW50aW1lIGV4dGVuc2lvbiBtZXRob2QgcmV0dXJuc1xuXHRcdFx0Ki9cblx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gcnVudGltZSA/IHJ1bnRpbWUuZXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogbnVsbDtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHRUZXN0IHJ1bnRpbWUgY2xpZW50IGZvciBzcGVjaWZpYyBjYXBhYmlsaXR5XG5cdFx0XHRcblx0XHRcdEBtZXRob2QgY2FuXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gY2FwXG5cdFx0XHRAcmV0dXJuIHtCb29sfVxuXHRcdFx0Ki9cblx0XHRcdGNhbjogZnVuY3Rpb24oY2FwKSB7XG5cdFx0XHRcdHJldHVybiBydW50aW1lID8gcnVudGltZS5jYW4oY2FwKSA6IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cdH07XG5cblxufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2ZpbGUvQmxvYi5qc1xuXG4vKipcbiAqIEJsb2IuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9maWxlL0Jsb2InLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJyxcblx0J21veGllL2NvcmUvdXRpbHMvRW5jb2RlJyxcblx0J21veGllL3J1bnRpbWUvUnVudGltZUNsaWVudCdcbl0sIGZ1bmN0aW9uKEJhc2ljLCBFbmNvZGUsIFJ1bnRpbWVDbGllbnQpIHtcblx0XG5cdHZhciBibG9icG9vbCA9IHt9O1xuXG5cdC8qKlxuXHRAY2xhc3MgbW94aWUvZmlsZS9CbG9iXG5cdEBjb25zdHJ1Y3RvclxuXHRAcGFyYW0ge1N0cmluZ30gcnVpZCBVbmlxdWUgaWQgb2YgdGhlIHJ1bnRpbWUsIHRvIHdoaWNoIHRoaXMgYmxvYiBiZWxvbmdzIHRvXG5cdEBwYXJhbSB7T2JqZWN0fSBibG9iIE9iamVjdCBcIk5hdGl2ZVwiIGJsb2Igb2JqZWN0LCBhcyBpdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgcnVudGltZVxuXHQqL1xuXHRmdW5jdGlvbiBCbG9iKHJ1aWQsIGJsb2IpIHtcblxuXHRcdGZ1bmN0aW9uIF9zbGljZURldGFjaGVkKHN0YXJ0LCBlbmQsIHR5cGUpIHtcblx0XHRcdHZhciBibG9iLCBkYXRhID0gYmxvYnBvb2xbdGhpcy51aWRdO1xuXG5cdFx0XHRpZiAoQmFzaWMudHlwZU9mKGRhdGEpICE9PSAnc3RyaW5nJyB8fCAhZGF0YS5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIG9yIHRocm93IGV4Y2VwdGlvblxuXHRcdFx0fVxuXG5cdFx0XHRibG9iID0gbmV3IEJsb2IobnVsbCwge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRzaXplOiBlbmQgLSBzdGFydFxuXHRcdFx0fSk7XG5cdFx0XHRibG9iLmRldGFjaChkYXRhLnN1YnN0cihzdGFydCwgYmxvYi5zaXplKSk7XG5cblx0XHRcdHJldHVybiBibG9iO1xuXHRcdH1cblxuXHRcdFJ1bnRpbWVDbGllbnQuY2FsbCh0aGlzKTtcblxuXHRcdGlmIChydWlkKSB7XHRcblx0XHRcdHRoaXMuY29ubmVjdFJ1bnRpbWUocnVpZCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFibG9iKSB7XG5cdFx0XHRibG9iID0ge307XG5cdFx0fSBlbHNlIGlmIChCYXNpYy50eXBlT2YoYmxvYikgPT09ICdzdHJpbmcnKSB7IC8vIGRhdGFVcmwgb3IgYmluYXJ5IHN0cmluZ1xuXHRcdFx0YmxvYiA9IHsgZGF0YTogYmxvYiB9O1xuXHRcdH1cblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0VW5pcXVlIGlkIG9mIHRoZSBjb21wb25lbnRcblxuXHRcdFx0QHByb3BlcnR5IHVpZFxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdCovXG5cdFx0XHR1aWQ6IGJsb2IudWlkIHx8IEJhc2ljLmd1aWQoJ3VpZF8nKSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRVbmlxdWUgaWQgb2YgdGhlIGNvbm5lY3RlZCBydW50aW1lLCBpZiBmYWxzeSwgdGhlbiBydW50aW1lIHdpbGwgaGF2ZSB0byBiZSBpbml0aWFsaXplZCBcblx0XHRcdGJlZm9yZSB0aGlzIEJsb2IgY2FuIGJlIHVzZWQsIG1vZGlmaWVkIG9yIHNlbnRcblxuXHRcdFx0QHByb3BlcnR5IHJ1aWRcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0cnVpZDogcnVpZCxcblx0XG5cdFx0XHQvKipcblx0XHRcdFNpemUgb2YgYmxvYlxuXG5cdFx0XHRAcHJvcGVydHkgc2l6ZVxuXHRcdFx0QHR5cGUge051bWJlcn1cblx0XHRcdEBkZWZhdWx0IDBcblx0XHRcdCovXG5cdFx0XHRzaXplOiBibG9iLnNpemUgfHwgMCxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRNaW1lIHR5cGUgb2YgYmxvYlxuXG5cdFx0XHRAcHJvcGVydHkgdHlwZVxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdEBkZWZhdWx0ICcnXG5cdFx0XHQqL1xuXHRcdFx0dHlwZTogYmxvYi50eXBlIHx8ICcnLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdEBtZXRob2Qgc2xpY2Vcblx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF1cblx0XHRcdCovXG5cdFx0XHRzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCwgdHlwZSkge1x0XHRcblx0XHRcdFx0aWYgKHRoaXMuaXNEZXRhY2hlZCgpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9zbGljZURldGFjaGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UnVudGltZSgpLmV4ZWMuY2FsbCh0aGlzLCAnQmxvYicsICdzbGljZScsIHRoaXMuZ2V0U291cmNlKCksIHN0YXJ0LCBlbmQsIHR5cGUpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXR1cm5zIFwibmF0aXZlXCIgYmxvYiBvYmplY3QgKGFzIGl0IGlzIHJlcHJlc2VudGVkIGluIGNvbm5lY3RlZCBydW50aW1lKSBvciBudWxsIGlmIG5vdCBmb3VuZFxuXG5cdFx0XHRAbWV0aG9kIGdldFNvdXJjZVxuXHRcdFx0QHJldHVybiB7QmxvYn0gUmV0dXJucyBcIm5hdGl2ZVwiIGJsb2Igb2JqZWN0IG9yIG51bGwgaWYgbm90IGZvdW5kXG5cdFx0XHQqL1xuXHRcdFx0Z2V0U291cmNlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCFibG9icG9vbFt0aGlzLnVpZF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcdFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBibG9icG9vbFt0aGlzLnVpZF07XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiogXG5cdFx0XHREZXRhY2hlcyBibG9iIGZyb20gYW55IHJ1bnRpbWUgdGhhdCBpdCBkZXBlbmRzIG9uIGFuZCBpbml0aWFsaXplIHdpdGggc3RhbmRhbG9uZSB2YWx1ZVxuXG5cdFx0XHRAbWV0aG9kIGRldGFjaFxuXHRcdFx0QHByb3RlY3RlZFxuXHRcdFx0QHBhcmFtIHtET01TdHJpbmd9IFtkYXRhPScnXSBTdGFuZGFsb25lIHZhbHVlXG5cdFx0XHQqL1xuXHRcdFx0ZGV0YWNoOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdGlmICh0aGlzLnJ1aWQpIHtcblx0XHRcdFx0XHR0aGlzLmdldFJ1bnRpbWUoKS5leGVjLmNhbGwodGhpcywgJ0Jsb2InLCAnZGVzdHJveScpO1xuXHRcdFx0XHRcdHRoaXMuZGlzY29ubmVjdFJ1bnRpbWUoKTtcblx0XHRcdFx0XHR0aGlzLnJ1aWQgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwgJyc7XG5cblx0XHRcdFx0Ly8gaWYgZGF0YVVybCwgY29udmVydCB0byBiaW5hcnkgc3RyaW5nXG5cdFx0XHRcdGlmIChkYXRhLnN1YnN0cigwLCA1KSA9PSAnZGF0YTonKSB7XG5cdFx0XHRcdFx0dmFyIGJhc2U2NE9mZnNldCA9IGRhdGEuaW5kZXhPZignO2Jhc2U2NCwnKTtcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBkYXRhLnN1YnN0cmluZyg1LCBiYXNlNjRPZmZzZXQpO1xuXHRcdFx0XHRcdGRhdGEgPSBFbmNvZGUuYXRvYihkYXRhLnN1YnN0cmluZyhiYXNlNjRPZmZzZXQgKyA4KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNpemUgPSBkYXRhLmxlbmd0aDtcblxuXHRcdFx0XHRibG9icG9vbFt0aGlzLnVpZF0gPSBkYXRhO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRDaGVja3MgaWYgYmxvYiBpcyBzdGFuZGFsb25lIChkZXRhY2hlZCBvZiBhbnkgcnVudGltZSlcblx0XHRcdFxuXHRcdFx0QG1ldGhvZCBpc0RldGFjaGVkXG5cdFx0XHRAcHJvdGVjdGVkXG5cdFx0XHRAcmV0dXJuIHtCb29sZWFufVxuXHRcdFx0Ki9cblx0XHRcdGlzRGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIXRoaXMucnVpZCAmJiBCYXNpYy50eXBlT2YoYmxvYnBvb2xbdGhpcy51aWRdKSA9PT0gJ3N0cmluZyc7XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHQvKiogXG5cdFx0XHREZXN0cm95IEJsb2IgYW5kIGZyZWUgYW55IHJlc291cmNlcyBpdCB3YXMgdXNpbmdcblxuXHRcdFx0QG1ldGhvZCBkZXN0cm95XG5cdFx0XHQqL1xuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZGV0YWNoKCk7XG5cdFx0XHRcdGRlbGV0ZSBibG9icG9vbFt0aGlzLnVpZF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRcblx0XHRpZiAoYmxvYi5kYXRhKSB7XG5cdFx0XHR0aGlzLmRldGFjaChibG9iLmRhdGEpOyAvLyBhdXRvLWRldGFjaCBpZiBwYXlsb2FkIGhhcyBiZWVuIHBhc3NlZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRibG9icG9vbFt0aGlzLnVpZF0gPSBibG9iO1x0XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gQmxvYjtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL0kxOG4uanNcblxuLyoqXG4gKiBJMThuLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZShcIm1veGllL2NvcmUvSTE4blwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiXG5dLCBmdW5jdGlvbihCYXNpYykge1xuXHR2YXIgaTE4biA9IHt9O1xuXG5cdC8qKlxuXHRAY2xhc3MgbW94aWUvY29yZS9JMThuXG5cdCovXG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogRXh0ZW5kcyB0aGUgbGFuZ3VhZ2UgcGFjayBvYmplY3Qgd2l0aCBuZXcgaXRlbXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFjayBMYW5ndWFnZSBwYWNrIGl0ZW1zIHRvIGFkZC5cblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuZGVkIGxhbmd1YWdlIHBhY2sgb2JqZWN0LlxuXHRcdCAqL1xuXHRcdGFkZEkxOG46IGZ1bmN0aW9uKHBhY2spIHtcblx0XHRcdHJldHVybiBCYXNpYy5leHRlbmQoaTE4biwgcGFjayk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zbGF0ZXMgdGhlIHNwZWNpZmllZCBzdHJpbmcgYnkgY2hlY2tpbmcgZm9yIHRoZSBlbmdsaXNoIHN0cmluZyBpbiB0aGUgbGFuZ3VhZ2UgcGFjayBsb29rdXAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBsb29rIGZvci5cblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRyYW5zbGF0ZWQgc3RyaW5nIG9yIHRoZSBpbnB1dCBzdHJpbmcgaWYgaXQgd2Fzbid0IGZvdW5kLlxuXHRcdCAqL1xuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gaTE4bltzdHJdIHx8IHN0cjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2hvcnRjdXQgZm9yIHRyYW5zbGF0ZSBmdW5jdGlvblxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gbG9vayBmb3IuXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUcmFuc2xhdGVkIHN0cmluZyBvciB0aGUgaW5wdXQgc3RyaW5nIGlmIGl0IHdhc24ndCBmb3VuZC5cblx0XHQgKi9cblx0XHRfOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZShzdHIpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQc2V1ZG8gc3ByaW50ZiBpbXBsZW1lbnRhdGlvbiAtIHNpbXBsZSB3YXkgdG8gcmVwbGFjZSB0b2tlbnMgd2l0aCBzcGVjaWZpZWQgdmFsdWVzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgd2l0aCB0b2tlbnNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyB3aXRoIHJlcGxhY2VkIHRva2Vuc1xuXHRcdCAqL1xuXHRcdHNwcmludGY6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvJVthLXpdL2csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBhcmdzLnNoaWZ0KCk7XG5cdFx0XHRcdHJldHVybiBCYXNpYy50eXBlT2YodmFsdWUpICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogJyc7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvY29yZS91dGlscy9NaW1lLmpzXG5cbi8qKlxuICogTWltZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoXCJtb3hpZS9jb3JlL3V0aWxzL01pbWVcIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL0kxOG5cIlxuXSwgZnVuY3Rpb24oQmFzaWMsIEkxOG4pIHtcblx0XG5cdHZhciBtaW1lRGF0YSA9IFwiXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vbXN3b3JkLGRvYyBkb3QsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vcGRmLHBkZixcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi9wZ3Atc2lnbmF0dXJlLHBncCxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0LHBzIGFpIGVwcyxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi9ydGYscnRmLFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCx4bHMgeGxiLFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LHBwdCBwcHMgcG90LFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ppcCx6aXAsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gsc3dmIHN3ZmwsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQsZG9jeCxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZSxkb3R4LFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0LHhsc3gsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbixwcHR4LFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC50ZW1wbGF0ZSxwb3R4LFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZXNob3cscHBzeCxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHQsanMsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vanNvbixqc29uLFwiICtcblx0XHRcImF1ZGlvL21wZWcsbXAzIG1wZ2EgbXBlZ2EgbXAyLFwiICtcblx0XHRcImF1ZGlvL3gtd2F2LHdhdixcIiArXG5cdFx0XCJhdWRpby94LW00YSxtNGEsXCIgK1xuXHRcdFwiYXVkaW8vb2dnLG9nYSBvZ2csXCIgK1xuXHRcdFwiYXVkaW8vYWlmZixhaWZmIGFpZixcIiArXG5cdFx0XCJhdWRpby9mbGFjLGZsYWMsXCIgK1xuXHRcdFwiYXVkaW8vYWFjLGFhYyxcIiArXG5cdFx0XCJhdWRpby9hYzMsYWMzLFwiICtcblx0XHRcImF1ZGlvL3gtbXMtd21hLHdtYSxcIiArXG5cdFx0XCJpbWFnZS9ibXAsYm1wLFwiICtcblx0XHRcImltYWdlL2dpZixnaWYsXCIgK1xuXHRcdFwiaW1hZ2UvanBlZyxqcGcganBlZyBqcGUsXCIgK1xuXHRcdFwiaW1hZ2UvcGhvdG9zaG9wLHBzZCxcIiArXG5cdFx0XCJpbWFnZS9wbmcscG5nLFwiICtcblx0XHRcImltYWdlL3N2Zyt4bWwsc3ZnIHN2Z3osXCIgK1xuXHRcdFwiaW1hZ2UvdGlmZix0aWZmIHRpZixcIiArXG5cdFx0XCJ0ZXh0L3BsYWluLGFzYyB0eHQgdGV4dCBkaWZmIGxvZyxcIiArXG5cdFx0XCJ0ZXh0L2h0bWwsaHRtIGh0bWwgeGh0bWwsXCIgK1xuXHRcdFwidGV4dC9jc3MsY3NzLFwiICtcblx0XHRcInRleHQvY3N2LGNzdixcIiArXG5cdFx0XCJ0ZXh0L3J0ZixydGYsXCIgK1xuXHRcdFwidmlkZW8vbXBlZyxtcGVnIG1wZyBtcGUgbTJ2LFwiICtcblx0XHRcInZpZGVvL3F1aWNrdGltZSxxdCBtb3YsXCIgK1xuXHRcdFwidmlkZW8vbXA0LG1wNCxcIiArXG5cdFx0XCJ2aWRlby94LW00dixtNHYsXCIgK1xuXHRcdFwidmlkZW8veC1mbHYsZmx2LFwiICtcblx0XHRcInZpZGVvL3gtbXMtd212LHdtdixcIiArXG5cdFx0XCJ2aWRlby9hdmksYXZpLFwiICtcblx0XHRcInZpZGVvL3dlYm0sd2VibSxcIiArXG5cdFx0XCJ2aWRlby8zZ3BwLDNncHAgM2dwLFwiICtcblx0XHRcInZpZGVvLzNncHAyLDNnMixcIiArXG5cdFx0XCJ2aWRlby92bmQucm4tcmVhbHZpZGVvLHJ2LFwiICtcblx0XHRcInZpZGVvL29nZyxvZ3YsXCIgKyBcblx0XHRcInZpZGVvL3gtbWF0cm9za2EsbWt2LFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZm9ybXVsYS10ZW1wbGF0ZSxvdGYsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtLGV4ZVwiO1xuXHRcblx0XG5cdHZhciBNaW1lID0ge1xuXG5cdFx0bWltZXM6IHt9LFxuXG5cdFx0ZXh0ZW5zaW9uczoge30sXG5cblx0XHQvLyBQYXJzZXMgdGhlIGRlZmF1bHQgbWltZSB0eXBlcyBzdHJpbmcgaW50byBhIG1pbWVzIGFuZCBleHRlbnNpb25zIGxvb2t1cCBtYXBzXG5cdFx0YWRkTWltZVR5cGU6IGZ1bmN0aW9uIChtaW1lRGF0YSkge1xuXHRcdFx0dmFyIGl0ZW1zID0gbWltZURhdGEuc3BsaXQoLywvKSwgaSwgaWksIGV4dDtcblx0XHRcdFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRcdGV4dCA9IGl0ZW1zW2kgKyAxXS5zcGxpdCgvIC8pO1xuXG5cdFx0XHRcdC8vIGV4dGVuc2lvbiB0byBtaW1lIGxvb2t1cFxuXHRcdFx0XHRmb3IgKGlpID0gMDsgaWkgPCBleHQubGVuZ3RoOyBpaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5taW1lc1tleHRbaWldXSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG1pbWUgdG8gZXh0ZW5zaW9uIGxvb2t1cFxuXHRcdFx0XHR0aGlzLmV4dGVuc2lvbnNbaXRlbXNbaV1dID0gZXh0O1xuXHRcdFx0fVxuXHRcdH0sXG5cblxuXHRcdGV4dExpc3QybWltZXM6IGZ1bmN0aW9uIChmaWx0ZXJzLCBhZGRNaXNzaW5nRXh0ZW5zaW9ucykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBleHQsIGksIGlpLCB0eXBlLCBtaW1lcyA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvLyBjb252ZXJ0IGV4dGVuc2lvbnMgdG8gbWltZSB0eXBlcyBsaXN0XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRleHQgPSBmaWx0ZXJzW2ldLmV4dGVuc2lvbnMudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKixcXHMqLyk7XG5cblx0XHRcdFx0Zm9yIChpaSA9IDA7IGlpIDwgZXh0Lmxlbmd0aDsgaWkrKykge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlJ3MgYW4gYXN0ZXJpc2sgaW4gdGhlIGxpc3QsIHRoZW4gYWNjZXB0IGF0dHJpYnV0ZSBpcyBub3QgcmVxdWlyZWRcblx0XHRcdFx0XHRpZiAoZXh0W2lpXSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHlwZSA9IHNlbGYubWltZXNbZXh0W2lpXV07XG5cblx0XHRcdFx0XHQvLyBmdXR1cmUgYnJvd3NlcnMgc2hvdWxkIGZpbHRlciBieSBleHRlbnNpb24sIGZpbmFsbHlcblx0XHRcdFx0XHRpZiAoYWRkTWlzc2luZ0V4dGVuc2lvbnMgJiYgL15cXHcrJC8udGVzdChleHRbaWldKSkge1xuXHRcdFx0XHRcdFx0bWltZXMucHVzaCgnLicgKyBleHRbaWldKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgJiYgQmFzaWMuaW5BcnJheSh0eXBlLCBtaW1lcykgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRtaW1lcy5wdXNoKHR5cGUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXR5cGUpIHtcblx0XHRcdFx0XHRcdC8vIGlmIHdlIGhhdmUgbm8gdHlwZSBpbiBvdXIgbWFwLCB0aGVuIGFjY2VwdCBhbGxcblx0XHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBtaW1lcztcblx0XHR9LFxuXG5cblx0XHRtaW1lczJleHRzOiBmdW5jdGlvbihtaW1lcykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBleHRzID0gW107XG5cdFx0XHRcblx0XHRcdEJhc2ljLmVhY2gobWltZXMsIGZ1bmN0aW9uKG1pbWUpIHtcblx0XHRcdFx0bWltZSA9IG1pbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAobWltZSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0ZXh0cyA9IFtdO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHRoaXMgdGhpbmcgbG9va3MgbGlrZSBtaW1lIHR5cGVcblx0XHRcdFx0dmFyIG0gPSBtaW1lLm1hdGNoKC9eKFxcdyspXFwvKFxcKnxcXHcrKSQvKTtcblx0XHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0XHRpZiAobVsyXSA9PT0gJyonKSB7IFxuXHRcdFx0XHRcdFx0Ly8gd2lsZGNhcmQgbWltZSB0eXBlIGRldGVjdGVkXG5cdFx0XHRcdFx0XHRCYXNpYy5lYWNoKHNlbGYuZXh0ZW5zaW9ucywgZnVuY3Rpb24oYXJyLCBtaW1lKSB7XG5cdFx0XHRcdFx0XHRcdGlmICgobmV3IFJlZ0V4cCgnXicgKyBtWzFdICsgJy8nKSkudGVzdChtaW1lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFtdLnB1c2guYXBwbHkoZXh0cywgc2VsZi5leHRlbnNpb25zW21pbWVdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLmV4dGVuc2lvbnNbbWltZV0pIHtcblx0XHRcdFx0XHRcdFtdLnB1c2guYXBwbHkoZXh0cywgc2VsZi5leHRlbnNpb25zW21pbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGV4dHM7XG5cdFx0fSxcblxuXG5cdFx0bWltZXMyZXh0TGlzdDogZnVuY3Rpb24obWltZXMpIHtcblx0XHRcdHZhciBhY2NlcHQgPSBbXSwgZXh0cyA9IFtdO1xuXG5cdFx0XHRpZiAoQmFzaWMudHlwZU9mKG1pbWVzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0bWltZXMgPSBCYXNpYy50cmltKG1pbWVzKS5zcGxpdCgvXFxzKixcXHMqLyk7XG5cdFx0XHR9XG5cblx0XHRcdGV4dHMgPSB0aGlzLm1pbWVzMmV4dHMobWltZXMpO1xuXHRcdFx0XG5cdFx0XHRhY2NlcHQucHVzaCh7XG5cdFx0XHRcdHRpdGxlOiBJMThuLnRyYW5zbGF0ZSgnRmlsZXMnKSxcblx0XHRcdFx0ZXh0ZW5zaW9uczogZXh0cy5sZW5ndGggPyBleHRzLmpvaW4oJywnKSA6ICcqJ1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIHNhdmUgb3JpZ2luYWwgbWltZXMgc3RyaW5nXG5cdFx0XHRhY2NlcHQubWltZXMgPSBtaW1lcztcblxuXHRcdFx0cmV0dXJuIGFjY2VwdDtcblx0XHR9LFxuXG5cblx0XHRnZXRGaWxlRXh0ZW5zaW9uOiBmdW5jdGlvbihmaWxlTmFtZSkge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBmaWxlTmFtZSAmJiBmaWxlTmFtZS5tYXRjaCgvXFwuKFteLl0rKSQvKTtcblx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fSxcblxuXHRcdGdldEZpbGVNaW1lOiBmdW5jdGlvbihmaWxlTmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWltZXNbdGhpcy5nZXRGaWxlRXh0ZW5zaW9uKGZpbGVOYW1lKV0gfHwgJyc7XG5cdFx0fVxuXHR9O1xuXG5cdE1pbWUuYWRkTWltZVR5cGUobWltZURhdGEpO1xuXG5cdHJldHVybiBNaW1lO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2ZpbGUvRmlsZUlucHV0LmpzXG5cbi8qKlxuICogRmlsZUlucHV0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvZmlsZS9GaWxlSW5wdXQnLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJyxcblx0J21veGllL2NvcmUvdXRpbHMvRW52Jyxcblx0J21veGllL2NvcmUvdXRpbHMvTWltZScsXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0RvbScsXG5cdCdtb3hpZS9jb3JlL0V4Y2VwdGlvbnMnLFxuXHQnbW94aWUvY29yZS9FdmVudFRhcmdldCcsXG5cdCdtb3hpZS9jb3JlL0kxOG4nLFxuXHQnbW94aWUvcnVudGltZS9SdW50aW1lJyxcblx0J21veGllL3J1bnRpbWUvUnVudGltZUNsaWVudCdcbl0sIGZ1bmN0aW9uKEJhc2ljLCBFbnYsIE1pbWUsIERvbSwgeCwgRXZlbnRUYXJnZXQsIEkxOG4sIFJ1bnRpbWUsIFJ1bnRpbWVDbGllbnQpIHtcblx0LyoqXG5cdFByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgdG8gY3JlYXRlIGNyb3NzLWJyb3dzZXIgZmlsZS1waWNrZXIuIEdlbmVyYXRlcyBmaWxlIHNlbGVjdGlvbiBkaWFsb2cgb24gY2xpY2ssXG5cdGNvbnZlcnRzIHNlbGVjdGVkIGZpbGVzIHRvIF9GaWxlXyBvYmplY3RzLCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggX0ltYWdlXywgcHJlbG9hZGVkIGluIG1lbW9yeVxuXHR3aXRoIF9GaWxlUmVhZGVyXyBvciB1cGxvYWRlZCB0byBhIHNlcnZlciB0aHJvdWdoIF9YTUxIdHRwUmVxdWVzdF8uXG5cblx0QGNsYXNzIG1veGllL2ZpbGUvRmlsZUlucHV0XG5cdEBjb25zdHJ1Y3RvclxuXHRAZXh0ZW5kcyBFdmVudFRhcmdldFxuXHRAdXNlcyBSdW50aW1lQ2xpZW50XG5cdEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xET01FbGVtZW50fSBvcHRpb25zIElmIG9wdGlvbnMgaXMgc3RyaW5nIG9yIG5vZGUsIGFyZ3VtZW50IGlzIGNvbnNpZGVyZWQgYXMgX2Jyb3dzZVxcX2J1dHRvbl8uXG5cdFx0QHBhcmFtIHtTdHJpbmd8RE9NRWxlbWVudH0gb3B0aW9ucy5icm93c2VfYnV0dG9uIERPTSBFbGVtZW50IHRvIHR1cm4gaW50byBmaWxlIHBpY2tlci5cblx0XHRAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5hY2NlcHRdIEFycmF5IG9mIG1pbWUgdHlwZXMgdG8gYWNjZXB0LiBCeSBkZWZhdWx0IGFjY2VwdHMgYWxsLlxuXHRcdEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXVsdGlwbGU9ZmFsc2VdIEVuYWJsZSBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgZmlsZXMuXG5cdFx0QHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXJlY3Rvcnk9ZmFsc2VdIFR1cm4gZmlsZSBpbnB1dCBpbnRvIHRoZSBmb2xkZXIgaW5wdXQgKGNhbm5vdCBiZSBib3RoIGF0IHRoZSBzYW1lIHRpbWUpLlxuXHRcdEBwYXJhbSB7U3RyaW5nfERPTUVsZW1lbnR9IFtvcHRpb25zLmNvbnRhaW5lcl0gRE9NIEVsZW1lbnQgdG8gdXNlIGFzIGEgY29udGFpbmVyIGZvciBmaWxlLXBpY2tlci4gRGVmYXVsdHMgdG8gcGFyZW50Tm9kZSBcblx0XHRmb3IgX2Jyb3dzZVxcX2J1dHRvbl8uXG5cdFx0QHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5yZXF1aXJlZF9jYXBzXSBTZXQgb2YgcmVxdWlyZWQgY2FwYWJpbGl0aWVzLCB0aGF0IGNob3NlbiBydW50aW1lIG11c3Qgc3VwcG9ydC5cblxuXHRAZXhhbXBsZVxuXHRcdDxkaXYgaWQ9XCJjb250YWluZXJcIj5cblx0XHRcdDxhIGlkPVwiZmlsZS1waWNrZXJcIiBocmVmPVwiamF2YXNjcmlwdDo7XCI+QnJvd3NlLi4uPC9hPlxuXHRcdDwvZGl2PlxuXG5cdFx0PHNjcmlwdD5cblx0XHRcdHZhciBmaWxlSW5wdXQgPSBuZXcgbU94aWUuRmlsZUlucHV0KHtcblx0XHRcdFx0YnJvd3NlX2J1dHRvbjogJ2ZpbGUtcGlja2VyJywgLy8gb3IgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGUtcGlja2VyJylcblx0XHRcdFx0Y29udGFpbmVyOiAnY29udGFpbmVyJyxcblx0XHRcdFx0YWNjZXB0OiBbXG5cdFx0XHRcdFx0e3RpdGxlOiBcIkltYWdlIGZpbGVzXCIsIGV4dGVuc2lvbnM6IFwianBnLGdpZixwbmdcIn0gLy8gYWNjZXB0IG9ubHkgaW1hZ2VzXG5cdFx0XHRcdF0sXG5cdFx0XHRcdG11bHRpcGxlOiB0cnVlIC8vIGFsbG93IG11bHRpcGxlIGZpbGUgc2VsZWN0aW9uXG5cdFx0XHR9KTtcblxuXHRcdFx0ZmlsZUlucHV0Lm9uY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvLyBkbyBzb21ldGhpbmcgdG8gZmlsZXMgYXJyYXlcblx0XHRcdFx0Y29uc29sZS5pbmZvKGUudGFyZ2V0LmZpbGVzKTsgLy8gb3IgdGhpcy5maWxlcyBvciBmaWxlSW5wdXQuZmlsZXNcblx0XHRcdH07XG5cblx0XHRcdGZpbGVJbnB1dC5pbml0KCk7IC8vIGluaXRpYWxpemVcblx0XHQ8L3NjcmlwdD5cblx0Ki9cblx0dmFyIGRpc3BhdGNoZXMgPSBbXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIHJ1bnRpbWUgaXMgY29ubmVjdGVkIGFuZCBmaWxlLXBpY2tlciBpcyByZWFkeSB0byBiZSB1c2VkLlxuXG5cdFx0QGV2ZW50IHJlYWR5XG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQncmVhZHknLFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCByaWdodCBhZnRlciBbcmVhZHldKCNldmVudF9yZWFkeSkgZXZlbnQsIGFuZCB3aGVuZXZlciBbcmVmcmVzaCgpXSgjbWV0aG9kX3JlZnJlc2gpIGlzIGludm9rZWQuIFxuXHRcdENoZWNrIFtjb3JyZXNwb25kaW5nIGRvY3VtZW50YXRpb24gZW50cnldKCNtZXRob2RfcmVmcmVzaCkgZm9yIG1vcmUgaW5mby5cblxuXHRcdEBldmVudCByZWZyZXNoXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgd2hlbiBzZWxlY3Rpb24gb2YgZmlsZXMgaW4gdGhlIGRpYWxvZyBpcyBjb21wbGV0ZS5cblxuXHRcdEBldmVudCBjaGFuZ2Vcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdjaGFuZ2UnLFxuXG5cdFx0J2NhbmNlbCcsIC8vIFRPRE86IG1pZ2h0IGJlIHVzZWZ1bFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIG1vdXNlIGN1cnNvciBlbnRlcnMgZmlsZS1waWNrZXIgYXJlYS4gQ2FuIGJlIHVzZWQgdG8gc3R5bGUgZWxlbWVudFxuXHRcdGFjY29yZGluZ2x5LlxuXG5cdFx0QGV2ZW50IG1vdXNlZW50ZXJcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdtb3VzZWVudGVyJyxcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgd2hlbiBtb3VzZSBjdXJzb3IgbGVhdmVzIGZpbGUtcGlja2VyIGFyZWEuIENhbiBiZSB1c2VkIHRvIHN0eWxlIGVsZW1lbnRcblx0XHRhY2NvcmRpbmdseS5cblxuXHRcdEBldmVudCBtb3VzZWxlYXZlXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQnbW91c2VsZWF2ZScsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gZnVuY3Rpb25hbCBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCBvbiB0b3Agb2YgZmlsZS1waWNrZXIgYXJlYS5cblxuXHRcdEBldmVudCBtb3VzZWRvd25cblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdtb3VzZWRvd24nLFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIGZ1bmN0aW9uYWwgbW91c2UgYnV0dG9uIGlzIHJlbGVhc2VkIG9uIHRvcCBvZiBmaWxlLXBpY2tlciBhcmVhLlxuXG5cdFx0QGV2ZW50IG1vdXNldXBcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdtb3VzZXVwJ1xuXHRdO1xuXG5cdGZ1bmN0aW9uIEZpbGVJbnB1dChvcHRpb25zKSB7XG5cdFx0aWYgKE1YSV9ERUJVRykge1xuXHRcdFx0RW52LmxvZyhcIkluc3RhbnRpYXRpbmcgRmlsZUlucHV0Li4uXCIpO1x0XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRhaW5lciwgYnJvd3NlQnV0dG9uLCBkZWZhdWx0cztcblxuXHRcdC8vIGlmIGZsYXQgYXJndW1lbnQgcGFzc2VkIGl0IHNob3VsZCBiZSBicm93c2VfYnV0dG9uIGlkXG5cdFx0aWYgKEJhc2ljLmluQXJyYXkoQmFzaWMudHlwZU9mKG9wdGlvbnMpLCBbJ3N0cmluZycsICdub2RlJ10pICE9PSAtMSkge1xuXHRcdFx0b3B0aW9ucyA9IHsgYnJvd3NlX2J1dHRvbiA6IG9wdGlvbnMgfTtcblx0XHR9XG5cblx0XHQvLyB0aGlzIHdpbGwgaGVscCB1cyB0byBmaW5kIHByb3BlciBkZWZhdWx0IGNvbnRhaW5lclxuXHRcdGJyb3dzZUJ1dHRvbiA9IERvbS5nZXQob3B0aW9ucy5icm93c2VfYnV0dG9uKTtcblx0XHRpZiAoIWJyb3dzZUJ1dHRvbikge1xuXHRcdFx0Ly8gYnJvd3NlIGJ1dHRvbiBpcyByZXF1aXJlZFxuXHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLk5PVF9GT1VORF9FUlIpO1xuXHRcdH1cblxuXHRcdC8vIGZpZ3VyZSBvdXQgdGhlIG9wdGlvbnNcblx0XHRkZWZhdWx0cyA9IHtcblx0XHRcdGFjY2VwdDogW3tcblx0XHRcdFx0dGl0bGU6IEkxOG4udHJhbnNsYXRlKCdBbGwgRmlsZXMnKSxcblx0XHRcdFx0ZXh0ZW5zaW9uczogJyonXG5cdFx0XHR9XSxcblx0XHRcdG11bHRpcGxlOiBmYWxzZSxcblx0XHRcdHJlcXVpcmVkX2NhcHM6IGZhbHNlLFxuXHRcdFx0Y29udGFpbmVyOiBicm93c2VCdXR0b24ucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5XG5cdFx0fTtcblx0XHRcblx0XHRvcHRpb25zID0gQmFzaWMuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cblx0XHQvLyBjb252ZXJ0IHRvIG9iamVjdCByZXByZXNlbnRhdGlvblxuXHRcdGlmICh0eXBlb2Yob3B0aW9ucy5yZXF1aXJlZF9jYXBzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdG9wdGlvbnMucmVxdWlyZWRfY2FwcyA9IFJ1bnRpbWUucGFyc2VDYXBzKG9wdGlvbnMucmVxdWlyZWRfY2Fwcyk7XG5cdFx0fVxuXHRcdFx0XHRcdFxuXHRcdC8vIG5vcm1hbGl6ZSBhY2NlcHQgb3B0aW9uIChjb3VsZCBiZSBsaXN0IG9mIG1pbWUgdHlwZXMgb3IgYXJyYXkgb2YgdGl0bGUvZXh0ZW5zaW9ucyBwYWlycylcblx0XHRpZiAodHlwZW9mKG9wdGlvbnMuYWNjZXB0KSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdG9wdGlvbnMuYWNjZXB0ID0gTWltZS5taW1lczJleHRMaXN0KG9wdGlvbnMuYWNjZXB0KTtcblx0XHR9XG5cblx0XHRjb250YWluZXIgPSBEb20uZ2V0KG9wdGlvbnMuY29udGFpbmVyKTtcblx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZSBjb250YWluZXJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuYm9keTtcblx0XHR9XG5cblx0XHQvLyBtYWtlIGNvbnRhaW5lciByZWxhdGl2ZSwgaWYgaXQncyBub3Rcblx0XHRpZiAoRG9tLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lciA9IGJyb3dzZUJ1dHRvbiA9IG51bGw7IC8vIElFXG5cdFx0XHRcdFx0XHRcblx0XHRSdW50aW1lQ2xpZW50LmNhbGwodGhpcyk7XG5cdFx0XG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0VW5pcXVlIGlkIG9mIHRoZSBjb21wb25lbnRcblxuXHRcdFx0QHByb3BlcnR5IHVpZFxuXHRcdFx0QHByb3RlY3RlZFxuXHRcdFx0QHJlYWRPbmx5XG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0QGRlZmF1bHQgVUlEXG5cdFx0XHQqL1xuXHRcdFx0dWlkOiBCYXNpYy5ndWlkKCd1aWRfJyksXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0VW5pcXVlIGlkIG9mIHRoZSBjb25uZWN0ZWQgcnVudGltZSwgaWYgYW55LlxuXG5cdFx0XHRAcHJvcGVydHkgcnVpZFxuXHRcdFx0QHByb3RlY3RlZFxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdCovXG5cdFx0XHRydWlkOiBudWxsLFxuXG5cdFx0XHQvKipcblx0XHRcdFVuaXF1ZSBpZCBvZiB0aGUgcnVudGltZSBjb250YWluZXIuIFVzZWZ1bCB0byBnZXQgaG9sZCBvZiBpdCBmb3IgdmFyaW91cyBtYW5pcHVsYXRpb25zLlxuXG5cdFx0XHRAcHJvcGVydHkgc2hpbWlkXG5cdFx0XHRAcHJvdGVjdGVkXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0Ki9cblx0XHRcdHNoaW1pZDogbnVsbCxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRBcnJheSBvZiBzZWxlY3RlZCBtT3hpZS5GaWxlIG9iamVjdHNcblxuXHRcdFx0QHByb3BlcnR5IGZpbGVzXG5cdFx0XHRAdHlwZSB7QXJyYXl9XG5cdFx0XHRAZGVmYXVsdCBudWxsXG5cdFx0XHQqL1xuXHRcdFx0ZmlsZXM6IG51bGwsXG5cblx0XHRcdC8qKlxuXHRcdFx0SW5pdGlhbGl6ZXMgdGhlIGZpbGUtcGlja2VyLCBjb25uZWN0cyBpdCB0byBydW50aW1lIGFuZCBkaXNwYXRjaGVzIGV2ZW50IHJlYWR5IHdoZW4gZG9uZS5cblxuXHRcdFx0QG1ldGhvZCBpbml0XG5cdFx0XHQqL1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0XHRzZWxmLmJpbmQoJ1J1bnRpbWVJbml0JywgZnVuY3Rpb24oZSwgcnVudGltZSkge1xuXHRcdFx0XHRcdHNlbGYucnVpZCA9IHJ1bnRpbWUudWlkO1xuXHRcdFx0XHRcdHNlbGYuc2hpbWlkID0gcnVudGltZS5zaGltaWQ7XG5cblx0XHRcdFx0XHRzZWxmLmJpbmQoXCJSZWFkeVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHNlbGYudHJpZ2dlcihcIlJlZnJlc2hcIik7XG5cdFx0XHRcdFx0fSwgOTk5KTtcblxuXHRcdFx0XHRcdC8vIHJlLXBvc2l0aW9uIGFuZCByZXNpemUgc2hpbSBjb250YWluZXJcblx0XHRcdFx0XHRzZWxmLmJpbmQoJ1JlZnJlc2gnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBwb3MsIHNpemUsIGJyb3dzZUJ1dHRvbiwgc2hpbUNvbnRhaW5lciwgekluZGV4O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRicm93c2VCdXR0b24gPSBEb20uZ2V0KG9wdGlvbnMuYnJvd3NlX2J1dHRvbik7XG5cdFx0XHRcdFx0XHRzaGltQ29udGFpbmVyID0gRG9tLmdldChydW50aW1lLnNoaW1pZCk7IC8vIGRvIG5vdCB1c2UgcnVudGltZS5nZXRTaGltQ29udGFpbmVyKCksIHNpbmNlIGl0IHdpbGwgY3JlYXRlIGNvbnRhaW5lciBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cblx0XHRcdFx0XHRcdGlmIChicm93c2VCdXR0b24pIHtcblx0XHRcdFx0XHRcdFx0cG9zID0gRG9tLmdldFBvcyhicm93c2VCdXR0b24sIERvbS5nZXQob3B0aW9ucy5jb250YWluZXIpKTtcblx0XHRcdFx0XHRcdFx0c2l6ZSA9IERvbS5nZXRTaXplKGJyb3dzZUJ1dHRvbik7XG5cdFx0XHRcdFx0XHRcdHpJbmRleCA9IHBhcnNlSW50KERvbS5nZXRTdHlsZShicm93c2VCdXR0b24sICd6LWluZGV4JyksIDEwKSB8fCAwO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChzaGltQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0QmFzaWMuZXh0ZW5kKHNoaW1Db250YWluZXIuc3R5bGUsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRvcDogcG9zLnkgKyAncHgnLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGVmdDogcG9zLnggKyAncHgnLFxuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGg6IHNpemUudyArICdweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHNpemUuaCArICdweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHR6SW5kZXg6IHpJbmRleCArIDFcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2hpbUNvbnRhaW5lciA9IGJyb3dzZUJ1dHRvbiA9IG51bGw7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cnVudGltZS5leGVjLmNhbGwoc2VsZiwgJ0ZpbGVJbnB1dCcsICdpbml0Jywgb3B0aW9ucyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHJ1bnRpbWUgbmVlZHM6IG9wdGlvbnMucmVxdWlyZWRfZmVhdHVyZXMsIG9wdGlvbnMucnVudGltZV9vcmRlciBhbmQgb3B0aW9ucy5jb250YWluZXJcblx0XHRcdFx0c2VsZi5jb25uZWN0UnVudGltZShCYXNpYy5leHRlbmQoe30sIG9wdGlvbnMsIHtcblx0XHRcdFx0XHRyZXF1aXJlZF9jYXBzOiB7XG5cdFx0XHRcdFx0XHRzZWxlY3RfZmlsZTogdHJ1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEdldCBjdXJyZW50IG9wdGlvbiB2YWx1ZSBieSBpdHMgbmFtZVxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZXRob2QgZ2V0T3B0aW9uXG5cdFx0XHQgKiBAcGFyYW0gbmFtZVxuXHRcdFx0ICogQHJldHVybiB7TWl4ZWR9XG5cdFx0XHQgKi9cblx0XHRcdGdldE9wdGlvbjogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9uc1tuYW1lXTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXRzIGEgbmV3IHZhbHVlIGZvciB0aGUgb3B0aW9uIHNwZWNpZmllZCBieSBuYW1lXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBzZXRPcHRpb25cblx0XHRcdCAqIEBwYXJhbSBuYW1lXG5cdFx0XHQgKiBAcGFyYW0gdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0c2V0T3B0aW9uOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2xkVmFsdWUgPSBvcHRpb25zW25hbWVdO1xuXG5cdFx0XHRcdHN3aXRjaCAobmFtZSkge1xuXHRcdFx0XHRcdGNhc2UgJ2FjY2VwdCc6XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBNaW1lLm1pbWVzMmV4dExpc3QodmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb250YWluZXInOlxuXHRcdFx0XHRcdGNhc2UgJ3JlcXVpcmVkX2NhcHMnOlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguRmlsZUV4Y2VwdGlvbih4LkZpbGVFeGNlcHRpb24uTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5leGVjKCdGaWxlSW5wdXQnLCAnc2V0T3B0aW9uJywgbmFtZSwgdmFsdWUpO1xuXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignT3B0aW9uQ2hhbmdlZCcsIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdERpc2FibGVzIGZpbGUtcGlja2VyIGVsZW1lbnQsIHNvIHRoYXQgaXQgZG9lc24ndCByZWFjdCB0byBtb3VzZSBjbGlja3MuXG5cblx0XHRcdEBtZXRob2QgZGlzYWJsZVxuXHRcdFx0QHBhcmFtIHtCb29sZWFufSBbc3RhdGU9dHJ1ZV0gRGlzYWJsZSBjb21wb25lbnQgaWYgLSB0cnVlLCBlbmFibGUgaWYgLSBmYWxzZVxuXHRcdFx0Ki9cblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0XHRcdHZhciBydW50aW1lID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cdFx0XHRcdGlmIChydW50aW1lKSB7XG5cdFx0XHRcdFx0dGhpcy5leGVjKCdGaWxlSW5wdXQnLCAnZGlzYWJsZScsIEJhc2ljLnR5cGVPZihzdGF0ZSkgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IHN0YXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdFJlcG9zaXRpb24gYW5kIHJlc2l6ZSBkaWFsb2cgdHJpZ2dlciB0byBtYXRjaCB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgYnJvd3NlX2J1dHRvbiBlbGVtZW50LlxuXG5cdFx0XHRAbWV0aG9kIHJlZnJlc2hcblx0XHRcdCovXG5cdFx0XHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiUmVmcmVzaFwiKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHREZXN0cm95IGNvbXBvbmVudC5cblxuXHRcdFx0QG1ldGhvZCBkZXN0cm95XG5cdFx0XHQqL1xuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBydW50aW1lID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cdFx0XHRcdGlmIChydW50aW1lKSB7XG5cdFx0XHRcdFx0cnVudGltZS5leGVjLmNhbGwodGhpcywgJ0ZpbGVJbnB1dCcsICdkZXN0cm95Jyk7XG5cdFx0XHRcdFx0dGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZih0aGlzLmZpbGVzKSA9PT0gJ2FycmF5Jykge1xuXHRcdFx0XHRcdC8vIG5vIHNlbnNlIGluIGxlYXZpbmcgYXNzb2NpYXRlZCBmaWxlcyBiZWhpbmRcblx0XHRcdFx0XHRCYXNpYy5lYWNoKHRoaXMuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRcdGZpbGUuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IFxuXHRcdFx0XHR0aGlzLmZpbGVzID0gbnVsbDtcblxuXHRcdFx0XHR0aGlzLnVuYmluZEFsbCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5oYW5kbGVFdmVudFByb3BzKGRpc3BhdGNoZXMpO1xuXHR9XG5cblx0RmlsZUlucHV0LnByb3RvdHlwZSA9IEV2ZW50VGFyZ2V0Lmluc3RhbmNlO1xuXG5cdHJldHVybiBGaWxlSW5wdXQ7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvZmlsZS9GaWxlLmpzXG5cbi8qKlxuICogRmlsZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL2ZpbGUvRmlsZScsIFtcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnLFxuXHQnbW94aWUvY29yZS91dGlscy9NaW1lJyxcblx0J21veGllL2ZpbGUvQmxvYidcbl0sIGZ1bmN0aW9uKEJhc2ljLCBNaW1lLCBCbG9iKSB7XG5cdC8qKlxuXHRAY2xhc3MgbW94aWUvZmlsZS9GaWxlXG5cdEBleHRlbmRzIEJsb2Jcblx0QGNvbnN0cnVjdG9yXG5cdEBwYXJhbSB7U3RyaW5nfSBydWlkIFVuaXF1ZSBpZCBvZiB0aGUgcnVudGltZSwgdG8gd2hpY2ggdGhpcyBibG9iIGJlbG9uZ3MgdG9cblx0QHBhcmFtIHtPYmplY3R9IGZpbGUgT2JqZWN0IFwiTmF0aXZlXCIgZmlsZSBvYmplY3QsIGFzIGl0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBydW50aW1lXG5cdCovXG5cdGZ1bmN0aW9uIEZpbGUocnVpZCwgZmlsZSkge1xuXHRcdGlmICghZmlsZSkgeyAvLyBhdm9pZCBleHRyYSBlcnJvcnMgaW4gY2FzZSB3ZSBvdmVybG9va2VkIHNvbWV0aGluZ1xuXHRcdFx0ZmlsZSA9IHt9O1xuXHRcdH1cblxuXHRcdEJsb2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdGlmICghdGhpcy50eXBlKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSBNaW1lLmdldEZpbGVNaW1lKGZpbGUubmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gc2FuaXRpemUgZmlsZSBuYW1lIG9yIGdlbmVyYXRlIG5ldyBvbmVcblx0XHR2YXIgbmFtZTtcblx0XHRpZiAoZmlsZS5uYW1lKSB7XG5cdFx0XHRuYW1lID0gZmlsZS5uYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblx0XHRcdG5hbWUgPSBuYW1lLnN1YnN0cihuYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMudHlwZSkge1xuXHRcdFx0dmFyIHByZWZpeCA9IHRoaXMudHlwZS5zcGxpdCgnLycpWzBdO1xuXHRcdFx0bmFtZSA9IEJhc2ljLmd1aWQoKHByZWZpeCAhPT0gJycgPyBwcmVmaXggOiAnZmlsZScpICsgJ18nKTtcblx0XHRcdFxuXHRcdFx0aWYgKE1pbWUuZXh0ZW5zaW9uc1t0aGlzLnR5cGVdKSB7XG5cdFx0XHRcdG5hbWUgKz0gJy4nICsgTWltZS5leHRlbnNpb25zW3RoaXMudHlwZV1bMF07IC8vIGFwcGVuZCBwcm9wZXIgZXh0ZW5zaW9uIGlmIHBvc3NpYmxlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdFxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHQvKipcblx0XHRcdEZpbGUgbmFtZVxuXG5cdFx0XHRAcHJvcGVydHkgbmFtZVxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdEBkZWZhdWx0IFVJRFxuXHRcdFx0Ki9cblx0XHRcdG5hbWU6IG5hbWUgfHwgQmFzaWMuZ3VpZCgnZmlsZV8nKSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZWxhdGl2ZSBwYXRoIHRvIHRoZSBmaWxlIGluc2lkZSBhIGRpcmVjdG9yeVxuXG5cdFx0XHRAcHJvcGVydHkgcmVsYXRpdmVQYXRoXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0QGRlZmF1bHQgJydcblx0XHRcdCovXG5cdFx0XHRyZWxhdGl2ZVBhdGg6ICcnLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdERhdGUgb2YgbGFzdCBtb2RpZmljYXRpb25cblxuXHRcdFx0QHByb3BlcnR5IGxhc3RNb2RpZmllZERhdGVcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHRAZGVmYXVsdCBub3dcblx0XHRcdCovXG5cdFx0XHRsYXN0TW9kaWZpZWREYXRlOiBmaWxlLmxhc3RNb2RpZmllZERhdGUgfHwgKG5ldyBEYXRlKCkpLnRvTG9jYWxlU3RyaW5nKCkgLy8gVGh1IEF1ZyAyMyAyMDEyIDE5OjQwOjAwIEdNVCswNDAwIChHRVQpXG5cdFx0fSk7XG5cdH1cblxuXHRGaWxlLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xuXG5cdHJldHVybiBGaWxlO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2ZpbGUvRmlsZURyb3AuanNcblxuLyoqXG4gKiBGaWxlRHJvcC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL2ZpbGUvRmlsZURyb3AnLCBbXG5cdCdtb3hpZS9jb3JlL0kxOG4nLFxuXHQnbW94aWUvY29yZS91dGlscy9Eb20nLFxuXHQnbW94aWUvY29yZS9FeGNlcHRpb25zJyxcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnLFxuXHQnbW94aWUvY29yZS91dGlscy9FbnYnLFxuXHQnbW94aWUvZmlsZS9GaWxlJyxcblx0J21veGllL3J1bnRpbWUvUnVudGltZUNsaWVudCcsXG5cdCdtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0Jyxcblx0J21veGllL2NvcmUvdXRpbHMvTWltZSdcbl0sIGZ1bmN0aW9uKEkxOG4sIERvbSwgeCwgQmFzaWMsIEVudiwgRmlsZSwgUnVudGltZUNsaWVudCwgRXZlbnRUYXJnZXQsIE1pbWUpIHtcblx0LyoqXG5cdFR1cm4gYXJiaXRyYXJ5IERPTSBlbGVtZW50IHRvIGEgZHJvcCB6b25lIGFjY2VwdGluZyBmaWxlcy4gQ29udmVydHMgc2VsZWN0ZWQgZmlsZXMgdG8gX0ZpbGVfIG9iamVjdHMsIHRvIGJlIHVzZWQgXG5cdGluIGNvbmp1bmN0aW9uIHdpdGggX0ltYWdlXywgcHJlbG9hZGVkIGluIG1lbW9yeSB3aXRoIF9GaWxlUmVhZGVyXyBvciB1cGxvYWRlZCB0byBhIHNlcnZlciB0aHJvdWdoIFxuXHRfWE1MSHR0cFJlcXVlc3RfLlxuXG5cdEBleGFtcGxlXG5cdFx0PGRpdiBpZD1cImRyb3Bfem9uZVwiPlxuXHRcdFx0RHJvcCBmaWxlcyBoZXJlXG5cdFx0PC9kaXY+XG5cdFx0PGJyIC8+XG5cdFx0PGRpdiBpZD1cImZpbGVsaXN0XCI+PC9kaXY+XG5cblx0XHQ8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5cblx0XHRcdHZhciBmaWxlRHJvcCA9IG5ldyBtT3hpZS5GaWxlRHJvcCgnZHJvcF96b25lJyksIGZpbGVMaXN0ID0gbU94aWUuZ2V0KCdmaWxlbGlzdCcpO1xuXG5cdFx0XHRmaWxlRHJvcC5vbmRyb3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bU94aWUuZWFjaCh0aGlzLmZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHRcdFx0ZmlsZUxpc3QuaW5uZXJIVE1MICs9ICc8ZGl2PicgKyBmaWxlLm5hbWUgKyAnPC9kaXY+Jztcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRmaWxlRHJvcC5pbml0KCk7XG5cdFx0PC9zY3JpcHQ+XG5cblx0QGNsYXNzIG1veGllL2ZpbGUvRmlsZURyb3Bcblx0QGNvbnN0cnVjdG9yXG5cdEBleHRlbmRzIEV2ZW50VGFyZ2V0XG5cdEB1c2VzIFJ1bnRpbWVDbGllbnRcblx0QHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zIElmIG9wdGlvbnMgaGFzIHR5cGVvZiBzdHJpbmcsIGFyZ3VtZW50IGlzIGNvbnNpZGVyZWQgYXMgb3B0aW9ucy5kcm9wX3pvbmVcblx0XHRAcGFyYW0ge1N0cmluZ3xET01FbGVtZW50fSBvcHRpb25zLmRyb3Bfem9uZSBET00gRWxlbWVudCB0byB0dXJuIGludG8gYSBkcm9wIHpvbmVcblx0XHRAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5hY2NlcHRdIEFycmF5IG9mIG1pbWUgdHlwZXMgdG8gYWNjZXB0LiBCeSBkZWZhdWx0IGFjY2VwdHMgYWxsXG5cdFx0QHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5yZXF1aXJlZF9jYXBzXSBTZXQgb2YgcmVxdWlyZWQgY2FwYWJpbGl0aWVzLCB0aGF0IGNob3NlbiBydW50aW1lIG11c3Qgc3VwcG9ydFxuXHQqL1xuXHR2YXIgZGlzcGF0Y2hlcyA9IFtcblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gcnVudGltZSBpcyBjb25uZWN0ZWQgYW5kIGRyb3Agem9uZSBpcyByZWFkeSB0byBhY2NlcHQgZmlsZXMuXG5cblx0XHRAZXZlbnQgcmVhZHlcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdyZWFkeScsIFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIGRyYWdnaW5nIGN1cnNvciBlbnRlcnMgdGhlIGRyb3Agem9uZS5cblxuXHRcdEBldmVudCBkcmFnZW50ZXJcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdkcmFnZW50ZXInLFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIGRyYWdnaW5nIGN1cnNvciBsZWF2ZXMgdGhlIGRyb3Agem9uZS5cblxuXHRcdEBldmVudCBkcmFnbGVhdmVcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdkcmFnbGVhdmUnLCBcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgd2hlbiBmaWxlIGlzIGRyb3BwZWQgb250byB0aGUgZHJvcCB6b25lLlxuXG5cdFx0QGV2ZW50IGRyb3Bcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdkcm9wJywgXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIGlmIGVycm9yIG9jY3Vycy5cblxuXHRcdEBldmVudCBlcnJvclxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2Vycm9yJ1xuXHRdO1xuXG5cdGZ1bmN0aW9uIEZpbGVEcm9wKG9wdGlvbnMpIHtcblx0XHRpZiAoTVhJX0RFQlVHKSB7XG5cdFx0XHRFbnYubG9nKFwiSW5zdGFudGlhdGluZyBGaWxlRHJvcC4uLlwiKTtcdFxuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcywgZGVmYXVsdHM7XG5cblx0XHQvLyBpZiBmbGF0IGFyZ3VtZW50IHBhc3NlZCBpdCBzaG91bGQgYmUgZHJvcF96b25lIGlkXG5cdFx0aWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdG9wdGlvbnMgPSB7IGRyb3Bfem9uZSA6IG9wdGlvbnMgfTtcblx0XHR9XG5cblx0XHQvLyBmaWd1cmUgb3V0IHRoZSBvcHRpb25zXG5cdFx0ZGVmYXVsdHMgPSB7XG5cdFx0XHRhY2NlcHQ6IFt7XG5cdFx0XHRcdHRpdGxlOiBJMThuLnRyYW5zbGF0ZSgnQWxsIEZpbGVzJyksXG5cdFx0XHRcdGV4dGVuc2lvbnM6ICcqJ1xuXHRcdFx0fV0sXG5cdFx0XHRyZXF1aXJlZF9jYXBzOiB7XG5cdFx0XHRcdGRyYWdfYW5kX2Ryb3A6IHRydWVcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdG9wdGlvbnMgPSB0eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnID8gQmFzaWMuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucykgOiBkZWZhdWx0cztcblxuXHRcdC8vIHRoaXMgd2lsbCBoZWxwIHVzIHRvIGZpbmQgcHJvcGVyIGRlZmF1bHQgY29udGFpbmVyXG5cdFx0b3B0aW9ucy5jb250YWluZXIgPSBEb20uZ2V0KG9wdGlvbnMuZHJvcF96b25lKSB8fCBkb2N1bWVudC5ib2R5O1xuXG5cdFx0Ly8gbWFrZSBjb250YWluZXIgcmVsYXRpdmUsIGlmIGl0IGlzIG5vdFxuXHRcdGlmIChEb20uZ2V0U3R5bGUob3B0aW9ucy5jb250YWluZXIsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuXHRcdFx0b3B0aW9ucy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHRcdH1cblx0XHRcdFx0XHRcblx0XHQvLyBub3JtYWxpemUgYWNjZXB0IG9wdGlvbiAoY291bGQgYmUgbGlzdCBvZiBtaW1lIHR5cGVzIG9yIGFycmF5IG9mIHRpdGxlL2V4dGVuc2lvbnMgcGFpcnMpXG5cdFx0aWYgKHR5cGVvZihvcHRpb25zLmFjY2VwdCkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRvcHRpb25zLmFjY2VwdCA9IE1pbWUubWltZXMyZXh0TGlzdChvcHRpb25zLmFjY2VwdCk7XG5cdFx0fVxuXG5cdFx0UnVudGltZUNsaWVudC5jYWxsKHNlbGYpO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHNlbGYsIHtcblx0XHRcdHVpZDogQmFzaWMuZ3VpZCgndWlkXycpLFxuXG5cdFx0XHRydWlkOiBudWxsLFxuXG5cdFx0XHRmaWxlczogbnVsbCxcblxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XHRcdFxuXHRcdFx0XHRzZWxmLmJpbmQoJ1J1bnRpbWVJbml0JywgZnVuY3Rpb24oZSwgcnVudGltZSkge1xuXHRcdFx0XHRcdHNlbGYucnVpZCA9IHJ1bnRpbWUudWlkO1xuXHRcdFx0XHRcdHJ1bnRpbWUuZXhlYy5jYWxsKHNlbGYsICdGaWxlRHJvcCcsICdpbml0Jywgb3B0aW9ucyk7XG5cdFx0XHRcdFx0c2VsZi5kaXNwYXRjaEV2ZW50KCdyZWFkeScpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdC8vIHJ1bnRpbWUgbmVlZHM6IG9wdGlvbnMucmVxdWlyZWRfZmVhdHVyZXMsIG9wdGlvbnMucnVudGltZV9vcmRlciBhbmQgb3B0aW9ucy5jb250YWluZXJcblx0XHRcdFx0c2VsZi5jb25uZWN0UnVudGltZShvcHRpb25zKTsgLy8gdGhyb3dzIFJ1bnRpbWVFcnJvclxuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBydW50aW1lID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cdFx0XHRcdGlmIChydW50aW1lKSB7XG5cdFx0XHRcdFx0cnVudGltZS5leGVjLmNhbGwodGhpcywgJ0ZpbGVEcm9wJywgJ2Rlc3Ryb3knKTtcblx0XHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RSdW50aW1lKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5maWxlcyA9IG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnVuYmluZEFsbCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5oYW5kbGVFdmVudFByb3BzKGRpc3BhdGNoZXMpO1xuXHR9XG5cblx0RmlsZURyb3AucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cblx0cmV0dXJuIEZpbGVEcm9wO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2ZpbGUvRmlsZVJlYWRlci5qc1xuXG4vKipcbiAqIEZpbGVSZWFkZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9maWxlL0ZpbGVSZWFkZXInLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJyxcblx0J21veGllL2NvcmUvdXRpbHMvRW5jb2RlJyxcblx0J21veGllL2NvcmUvRXhjZXB0aW9ucycsXG5cdCdtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0Jyxcblx0J21veGllL2ZpbGUvQmxvYicsXG5cdCdtb3hpZS9ydW50aW1lL1J1bnRpbWVDbGllbnQnXG5dLCBmdW5jdGlvbihCYXNpYywgRW5jb2RlLCB4LCBFdmVudFRhcmdldCwgQmxvYiwgUnVudGltZUNsaWVudCkge1xuXHQvKipcblx0VXRpbGl0eSBmb3IgcHJlbG9hZGluZyBvLkJsb2Ivby5GaWxlIG9iamVjdHMgaW4gbWVtb3J5LiBCeSBkZXNpZ24gY2xvc2VseSBmb2xsb3dzIFtXM0MgRmlsZVJlYWRlcl0oaHR0cDovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jZGZuLWZpbGVyZWFkZXIpXG5cdGludGVyZmFjZS4gV2hlcmUgcG9zc2libGUgdXNlcyBuYXRpdmUgRmlsZVJlYWRlciwgd2hlcmUgLSBub3QgZmFsbHMgYmFjayB0byBzaGltcy5cblxuXHRAY2xhc3MgbW94aWUvZmlsZS9GaWxlUmVhZGVyXG5cdEBjb25zdHJ1Y3RvciBGaWxlUmVhZGVyXG5cdEBleHRlbmRzIEV2ZW50VGFyZ2V0XG5cdEB1c2VzIFJ1bnRpbWVDbGllbnRcblx0Ki9cblx0dmFyIGRpc3BhdGNoZXMgPSBbXG5cblx0XHQvKiogXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIHRoZSByZWFkIHN0YXJ0cy5cblxuXHRcdEBldmVudCBsb2Fkc3RhcnRcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdsb2Fkc3RhcnQnLCBcblxuXHRcdC8qKiBcblx0XHREaXNwYXRjaGVkIHdoaWxlIHJlYWRpbmcgKGFuZCBkZWNvZGluZykgYmxvYiwgYW5kIHJlcG9ydGluZyBwYXJ0aWFsIEJsb2IgZGF0YSAocHJvZ2Vzcy5sb2FkZWQvcHJvZ3Jlc3MudG90YWwpLlxuXG5cdFx0QGV2ZW50IHByb2dyZXNzXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQncHJvZ3Jlc3MnLCBcblxuXHRcdC8qKiBcblx0XHREaXNwYXRjaGVkIHdoZW4gdGhlIHJlYWQgaGFzIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXG5cblx0XHRAZXZlbnQgbG9hZFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2xvYWQnLCBcblxuXHRcdC8qKiBcblx0XHREaXNwYXRjaGVkIHdoZW4gdGhlIHJlYWQgaGFzIGJlZW4gYWJvcnRlZC4gRm9yIGluc3RhbmNlLCBieSBpbnZva2luZyB0aGUgYWJvcnQoKSBtZXRob2QuXG5cblx0XHRAZXZlbnQgYWJvcnRcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdhYm9ydCcsIFxuXG5cdFx0LyoqIFxuXHRcdERpc3BhdGNoZWQgd2hlbiB0aGUgcmVhZCBoYXMgZmFpbGVkLlxuXG5cdFx0QGV2ZW50IGVycm9yXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQnZXJyb3InLCBcblxuXHRcdC8qKiBcblx0XHREaXNwYXRjaGVkIHdoZW4gdGhlIHJlcXVlc3QgaGFzIGNvbXBsZXRlZCAoZWl0aGVyIGluIHN1Y2Nlc3Mgb3IgZmFpbHVyZSkuXG5cblx0XHRAZXZlbnQgbG9hZGVuZFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2xvYWRlbmQnXG5cdF07XG5cdFxuXHRmdW5jdGlvbiBGaWxlUmVhZGVyKCkge1xuXG5cdFx0UnVudGltZUNsaWVudC5jYWxsKHRoaXMpO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0VUlEIG9mIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG5cblx0XHRcdEBwcm9wZXJ0eSB1aWRcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0dWlkOiBCYXNpYy5ndWlkKCd1aWRfJyksXG5cblx0XHRcdC8qKlxuXHRcdFx0Q29udGFpbnMgY3VycmVudCBzdGF0ZSBvZiBGaWxlUmVhZGVyIG9iamVjdC4gQ2FuIHRha2UgdmFsdWVzIG9mIEZpbGVSZWFkZXIuRU1QVFksIEZpbGVSZWFkZXIuTE9BRElOR1xuXHRcdFx0YW5kIEZpbGVSZWFkZXIuRE9ORS5cblxuXHRcdFx0QHByb3BlcnR5IHJlYWR5U3RhdGVcblx0XHRcdEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHRAZGVmYXVsdCBGaWxlUmVhZGVyLkVNUFRZXG5cdFx0XHQqL1xuXHRcdFx0cmVhZHlTdGF0ZTogRmlsZVJlYWRlci5FTVBUWSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRSZXN1bHQgb2YgdGhlIHN1Y2Nlc3NmdWwgcmVhZCBvcGVyYXRpb24uXG5cblx0XHRcdEBwcm9wZXJ0eSByZXN1bHRcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0cmVzdWx0OiBudWxsLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdFN0b3JlcyB0aGUgZXJyb3Igb2YgZmFpbGVkIGFzeW5jaHJvbm91cyByZWFkIG9wZXJhdGlvbi5cblxuXHRcdFx0QHByb3BlcnR5IGVycm9yXG5cdFx0XHRAdHlwZSB7RE9NRXJyb3J9XG5cdFx0XHQqL1xuXHRcdFx0ZXJyb3I6IG51bGwsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0SW5pdGlhdGVzIHJlYWRpbmcgb2YgRmlsZS9CbG9iIG9iamVjdCBjb250ZW50cyB0byBiaW5hcnkgc3RyaW5nLlxuXG5cdFx0XHRAbWV0aG9kIHJlYWRBc0JpbmFyeVN0cmluZ1xuXHRcdFx0QHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgT2JqZWN0IHRvIHByZWxvYWRcblx0XHRcdCovXG5cdFx0XHRyZWFkQXNCaW5hcnlTdHJpbmc6IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdFx0X3JlYWQuY2FsbCh0aGlzLCAncmVhZEFzQmluYXJ5U3RyaW5nJywgYmxvYik7XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdEluaXRpYXRlcyByZWFkaW5nIG9mIEZpbGUvQmxvYiBvYmplY3QgY29udGVudHMgdG8gZGF0YVVSTCBzdHJpbmcuXG5cblx0XHRcdEBtZXRob2QgcmVhZEFzRGF0YVVSTFxuXHRcdFx0QHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgT2JqZWN0IHRvIHByZWxvYWRcblx0XHRcdCovXG5cdFx0XHRyZWFkQXNEYXRhVVJMOiBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHRcdF9yZWFkLmNhbGwodGhpcywgJ3JlYWRBc0RhdGFVUkwnLCBibG9iKTtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0SW5pdGlhdGVzIHJlYWRpbmcgb2YgRmlsZS9CbG9iIG9iamVjdCBjb250ZW50cyB0byBzdHJpbmcuXG5cblx0XHRcdEBtZXRob2QgcmVhZEFzVGV4dFxuXHRcdFx0QHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgT2JqZWN0IHRvIHByZWxvYWRcblx0XHRcdCovXG5cdFx0XHRyZWFkQXNUZXh0OiBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHRcdF9yZWFkLmNhbGwodGhpcywgJ3JlYWRBc1RleHQnLCBibG9iKTtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0QWJvcnRzIHByZWxvYWRpbmcgcHJvY2Vzcy5cblxuXHRcdFx0QG1ldGhvZCBhYm9ydFxuXHRcdFx0Ki9cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZXN1bHQgPSBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKEJhc2ljLmluQXJyYXkodGhpcy5yZWFkeVN0YXRlLCBbRmlsZVJlYWRlci5FTVBUWSwgRmlsZVJlYWRlci5ET05FXSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gRmlsZVJlYWRlci5MT0FESU5HKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWFkeVN0YXRlID0gRmlsZVJlYWRlci5ET05FO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5leGVjKCdGaWxlUmVhZGVyJywgJ2Fib3J0Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2Fib3J0Jyk7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignbG9hZGVuZCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHREZXN0cm95IGNvbXBvbmVudCBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXG5cblx0XHRcdEBtZXRob2QgZGVzdHJveVxuXHRcdFx0Ki9cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmFib3J0KCk7XG5cdFx0XHRcdHRoaXMuZXhlYygnRmlsZVJlYWRlcicsICdkZXN0cm95Jyk7XG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdFJ1bnRpbWUoKTtcblx0XHRcdFx0dGhpcy51bmJpbmRBbGwoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHVpZCBtdXN0IGFscmVhZHkgYmUgYXNzaWduZWRcblx0XHR0aGlzLmhhbmRsZUV2ZW50UHJvcHMoZGlzcGF0Y2hlcyk7XG5cblx0XHR0aGlzLmJpbmQoJ0Vycm9yJywgZnVuY3Rpb24oZSwgZXJyKSB7XG5cdFx0XHR0aGlzLnJlYWR5U3RhdGUgPSBGaWxlUmVhZGVyLkRPTkU7XG5cdFx0XHR0aGlzLmVycm9yID0gZXJyO1xuXHRcdH0sIDk5OSk7XG5cdFx0XG5cdFx0dGhpcy5iaW5kKCdMb2FkJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0dGhpcy5yZWFkeVN0YXRlID0gRmlsZVJlYWRlci5ET05FO1xuXHRcdH0sIDk5OSk7XG5cblx0XHRcblx0XHRmdW5jdGlvbiBfcmVhZChvcCwgYmxvYikge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1x0XHRcdFxuXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuXG5cdFx0XHRpZiAodGhpcy5yZWFkeVN0YXRlID09PSBGaWxlUmVhZGVyLkxPQURJTkcpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdlcnJvcicsIG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUikpO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWRlbmQnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiBzb3VyY2UgaXMgbm90IG8uQmxvYi9vLkZpbGVcblx0XHRcdGlmICghKGJsb2IgaW5zdGFuY2VvZiBCbG9iKSkge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2Vycm9yJywgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLk5PVF9GT1VORF9FUlIpKTtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdsb2FkZW5kJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yZXN1bHQgPSBudWxsO1xuXHRcdFx0dGhpcy5yZWFkeVN0YXRlID0gRmlsZVJlYWRlci5MT0FESU5HO1xuXHRcdFx0XG5cdFx0XHRpZiAoYmxvYi5pc0RldGFjaGVkKCkpIHtcblx0XHRcdFx0dmFyIHNyYyA9IGJsb2IuZ2V0U291cmNlKCk7XG5cdFx0XHRcdHN3aXRjaCAob3ApIHtcblx0XHRcdFx0XHRjYXNlICdyZWFkQXNUZXh0Jzpcblx0XHRcdFx0XHRjYXNlICdyZWFkQXNCaW5hcnlTdHJpbmcnOlxuXHRcdFx0XHRcdFx0dGhpcy5yZXN1bHQgPSBzcmM7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdyZWFkQXNEYXRhVVJMJzpcblx0XHRcdFx0XHRcdHRoaXMucmVzdWx0ID0gJ2RhdGE6JyArIGJsb2IudHlwZSArICc7YmFzZTY0LCcgKyBFbmNvZGUuYnRvYShzcmMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yZWFkeVN0YXRlID0gRmlsZVJlYWRlci5ET05FO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWQnKTtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdsb2FkZW5kJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNvbm5lY3RSdW50aW1lKGJsb2IucnVpZCk7XG5cdFx0XHRcdHRoaXMuZXhlYygnRmlsZVJlYWRlcicsICdyZWFkJywgb3AsIGJsb2IpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdEluaXRpYWwgRmlsZVJlYWRlciBzdGF0ZVxuXG5cdEBwcm9wZXJ0eSBFTVBUWVxuXHRAdHlwZSB7TnVtYmVyfVxuXHRAZmluYWxcblx0QHN0YXRpY1xuXHRAZGVmYXVsdCAwXG5cdCovXG5cdEZpbGVSZWFkZXIuRU1QVFkgPSAwO1xuXG5cdC8qKlxuXHRGaWxlUmVhZGVyIHN3aXRjaGVzIHRvIHRoaXMgc3RhdGUgd2hlbiBpdCBpcyBwcmVsb2FkaW5nIHRoZSBzb3VyY2VcblxuXHRAcHJvcGVydHkgTE9BRElOR1xuXHRAdHlwZSB7TnVtYmVyfVxuXHRAZmluYWxcblx0QHN0YXRpY1xuXHRAZGVmYXVsdCAxXG5cdCovXG5cdEZpbGVSZWFkZXIuTE9BRElORyA9IDE7XG5cblx0LyoqXG5cdFByZWxvYWRpbmcgaXMgY29tcGxldGUsIHRoaXMgaXMgYSBmaW5hbCBzdGF0ZVxuXG5cdEBwcm9wZXJ0eSBET05FXG5cdEB0eXBlIHtOdW1iZXJ9XG5cdEBmaW5hbFxuXHRAc3RhdGljXG5cdEBkZWZhdWx0IDJcblx0Ki9cblx0RmlsZVJlYWRlci5ET05FID0gMjtcblxuXHRGaWxlUmVhZGVyLnByb3RvdHlwZSA9IEV2ZW50VGFyZ2V0Lmluc3RhbmNlO1xuXG5cdHJldHVybiBGaWxlUmVhZGVyO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvdXRpbHMvVXJsLmpzXG5cbi8qKlxuICogVXJsLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvY29yZS91dGlscy9VcmwnLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJ1xuXSwgZnVuY3Rpb24oQmFzaWMpIHtcblx0LyoqXG5cdFBhcnNlIHVybCBpbnRvIHNlcGFyYXRlIGNvbXBvbmVudHMgYW5kIGZpbGwgaW4gYWJzZW50IHBhcnRzIHdpdGggcGFydHMgZnJvbSBjdXJyZW50IHVybCxcblx0YmFzZWQgb24gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9rdnovcGhwanMvbWFzdGVyL2Z1bmN0aW9ucy91cmwvcGFyc2VfdXJsLmpzXG5cblx0QG1ldGhvZCBwYXJzZVVybFxuXHRAZm9yIFV0aWxzXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHVybCBVcmwgdG8gcGFyc2UgKGRlZmF1bHRzIHRvIGVtcHR5IHN0cmluZyBpZiB1bmRlZmluZWQpXG5cdEByZXR1cm4ge09iamVjdH0gSGFzaCBjb250YWluaW5nIGV4dHJhY3RlZCB1cmkgY29tcG9uZW50c1xuXHQqL1xuXHR2YXIgcGFyc2VVcmwgPSBmdW5jdGlvbih1cmwsIGN1cnJlbnRVcmwpIHtcblx0XHR2YXIga2V5ID0gWydzb3VyY2UnLCAnc2NoZW1lJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3MnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnZnJhZ21lbnQnXVxuXHRcdCwgaSA9IGtleS5sZW5ndGhcblx0XHQsIHBvcnRzID0ge1xuXHRcdFx0aHR0cDogODAsXG5cdFx0XHRodHRwczogNDQzXG5cdFx0fVxuXHRcdCwgdXJpID0ge31cblx0XHQsIHJlZ2V4ID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKSg/Oig/OigpKD86KFteOkBcXC9dKik6PyhbXjpAXFwvXSopKT9AKT8oXFxbW1xcZGEtZkEtRjpdK1xcXXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygpKD86KCgpKD86KD86W14/I1xcL10qXFwvKSopKCkoPzpbXj8jXSopKSg/OlxcXFw/KFteI10qKSk/KD86IyguKikpPykvXG5cdFx0LCBtID0gcmVnZXguZXhlYyh1cmwgfHwgJycpXG5cdFx0LCBpc1JlbGF0aXZlXG5cdFx0LCBpc1NjaGVtZUxlc3MgPSAvXlxcL1xcL1xcdy8udGVzdCh1cmwpXG5cdFx0O1xuXG5cdFx0c3dpdGNoIChCYXNpYy50eXBlT2YoY3VycmVudFVybCkpIHtcblx0XHRcdGNhc2UgJ3VuZGVmaW5lZCc6XG5cdFx0XHRcdGN1cnJlbnRVcmwgPSBwYXJzZVVybChkb2N1bWVudC5sb2NhdGlvbi5ocmVmLCBmYWxzZSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0XHRjdXJyZW50VXJsID0gcGFyc2VVcmwoY3VycmVudFVybCwgZmFsc2UpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAobVtpXSkge1xuXHRcdFx0XHR1cmlba2V5W2ldXSA9IG1baV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aXNSZWxhdGl2ZSA9ICFpc1NjaGVtZUxlc3MgJiYgIXVyaS5zY2hlbWU7XG5cblx0XHRpZiAoaXNTY2hlbWVMZXNzIHx8IGlzUmVsYXRpdmUpIHtcblx0XHRcdHVyaS5zY2hlbWUgPSBjdXJyZW50VXJsLnNjaGVtZTtcblx0XHR9XG5cblx0XHQvLyB3aGVuIHVybCBpcyByZWxhdGl2ZSwgd2Ugc2V0IHRoZSBvcmlnaW4gYW5kIHRoZSBwYXRoIG91cnNlbHZlc1xuXHRcdGlmIChpc1JlbGF0aXZlKSB7XG5cdFx0XHR1cmkuaG9zdCA9IGN1cnJlbnRVcmwuaG9zdDtcblx0XHRcdHVyaS5wb3J0ID0gY3VycmVudFVybC5wb3J0O1xuXG5cdFx0XHR2YXIgcGF0aCA9ICcnO1xuXHRcdFx0Ly8gZm9yIHVybHMgd2l0aG91dCB0cmFpbGluZyBzbGFzaCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIHBhdGhcblx0XHRcdGlmICgvXlteXFwvXS8udGVzdCh1cmkucGF0aCkpIHtcblx0XHRcdFx0cGF0aCA9IGN1cnJlbnRVcmwucGF0aDtcblx0XHRcdFx0Ly8gaWYgcGF0aCBlbmRzIHdpdGggYSBmaWxlbmFtZSwgc3RyaXAgaXRcblx0XHRcdFx0aWYgKC9cXC9bXlxcL10qXFwuW15cXC9dKiQvLnRlc3QocGF0aCkpIHtcblx0XHRcdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC9bXlxcL10rJC8sICcvJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYXZvaWQgZG91YmxlIHNsYXNoIGF0IHRoZSBlbmQgKHNlZSAjMTI3KVxuXHRcdFx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLz8kLywgJy8nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dXJpLnBhdGggPSBwYXRoICsgKHVyaS5wYXRoIHx8ICcnKTsgLy8gc2l0ZSBtYXkgcmVzaWRlIGF0IGRvbWFpbi5jb20gb3IgZG9tYWluLmNvbS9zdWJkaXJcblx0XHR9XG5cblx0XHRpZiAoIXVyaS5wb3J0KSB7XG5cdFx0XHR1cmkucG9ydCA9IHBvcnRzW3VyaS5zY2hlbWVdIHx8IDgwO1xuXHRcdH1cblxuXHRcdHVyaS5wb3J0ID0gcGFyc2VJbnQodXJpLnBvcnQsIDEwKTtcblxuXHRcdGlmICghdXJpLnBhdGgpIHtcblx0XHRcdHVyaS5wYXRoID0gXCIvXCI7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHVyaS5zb3VyY2U7XG5cblx0XHRyZXR1cm4gdXJpO1xuXHR9O1xuXG5cdC8qKlxuXHRSZXNvbHZlIHVybCAtIGFtb25nIG90aGVyIHRoaW5ncyB3aWxsIHR1cm4gcmVsYXRpdmUgdXJsIHRvIGFic29sdXRlXG5cblx0QG1ldGhvZCByZXNvbHZlVXJsXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmwgRWl0aGVyIGFic29sdXRlIG9yIHJlbGF0aXZlLCBvciBhIHJlc3VsdCBvZiBwYXJzZVVybCBjYWxsXG5cdEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQsIGFic29sdXRlIHVybFxuXHQqL1xuXHR2YXIgcmVzb2x2ZVVybCA9IGZ1bmN0aW9uKHVybCkge1xuXHRcdHZhciBwb3J0cyA9IHsgLy8gd2UgaWdub3JlIGRlZmF1bHQgcG9ydHNcblx0XHRcdGh0dHA6IDgwLFxuXHRcdFx0aHR0cHM6IDQ0M1xuXHRcdH1cblx0XHQsIHVybHAgPSB0eXBlb2YodXJsKSA9PT0gJ29iamVjdCcgPyB1cmwgOiBwYXJzZVVybCh1cmwpO1xuXHRcdDtcblxuXHRcdHJldHVybiB1cmxwLnNjaGVtZSArICc6Ly8nICsgdXJscC5ob3N0ICsgKHVybHAucG9ydCAhPT0gcG9ydHNbdXJscC5zY2hlbWVdID8gJzonICsgdXJscC5wb3J0IDogJycpICsgdXJscC5wYXRoICsgKHVybHAucXVlcnkgPyB1cmxwLnF1ZXJ5IDogJycpO1xuXHR9O1xuXG5cdC8qKlxuXHRDaGVjayBpZiBzcGVjaWZpZWQgdXJsIGhhcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcblxuXHRAbWV0aG9kIGhhc1NhbWVPcmlnaW5cblx0QHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmxcblx0QHJldHVybiB7Qm9vbGVhbn1cblx0Ki9cblx0dmFyIGhhc1NhbWVPcmlnaW4gPSBmdW5jdGlvbih1cmwpIHtcblx0XHRmdW5jdGlvbiBvcmlnaW4odXJsKSB7XG5cdFx0XHRyZXR1cm4gW3VybC5zY2hlbWUsIHVybC5ob3N0LCB1cmwucG9ydF0uam9pbignLycpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuXHRcdFx0dXJsID0gcGFyc2VVcmwodXJsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3JpZ2luKHBhcnNlVXJsKCkpID09PSBvcmlnaW4odXJsKTtcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdHBhcnNlVXJsOiBwYXJzZVVybCxcblx0XHRyZXNvbHZlVXJsOiByZXNvbHZlVXJsLFxuXHRcdGhhc1NhbWVPcmlnaW46IGhhc1NhbWVPcmlnaW5cblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL1J1bnRpbWVUYXJnZXQuanNcblxuLyoqXG4gKiBSdW50aW1lVGFyZ2V0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvcnVudGltZS9SdW50aW1lVGFyZ2V0JywgW1xuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYycsXG5cdCdtb3hpZS9ydW50aW1lL1J1bnRpbWVDbGllbnQnLFxuXHRcIm1veGllL2NvcmUvRXZlbnRUYXJnZXRcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIFJ1bnRpbWVDbGllbnQsIEV2ZW50VGFyZ2V0KSB7XG5cdC8qKlxuXHRJbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGNhbiBiZSB1c2VkIGFzIGEgdGFyZ2V0IGZvciB0aGUgZXZlbnRzIGRpc3BhdGNoZWQgYnkgc2hpbXMsXG5cdHdoZW4gYWxsb3dpbmcgdGhlbSBvbnRvIGNvbXBvbmVudHMgaXMgZm9yIGVpdGhlciByZWFzb24gaW5hcHByb3ByaWF0ZVxuXG5cdEBjbGFzcyBtb3hpZS9ydW50aW1lL1J1bnRpbWVUYXJnZXRcblx0QGNvbnN0cnVjdG9yXG5cdEBwcm90ZWN0ZWRcblx0QGV4dGVuZHMgRXZlbnRUYXJnZXRcblx0Ki9cblx0ZnVuY3Rpb24gUnVudGltZVRhcmdldCgpIHtcblx0XHR0aGlzLnVpZCA9IEJhc2ljLmd1aWQoJ3VpZF8nKTtcblx0XHRcblx0XHRSdW50aW1lQ2xpZW50LmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZGlzY29ubmVjdFJ1bnRpbWUoKTtcblx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cdFx0fTtcblx0fVxuXG5cdFJ1bnRpbWVUYXJnZXQucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cblx0cmV0dXJuIFJ1bnRpbWVUYXJnZXQ7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvZmlsZS9GaWxlUmVhZGVyU3luYy5qc1xuXG4vKipcbiAqIEZpbGVSZWFkZXJTeW5jLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvZmlsZS9GaWxlUmVhZGVyU3luYycsIFtcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnLFxuXHQnbW94aWUvcnVudGltZS9SdW50aW1lQ2xpZW50Jyxcblx0J21veGllL2NvcmUvdXRpbHMvRW5jb2RlJ1xuXSwgZnVuY3Rpb24oQmFzaWMsIFJ1bnRpbWVDbGllbnQsIEVuY29kZSkge1xuXHQvKipcblx0U3luY2hyb25vdXMgRmlsZVJlYWRlciBpbXBsZW1lbnRhdGlvbi4gU29tZXRoaW5nIGxpa2UgdGhpcyBpcyBhdmFpbGFibGUgaW4gV2ViV29ya2VycyBlbnZpcm9ubWVudCwgaGVyZVxuXHRpdCBjYW4gYmUgdXNlZCB0byByZWFkIG9ubHkgcHJlbG9hZGVkIGJsb2JzL2ZpbGVzIGFuZCBvbmx5IGJlbG93IGNlcnRhaW4gc2l6ZSAobm90IHlldCBzdXJlIHdoYXQgdGhhdCdkIGJlLFxuXHRidXQgcHJvYmFibHkgPCAxbWIpLiBOb3QgbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseSBieSB1c2VyLlxuXG5cdEBjbGFzcyBtb3hpZS9maWxlL0ZpbGVSZWFkZXJTeW5jXG5cdEBwcml2YXRlXG5cdEBjb25zdHJ1Y3RvclxuXHQqL1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0UnVudGltZUNsaWVudC5jYWxsKHRoaXMpO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdHVpZDogQmFzaWMuZ3VpZCgndWlkXycpLFxuXG5cdFx0XHRyZWFkQXNCaW5hcnlTdHJpbmc6IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdFx0cmV0dXJuIF9yZWFkLmNhbGwodGhpcywgJ3JlYWRBc0JpbmFyeVN0cmluZycsIGJsb2IpO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0cmVhZEFzRGF0YVVSTDogZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gX3JlYWQuY2FsbCh0aGlzLCAncmVhZEFzRGF0YVVSTCcsIGJsb2IpO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LypyZWFkQXNBcnJheUJ1ZmZlcjogZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gX3JlYWQuY2FsbCh0aGlzLCAncmVhZEFzQXJyYXlCdWZmZXInLCBibG9iKTtcblx0XHRcdH0sKi9cblx0XHRcdFxuXHRcdFx0cmVhZEFzVGV4dDogZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gX3JlYWQuY2FsbCh0aGlzLCAncmVhZEFzVGV4dCcsIGJsb2IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZnVuY3Rpb24gX3JlYWQob3AsIGJsb2IpIHtcblx0XHRcdGlmIChibG9iLmlzRGV0YWNoZWQoKSkge1xuXHRcdFx0XHR2YXIgc3JjID0gYmxvYi5nZXRTb3VyY2UoKTtcblx0XHRcdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0XHRcdGNhc2UgJ3JlYWRBc0JpbmFyeVN0cmluZyc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3JjO1xuXHRcdFx0XHRcdGNhc2UgJ3JlYWRBc0RhdGFVUkwnOlxuXHRcdFx0XHRcdFx0cmV0dXJuICdkYXRhOicgKyBibG9iLnR5cGUgKyAnO2Jhc2U2NCwnICsgRW5jb2RlLmJ0b2Eoc3JjKTtcblx0XHRcdFx0XHRjYXNlICdyZWFkQXNUZXh0Jzpcblx0XHRcdFx0XHRcdHZhciB0eHQgPSAnJztcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzcmMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dHh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3JjW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB0eHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmNvbm5lY3RSdW50aW1lKGJsb2IucnVpZCkuZXhlYy5jYWxsKHRoaXMsICdGaWxlUmVhZGVyU3luYycsICdyZWFkJywgb3AsIGJsb2IpO1xuXHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RSdW50aW1lKCk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3hoci9Gb3JtRGF0YS5qc1xuXG4vKipcbiAqIEZvcm1EYXRhLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZShcIm1veGllL3hoci9Gb3JtRGF0YVwiLCBbXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2ZpbGUvQmxvYlwiXG5dLCBmdW5jdGlvbih4LCBCYXNpYywgQmxvYikge1xuXHQvKipcblx0Rm9ybURhdGFcblxuXHRAY2xhc3MgbW94aWUveGhyL0Zvcm1EYXRhXG5cdEBjb25zdHJ1Y3RvclxuXHQqL1xuXHRmdW5jdGlvbiBGb3JtRGF0YSgpIHtcblx0XHR2YXIgX2Jsb2IsIF9maWVsZHMgPSBbXTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHQvKipcblx0XHRcdEFwcGVuZCBhbm90aGVyIGtleS12YWx1ZSBwYWlyIHRvIHRoZSBGb3JtRGF0YSBvYmplY3RcblxuXHRcdFx0QG1ldGhvZCBhcHBlbmRcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgZm9yIHRoZSBuZXcgZmllbGRcblx0XHRcdEBwYXJhbSB7U3RyaW5nfEJsb2J8QXJyYXl8T2JqZWN0fSB2YWx1ZSBWYWx1ZSBmb3IgdGhlIGZpZWxkXG5cdFx0XHQqL1xuXHRcdFx0YXBwZW5kOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHZhbHVlVHlwZSA9IEJhc2ljLnR5cGVPZih2YWx1ZSk7XG5cblx0XHRcdFx0Ly8gYWNjb3JkaW5nIHRvIHNwZWNzIHZhbHVlIG1pZ2h0IGJlIGVpdGhlciBCbG9iIG9yIFN0cmluZ1xuXHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdFx0X2Jsb2IgPSB7XG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlIC8vIHVuZm9ydHVuYXRlbHkgd2UgY2FuIG9ubHkgc2VuZCBzaW5nbGUgQmxvYiBpbiBvbmUgRm9ybURhdGFcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCdhcnJheScgPT09IHZhbHVlVHlwZSkge1xuXHRcdFx0XHRcdG5hbWUgKz0gJ1tdJztcblxuXHRcdFx0XHRcdEJhc2ljLmVhY2godmFsdWUsIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHZhbHVlVHlwZSkge1xuXHRcdFx0XHRcdEJhc2ljLmVhY2godmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdHNlbGYuYXBwZW5kKG5hbWUgKyAnWycgKyBrZXkgKyAnXScsIHZhbHVlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIGlmICgnbnVsbCcgPT09IHZhbHVlVHlwZSB8fCAndW5kZWZpbmVkJyA9PT0gdmFsdWVUeXBlIHx8ICdudW1iZXInID09PSB2YWx1ZVR5cGUgJiYgaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdFx0c2VsZi5hcHBlbmQobmFtZSwgXCJmYWxzZVwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZmllbGRzLnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b1N0cmluZygpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0Q2hlY2tzIGlmIEZvcm1EYXRhIGNvbnRhaW5zIEJsb2IuXG5cblx0XHRcdEBtZXRob2QgaGFzQmxvYlxuXHRcdFx0QHJldHVybiB7Qm9vbGVhbn1cblx0XHRcdCovXG5cdFx0XHRoYXNCbG9iOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhdGhpcy5nZXRCbG9iKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHJpZXZlcyBibG9iLlxuXG5cdFx0XHRAbWV0aG9kIGdldEJsb2Jcblx0XHRcdEByZXR1cm4ge09iamVjdH0gRWl0aGVyIEJsb2IgaWYgZm91bmQgb3IgbnVsbFxuXHRcdFx0Ki9cblx0XHRcdGdldEJsb2I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX2Jsb2IgJiYgX2Jsb2IudmFsdWUgfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0UmV0cmlldmVzIGJsb2IgZmllbGQgbmFtZS5cblxuXHRcdFx0QG1ldGhvZCBnZXRCbG9iTmFtZVxuXHRcdFx0QHJldHVybiB7U3RyaW5nfSBFaXRoZXIgQmxvYiBmaWVsZCBuYW1lIG9yIG51bGxcblx0XHRcdCovXG5cdFx0XHRnZXRCbG9iTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfYmxvYiAmJiBfYmxvYi5uYW1lIHx8IG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdExvb3Agb3ZlciB0aGUgZmllbGRzIGluIEZvcm1EYXRhIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZW0uXG5cblx0XHRcdEBtZXRob2QgZWFjaFxuXHRcdFx0QHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBmaWVsZFxuXHRcdFx0Ki9cblx0XHRcdGVhY2g6IGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdEJhc2ljLmVhY2goX2ZpZWxkcywgZnVuY3Rpb24oZmllbGQpIHtcblx0XHRcdFx0XHRjYihmaWVsZC52YWx1ZSwgZmllbGQubmFtZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChfYmxvYikge1xuXHRcdFx0XHRcdGNiKF9ibG9iLnZhbHVlLCBfYmxvYi5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9ibG9iID0gbnVsbDtcblx0XHRcdFx0X2ZpZWxkcyA9IFtdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIEZvcm1EYXRhO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3hoci9YTUxIdHRwUmVxdWVzdC5qc1xuXG4vKipcbiAqIFhNTEh0dHBSZXF1ZXN0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZShcIm1veGllL3hoci9YTUxIdHRwUmVxdWVzdFwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL2NvcmUvRXZlbnRUYXJnZXRcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VuY29kZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvVXJsXCIsXG5cdFwibW94aWUvcnVudGltZS9SdW50aW1lXCIsXG5cdFwibW94aWUvcnVudGltZS9SdW50aW1lVGFyZ2V0XCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlUmVhZGVyU3luY1wiLFxuXHRcIm1veGllL3hoci9Gb3JtRGF0YVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCIsXG5cdFwibW94aWUvY29yZS91dGlscy9NaW1lXCJcbl0sIGZ1bmN0aW9uKEJhc2ljLCB4LCBFdmVudFRhcmdldCwgRW5jb2RlLCBVcmwsIFJ1bnRpbWUsIFJ1bnRpbWVUYXJnZXQsIEJsb2IsIEZpbGVSZWFkZXJTeW5jLCBGb3JtRGF0YSwgRW52LCBNaW1lKSB7XG5cblx0dmFyIGh0dHBDb2RlID0ge1xuXHRcdDEwMDogJ0NvbnRpbnVlJyxcblx0XHQxMDE6ICdTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcblx0XHQxMDI6ICdQcm9jZXNzaW5nJyxcblxuXHRcdDIwMDogJ09LJyxcblx0XHQyMDE6ICdDcmVhdGVkJyxcblx0XHQyMDI6ICdBY2NlcHRlZCcsXG5cdFx0MjAzOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuXHRcdDIwNDogJ05vIENvbnRlbnQnLFxuXHRcdDIwNTogJ1Jlc2V0IENvbnRlbnQnLFxuXHRcdDIwNjogJ1BhcnRpYWwgQ29udGVudCcsXG5cdFx0MjA3OiAnTXVsdGktU3RhdHVzJyxcblx0XHQyMjY6ICdJTSBVc2VkJyxcblxuXHRcdDMwMDogJ011bHRpcGxlIENob2ljZXMnLFxuXHRcdDMwMTogJ01vdmVkIFBlcm1hbmVudGx5Jyxcblx0XHQzMDI6ICdGb3VuZCcsXG5cdFx0MzAzOiAnU2VlIE90aGVyJyxcblx0XHQzMDQ6ICdOb3QgTW9kaWZpZWQnLFxuXHRcdDMwNTogJ1VzZSBQcm94eScsXG5cdFx0MzA2OiAnUmVzZXJ2ZWQnLFxuXHRcdDMwNzogJ1RlbXBvcmFyeSBSZWRpcmVjdCcsXG5cblx0XHQ0MDA6ICdCYWQgUmVxdWVzdCcsXG5cdFx0NDAxOiAnVW5hdXRob3JpemVkJyxcblx0XHQ0MDI6ICdQYXltZW50IFJlcXVpcmVkJyxcblx0XHQ0MDM6ICdGb3JiaWRkZW4nLFxuXHRcdDQwNDogJ05vdCBGb3VuZCcsXG5cdFx0NDA1OiAnTWV0aG9kIE5vdCBBbGxvd2VkJyxcblx0XHQ0MDY6ICdOb3QgQWNjZXB0YWJsZScsXG5cdFx0NDA3OiAnUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnLFxuXHRcdDQwODogJ1JlcXVlc3QgVGltZW91dCcsXG5cdFx0NDA5OiAnQ29uZmxpY3QnLFxuXHRcdDQxMDogJ0dvbmUnLFxuXHRcdDQxMTogJ0xlbmd0aCBSZXF1aXJlZCcsXG5cdFx0NDEyOiAnUHJlY29uZGl0aW9uIEZhaWxlZCcsXG5cdFx0NDEzOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJyxcblx0XHQ0MTQ6ICdSZXF1ZXN0LVVSSSBUb28gTG9uZycsXG5cdFx0NDE1OiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG5cdFx0NDE2OiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG5cdFx0NDE3OiAnRXhwZWN0YXRpb24gRmFpbGVkJyxcblx0XHQ0MjI6ICdVbnByb2Nlc3NhYmxlIEVudGl0eScsXG5cdFx0NDIzOiAnTG9ja2VkJyxcblx0XHQ0MjQ6ICdGYWlsZWQgRGVwZW5kZW5jeScsXG5cdFx0NDI2OiAnVXBncmFkZSBSZXF1aXJlZCcsXG5cblx0XHQ1MDA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuXHRcdDUwMTogJ05vdCBJbXBsZW1lbnRlZCcsXG5cdFx0NTAyOiAnQmFkIEdhdGV3YXknLFxuXHRcdDUwMzogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLFxuXHRcdDUwNDogJ0dhdGV3YXkgVGltZW91dCcsXG5cdFx0NTA1OiAnSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnLFxuXHRcdDUwNjogJ1ZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzJyxcblx0XHQ1MDc6ICdJbnN1ZmZpY2llbnQgU3RvcmFnZScsXG5cdFx0NTEwOiAnTm90IEV4dGVuZGVkJ1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0VXBsb2FkKCkge1xuXHRcdHRoaXMudWlkID0gQmFzaWMuZ3VpZCgndWlkXycpO1xuXHR9XG5cblx0WE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cblx0LyoqXG5cdEltcGxlbWVudGF0aW9uIG9mIFhNTEh0dHBSZXF1ZXN0XG5cblx0QGNsYXNzIG1veGllL3hoci9YTUxIdHRwUmVxdWVzdFxuXHRAY29uc3RydWN0b3Jcblx0QHVzZXMgUnVudGltZUNsaWVudFxuXHRAZXh0ZW5kcyBFdmVudFRhcmdldFxuXHQqL1xuXHR2YXIgZGlzcGF0Y2hlcyA9IFtcblx0XHQnbG9hZHN0YXJ0JyxcblxuXHRcdCdwcm9ncmVzcycsXG5cblx0XHQnYWJvcnQnLFxuXG5cdFx0J2Vycm9yJyxcblxuXHRcdCdsb2FkJyxcblxuXHRcdCd0aW1lb3V0JyxcblxuXHRcdCdsb2FkZW5kJ1xuXG5cdFx0Ly8gcmVhZHlzdGF0ZWNoYW5nZSAoZm9yIGhpc3RvcmljYWwgcmVhc29ucylcblx0XTtcblxuXHR2YXIgTkFUSVZFID0gMSwgUlVOVElNRSA9IDI7XG5cblx0ZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3QoKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0Ly8gdGhpcyAodG9nZXRoZXIgd2l0aCBfcCgpIEBzZWUgYmVsb3cpIGlzIGhlcmUgdG8gZ3JhY2VmdWxseSB1cGdyYWRlIHRvIHNldHRlci9nZXR0ZXIgc3ludGF4IHdoZXJlIHBvc3NpYmxlXG5cdFx0XHRwcm9wcyA9IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIGEgcmVxdWVzdCBjYW4gdGFrZSBiZWZvcmUgYmVpbmcgdGVybWluYXRlZC4gSW5pdGlhbGx5IHplcm8uIFplcm8gbWVhbnMgdGhlcmUgaXMgbm8gdGltZW91dC5cblxuXHRcdFx0XHRAcHJvcGVydHkgdGltZW91dFxuXHRcdFx0XHRAdHlwZSBOdW1iZXJcblx0XHRcdFx0QGRlZmF1bHQgMFxuXHRcdFx0XHQqL1xuXHRcdFx0XHR0aW1lb3V0OiAwLFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHRDdXJyZW50IHN0YXRlLCBjYW4gdGFrZSBmb2xsb3dpbmcgdmFsdWVzOlxuXHRcdFx0XHRVTlNFTlQgKG51bWVyaWMgdmFsdWUgMClcblx0XHRcdFx0VGhlIG9iamVjdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZC5cblxuXHRcdFx0XHRPUEVORUQgKG51bWVyaWMgdmFsdWUgMSlcblx0XHRcdFx0VGhlIG9wZW4oKSBtZXRob2QgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGludm9rZWQuIER1cmluZyB0aGlzIHN0YXRlIHJlcXVlc3QgaGVhZGVycyBjYW4gYmUgc2V0IHVzaW5nIHNldFJlcXVlc3RIZWFkZXIoKSBhbmQgdGhlIHJlcXVlc3QgY2FuIGJlIG1hZGUgdXNpbmcgdGhlIHNlbmQoKSBtZXRob2QuXG5cblx0XHRcdFx0SEVBREVSU19SRUNFSVZFRCAobnVtZXJpYyB2YWx1ZSAyKVxuXHRcdFx0XHRBbGwgcmVkaXJlY3RzIChpZiBhbnkpIGhhdmUgYmVlbiBmb2xsb3dlZCBhbmQgYWxsIEhUVFAgaGVhZGVycyBvZiB0aGUgZmluYWwgcmVzcG9uc2UgaGF2ZSBiZWVuIHJlY2VpdmVkLiBTZXZlcmFsIHJlc3BvbnNlIG1lbWJlcnMgb2YgdGhlIG9iamVjdCBhcmUgbm93IGF2YWlsYWJsZS5cblxuXHRcdFx0XHRMT0FESU5HIChudW1lcmljIHZhbHVlIDMpXG5cdFx0XHRcdFRoZSByZXNwb25zZSBlbnRpdHkgYm9keSBpcyBiZWluZyByZWNlaXZlZC5cblxuXHRcdFx0XHRET05FIChudW1lcmljIHZhbHVlIDQpXG5cblx0XHRcdFx0QHByb3BlcnR5IHJlYWR5U3RhdGVcblx0XHRcdFx0QHR5cGUgTnVtYmVyXG5cdFx0XHRcdEBkZWZhdWx0IDAgKFVOU0VOVClcblx0XHRcdFx0Ki9cblx0XHRcdFx0cmVhZHlTdGF0ZTogWE1MSHR0cFJlcXVlc3QuVU5TRU5ULFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHRUcnVlIHdoZW4gdXNlciBjcmVkZW50aWFscyBhcmUgdG8gYmUgaW5jbHVkZWQgaW4gYSBjcm9zcy1vcmlnaW4gcmVxdWVzdC4gRmFsc2Ugd2hlbiB0aGV5IGFyZSB0byBiZSBleGNsdWRlZFxuXHRcdFx0XHRpbiBhIGNyb3NzLW9yaWdpbiByZXF1ZXN0IGFuZCB3aGVuIGNvb2tpZXMgYXJlIHRvIGJlIGlnbm9yZWQgaW4gaXRzIHJlc3BvbnNlLiBJbml0aWFsbHkgZmFsc2UuXG5cblx0XHRcdFx0QHByb3BlcnR5IHdpdGhDcmVkZW50aWFsc1xuXHRcdFx0XHRAdHlwZSBCb29sZWFuXG5cdFx0XHRcdEBkZWZhdWx0IGZhbHNlXG5cdFx0XHRcdCovXG5cdFx0XHRcdHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdFJldHVybnMgdGhlIEhUVFAgc3RhdHVzIGNvZGUuXG5cblx0XHRcdFx0QHByb3BlcnR5IHN0YXR1c1xuXHRcdFx0XHRAdHlwZSBOdW1iZXJcblx0XHRcdFx0QGRlZmF1bHQgMFxuXHRcdFx0XHQqL1xuXHRcdFx0XHRzdGF0dXM6IDAsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdFJldHVybnMgdGhlIEhUVFAgc3RhdHVzIHRleHQuXG5cblx0XHRcdFx0QHByb3BlcnR5IHN0YXR1c1RleHRcblx0XHRcdFx0QHR5cGUgU3RyaW5nXG5cdFx0XHRcdCovXG5cdFx0XHRcdHN0YXR1c1RleHQ6IFwiXCIsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdFJldHVybnMgdGhlIHJlc3BvbnNlIHR5cGUuIENhbiBiZSBzZXQgdG8gY2hhbmdlIHRoZSByZXNwb25zZSB0eXBlLiBWYWx1ZXMgYXJlOlxuXHRcdFx0XHR0aGUgZW1wdHkgc3RyaW5nIChkZWZhdWx0KSwgXCJhcnJheWJ1ZmZlclwiLCBcImJsb2JcIiwgXCJkb2N1bWVudFwiLCBcImpzb25cIiwgYW5kIFwidGV4dFwiLlxuXG5cdFx0XHRcdEBwcm9wZXJ0eSByZXNwb25zZVR5cGVcblx0XHRcdFx0QHR5cGUgU3RyaW5nXG5cdFx0XHRcdCovXG5cdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJcIixcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0UmV0dXJucyB0aGUgZG9jdW1lbnQgcmVzcG9uc2UgZW50aXR5IGJvZHkuXG5cblx0XHRcdFx0VGhyb3dzIGFuIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBleGNlcHRpb24gaWYgcmVzcG9uc2VUeXBlIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nIG9yIFwiZG9jdW1lbnRcIi5cblxuXHRcdFx0XHRAcHJvcGVydHkgcmVzcG9uc2VYTUxcblx0XHRcdFx0QHR5cGUgRG9jdW1lbnRcblx0XHRcdFx0Ki9cblx0XHRcdFx0cmVzcG9uc2VYTUw6IG51bGwsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdFJldHVybnMgdGhlIHRleHQgcmVzcG9uc2UgZW50aXR5IGJvZHkuXG5cblx0XHRcdFx0VGhyb3dzIGFuIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBleGNlcHRpb24gaWYgcmVzcG9uc2VUeXBlIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nIG9yIFwidGV4dFwiLlxuXG5cdFx0XHRcdEBwcm9wZXJ0eSByZXNwb25zZVRleHRcblx0XHRcdFx0QHR5cGUgU3RyaW5nXG5cdFx0XHRcdCovXG5cdFx0XHRcdHJlc3BvbnNlVGV4dDogbnVsbCxcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0UmV0dXJucyB0aGUgcmVzcG9uc2UgZW50aXR5IGJvZHkgKGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyNyZXNwb25zZS1lbnRpdHktYm9keSkuXG5cdFx0XHRcdENhbiBiZWNvbWU6IEFycmF5QnVmZmVyLCBCbG9iLCBEb2N1bWVudCwgSlNPTiwgVGV4dFxuXG5cdFx0XHRcdEBwcm9wZXJ0eSByZXNwb25zZVxuXHRcdFx0XHRAdHlwZSBNaXhlZFxuXHRcdFx0XHQqL1xuXHRcdFx0XHRyZXNwb25zZTogbnVsbFxuXHRcdFx0fSxcblxuXHRcdFx0X2FzeW5jID0gdHJ1ZSxcblx0XHRcdF91cmwsXG5cdFx0XHRfbWV0aG9kLFxuXHRcdFx0X2hlYWRlcnMgPSB7fSxcblx0XHRcdF91c2VyLFxuXHRcdFx0X3Bhc3N3b3JkLFxuXHRcdFx0X2VuY29kaW5nID0gbnVsbCxcblx0XHRcdF9taW1lVHlwZSA9IG51bGwsXG5cblx0XHRcdC8vIGZsYWdzXG5cdFx0XHRfc3luY19mbGFnID0gZmFsc2UsXG5cdFx0XHRfc2VuZF9mbGFnID0gZmFsc2UsXG5cdFx0XHRfdXBsb2FkX2V2ZW50c19mbGFnID0gZmFsc2UsXG5cdFx0XHRfdXBsb2FkX2NvbXBsZXRlX2ZsYWcgPSBmYWxzZSxcblx0XHRcdF9lcnJvcl9mbGFnID0gZmFsc2UsXG5cdFx0XHRfc2FtZV9vcmlnaW5fZmxhZyA9IGZhbHNlLFxuXG5cdFx0XHQvLyB0aW1lc1xuXHRcdFx0X3N0YXJ0X3RpbWUsXG5cdFx0XHRfdGltZW91dHNldF90aW1lLFxuXG5cdFx0XHRfZmluYWxNaW1lID0gbnVsbCxcblx0XHRcdF9maW5hbENoYXJzZXQgPSBudWxsLFxuXG5cdFx0XHRfb3B0aW9ucyA9IHt9LFxuXHRcdFx0X3hocixcblx0XHRcdF9yZXNwb25zZUhlYWRlcnMgPSAnJyxcblx0XHRcdF9yZXNwb25zZUhlYWRlcnNCYWdcblx0XHRcdDtcblxuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHByb3BzLCB7XG5cdFx0XHQvKipcblx0XHRcdFVuaXF1ZSBpZCBvZiB0aGUgY29tcG9uZW50XG5cblx0XHRcdEBwcm9wZXJ0eSB1aWRcblx0XHRcdEB0eXBlIFN0cmluZ1xuXHRcdFx0Ki9cblx0XHRcdHVpZDogQmFzaWMuZ3VpZCgndWlkXycpLFxuXG5cdFx0XHQvKipcblx0XHRcdFRhcmdldCBmb3IgVXBsb2FkIGV2ZW50c1xuXG5cdFx0XHRAcHJvcGVydHkgdXBsb2FkXG5cdFx0XHRAdHlwZSBYTUxIdHRwUmVxdWVzdFVwbG9hZFxuXHRcdFx0Ki9cblx0XHRcdHVwbG9hZDogbmV3IFhNTEh0dHBSZXF1ZXN0VXBsb2FkKCksXG5cblxuXHRcdFx0LyoqXG5cdFx0XHRTZXRzIHRoZSByZXF1ZXN0IG1ldGhvZCwgcmVxdWVzdCBVUkwsIHN5bmNocm9ub3VzIGZsYWcsIHJlcXVlc3QgdXNlcm5hbWUsIGFuZCByZXF1ZXN0IHBhc3N3b3JkLlxuXG5cdFx0XHRUaHJvd3MgYSBcIlN5bnRheEVycm9yXCIgZXhjZXB0aW9uIGlmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG5cblx0XHRcdG1ldGhvZCBpcyBub3QgYSB2YWxpZCBIVFRQIG1ldGhvZC5cblx0XHRcdHVybCBjYW5ub3QgYmUgcmVzb2x2ZWQuXG5cdFx0XHR1cmwgY29udGFpbnMgdGhlIFwidXNlcjpwYXNzd29yZFwiIGZvcm1hdCBpbiB0aGUgdXNlcmluZm8gcHJvZHVjdGlvbi5cblx0XHRcdFRocm93cyBhIFwiU2VjdXJpdHlFcnJvclwiIGV4Y2VwdGlvbiBpZiBtZXRob2QgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBDT05ORUNULCBUUkFDRSBvciBUUkFDSy5cblxuXHRcdFx0VGhyb3dzIGFuIFwiSW52YWxpZEFjY2Vzc0Vycm9yXCIgZXhjZXB0aW9uIGlmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG5cblx0XHRcdEVpdGhlciB1c2VyIG9yIHBhc3N3b3JkIGlzIHBhc3NlZCBhcyBhcmd1bWVudCBhbmQgdGhlIG9yaWdpbiBvZiB1cmwgZG9lcyBub3QgbWF0Y2ggdGhlIFhNTEh0dHBSZXF1ZXN0IG9yaWdpbi5cblx0XHRcdFRoZXJlIGlzIGFuIGFzc29jaWF0ZWQgWE1MSHR0cFJlcXVlc3QgZG9jdW1lbnQgYW5kIGVpdGhlciB0aGUgdGltZW91dCBhdHRyaWJ1dGUgaXMgbm90IHplcm8sXG5cdFx0XHR0aGUgd2l0aENyZWRlbnRpYWxzIGF0dHJpYnV0ZSBpcyB0cnVlLCBvciB0aGUgcmVzcG9uc2VUeXBlIGF0dHJpYnV0ZSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZy5cblxuXG5cdFx0XHRAbWV0aG9kIG9wZW5cblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgSFRUUCBtZXRob2QgdG8gdXNlIG9uIHJlcXVlc3Rcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIHJlcXVlc3Rcblx0XHRcdEBwYXJhbSB7Qm9vbGVhbn0gW2FzeW5jPXRydWVdIElmIGZhbHNlIHJlcXVlc3Qgd2lsbCBiZSBkb25lIGluIHN5bmNocm9ub3VzIG1hbm5lci4gQXN5bmNocm9ub3VzIGJ5IGRlZmF1bHQuXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gW3VzZXJdIFVzZXJuYW1lIHRvIHVzZSBpbiBIVFRQIGF1dGhlbnRpY2F0aW9uIHByb2Nlc3Mgb24gc2VydmVyLXNpZGVcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBbcGFzc3dvcmRdIFBhc3N3b3JkIHRvIHVzZSBpbiBIVFRQIGF1dGhlbnRpY2F0aW9uIHByb2Nlc3Mgb24gc2VydmVyLXNpZGVcblx0XHRcdCovXG5cdFx0XHRvcGVuOiBmdW5jdGlvbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XG5cdFx0XHRcdHZhciB1cmxwO1xuXG5cdFx0XHRcdC8vIGZpcnN0IHR3byBhcmd1bWVudHMgYXJlIHJlcXVpcmVkXG5cdFx0XHRcdGlmICghbWV0aG9kIHx8ICF1cmwpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uU1lOVEFYX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAyIC0gY2hlY2sgaWYgYW55IGNvZGUgcG9pbnQgaW4gbWV0aG9kIGlzIGhpZ2hlciB0aGFuIFUrMDBGRiBvciBhZnRlciBkZWZsYXRpbmcgbWV0aG9kIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBtZXRob2Rcblx0XHRcdFx0aWYgKC9bXFx1MDEwMC1cXHVmZmZmXS8udGVzdChtZXRob2QpIHx8IEVuY29kZS51dGY4X2VuY29kZShtZXRob2QpICE9PSBtZXRob2QpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uU1lOVEFYX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAzXG5cdFx0XHRcdGlmICghIX5CYXNpYy5pbkFycmF5KG1ldGhvZC50b1VwcGVyQ2FzZSgpLCBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnLCAnVFJBQ0snXSkpIHtcblx0XHRcdFx0XHRfbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vIDQgLSBhbGxvd2luZyB0aGVzZSBtZXRob2RzIHBvc2VzIGEgc2VjdXJpdHkgcmlza1xuXHRcdFx0XHRpZiAoISF+QmFzaWMuaW5BcnJheShfbWV0aG9kLCBbJ0NPTk5FQ1QnLCAnVFJBQ0UnLCAnVFJBQ0snXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uU0VDVVJJVFlfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDVcblx0XHRcdFx0dXJsID0gRW5jb2RlLnV0ZjhfZW5jb2RlKHVybCk7XG5cblx0XHRcdFx0Ly8gNiAtIFJlc29sdmUgdXJsIHJlbGF0aXZlIHRvIHRoZSBYTUxIdHRwUmVxdWVzdCBiYXNlIFVSTC4gSWYgdGhlIGFsZ29yaXRobSByZXR1cm5zIGFuIGVycm9yLCB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIi5cblx0XHRcdFx0dXJscCA9IFVybC5wYXJzZVVybCh1cmwpO1xuXG5cdFx0XHRcdF9zYW1lX29yaWdpbl9mbGFnID0gVXJsLmhhc1NhbWVPcmlnaW4odXJscCk7XG5cblx0XHRcdFx0Ly8gNyAtIG1hbnVhbGx5IGJ1aWxkIHVwIGFic29sdXRlIHVybFxuXHRcdFx0XHRfdXJsID0gVXJsLnJlc29sdmVVcmwodXJsKTtcblxuXHRcdFx0XHQvLyA5LTEwLCAxMi0xM1xuXHRcdFx0XHRpZiAoKHVzZXIgfHwgcGFzc3dvcmQpICYmICFfc2FtZV9vcmlnaW5fZmxhZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX0FDQ0VTU19FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3VzZXIgPSB1c2VyIHx8IHVybHAudXNlcjtcblx0XHRcdFx0X3Bhc3N3b3JkID0gcGFzc3dvcmQgfHwgdXJscC5wYXNzO1xuXG5cdFx0XHRcdC8vIDExXG5cdFx0XHRcdF9hc3luYyA9IGFzeW5jIHx8IHRydWU7XG5cblx0XHRcdFx0aWYgKF9hc3luYyA9PT0gZmFsc2UgJiYgKF9wKCd0aW1lb3V0JykgfHwgX3AoJ3dpdGhDcmVkZW50aWFscycpIHx8IF9wKCdyZXNwb25zZVR5cGUnKSAhPT0gXCJcIikpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9BQ0NFU1NfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDE0IC0gdGVybWluYXRlIGFib3J0KClcblxuXHRcdFx0XHQvLyAxNSAtIHRlcm1pbmF0ZSBzZW5kKClcblxuXHRcdFx0XHQvLyAxOFxuXHRcdFx0XHRfc3luY19mbGFnID0gIV9hc3luYztcblx0XHRcdFx0X3NlbmRfZmxhZyA9IGZhbHNlO1xuXHRcdFx0XHRfaGVhZGVycyA9IHt9O1xuXHRcdFx0XHRfcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdFx0XHQvLyAxOVxuXHRcdFx0XHRfcCgncmVhZHlTdGF0ZScsIFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCk7XG5cblx0XHRcdFx0Ly8gMjBcblx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdEFwcGVuZHMgYW4gaGVhZGVyIHRvIHRoZSBsaXN0IG9mIGF1dGhvciByZXF1ZXN0IGhlYWRlcnMsIG9yIGlmIGhlYWRlciBpcyBhbHJlYWR5XG5cdFx0XHRpbiB0aGUgbGlzdCBvZiBhdXRob3IgcmVxdWVzdCBoZWFkZXJzLCBjb21iaW5lcyBpdHMgdmFsdWUgd2l0aCB2YWx1ZS5cblxuXHRcdFx0VGhyb3dzIGFuIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBleGNlcHRpb24gaWYgdGhlIHN0YXRlIGlzIG5vdCBPUEVORUQgb3IgaWYgdGhlIHNlbmQoKSBmbGFnIGlzIHNldC5cblx0XHRcdFRocm93cyBhIFwiU3ludGF4RXJyb3JcIiBleGNlcHRpb24gaWYgaGVhZGVyIGlzIG5vdCBhIHZhbGlkIEhUVFAgaGVhZGVyIGZpZWxkIG5hbWUgb3IgaWYgdmFsdWVcblx0XHRcdGlzIG5vdCBhIHZhbGlkIEhUVFAgaGVhZGVyIGZpZWxkIHZhbHVlLlxuXG5cdFx0XHRAbWV0aG9kIHNldFJlcXVlc3RIZWFkZXJcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJcblx0XHRcdEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWVcblx0XHRcdCovXG5cdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbihoZWFkZXIsIHZhbHVlKSB7XG5cdFx0XHRcdHZhciB1YUhlYWRlcnMgPSBbIC8vIHRoZXNlIGhlYWRlcnMgYXJlIGNvbnRyb2xsZWQgYnkgdGhlIHVzZXIgYWdlbnRcblx0XHRcdFx0XHRcdFwiYWNjZXB0LWNoYXJzZXRcIixcblx0XHRcdFx0XHRcdFwiYWNjZXB0LWVuY29kaW5nXCIsXG5cdFx0XHRcdFx0XHRcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuXHRcdFx0XHRcdFx0XCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxuXHRcdFx0XHRcdFx0XCJjb25uZWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcImNvbnRlbnQtbGVuZ3RoXCIsXG5cdFx0XHRcdFx0XHRcImNvb2tpZVwiLFxuXHRcdFx0XHRcdFx0XCJjb29raWUyXCIsXG5cdFx0XHRcdFx0XHRcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcblx0XHRcdFx0XHRcdFwiZGF0ZVwiLFxuXHRcdFx0XHRcdFx0XCJleHBlY3RcIixcblx0XHRcdFx0XHRcdFwiaG9zdFwiLFxuXHRcdFx0XHRcdFx0XCJrZWVwLWFsaXZlXCIsXG5cdFx0XHRcdFx0XHRcIm9yaWdpblwiLFxuXHRcdFx0XHRcdFx0XCJyZWZlcmVyXCIsXG5cdFx0XHRcdFx0XHRcInRlXCIsXG5cdFx0XHRcdFx0XHRcInRyYWlsZXJcIixcblx0XHRcdFx0XHRcdFwidHJhbnNmZXItZW5jb2RpbmdcIixcblx0XHRcdFx0XHRcdFwidXBncmFkZVwiLFxuXHRcdFx0XHRcdFx0XCJ1c2VyLWFnZW50XCIsXG5cdFx0XHRcdFx0XHRcInZpYVwiXG5cdFx0XHRcdFx0XTtcblxuXHRcdFx0XHQvLyAxLTJcblx0XHRcdFx0aWYgKF9wKCdyZWFkeVN0YXRlJykgIT09IFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCB8fCBfc2VuZF9mbGFnKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDNcblx0XHRcdFx0aWYgKC9bXFx1MDEwMC1cXHVmZmZmXS8udGVzdChoZWFkZXIpIHx8IEVuY29kZS51dGY4X2VuY29kZShoZWFkZXIpICE9PSBoZWFkZXIpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uU1lOVEFYX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyA0XG5cdFx0XHRcdC8qIHRoaXMgc3RlcCBpcyBzZWVtaW5nbHkgYnlwYXNzZWQgaW4gYnJvd3NlcnMsIHByb2JhYmx5IHRvIGFsbG93IHZhcmlvdXMgdW5pY29kZSBjaGFyYWN0ZXJzIGluIGhlYWRlciB2YWx1ZXNcblx0XHRcdFx0aWYgKC9bXFx1MDEwMC1cXHVmZmZmXS8udGVzdCh2YWx1ZSkgfHwgRW5jb2RlLnV0ZjhfZW5jb2RlKHZhbHVlKSAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uU1lOVEFYX0VSUik7XG5cdFx0XHRcdH0qL1xuXG5cdFx0XHRcdGhlYWRlciA9IEJhc2ljLnRyaW0oaGVhZGVyKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdC8vIHNldHRpbmcgb2YgcHJveHktKiBhbmQgc2VjLSogaGVhZGVycyBpcyBwcm9oaWJpdGVkIGJ5IHNwZWNcblx0XHRcdFx0aWYgKCEhfkJhc2ljLmluQXJyYXkoaGVhZGVyLCB1YUhlYWRlcnMpIHx8IC9eKHByb3h5XFwtfHNlY1xcLSkvLnRlc3QoaGVhZGVyKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNhbWVsaXplXG5cdFx0XHRcdC8vIGJyb3dzZXJzIGxvd2VyY2FzZSBoZWFkZXIgbmFtZXMgKGF0IGxlYXN0IGZvciBjdXN0b20gb25lcylcblx0XHRcdFx0Ly8gaGVhZGVyID0gaGVhZGVyLnJlcGxhY2UoL1xcYlxcdy9nLCBmdW5jdGlvbigkMSkgeyByZXR1cm4gJDEudG9VcHBlckNhc2UoKTsgfSk7XG5cblx0XHRcdFx0aWYgKCFfaGVhZGVyc1toZWFkZXJdKSB7XG5cdFx0XHRcdFx0X2hlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTYjc2VjdGlvbi00LjIgKGxhc3QgcGFyYWdyYXBoKVxuXHRcdFx0XHRcdF9oZWFkZXJzW2hlYWRlcl0gKz0gJywgJyArIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXN0IGlmIHRoZSBzcGVjaWZpZWQgaGVhZGVyIGlzIGFscmVhZHkgc2V0IG9uIHRoaXMgcmVxdWVzdC5cblx0XHRcdCAqIFJldHVybnMgYSBoZWFkZXIgdmFsdWUgb3IgYm9vbGVhbiBmYWxzZSBpZiBpdCdzIG5vdCB5ZXQgc2V0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZXRob2QgaGFzUmVxdWVzdEhlYWRlclxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBOYW1lIG9mIHRoZSBoZWFkZXIgdG8gdGVzdFxuXHRcdFx0ICogQHJldHVybiB7Qm9vbGVhbnxTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdGhhc1JlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlcikge1xuXHRcdFx0XHRyZXR1cm4gaGVhZGVyICYmIF9oZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSB8fCBmYWxzZTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0UmV0dXJucyBhbGwgaGVhZGVycyBmcm9tIHRoZSByZXNwb25zZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRob3NlIHdob3NlIGZpZWxkIG5hbWUgaXMgU2V0LUNvb2tpZSBvciBTZXQtQ29va2llMi5cblxuXHRcdFx0QG1ldGhvZCBnZXRBbGxSZXNwb25zZUhlYWRlcnNcblx0XHRcdEByZXR1cm4ge1N0cmluZ30gcmVwb25zZSBoZWFkZXJzIG9yIGVtcHR5IHN0cmluZ1xuXHRcdFx0Ki9cblx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfcmVzcG9uc2VIZWFkZXJzIHx8ICcnO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXR1cm5zIHRoZSBoZWFkZXIgZmllbGQgdmFsdWUgZnJvbSB0aGUgcmVzcG9uc2Ugb2Ygd2hpY2ggdGhlIGZpZWxkIG5hbWUgbWF0Y2hlcyBoZWFkZXIsXG5cdFx0XHR1bmxlc3MgdGhlIGZpZWxkIG5hbWUgaXMgU2V0LUNvb2tpZSBvciBTZXQtQ29va2llMi5cblxuXHRcdFx0QG1ldGhvZCBnZXRSZXNwb25zZUhlYWRlclxuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IGhlYWRlclxuXHRcdFx0QHJldHVybiB7U3RyaW5nfSB2YWx1ZShzKSBmb3IgdGhlIHNwZWNpZmllZCBoZWFkZXIgb3IgbnVsbFxuXHRcdFx0Ki9cblx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbihoZWFkZXIpIHtcblx0XHRcdFx0aGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0aWYgKF9lcnJvcl9mbGFnIHx8ICEhfkJhc2ljLmluQXJyYXkoaGVhZGVyLCBbJ3NldC1jb29raWUnLCAnc2V0LWNvb2tpZTInXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChfcmVzcG9uc2VIZWFkZXJzICYmIF9yZXNwb25zZUhlYWRlcnMgIT09ICcnKSB7XG5cdFx0XHRcdFx0Ly8gaWYgd2UgZGlkbid0IHBhcnNlIHJlc3BvbnNlIGhlYWRlcnMgdW50aWwgbm93LCBkbyBpdCBhbmQga2VlcCBmb3IgbGF0ZXJcblx0XHRcdFx0XHRpZiAoIV9yZXNwb25zZUhlYWRlcnNCYWcpIHtcblx0XHRcdFx0XHRcdF9yZXNwb25zZUhlYWRlcnNCYWcgPSB7fTtcblx0XHRcdFx0XHRcdEJhc2ljLmVhY2goX3Jlc3BvbnNlSGVhZGVycy5zcGxpdCgvXFxyXFxuLyksIGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHBhaXIgPSBsaW5lLnNwbGl0KC86XFxzKy8pO1xuXHRcdFx0XHRcdFx0XHRpZiAocGFpci5sZW5ndGggPT09IDIpIHsgLy8gbGFzdCBsaW5lIG1pZ2h0IGJlIGVtcHR5LCBvbWl0XG5cdFx0XHRcdFx0XHRcdFx0cGFpclswXSA9IEJhc2ljLnRyaW0ocGFpclswXSk7IC8vIGp1c3QgaW4gY2FzZVxuXHRcdFx0XHRcdFx0XHRcdF9yZXNwb25zZUhlYWRlcnNCYWdbcGFpclswXS50b0xvd2VyQ2FzZSgpXSA9IHsgLy8gc2ltcGx5IHRvIHJldGFpbiBoZWFkZXIgbmFtZSBpbiBvcmlnaW5hbCBmb3JtXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWFkZXI6IHBhaXJbMF0sXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogQmFzaWMudHJpbShwYWlyWzFdKVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoX3Jlc3BvbnNlSGVhZGVyc0JhZy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gX3Jlc3BvbnNlSGVhZGVyc0JhZ1toZWFkZXJdLmhlYWRlciArICc6ICcgKyBfcmVzcG9uc2VIZWFkZXJzQmFnW2hlYWRlcl0udmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRTZXRzIHRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGZvciB0aGUgcmVzcG9uc2UgdG8gbWltZS5cblx0XHRcdFRocm93cyBhbiBcIkludmFsaWRTdGF0ZUVycm9yXCIgZXhjZXB0aW9uIGlmIHRoZSBzdGF0ZSBpcyBMT0FESU5HIG9yIERPTkUuXG5cdFx0XHRUaHJvd3MgYSBcIlN5bnRheEVycm9yXCIgZXhjZXB0aW9uIGlmIG1pbWUgaXMgbm90IGEgdmFsaWQgbWVkaWEgdHlwZS5cblxuXHRcdFx0QG1ldGhvZCBvdmVycmlkZU1pbWVUeXBlXG5cdFx0XHRAcGFyYW0gU3RyaW5nIG1pbWUgTWltZSB0eXBlIHRvIHNldFxuXHRcdFx0Ki9cblx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKG1pbWUpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMsIGNoYXJzZXQ7XG5cblx0XHRcdFx0Ly8gMVxuXHRcdFx0XHRpZiAoISF+QmFzaWMuaW5BcnJheShfcCgncmVhZHlTdGF0ZScpLCBbWE1MSHR0cFJlcXVlc3QuTE9BRElORywgWE1MSHR0cFJlcXVlc3QuRE9ORV0pKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDJcblx0XHRcdFx0bWltZSA9IEJhc2ljLnRyaW0obWltZS50b0xvd2VyQ2FzZSgpKTtcblxuXHRcdFx0XHRpZiAoLzsvLnRlc3QobWltZSkgJiYgKG1hdGNoZXMgPSBtaW1lLm1hdGNoKC9eKFteO10rKSg/OjtcXHNjaGFyc2V0XFw9KT8oLiopJC8pKSkge1xuXHRcdFx0XHRcdG1pbWUgPSBtYXRjaGVzWzFdO1xuXHRcdFx0XHRcdGlmIChtYXRjaGVzWzJdKSB7XG5cdFx0XHRcdFx0XHRjaGFyc2V0ID0gbWF0Y2hlc1syXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIU1pbWUubWltZXNbbWltZV0pIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uU1lOVEFYX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAzLTRcblx0XHRcdFx0X2ZpbmFsTWltZSA9IG1pbWU7XG5cdFx0XHRcdF9maW5hbENoYXJzZXQgPSBjaGFyc2V0O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRJbml0aWF0ZXMgdGhlIHJlcXVlc3QuIFRoZSBvcHRpb25hbCBhcmd1bWVudCBwcm92aWRlcyB0aGUgcmVxdWVzdCBlbnRpdHkgYm9keS5cblx0XHRcdFRoZSBhcmd1bWVudCBpcyBpZ25vcmVkIGlmIHJlcXVlc3QgbWV0aG9kIGlzIEdFVCBvciBIRUFELlxuXG5cdFx0XHRUaHJvd3MgYW4gXCJJbnZhbGlkU3RhdGVFcnJvclwiIGV4Y2VwdGlvbiBpZiB0aGUgc3RhdGUgaXMgbm90IE9QRU5FRCBvciBpZiB0aGUgc2VuZCgpIGZsYWcgaXMgc2V0LlxuXG5cdFx0XHRAbWV0aG9kIHNlbmRcblx0XHRcdEBwYXJhbSB7QmxvYnxEb2N1bWVudHxTdHJpbmd8Rm9ybURhdGF9IFtkYXRhXSBSZXF1ZXN0IGVudGl0eSBib2R5XG5cdFx0XHRAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNldCBvZiByZXF1aXJlbWVudHMgYW5kIHByZS1yZXF1aXNpdGllcyBmb3IgcnVudGltZSBpbml0aWFsaXphdGlvblxuXHRcdFx0Ki9cblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZihvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRfb3B0aW9ucyA9IHsgcnVpZDogb3B0aW9ucyB9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG5cdFx0XHRcdFx0X29wdGlvbnMgPSB7fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAxLTJcblx0XHRcdFx0aWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEIHx8IF9zZW5kX2ZsYWcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gM1xuXHRcdFx0XHQvLyBzZW5kaW5nIEJsb2Jcblx0XHRcdFx0aWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdFx0X29wdGlvbnMucnVpZCA9IGRhdGEucnVpZDtcblx0XHRcdFx0XHRfbWltZVR5cGUgPSBkYXRhLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JtRGF0YVxuXHRcdFx0XHRlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdFx0XHRpZiAoZGF0YS5oYXNCbG9iKCkpIHtcblx0XHRcdFx0XHRcdHZhciBibG9iID0gZGF0YS5nZXRCbG9iKCk7XG5cdFx0XHRcdFx0XHRfb3B0aW9ucy5ydWlkID0gYmxvYi5ydWlkO1xuXHRcdFx0XHRcdFx0X21pbWVUeXBlID0gYmxvYi50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERPTVN0cmluZ1xuXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRfZW5jb2RpbmcgPSAnVVRGLTgnO1xuXHRcdFx0XHRcdF9taW1lVHlwZSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuXG5cdFx0XHRcdFx0Ly8gZGF0YSBzaG91bGQgYmUgY29udmVydGVkIHRvIFVuaWNvZGUgYW5kIGVuY29kZWQgYXMgVVRGLThcblx0XHRcdFx0XHRkYXRhID0gRW5jb2RlLnV0ZjhfZW5jb2RlKGRhdGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgd2l0aENyZWRlbnRpYWxzIG5vdCBzZXQsIGJ1dCByZXF1ZXN0ZWQsIHNldCBpdCBhdXRvbWF0aWNhbGx5XG5cdFx0XHRcdGlmICghdGhpcy53aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRcdFx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IChfb3B0aW9ucy5yZXF1aXJlZF9jYXBzICYmIF9vcHRpb25zLnJlcXVpcmVkX2NhcHMuc2VuZF9icm93c2VyX2Nvb2tpZXMpICYmICFfc2FtZV9vcmlnaW5fZmxhZztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDQgLSBzdG9yYWdlIG11dGV4XG5cdFx0XHRcdC8vIDVcblx0XHRcdFx0X3VwbG9hZF9ldmVudHNfZmxhZyA9ICghX3N5bmNfZmxhZyAmJiB0aGlzLnVwbG9hZC5oYXNFdmVudExpc3RlbmVyKCkpOyAvLyBEU0FQXG5cdFx0XHRcdC8vIDZcblx0XHRcdFx0X2Vycm9yX2ZsYWcgPSBmYWxzZTtcblx0XHRcdFx0Ly8gN1xuXHRcdFx0XHRfdXBsb2FkX2NvbXBsZXRlX2ZsYWcgPSAhZGF0YTtcblx0XHRcdFx0Ly8gOCAtIEFzeW5jaHJvbm91cyBzdGVwc1xuXHRcdFx0XHRpZiAoIV9zeW5jX2ZsYWcpIHtcblx0XHRcdFx0XHQvLyA4LjFcblx0XHRcdFx0XHRfc2VuZF9mbGFnID0gdHJ1ZTtcblx0XHRcdFx0XHQvLyA4LjJcblx0XHRcdFx0XHQvLyB0aGlzLmRpc3BhdGNoRXZlbnQoJ2xvYWRzdGFydCcpOyAvLyB3aWxsIGJlIGRpc3BhdGNoZWQgZWl0aGVyIGJ5IG5hdGl2ZSBvciBydW50aW1lIHhoclxuXHRcdFx0XHRcdC8vIDguM1xuXHRcdFx0XHRcdC8vaWYgKCFfdXBsb2FkX2NvbXBsZXRlX2ZsYWcpIHtcblx0XHRcdFx0XHRcdC8vIHRoaXMudXBsb2FkLmRpc3BhdGNoRXZlbnQoJ2xvYWRzdGFydCcpO1x0Ly8gd2lsbCBiZSBkaXNwYXRjaGVkIGVpdGhlciBieSBuYXRpdmUgb3IgcnVudGltZSB4aHJcblx0XHRcdFx0XHQvL31cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyA4LjUgLSBSZXR1cm4gdGhlIHNlbmQoKSBtZXRob2QgY2FsbCwgYnV0IGNvbnRpbnVlIHJ1bm5pbmcgdGhlIHN0ZXBzIGluIHRoaXMgYWxnb3JpdGhtLlxuXHRcdFx0XHRfZG9YSFIuY2FsbCh0aGlzLCBkYXRhKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0Q2FuY2VscyBhbnkgbmV0d29yayBhY3Rpdml0eS5cblxuXHRcdFx0QG1ldGhvZCBhYm9ydFxuXHRcdFx0Ki9cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X2Vycm9yX2ZsYWcgPSB0cnVlO1xuXHRcdFx0XHRfc3luY19mbGFnID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCF+QmFzaWMuaW5BcnJheShfcCgncmVhZHlTdGF0ZScpLCBbWE1MSHR0cFJlcXVlc3QuVU5TRU5ULCBYTUxIdHRwUmVxdWVzdC5PUEVORUQsIFhNTEh0dHBSZXF1ZXN0LkRPTkVdKSkge1xuXHRcdFx0XHRcdF9wKCdyZWFkeVN0YXRlJywgWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG5cdFx0XHRcdFx0X3NlbmRfZmxhZyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKF94aHIpIHtcblx0XHRcdFx0XHRcdF94aHIuZ2V0UnVudGltZSgpLmV4ZWMuY2FsbChfeGhyLCAnWE1MSHR0cFJlcXVlc3QnLCAnYWJvcnQnLCBfdXBsb2FkX2NvbXBsZXRlX2ZsYWcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF91cGxvYWRfY29tcGxldGVfZmxhZyA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3AoJ3JlYWR5U3RhdGUnLCBYTUxIdHRwUmVxdWVzdC5VTlNFTlQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF94aHIpIHtcblx0XHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKF94aHIuZGVzdHJveSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdF94aHIuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfeGhyID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cblx0XHRcdFx0aWYgKHRoaXMudXBsb2FkKSB7XG5cdFx0XHRcdFx0dGhpcy51cGxvYWQudW5iaW5kQWxsKCk7XG5cdFx0XHRcdFx0dGhpcy51cGxvYWQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmhhbmRsZUV2ZW50UHJvcHMoZGlzcGF0Y2hlcy5jb25jYXQoWydyZWFkeXN0YXRlY2hhbmdlJ10pKTsgLy8gZm9yIGhpc3RvcmljYWwgcmVhc29uc1xuXHRcdHRoaXMudXBsb2FkLmhhbmRsZUV2ZW50UHJvcHMoZGlzcGF0Y2hlcyk7XG5cblx0XHQvKiB0aGlzIGlzIG5pY2UsIGJ1dCBtYXliZSB0b28gbGVuZ3RoeVxuXG5cdFx0Ly8gaWYgc3VwcG9ydGVkIGJ5IEpTIHZlcnNpb24sIHNldCBnZXR0ZXJzL3NldHRlcnMgZm9yIHNwZWNpZmljIHByb3BlcnRpZXNcblx0XHRvLmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkeVN0YXRlJywge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9wKCdyZWFkeVN0YXRlJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRvLmRlZmluZVByb3BlcnR5KHRoaXMsICd0aW1lb3V0Jywge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9wKCd0aW1lb3V0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cblx0XHRcdFx0aWYgKF9zeW5jX2ZsYWcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9BQ0NFU1NfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRpbWVvdXQgc3RpbGwgc2hvdWxkIGJlIG1lYXN1cmVkIHJlbGF0aXZlIHRvIHRoZSBzdGFydCB0aW1lIG9mIHJlcXVlc3Rcblx0XHRcdFx0X3RpbWVvdXRzZXRfdGltZSA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuXG5cdFx0XHRcdF9wKCd0aW1lb3V0JywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gdGhlIHdpdGhDcmVkZW50aWFscyBhdHRyaWJ1dGUgaGFzIG5vIGVmZmVjdCB3aGVuIGZldGNoaW5nIHNhbWUtb3JpZ2luIHJlc291cmNlc1xuXHRcdG8uZGVmaW5lUHJvcGVydHkodGhpcywgJ3dpdGhDcmVkZW50aWFscycsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfcCgnd2l0aENyZWRlbnRpYWxzJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdC8vIDEtMlxuXHRcdFx0XHRpZiAoIX5vLmluQXJyYXkoX3AoJ3JlYWR5U3RhdGUnKSwgW1hNTEh0dHBSZXF1ZXN0LlVOU0VOVCwgWE1MSHR0cFJlcXVlc3QuT1BFTkVEXSkgfHwgX3NlbmRfZmxhZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAzLTRcblx0XHRcdFx0aWYgKF9hbm9ueW1vdXNfZmxhZyB8fCBfc3luY19mbGFnKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfQUNDRVNTX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyA1XG5cdFx0XHRcdF9wKCd3aXRoQ3JlZGVudGlhbHMnLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRvLmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGF0dXMnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX3AoJ3N0YXR1cycpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0by5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhdHVzVGV4dCcsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfcCgnc3RhdHVzVGV4dCcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0by5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2VUeXBlJywge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9wKCdyZXNwb25zZVR5cGUnKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0Ly8gMVxuXHRcdFx0XHRpZiAoISF+by5pbkFycmF5KF9wKCdyZWFkeVN0YXRlJyksIFtYTUxIdHRwUmVxdWVzdC5MT0FESU5HLCBYTUxIdHRwUmVxdWVzdC5ET05FXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gMlxuXHRcdFx0XHRpZiAoX3N5bmNfZmxhZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX0FDQ0VTU19FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gM1xuXHRcdFx0XHRfcCgncmVzcG9uc2VUeXBlJywgdmFsdWUudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRvLmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXNwb25zZVRleHQnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyAxXG5cdFx0XHRcdGlmICghfm8uaW5BcnJheShfcCgncmVzcG9uc2VUeXBlJyksIFsnJywgJ3RleHQnXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gMi0zXG5cdFx0XHRcdGlmIChfcCgncmVhZHlTdGF0ZScpICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FICYmIF9wKCdyZWFkeVN0YXRlJykgIT09IFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgfHwgX2Vycm9yX2ZsYWcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIF9wKCdyZXNwb25zZVRleHQnKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG8uZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlWE1MJywge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gMVxuXHRcdFx0XHRpZiAoIX5vLmluQXJyYXkoX3AoJ3Jlc3BvbnNlVHlwZScpLCBbJycsICdkb2N1bWVudCddKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAyLTNcblx0XHRcdFx0aWYgKF9wKCdyZWFkeVN0YXRlJykgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgfHwgX2Vycm9yX2ZsYWcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIF9wKCdyZXNwb25zZVhNTCcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0by5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2UnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoISF+by5pbkFycmF5KF9wKCdyZXNwb25zZVR5cGUnKSwgWycnLCAndGV4dCddKSkge1xuXHRcdFx0XHRcdGlmIChfcCgncmVhZHlTdGF0ZScpICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FICYmIF9wKCdyZWFkeVN0YXRlJykgIT09IFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgfHwgX2Vycm9yX2ZsYWcpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoX3AoJ3JlYWR5U3RhdGUnKSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSB8fCBfZXJyb3JfZmxhZykge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIF9wKCdyZXNwb25zZScpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ki9cblxuXHRcdGZ1bmN0aW9uIF9wKHByb3AsIHZhbHVlKSB7XG5cdFx0XHRpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gRW52LmNhbignZGVmaW5lX3Byb3BlcnR5JykgPyBwcm9wc1twcm9wXSA6IHNlbGZbcHJvcF07XG5cdFx0XHR9IGVsc2UgeyAvLyBzZXRcblx0XHRcdFx0aWYgKEVudi5jYW4oJ2RlZmluZV9wcm9wZXJ0eScpKSB7XG5cdFx0XHRcdFx0cHJvcHNbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmW3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKlxuXHRcdGZ1bmN0aW9uIF90b0FTQ0lJKHN0ciwgQWxsb3dVbmFzc2lnbmVkLCBVc2VTVEQzQVNDSUlSdWxlcykge1xuXHRcdFx0Ly8gVE9ETzogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MCNzZWN0aW9uLTQuMVxuXHRcdFx0cmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0XHQqL1xuXG5cblx0XHRmdW5jdGlvbiBfZG9YSFIoZGF0YSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHRfc3RhcnRfdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG5cdFx0XHRfeGhyID0gbmV3IFJ1bnRpbWVUYXJnZXQoKTtcblxuXHRcdFx0ZnVuY3Rpb24gbG9hZEVuZCgpIHtcblx0XHRcdFx0aWYgKF94aHIpIHsgLy8gaXQgY291bGQgaGF2ZSBiZWVuIGRlc3Ryb3llZCBieSBub3dcblx0XHRcdFx0XHRfeGhyLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRfeGhyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoJ2xvYWRlbmQnKTtcblx0XHRcdFx0c2VsZiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGV4ZWMocnVudGltZSkge1xuXHRcdFx0XHRfeGhyLmJpbmQoJ0xvYWRTdGFydCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRfcCgncmVhZHlTdGF0ZScsIFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcpO1xuXHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpO1xuXG5cdFx0XHRcdFx0c2VsZi5kaXNwYXRjaEV2ZW50KGUpO1xuXG5cdFx0XHRcdFx0aWYgKF91cGxvYWRfZXZlbnRzX2ZsYWcpIHtcblx0XHRcdFx0XHRcdHNlbGYudXBsb2FkLmRpc3BhdGNoRXZlbnQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfeGhyLmJpbmQoJ1Byb2dyZXNzJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGlmIChfcCgncmVhZHlTdGF0ZScpICE9PSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HKSB7XG5cdFx0XHRcdFx0XHRfcCgncmVhZHlTdGF0ZScsIFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcpOyAvLyBMb2FkU3RhcnQgdW5yZWxpYWJsZSAoaW4gRmxhc2ggZm9yIGV4YW1wbGUpXG5cdFx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoJ3JlYWR5c3RhdGVjaGFuZ2UnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5kaXNwYXRjaEV2ZW50KGUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfeGhyLmJpbmQoJ1VwbG9hZFByb2dyZXNzJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGlmIChfdXBsb2FkX2V2ZW50c19mbGFnKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnVwbG9hZC5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHRcdFx0dHlwZTogJ3Byb2dyZXNzJyxcblx0XHRcdFx0XHRcdFx0bGVuZ3RoQ29tcHV0YWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdHRvdGFsOiBlLnRvdGFsLFxuXHRcdFx0XHRcdFx0XHRsb2FkZWQ6IGUubG9hZGVkXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF94aHIuYmluZCgnTG9hZCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRfcCgncmVhZHlTdGF0ZScsIFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuXHRcdFx0XHRcdF9wKCdzdGF0dXMnLCBOdW1iZXIocnVudGltZS5leGVjLmNhbGwoX3hociwgJ1hNTEh0dHBSZXF1ZXN0JywgJ2dldFN0YXR1cycpIHx8IDApKTtcblx0XHRcdFx0XHRfcCgnc3RhdHVzVGV4dCcsIGh0dHBDb2RlW19wKCdzdGF0dXMnKV0gfHwgXCJcIik7XG5cblx0XHRcdFx0XHRfcCgncmVzcG9uc2UnLCBydW50aW1lLmV4ZWMuY2FsbChfeGhyLCAnWE1MSHR0cFJlcXVlc3QnLCAnZ2V0UmVzcG9uc2UnLCBfcCgncmVzcG9uc2VUeXBlJykpKTtcblxuXHRcdFx0XHRcdGlmICghIX5CYXNpYy5pbkFycmF5KF9wKCdyZXNwb25zZVR5cGUnKSwgWyd0ZXh0JywgJyddKSkge1xuXHRcdFx0XHRcdFx0X3AoJ3Jlc3BvbnNlVGV4dCcsIF9wKCdyZXNwb25zZScpKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKF9wKCdyZXNwb25zZVR5cGUnKSA9PT0gJ2RvY3VtZW50Jykge1xuXHRcdFx0XHRcdFx0X3AoJ3Jlc3BvbnNlWE1MJywgX3AoJ3Jlc3BvbnNlJykpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9yZXNwb25zZUhlYWRlcnMgPSBydW50aW1lLmV4ZWMuY2FsbChfeGhyLCAnWE1MSHR0cFJlcXVlc3QnLCAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyk7XG5cblx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoJ3JlYWR5c3RhdGVjaGFuZ2UnKTtcblxuXHRcdFx0XHRcdGlmIChfcCgnc3RhdHVzJykgPiAwKSB7IC8vIHN0YXR1cyAwIHVzdWFsbHkgbWVhbnMgdGhhdCBzZXJ2ZXIgaXMgdW5yZWFjaGFibGVcblx0XHRcdFx0XHRcdGlmIChfdXBsb2FkX2V2ZW50c19mbGFnKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYudXBsb2FkLmRpc3BhdGNoRXZlbnQoZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9lcnJvcl9mbGFnID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudCgnZXJyb3InKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bG9hZEVuZCgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfeGhyLmJpbmQoJ0Fib3J0JywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudChlKTtcblx0XHRcdFx0XHRsb2FkRW5kKCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF94aHIuYmluZCgnRXJyb3InLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0X2Vycm9yX2ZsYWcgPSB0cnVlO1xuXHRcdFx0XHRcdF9wKCdyZWFkeVN0YXRlJywgWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG5cdFx0XHRcdFx0c2VsZi5kaXNwYXRjaEV2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJyk7XG5cdFx0XHRcdFx0X3VwbG9hZF9jb21wbGV0ZV9mbGFnID0gdHJ1ZTtcblx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoZSk7XG5cdFx0XHRcdFx0bG9hZEVuZCgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRydW50aW1lLmV4ZWMuY2FsbChfeGhyLCAnWE1MSHR0cFJlcXVlc3QnLCAnc2VuZCcsIHtcblx0XHRcdFx0XHR1cmw6IF91cmwsXG5cdFx0XHRcdFx0bWV0aG9kOiBfbWV0aG9kLFxuXHRcdFx0XHRcdGFzeW5jOiBfYXN5bmMsXG5cdFx0XHRcdFx0dXNlcjogX3VzZXIsXG5cdFx0XHRcdFx0cGFzc3dvcmQ6IF9wYXNzd29yZCxcblx0XHRcdFx0XHRoZWFkZXJzOiBfaGVhZGVycyxcblx0XHRcdFx0XHRtaW1lVHlwZTogX21pbWVUeXBlLFxuXHRcdFx0XHRcdGVuY29kaW5nOiBfZW5jb2RpbmcsXG5cdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBzZWxmLnJlc3BvbnNlVHlwZSxcblx0XHRcdFx0XHR3aXRoQ3JlZGVudGlhbHM6IHNlbGYud2l0aENyZWRlbnRpYWxzLFxuXHRcdFx0XHRcdG9wdGlvbnM6IF9vcHRpb25zXG5cdFx0XHRcdH0sIGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbGFyaWZ5IG91ciByZXF1aXJlbWVudHNcblx0XHRcdGlmICh0eXBlb2YoX29wdGlvbnMucmVxdWlyZWRfY2FwcykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdF9vcHRpb25zLnJlcXVpcmVkX2NhcHMgPSBSdW50aW1lLnBhcnNlQ2Fwcyhfb3B0aW9ucy5yZXF1aXJlZF9jYXBzKTtcblx0XHRcdH1cblxuXHRcdFx0X29wdGlvbnMucmVxdWlyZWRfY2FwcyA9IEJhc2ljLmV4dGVuZCh7fSwgX29wdGlvbnMucmVxdWlyZWRfY2Fwcywge1xuXHRcdFx0XHRyZXR1cm5fcmVzcG9uc2VfdHlwZTogc2VsZi5yZXNwb25zZVR5cGVcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdF9vcHRpb25zLnJlcXVpcmVkX2NhcHMuc2VuZF9tdWx0aXBhcnQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIUJhc2ljLmlzRW1wdHlPYmooX2hlYWRlcnMpKSB7XG5cdFx0XHRcdF9vcHRpb25zLnJlcXVpcmVkX2NhcHMuc2VuZF9jdXN0b21faGVhZGVycyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghX3NhbWVfb3JpZ2luX2ZsYWcpIHtcblx0XHRcdFx0X29wdGlvbnMucmVxdWlyZWRfY2Fwcy5kb19jb3JzID0gdHJ1ZTtcblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoX29wdGlvbnMucnVpZCkgeyAvLyB3ZSBkbyBub3QgbmVlZCB0byB3YWl0IGlmIHdlIGNhbiBjb25uZWN0IGRpcmVjdGx5XG5cdFx0XHRcdGV4ZWMoX3hoci5jb25uZWN0UnVudGltZShfb3B0aW9ucykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3hoci5iaW5kKCdSdW50aW1lSW5pdCcsIGZ1bmN0aW9uKGUsIHJ1bnRpbWUpIHtcblx0XHRcdFx0XHRleGVjKHJ1bnRpbWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0X3hoci5iaW5kKCdSdW50aW1lRXJyb3InLCBmdW5jdGlvbihlLCBlcnIpIHtcblx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoJ1J1bnRpbWVFcnJvcicsIGVycik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRfeGhyLmNvbm5lY3RSdW50aW1lKF9vcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9yZXNldCgpIHtcblx0XHRcdF9wKCdyZXNwb25zZVRleHQnLCBcIlwiKTtcblx0XHRcdF9wKCdyZXNwb25zZVhNTCcsIG51bGwpO1xuXHRcdFx0X3AoJ3Jlc3BvbnNlJywgbnVsbCk7XG5cdFx0XHRfcCgnc3RhdHVzJywgMCk7XG5cdFx0XHRfcCgnc3RhdHVzVGV4dCcsIFwiXCIpO1xuXHRcdFx0X3N0YXJ0X3RpbWUgPSBfdGltZW91dHNldF90aW1lID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRYTUxIdHRwUmVxdWVzdC5VTlNFTlQgPSAwO1xuXHRYTUxIdHRwUmVxdWVzdC5PUEVORUQgPSAxO1xuXHRYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEID0gMjtcblx0WE1MSHR0cFJlcXVlc3QuTE9BRElORyA9IDM7XG5cdFhNTEh0dHBSZXF1ZXN0LkRPTkUgPSA0O1xuXG5cdFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSA9IEV2ZW50VGFyZ2V0Lmluc3RhbmNlO1xuXG5cdHJldHVybiBYTUxIdHRwUmVxdWVzdDtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL1RyYW5zcG9ydGVyLmpzXG5cbi8qKlxuICogVHJhbnNwb3J0ZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKFwibW94aWUvcnVudGltZS9UcmFuc3BvcnRlclwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW5jb2RlXCIsXG5cdFwibW94aWUvcnVudGltZS9SdW50aW1lQ2xpZW50XCIsXG5cdFwibW94aWUvY29yZS9FdmVudFRhcmdldFwiXG5dLCBmdW5jdGlvbihCYXNpYywgRW5jb2RlLCBSdW50aW1lQ2xpZW50LCBFdmVudFRhcmdldCkge1xuXG5cdC8qKlxuXHRAY2xhc3MgbW94aWUvcnVudGltZS9UcmFuc3BvcnRlclxuXHRAY29uc3RydWN0b3Jcblx0Ki9cblx0ZnVuY3Rpb24gVHJhbnNwb3J0ZXIoKSB7XG5cdFx0dmFyIG1vZCwgX3J1bnRpbWUsIF9kYXRhLCBfc2l6ZSwgX3BvcywgX2NodW5rX3NpemU7XG5cblx0XHRSdW50aW1lQ2xpZW50LmNhbGwodGhpcyk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0dWlkOiBCYXNpYy5ndWlkKCd1aWRfJyksXG5cblx0XHRcdHN0YXRlOiBUcmFuc3BvcnRlci5JRExFLFxuXG5cdFx0XHRyZXN1bHQ6IG51bGwsXG5cblx0XHRcdHRyYW5zcG9ydDogZnVuY3Rpb24oZGF0YSwgdHlwZSwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdFx0b3B0aW9ucyA9IEJhc2ljLmV4dGVuZCh7XG5cdFx0XHRcdFx0Y2h1bmtfc2l6ZTogMjA0Nzk4XG5cdFx0XHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0XHRcdC8vIHNob3VsZCBkaXZpZGUgYnkgdGhyZWUsIGJhc2U2NCByZXF1aXJlcyB0aGlzXG5cdFx0XHRcdGlmICgobW9kID0gb3B0aW9ucy5jaHVua19zaXplICUgMykpIHtcblx0XHRcdFx0XHRvcHRpb25zLmNodW5rX3NpemUgKz0gMyAtIG1vZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9jaHVua19zaXplID0gb3B0aW9ucy5jaHVua19zaXplO1xuXG5cdFx0XHRcdF9yZXNldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRfZGF0YSA9IGRhdGE7XG5cdFx0XHRcdF9zaXplID0gZGF0YS5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZihvcHRpb25zKSA9PT0gJ3N0cmluZycgfHwgb3B0aW9ucy5ydWlkKSB7XG5cdFx0XHRcdFx0X3J1bi5jYWxsKHNlbGYsIHR5cGUsIHRoaXMuY29ubmVjdFJ1bnRpbWUob3B0aW9ucykpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHdlIHJlcXVpcmUgdGhpcyB0byBydW4gb25seSBvbmNlXG5cdFx0XHRcdFx0dmFyIGNiID0gZnVuY3Rpb24oZSwgcnVudGltZSkge1xuXHRcdFx0XHRcdFx0c2VsZi51bmJpbmQoXCJSdW50aW1lSW5pdFwiLCBjYik7XG5cdFx0XHRcdFx0XHRfcnVuLmNhbGwoc2VsZiwgdHlwZSwgcnVudGltZSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR0aGlzLmJpbmQoXCJSdW50aW1lSW5pdFwiLCBjYik7XG5cdFx0XHRcdFx0dGhpcy5jb25uZWN0UnVudGltZShvcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdFx0c2VsZi5zdGF0ZSA9IFRyYW5zcG9ydGVyLklETEU7XG5cdFx0XHRcdGlmIChfcnVudGltZSkge1xuXHRcdFx0XHRcdF9ydW50aW1lLmV4ZWMuY2FsbChzZWxmLCAnVHJhbnNwb3J0ZXInLCAnY2xlYXInKTtcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoXCJUcmFuc3BvcnRpbmdBYm9ydGVkXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3Jlc2V0LmNhbGwoc2VsZik7XG5cdFx0XHR9LFxuXG5cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnVuYmluZEFsbCgpO1xuXHRcdFx0XHRfcnVudGltZSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdFJ1bnRpbWUoKTtcblx0XHRcdFx0X3Jlc2V0LmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBfcmVzZXQoKSB7XG5cdFx0XHRfc2l6ZSA9IF9wb3MgPSAwO1xuXHRcdFx0X2RhdGEgPSB0aGlzLnJlc3VsdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX3J1bih0eXBlLCBydW50aW1lKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdF9ydW50aW1lID0gcnVudGltZTtcblxuXHRcdFx0Ly9zZWxmLnVuYmluZChcIlJ1bnRpbWVJbml0XCIpO1xuXG5cdFx0XHRzZWxmLmJpbmQoXCJUcmFuc3BvcnRpbmdQcm9ncmVzc1wiLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdF9wb3MgPSBlLmxvYWRlZDtcblxuXHRcdFx0XHRpZiAoX3BvcyA8IF9zaXplICYmIEJhc2ljLmluQXJyYXkoc2VsZi5zdGF0ZSwgW1RyYW5zcG9ydGVyLklETEUsIFRyYW5zcG9ydGVyLkRPTkVdKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRfdHJhbnNwb3J0LmNhbGwoc2VsZik7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDk5OSk7XG5cblx0XHRcdHNlbGYuYmluZChcIlRyYW5zcG9ydGluZ0NvbXBsZXRlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfcG9zID0gX3NpemU7XG5cdFx0XHRcdHNlbGYuc3RhdGUgPSBUcmFuc3BvcnRlci5ET05FO1xuXHRcdFx0XHRfZGF0YSA9IG51bGw7IC8vIGNsZWFuIGEgYml0XG5cdFx0XHRcdHNlbGYucmVzdWx0ID0gX3J1bnRpbWUuZXhlYy5jYWxsKHNlbGYsICdUcmFuc3BvcnRlcicsICdnZXRBc0Jsb2InLCB0eXBlIHx8ICcnKTtcblx0XHRcdH0sIDk5OSk7XG5cblx0XHRcdHNlbGYuc3RhdGUgPSBUcmFuc3BvcnRlci5CVVNZO1xuXHRcdFx0c2VsZi50cmlnZ2VyKFwiVHJhbnNwb3J0aW5nU3RhcnRlZFwiKTtcblx0XHRcdF90cmFuc3BvcnQuY2FsbChzZWxmKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfdHJhbnNwb3J0KCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRjaHVuayxcblx0XHRcdFx0Ynl0ZXNMZWZ0ID0gX3NpemUgLSBfcG9zO1xuXG5cdFx0XHRpZiAoX2NodW5rX3NpemUgPiBieXRlc0xlZnQpIHtcblx0XHRcdFx0X2NodW5rX3NpemUgPSBieXRlc0xlZnQ7XG5cdFx0XHR9XG5cblx0XHRcdGNodW5rID0gRW5jb2RlLmJ0b2EoX2RhdGEuc3Vic3RyKF9wb3MsIF9jaHVua19zaXplKSk7XG5cdFx0XHRfcnVudGltZS5leGVjLmNhbGwoc2VsZiwgJ1RyYW5zcG9ydGVyJywgJ3JlY2VpdmUnLCBjaHVuaywgX3NpemUpO1xuXHRcdH1cblx0fVxuXG5cdFRyYW5zcG9ydGVyLklETEUgPSAwO1xuXHRUcmFuc3BvcnRlci5CVVNZID0gMTtcblx0VHJhbnNwb3J0ZXIuRE9ORSA9IDI7XG5cblx0VHJhbnNwb3J0ZXIucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cblx0cmV0dXJuIFRyYW5zcG9ydGVyO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2ltYWdlL0ltYWdlLmpzXG5cbi8qKlxuICogSW1hZ2UuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKFwibW94aWUvaW1hZ2UvSW1hZ2VcIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0RvbVwiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL2ZpbGUvRmlsZVJlYWRlclN5bmNcIixcblx0XCJtb3hpZS94aHIvWE1MSHR0cFJlcXVlc3RcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVDbGllbnRcIixcblx0XCJtb3hpZS9ydW50aW1lL1RyYW5zcG9ydGVyXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbnZcIixcblx0XCJtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0XCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbmNvZGVcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIERvbSwgeCwgRmlsZVJlYWRlclN5bmMsIFhNTEh0dHBSZXF1ZXN0LCBSdW50aW1lLCBSdW50aW1lQ2xpZW50LCBUcmFuc3BvcnRlciwgRW52LCBFdmVudFRhcmdldCwgQmxvYiwgRmlsZSwgRW5jb2RlKSB7XG5cdC8qKlxuXHRJbWFnZSBwcmVsb2FkaW5nIGFuZCBtYW5pcHVsYXRpb24gdXRpbGl0eS4gQWRkaXRpb25hbGx5IGl0IHByb3ZpZGVzIGFjY2VzcyB0byBpbWFnZSBtZXRhIGluZm8gKEV4aWYsIEdQUykgYW5kIHJhdyBiaW5hcnkgZGF0YS5cblxuXHRAY2xhc3MgbW94aWUvaW1hZ2UvSW1hZ2Vcblx0QGNvbnN0cnVjdG9yXG5cdEBleHRlbmRzIEV2ZW50VGFyZ2V0XG5cdCovXG5cdHZhciBkaXNwYXRjaGVzID0gW1xuXHRcdCdwcm9ncmVzcycsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gbG9hZGluZyBpcyBjb21wbGV0ZS5cblxuXHRcdEBldmVudCBsb2FkXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQnbG9hZCcsXG5cblx0XHQnZXJyb3InLFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIHJlc2l6ZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG5cdFx0XG5cdFx0QGV2ZW50IHJlc2l6ZVxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J3Jlc2l6ZScsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbWFnZSBpcyBzdWNjZXNzZnVsbHkgZW1iZWRkZWRcblx0XHRpbnRvIHRoZSBjb3JyZXNwb25zaW5nIGNvbnRhaW5lci5cblxuXHRcdEBldmVudCBlbWJlZGRlZFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2VtYmVkZGVkJ1xuXHRdO1xuXG5cdGZ1bmN0aW9uIEltYWdlKCkge1xuXG5cdFx0UnVudGltZUNsaWVudC5jYWxsKHRoaXMpO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0VW5pcXVlIGlkIG9mIHRoZSBjb21wb25lbnRcblxuXHRcdFx0QHByb3BlcnR5IHVpZFxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdCovXG5cdFx0XHR1aWQ6IEJhc2ljLmd1aWQoJ3VpZF8nKSxcblxuXHRcdFx0LyoqXG5cdFx0XHRVbmlxdWUgaWQgb2YgdGhlIGNvbm5lY3RlZCBydW50aW1lLCBpZiBhbnkuXG5cblx0XHRcdEBwcm9wZXJ0eSBydWlkXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0Ki9cblx0XHRcdHJ1aWQ6IG51bGwsXG5cblx0XHRcdC8qKlxuXHRcdFx0TmFtZSBvZiB0aGUgZmlsZSwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgYW4gaW1hZ2UsIGlmIGF2YWlsYWJsZS4gSWYgbm90IGVxdWFscyB0byBlbXB0eSBzdHJpbmcuXG5cblx0XHRcdEBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0QGRlZmF1bHQgXCJcIlxuXHRcdFx0Ki9cblx0XHRcdG5hbWU6IFwiXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0U2l6ZSBvZiB0aGUgaW1hZ2UgaW4gYnl0ZXMuIEFjdHVhbCB2YWx1ZSBpcyBzZXQgb25seSBhZnRlciBpbWFnZSBpcyBwcmVsb2FkZWQuXG5cblx0XHRcdEBwcm9wZXJ0eSBzaXplXG5cdFx0XHRAdHlwZSB7TnVtYmVyfVxuXHRcdFx0QGRlZmF1bHQgMFxuXHRcdFx0Ki9cblx0XHRcdHNpemU6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0V2lkdGggb2YgdGhlIGltYWdlLiBBY3R1YWwgdmFsdWUgaXMgc2V0IG9ubHkgYWZ0ZXIgaW1hZ2UgaXMgcHJlbG9hZGVkLlxuXG5cdFx0XHRAcHJvcGVydHkgd2lkdGhcblx0XHRcdEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHRAZGVmYXVsdCAwXG5cdFx0XHQqL1xuXHRcdFx0d2lkdGg6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0SGVpZ2h0IG9mIHRoZSBpbWFnZS4gQWN0dWFsIHZhbHVlIGlzIHNldCBvbmx5IGFmdGVyIGltYWdlIGlzIHByZWxvYWRlZC5cblxuXHRcdFx0QHByb3BlcnR5IGhlaWdodFxuXHRcdFx0QHR5cGUge051bWJlcn1cblx0XHRcdEBkZWZhdWx0IDBcblx0XHRcdCovXG5cdFx0XHRoZWlnaHQ6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0TWltZSB0eXBlIG9mIHRoZSBpbWFnZS4gQ3VycmVudGx5IG9ubHkgaW1hZ2UvanBlZyBhbmQgaW1hZ2UvcG5nIGFyZSBzdXBwb3J0ZWQuIEFjdHVhbCB2YWx1ZSBpcyBzZXQgb25seSBhZnRlciBpbWFnZSBpcyBwcmVsb2FkZWQuXG5cblx0XHRcdEBwcm9wZXJ0eSB0eXBlXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0QGRlZmF1bHQgXCJcIlxuXHRcdFx0Ki9cblx0XHRcdHR5cGU6IFwiXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0SG9sZHMgbWV0YSBpbmZvIChFeGlmLCBHUFMpLiBJcyBwb3B1bGF0ZWQgb25seSBmb3IgaW1hZ2UvanBlZy4gQWN0dWFsIHZhbHVlIGlzIHNldCBvbmx5IGFmdGVyIGltYWdlIGlzIHByZWxvYWRlZC5cblxuXHRcdFx0QHByb3BlcnR5IG1ldGFcblx0XHRcdEB0eXBlIHtPYmplY3R9XG5cdFx0XHRAZGVmYXVsdCB7fVxuXHRcdFx0Ki9cblx0XHRcdG1ldGE6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdEFsaWFzIGZvciBsb2FkIG1ldGhvZCwgdGhhdCB0YWtlcyBhbm90aGVyIG1PeGllLkltYWdlIG9iamVjdCBhcyBhIHNvdXJjZSAoc2VlIGxvYWQpLlxuXG5cdFx0XHRAbWV0aG9kIGNsb25lXG5cdFx0XHRAcGFyYW0ge0ltYWdlfSBzcmMgU291cmNlIGZvciB0aGUgaW1hZ2Vcblx0XHRcdEBwYXJhbSB7Qm9vbGVhbn0gW2V4YWN0PWZhbHNlXSBXaGV0aGVyIHRvIGFjdGl2YXRlIGluLWRlcHRoIGNsb25lIG1vZGVcblx0XHRcdCovXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMubG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRMb2FkcyBpbWFnZSBmcm9tIHZhcmlvdXMgc291cmNlcy4gQ3VycmVudGx5IHRoZSBzb3VyY2UgZm9yIG5ldyBpbWFnZSBjYW4gYmU6IG1PeGllLkltYWdlLCBtT3hpZS5CbG9iL21PeGllLkZpbGUsIFxuXHRcdFx0bmF0aXZlIEJsb2IvRmlsZSwgZGF0YVVybCBvciBVUkwuIERlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiB0aGUgc291cmNlLCBhcmd1bWVudHMgLSBkaWZmZXIuIFdoZW4gc291cmNlIGlzIFVSTCwgXG5cdFx0XHRJbWFnZSB3aWxsIGJlIGRvd25sb2FkZWQgZnJvbSByZW1vdGUgZGVzdGluYXRpb24gYW5kIGxvYWRlZCBpbiBtZW1vcnkuXG5cblx0XHRcdEBleGFtcGxlXG5cdFx0XHRcdHZhciBpbWcgPSBuZXcgbU94aWUuSW1hZ2UoKTtcblx0XHRcdFx0aW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBibG9iID0gaW1nLmdldEFzQmxvYigpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBmb3JtRGF0YSA9IG5ldyBtT3hpZS5Gb3JtRGF0YSgpO1xuXHRcdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGJsb2IpO1xuXG5cdFx0XHRcdFx0dmFyIHhociA9IG5ldyBtT3hpZS5YTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0XHRcdHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdC8vIHVwbG9hZCBjb21wbGV0ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0eGhyLm9wZW4oJ3Bvc3QnLCAndXBsb2FkLnBocCcpO1xuXHRcdFx0XHRcdHhoci5zZW5kKGZvcm1EYXRhKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aW1nLmxvYWQoXCJodHRwOi8vd3d3Lm1veGllY29kZS5jb20vaW1hZ2VzL21veC1sb2dvLmpwZ1wiKTsgLy8gbm90aWNlIGZpbGUgZXh0ZW5zaW9uICguanBnKVxuXHRcdFx0XG5cblx0XHRcdEBtZXRob2QgbG9hZFxuXHRcdFx0QHBhcmFtIHtJbWFnZXxCbG9ifEZpbGV8U3RyaW5nfSBzcmMgU291cmNlIGZvciB0aGUgaW1hZ2Vcblx0XHRcdEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IFttaXhlZF1cblx0XHRcdCovXG5cdFx0XHRsb2FkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X2xvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHRSZXNpemVzIHRoZSBpbWFnZSB0byBmaXQgdGhlIHNwZWNpZmllZCB3aWR0aC9oZWlnaHQuIElmIGNyb3AgaXMgc3BlY2lmaWVkLCBpbWFnZSB3aWxsIGFsc28gYmUgXG5cdFx0XHRjcm9wcGVkIHRvIHRoZSBleGFjdCBkaW1lbnNpb25zLlxuXG5cdFx0XHRAbWV0aG9kIHJlc2l6ZVxuXHRcdFx0QHNpbmNlIDMuMFxuXHRcdFx0QHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0XHRcdFx0QHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMud2lkdGggUmVzdWx0aW5nIHdpZHRoXG5cdFx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9d2lkdGhdIFJlc3VsdGluZyBoZWlnaHQgKG9wdGlvbmFsLCBpZiBub3Qgc3VwcGxpZWQgd2lsbCBkZWZhdWx0IHRvIHdpZHRoKVxuXHRcdFx0XHRAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHlwZT0naW1hZ2UvanBlZyddIE1JTUUgdHlwZSBvZiB0aGUgcmVzdWx0aW5nIGltYWdlXG5cdFx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTkwXSBJbiB0aGUgY2FzZSBvZiBKUEVHLCBjb250cm9scyB0aGUgcXVhbGl0eSBvZiByZXN1bHRpbmcgaW1hZ2Vcblx0XHRcdFx0QHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jcm9wPSdjYyddIElmIG5vdCBmYWxzeSwgaW1hZ2Ugd2lsbCBiZSBjcm9wcGVkLCBieSBkZWZhdWx0IGZyb20gY2VudGVyXG5cdFx0XHRcdEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZml0PXRydWVdIEluIGNhc2Ugb2YgY3JvcCB3aGV0aGVyIHRvIHVwc2NhbGUgdGhlIGltYWdlIHRvIGZpdCB0aGUgZXhhY3QgZGltZW5zaW9uc1xuXHRcdFx0XHRAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlSGVhZGVycz10cnVlXSBXaGV0aGVyIHRvIHByZXNlcnZlIG1ldGEgaGVhZGVycyAob24gSlBFR3MgYWZ0ZXIgcmVzaXplKVxuXHRcdFx0XHRAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVzYW1wbGU9J2RlZmF1bHQnXSBSZXNhbXBsaW5nIGFsZ29yaXRobSB0byB1c2UgZHVyaW5nIHJlc2l6ZVxuXHRcdFx0XHRAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGFzcz10cnVlXSBXaGV0aGVyIHRvIHNjYWxlIHRoZSBpbWFnZSBpbiBzdGVwcyAocmVzdWx0cyBpbiBiZXR0ZXIgcXVhbGl0eSlcblx0XHRcdCovXG5cdFx0XHRyZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XHR2YXIgb3JpZW50YXRpb247XG5cdFx0XHRcdHZhciBzY2FsZTtcblxuXHRcdFx0XHR2YXIgc3JjUmVjdCA9IHtcblx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IHNlbGYud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzZWxmLmhlaWdodFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciBvcHRzID0gQmFzaWMuZXh0ZW5kSWYoe1xuXHRcdFx0XHRcdHdpZHRoOiBzZWxmLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc2VsZi5oZWlnaHQsXG5cdFx0XHRcdFx0dHlwZTogc2VsZi50eXBlIHx8ICdpbWFnZS9qcGVnJyxcblx0XHRcdFx0XHRxdWFsaXR5OiA5MCxcblx0XHRcdFx0XHRjcm9wOiBmYWxzZSxcblx0XHRcdFx0XHRmaXQ6IHRydWUsXG5cdFx0XHRcdFx0cHJlc2VydmVIZWFkZXJzOiB0cnVlLFxuXHRcdFx0XHRcdHJlc2FtcGxlOiAnZGVmYXVsdCcsXG5cdFx0XHRcdFx0bXVsdGlwYXNzOiB0cnVlXG5cdFx0XHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFzZWxmLnNpemUpIHsgLy8gb25seSBwcmVsb2FkZWQgaW1hZ2Ugb2JqZWN0cyBjYW4gYmUgdXNlZCBhcyBzb3VyY2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbm8gd2F5IHRvIHJlbGlhYmx5IGludGVyY2VwdCB0aGUgY3Jhc2ggZHVlIHRvIGhpZ2ggcmVzb2x1dGlvbiwgc28gd2Ugc2ltcGx5IGF2b2lkIGl0XG5cdFx0XHRcdFx0aWYgKHNlbGYud2lkdGggPiBJbWFnZS5NQVhfUkVTSVpFX1dJRFRIIHx8IHNlbGYuaGVpZ2h0ID4gSW1hZ2UuTUFYX1JFU0laRV9IRUlHSFQpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLk1BWF9SRVNPTFVUSU9OX0VSUik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGFrZSBpbnRvIGFjY291bnQgb3JpZW50YXRpb24gdGFnXG5cdFx0XHRcdFx0b3JpZW50YXRpb24gPSAoc2VsZi5tZXRhICYmIHNlbGYubWV0YS50aWZmICYmIHNlbGYubWV0YS50aWZmLk9yaWVudGF0aW9uKSB8fCAxO1xuXG5cdFx0XHRcdFx0aWYgKEJhc2ljLmluQXJyYXkob3JpZW50YXRpb24sIFs1LDYsNyw4XSkgIT09IC0xKSB7IC8vIHZhbHVlcyB0aGF0IHJlcXVpcmUgOTAgZGVncmVlIHJvdGF0aW9uXG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gb3B0cy53aWR0aDtcblx0XHRcdFx0XHRcdG9wdHMud2lkdGggPSBvcHRzLmhlaWdodDtcblx0XHRcdFx0XHRcdG9wdHMuaGVpZ2h0ID0gdG1wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChvcHRzLmNyb3ApIHtcblx0XHRcdFx0XHRcdHNjYWxlID0gTWF0aC5tYXgob3B0cy53aWR0aC9zZWxmLndpZHRoLCBvcHRzLmhlaWdodC9zZWxmLmhlaWdodCk7XG5cblx0XHRcdFx0XHRcdGlmIChvcHRpb25zLmZpdCkge1xuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBzY2FsZSBpdCB1cCBvciBkb3duIHRvIGZpdCB0aGUgb3JpZ2luYWwgaW1hZ2Vcblx0XHRcdFx0XHRcdFx0c3JjUmVjdC53aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChvcHRzLndpZHRoL3NjYWxlKSwgc2VsZi53aWR0aCk7XG5cdFx0XHRcdFx0XHRcdHNyY1JlY3QuaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKG9wdHMuaGVpZ2h0L3NjYWxlKSwgc2VsZi5oZWlnaHQpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gcmVjYWxjdWxhdGUgdGhlIHNjYWxlIGZvciBhZGFwdGVkIGRpbWVuc2lvbnNcblx0XHRcdFx0XHRcdFx0c2NhbGUgPSBvcHRzLndpZHRoL3NyY1JlY3Qud2lkdGg7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzcmNSZWN0LndpZHRoID0gTWF0aC5taW4ob3B0cy53aWR0aCwgc2VsZi53aWR0aCk7XG5cdFx0XHRcdFx0XHRcdHNyY1JlY3QuaGVpZ2h0ID0gTWF0aC5taW4ob3B0cy5oZWlnaHQsIHNlbGYuaGVpZ2h0KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBub3cgd2UgZG8gbm90IG5lZWQgdG8gc2NhbGUgaXQgYW55IGZ1cnRoZXJcblx0XHRcdFx0XHRcdFx0c2NhbGUgPSAxOyBcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihvcHRzLmNyb3ApID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0XHRcdFx0b3B0cy5jcm9wID0gJ2NjJztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3dpdGNoIChvcHRzLmNyb3AudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fLywgJy0nKSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdyYic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3JpZ2h0LWJvdHRvbSc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gc2VsZi53aWR0aCAtIHNyY1JlY3Qud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gc2VsZi5oZWlnaHQgLSBzcmNSZWN0LmhlaWdodDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdjYic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NlbnRlci1ib3R0b20nOlxuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IE1hdGguZmxvb3IoKHNlbGYud2lkdGggLSBzcmNSZWN0LndpZHRoKSAvIDIpO1xuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueSA9IHNlbGYuaGVpZ2h0IC0gc3JjUmVjdC5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnbGInOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdsZWZ0LWJvdHRvbSc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnkgPSBzZWxmLmhlaWdodCAtIHNyY1JlY3QuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2x0Jzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbGVmdC10b3AnOlxuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdjdCc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NlbnRlci10b3AnOlxuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IE1hdGguZmxvb3IoKHNlbGYud2lkdGggLSBzcmNSZWN0LndpZHRoKSAvIDIpO1xuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAncnQnOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdyaWdodC10b3AnOlxuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IHNlbGYud2lkdGggLSBzcmNSZWN0LndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAncmMnOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdyaWdodC1jZW50ZXInOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdyaWdodC1taWRkbGUnOlxuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IHNlbGYud2lkdGggLSBzcmNSZWN0LndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueSA9IE1hdGguZmxvb3IoKHNlbGYuaGVpZ2h0IC0gc3JjUmVjdC5oZWlnaHQpIC8gMik7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblxuXHRcdFx0XHRcdFx0XHRjYXNlICdsYyc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2xlZnQtY2VudGVyJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbGVmdC1taWRkbGUnOlxuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gTWF0aC5mbG9vcigoc2VsZi5oZWlnaHQgLSBzcmNSZWN0LmhlaWdodCkgLyAyKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdjYyc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NlbnRlci1jZW50ZXInOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdjZW50ZXItbWlkZGxlJzpcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnggPSBNYXRoLmZsb29yKChzZWxmLndpZHRoIC0gc3JjUmVjdC53aWR0aCkgLyAyKTtcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnkgPSBNYXRoLmZsb29yKChzZWxmLmhlaWdodCAtIHNyY1JlY3QuaGVpZ2h0KSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBvcmlnaW5hbCBpbWFnZSBtaWdodCBiZSBzbWFsbGVyIHRoYW4gcmVxdWVzdGVkIGNyb3AsIHNvIC0gYXZvaWQgbmVnYXRpdmUgdmFsdWVzXG5cdFx0XHRcdFx0XHRzcmNSZWN0LnggPSBNYXRoLm1heChzcmNSZWN0LngsIDApO1xuXHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gTWF0aC5tYXgoc3JjUmVjdC55LCAwKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2NhbGUgPSBNYXRoLm1pbihvcHRzLndpZHRoL3NlbGYud2lkdGgsIG9wdHMuaGVpZ2h0L3NlbGYuaGVpZ2h0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmV4ZWMoJ0ltYWdlJywgJ3Jlc2l6ZScsIHNyY1JlY3QsIHNjYWxlLCBvcHRzKTtcblx0XHRcdFx0fSBjYXRjaChleCkge1xuXHRcdFx0XHRcdC8vIGZvciBub3cgc2ltcGx5IHRyaWdnZXIgZXJyb3IgZXZlbnRcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2Vycm9yJywgZXguY29kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0RG93bnNpemVzIHRoZSBpbWFnZSB0byBmaXQgdGhlIHNwZWNpZmllZCB3aWR0aC9oZWlnaHQuIElmIGNyb3AgaXMgc3VwcGxpZWQsIGltYWdlIHdpbGwgYmUgY3JvcHBlZCB0byBleGFjdCBkaW1lbnNpb25zLlxuXG5cdFx0XHRAbWV0aG9kIGRvd25zaXplXG5cdFx0XHRAZGVwcmVjYXRlZCB1c2UgcmVzaXplKClcblx0XHRcdCovXG5cdFx0XHRkb3duc2l6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0XHRcdFx0d2lkdGg6IHRoaXMud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGlzLmhlaWdodCxcblx0XHRcdFx0XHR0eXBlOiB0aGlzLnR5cGUgfHwgJ2ltYWdlL2pwZWcnLFxuXHRcdFx0XHRcdHF1YWxpdHk6IDkwLFxuXHRcdFx0XHRcdGNyb3A6IGZhbHNlLFxuXHRcdFx0XHRcdHByZXNlcnZlSGVhZGVyczogdHJ1ZSxcblx0XHRcdFx0XHRyZXNhbXBsZTogJ2RlZmF1bHQnXG5cdFx0XHRcdH0sIG9wdHM7XG5cblx0XHRcdFx0aWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRvcHRzID0gQmFzaWMuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdG9wdHMgPSBCYXNpYy5leHRlbmQoZGVmYXVsdHMsIHtcblx0XHRcdFx0XHRcdHdpZHRoOiBhcmd1bWVudHNbMF0sXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGFyZ3VtZW50c1sxXSxcblx0XHRcdFx0XHRcdGNyb3A6IGFyZ3VtZW50c1syXSxcblx0XHRcdFx0XHRcdHByZXNlcnZlSGVhZGVyczogYXJndW1lbnRzWzNdXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnJlc2l6ZShvcHRzKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0QWxpYXMgZm9yIGRvd25zaXplKHdpZHRoLCBoZWlnaHQsIHRydWUpLiAoc2VlIGRvd25zaXplKVxuXHRcdFx0XG5cdFx0XHRAbWV0aG9kIGNyb3Bcblx0XHRcdEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBSZXN1bHRpbmcgd2lkdGhcblx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PXdpZHRoXSBSZXN1bHRpbmcgaGVpZ2h0IChvcHRpb25hbCwgaWYgbm90IHN1cHBsaWVkIHdpbGwgZGVmYXVsdCB0byB3aWR0aClcblx0XHRcdEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXNlcnZlSGVhZGVycz10cnVlXSBXaGV0aGVyIHRvIHByZXNlcnZlIG1ldGEgaGVhZGVycyAob24gSlBFR3MgYWZ0ZXIgcmVzaXplKVxuXHRcdFx0Ki9cblx0XHRcdGNyb3A6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHByZXNlcnZlSGVhZGVycykge1xuXHRcdFx0XHR0aGlzLmRvd25zaXplKHdpZHRoLCBoZWlnaHQsIHRydWUsIHByZXNlcnZlSGVhZGVycyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBc0NhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghRW52LmNhbignY3JlYXRlX2NhbnZhcycpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguUnVudGltZUVycm9yKHguUnVudGltZUVycm9yLk5PVF9TVVBQT1JURURfRVJSKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leGVjKCdJbWFnZScsICdnZXRBc0NhbnZhcycpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXRyaWV2ZXMgaW1hZ2UgaW4gaXQncyBjdXJyZW50IHN0YXRlIGFzIG1PeGllLkJsb2Igb2JqZWN0LiBDYW5ub3QgYmUgcnVuIG9uIGVtcHR5IG9yIGltYWdlIGluIHByb2dyZXNzICh0aHJvd3Ncblx0XHRcdERPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUikuXG5cblx0XHRcdEBtZXRob2QgZ2V0QXNCbG9iXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gW3R5cGU9XCJpbWFnZS9qcGVnXCJdIE1pbWUgdHlwZSBvZiByZXN1bHRpbmcgYmxvYi4gQ2FuIGVpdGhlciBiZSBpbWFnZS9qcGVnIG9yIGltYWdlL3BuZ1xuXHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtxdWFsaXR5PTkwXSBBcHBsaWNhYmxlIG9ubHkgdG9nZXRoZXIgd2l0aCBtaW1lIHR5cGUgaW1hZ2UvanBlZ1xuXHRcdFx0QHJldHVybiB7QmxvYn0gSW1hZ2UgYXMgQmxvYlxuXHRcdFx0Ki9cblx0XHRcdGdldEFzQmxvYjogZnVuY3Rpb24odHlwZSwgcXVhbGl0eSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuc2l6ZSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZXhlYygnSW1hZ2UnLCAnZ2V0QXNCbG9iJywgdHlwZSB8fCAnaW1hZ2UvanBlZycsIHF1YWxpdHkgfHwgOTApO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXRyaWV2ZXMgaW1hZ2UgaW4gaXQncyBjdXJyZW50IHN0YXRlIGFzIGRhdGFVUkwgc3RyaW5nLiBDYW5ub3QgYmUgcnVuIG9uIGVtcHR5IG9yIGltYWdlIGluIHByb2dyZXNzICh0aHJvd3Ncblx0XHRcdERPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUikuXG5cblx0XHRcdEBtZXRob2QgZ2V0QXNEYXRhVVJMXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gW3R5cGU9XCJpbWFnZS9qcGVnXCJdIE1pbWUgdHlwZSBvZiByZXN1bHRpbmcgYmxvYi4gQ2FuIGVpdGhlciBiZSBpbWFnZS9qcGVnIG9yIGltYWdlL3BuZ1xuXHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtxdWFsaXR5PTkwXSBBcHBsaWNhYmxlIG9ubHkgdG9nZXRoZXIgd2l0aCBtaW1lIHR5cGUgaW1hZ2UvanBlZ1xuXHRcdFx0QHJldHVybiB7U3RyaW5nfSBJbWFnZSBhcyBkYXRhVVJMIHN0cmluZ1xuXHRcdFx0Ki9cblx0XHRcdGdldEFzRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgcXVhbGl0eSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuc2l6ZSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZXhlYygnSW1hZ2UnLCAnZ2V0QXNEYXRhVVJMJywgdHlwZSB8fCAnaW1hZ2UvanBlZycsIHF1YWxpdHkgfHwgOTApO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXRyaWV2ZXMgaW1hZ2UgaW4gaXQncyBjdXJyZW50IHN0YXRlIGFzIGJpbmFyeSBzdHJpbmcuIENhbm5vdCBiZSBydW4gb24gZW1wdHkgb3IgaW1hZ2UgaW4gcHJvZ3Jlc3MgKHRocm93c1xuXHRcdFx0RE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKS5cblxuXHRcdFx0QG1ldGhvZCBnZXRBc0JpbmFyeVN0cmluZ1xuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IFt0eXBlPVwiaW1hZ2UvanBlZ1wiXSBNaW1lIHR5cGUgb2YgcmVzdWx0aW5nIGJsb2IuIENhbiBlaXRoZXIgYmUgaW1hZ2UvanBlZyBvciBpbWFnZS9wbmdcblx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbcXVhbGl0eT05MF0gQXBwbGljYWJsZSBvbmx5IHRvZ2V0aGVyIHdpdGggbWltZSB0eXBlIGltYWdlL2pwZWdcblx0XHRcdEByZXR1cm4ge1N0cmluZ30gSW1hZ2UgYXMgYmluYXJ5IHN0cmluZ1xuXHRcdFx0Ki9cblx0XHRcdGdldEFzQmluYXJ5U3RyaW5nOiBmdW5jdGlvbih0eXBlLCBxdWFsaXR5KSB7XG5cdFx0XHRcdHZhciBkYXRhVXJsID0gdGhpcy5nZXRBc0RhdGFVUkwodHlwZSwgcXVhbGl0eSk7XG5cdFx0XHRcdHJldHVybiBFbmNvZGUuYXRvYihkYXRhVXJsLnN1YnN0cmluZyhkYXRhVXJsLmluZGV4T2YoJ2Jhc2U2NCwnKSArIDcpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0RW1iZWRzIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbWFnZSBpbnRvIHRoZSBzcGVjaWZpZWQgbm9kZS4gRGVwZW5kaW5nIG9uIHRoZSBydW50aW1lLCBcblx0XHRcdGl0IG1pZ2h0IGJlIGEgY2FudmFzLCBhbiBpbWcgbm9kZSBvciBhIHRocmlkIHBhcnR5IHNoaW0gb2JqZWN0IChGbGFzaCBvciBTaWx2ZXJMaWdodCAtIHZlcnkgcmFyZSwgXG5cdFx0XHRjYW4gYmUgdXNlZCBpbiBsZWdhY3kgYnJvd3NlcnMgdGhhdCBkbyBub3QgaGF2ZSBjYW52YXMgb3IgcHJvcGVyIGRhdGFVUkkgc3VwcG9ydCkuXG5cblx0XHRcdEBtZXRob2QgZW1iZWRcblx0XHRcdEBwYXJhbSB7RE9NRWxlbWVudH0gZWwgRE9NIGVsZW1lbnQgdG8gaW5zZXJ0IHRoZSBpbWFnZSBvYmplY3QgaW50b1xuXHRcdFx0QHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHRcdFx0XHRAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIFRoZSB3aWR0aCBvZiBhbiBlbWJlZCAoZGVmYXVsdHMgdG8gdGhlIGltYWdlIHdpZHRoKVxuXHRcdFx0XHRAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBUaGUgaGVpZ2h0IG9mIGFuIGVtYmVkIChkZWZhdWx0cyB0byB0aGUgaW1hZ2UgaGVpZ2h0KVxuXHRcdFx0XHRAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHlwZT1cImltYWdlL2pwZWdcIl0gTWltZSB0eXBlXG5cdFx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTkwXSBRdWFsaXR5IG9mIGFuIGVtYmVkLCBpZiBtaW1lIHR5cGUgaXMgaW1hZ2UvanBlZ1xuXHRcdFx0XHRAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNyb3A9ZmFsc2VdIFdoZXRoZXIgdG8gY3JvcCBhbiBlbWJlZCB0byB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnNcblx0XHRcdCovXG5cdFx0XHRlbWJlZDogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0XHRcdCwgcnVudGltZSAvLyB0aGlzIGhhcyB0byBiZSBvdXRzaWRlIG9mIGFsbCB0aGUgY2xvc3VyZXMgdG8gY29udGFpbiBwcm9wZXIgcnVudGltZVxuXHRcdFx0XHQ7XG5cblx0XHRcdFx0dmFyIG9wdHMgPSBCYXNpYy5leHRlbmQoe1xuXHRcdFx0XHRcdHdpZHRoOiB0aGlzLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogdGhpcy5oZWlnaHQsXG5cdFx0XHRcdFx0dHlwZTogdGhpcy50eXBlIHx8ICdpbWFnZS9qcGVnJyxcblx0XHRcdFx0XHRxdWFsaXR5OiA5MFxuXHRcdFx0XHR9LCBvcHRpb25zKTtcblx0XHRcdFx0XG5cblx0XHRcdFx0ZnVuY3Rpb24gcmVuZGVyKHR5cGUsIHF1YWxpdHkpIHtcblx0XHRcdFx0XHR2YXIgaW1nID0gdGhpcztcblxuXHRcdFx0XHRcdC8vIGlmIHBvc3NpYmxlLCBlbWJlZCBhIGNhbnZhcyBlbGVtZW50IGRpcmVjdGx5XG5cdFx0XHRcdFx0aWYgKEVudi5jYW4oJ2NyZWF0ZV9jYW52YXMnKSkge1xuXHRcdFx0XHRcdFx0dmFyIGNhbnZhcyA9IGltZy5nZXRBc0NhbnZhcygpO1xuXHRcdFx0XHRcdFx0aWYgKGNhbnZhcykge1xuXHRcdFx0XHRcdFx0XHRlbC5hcHBlbmRDaGlsZChjYW52YXMpO1xuXHRcdFx0XHRcdFx0XHRjYW52YXMgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRpbWcuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2VtYmVkZGVkJyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgZGF0YVVybCA9IGltZy5nZXRBc0RhdGFVUkwodHlwZSwgcXVhbGl0eSk7XG5cdFx0XHRcdFx0aWYgKCFkYXRhVXJsKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChFbnYuY2FuKCd1c2VfZGF0YV91cmlfb2YnLCBkYXRhVXJsLmxlbmd0aCkpIHtcblx0XHRcdFx0XHRcdGVsLmlubmVySFRNTCA9ICc8aW1nIHNyYz1cIicgKyBkYXRhVXJsICsgJ1wiIHdpZHRoPVwiJyArIGltZy53aWR0aCArICdcIiBoZWlnaHQ9XCInICsgaW1nLmhlaWdodCArICdcIiAvPic7XG5cdFx0XHRcdFx0XHRpbWcuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdlbWJlZGRlZCcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgdHIgPSBuZXcgVHJhbnNwb3J0ZXIoKTtcblxuXHRcdFx0XHRcdFx0dHIuYmluZChcIlRyYW5zcG9ydGluZ0NvbXBsZXRlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRydW50aW1lID0gc2VsZi5jb25uZWN0UnVudGltZSh0aGlzLnJlc3VsdC5ydWlkKTtcblxuXHRcdFx0XHRcdFx0XHRzZWxmLmJpbmQoXCJFbWJlZGRlZFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBwb3NpdGlvbiBhbmQgc2l6ZSBwcm9wZXJseVxuXHRcdFx0XHRcdFx0XHRcdEJhc2ljLmV4dGVuZChydW50aW1lLmdldFNoaW1Db250YWluZXIoKS5zdHlsZSwge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly9wb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdFx0XHRcdHRvcDogJzBweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWZ0OiAnMHB4Jyxcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoOiBpbWcud2lkdGggKyAncHgnLFxuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBpbWcuaGVpZ2h0ICsgJ3B4J1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc29tZSBzaGltcyAoRmxhc2gvU2lsdmVyTGlnaHQpIHJlaW5pdGlhbGl6ZSwgaWYgcGFyZW50IGVsZW1lbnQgaXMgaGlkZGVuLCByZW9yZGVyZWQgb3IgaXQnc1xuXHRcdFx0XHRcdFx0XHRcdC8vIHBvc2l0aW9uIHR5cGUgY2hhbmdlcyAoaW4gR2Vja28pLCBidXQgc2luY2Ugd2UgYmFzaWNhbGx5IG5lZWQgdGhpcyBvbmx5IGluIElFcyA2LzcgYW5kXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc29tZXRpbWVzIDggYW5kIHRoZXkgZG8gbm90IGhhdmUgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gY29tbWVudCB0aGlzIGZvciBub3dcblx0XHRcdFx0XHRcdFx0XHQvKnRyLmJpbmQoXCJSdW50aW1lSW5pdFwiLCBmdW5jdGlvbihlLCBydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ci5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRydW50aW1lLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVzaXplLmNhbGwoc2VsZik7IC8vIHJlLWZlZWQgb3VyIGltYWdlIGRhdGFcblx0XHRcdFx0XHRcdFx0XHR9KTsqL1xuXG5cdFx0XHRcdFx0XHRcdFx0cnVudGltZSA9IG51bGw7IC8vIHJlbGVhc2Vcblx0XHRcdFx0XHRcdFx0fSwgOTk5KTtcblxuXHRcdFx0XHRcdFx0XHRydW50aW1lLmV4ZWMuY2FsbChzZWxmLCBcIkltYWdlVmlld1wiLCBcImRpc3BsYXlcIiwgdGhpcy5yZXN1bHQudWlkLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0XHRcdFx0aW1nLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHR0ci50cmFuc3BvcnQoRW5jb2RlLmF0b2IoZGF0YVVybC5zdWJzdHJpbmcoZGF0YVVybC5pbmRleE9mKCdiYXNlNjQsJykgKyA3KSksIHR5cGUsIHtcblx0XHRcdFx0XHRcdFx0cmVxdWlyZWRfY2Fwczoge1xuXHRcdFx0XHRcdFx0XHRcdGRpc3BsYXlfbWVkaWE6IHRydWVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cnVudGltZV9vcmRlcjogJ2ZsYXNoLHNpbHZlcmxpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0Y29udGFpbmVyOiBlbFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIShlbCA9IERvbS5nZXQoZWwpKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfTk9ERV9UWVBFX0VSUik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCF0aGlzLnNpemUpIHsgLy8gb25seSBwcmVsb2FkZWQgaW1hZ2Ugb2JqZWN0cyBjYW4gYmUgdXNlZCBhcyBzb3VyY2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGhpZ2gtcmVzb2x1dGlvbiBpbWFnZXMgY2Fubm90IGJlIGNvbnNpc3RlbnRseSBoYW5kbGVkIGFjcm9zcyB0aGUgcnVudGltZXNcblx0XHRcdFx0XHRpZiAodGhpcy53aWR0aCA+IEltYWdlLk1BWF9SRVNJWkVfV0lEVEggfHwgdGhpcy5oZWlnaHQgPiBJbWFnZS5NQVhfUkVTSVpFX0hFSUdIVCkge1xuXHRcdFx0XHRcdFx0Ly90aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5NQVhfUkVTT0xVVElPTl9FUlIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBpbWdDb3B5ID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdFx0XHRpbWdDb3B5LmJpbmQoXCJSZXNpemVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZW5kZXIuY2FsbCh0aGlzLCBvcHRzLnR5cGUsIG9wdHMucXVhbGl0eSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpbWdDb3B5LmJpbmQoXCJMb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5kb3duc2l6ZShvcHRzKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIGlmIGVtYmVkZGVkIHRodW1iIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBkaW1lbnNpb25zIGFyZSBiaWcgZW5vdWdoLCB1c2UgaXRcblx0XHRcdFx0XHRpZiAodGhpcy5tZXRhLnRodW1iICYmIHRoaXMubWV0YS50aHVtYi53aWR0aCA+PSBvcHRzLndpZHRoICYmIHRoaXMubWV0YS50aHVtYi5oZWlnaHQgPj0gb3B0cy5oZWlnaHQpIHtcblx0XHRcdFx0XHRcdGltZ0NvcHkubG9hZCh0aGlzLm1ldGEudGh1bWIuZGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGltZ0NvcHkuY2xvbmUodGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBpbWdDb3B5O1xuXHRcdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdFx0Ly8gZm9yIG5vdyBzaW1wbHkgdHJpZ2dlciBlcnJvciBldmVudFxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignZXJyb3InLCBleC5jb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRQcm9wZXJseSBkZXN0cm95cyB0aGUgaW1hZ2UgYW5kIGZyZWVzIHJlc291cmNlcyBpbiB1c2UuIElmIGFueS4gUmVjb21tZW5kZWQgd2F5IHRvIGRpc3Bvc2UgbU94aWUuSW1hZ2Ugb2JqZWN0LlxuXG5cdFx0XHRAbWV0aG9kIGRlc3Ryb3lcblx0XHRcdCovXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHRoaXMucnVpZCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0UnVudGltZSgpLmV4ZWMuY2FsbCh0aGlzLCAnSW1hZ2UnLCAnZGVzdHJveScpO1xuXHRcdFx0XHRcdHRoaXMuZGlzY29ubmVjdFJ1bnRpbWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5tZXRhICYmIHRoaXMubWV0YS50aHVtYikge1xuXHRcdFx0XHRcdC8vIHRodW1iIGlzIGJsb2IsIG1ha2Ugc3VyZSB3ZSBkZXN0cm95IGl0IGZpcnN0XG5cdFx0XHRcdFx0dGhpcy5tZXRhLnRodW1iLmRhdGEuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHRcdC8vIHRoaXMgaXMgaGVyZSwgYmVjYXVzZSBpbiBvcmRlciB0byBiaW5kIHByb3Blcmx5LCB3ZSBuZWVkIHVpZCwgd2hpY2ggaXMgY3JlYXRlZCBhYm92ZVxuXHRcdHRoaXMuaGFuZGxlRXZlbnRQcm9wcyhkaXNwYXRjaGVzKTtcblxuXHRcdHRoaXMuYmluZCgnTG9hZCBSZXNpemUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBfdXBkYXRlSW5mby5jYWxsKHRoaXMpOyAvLyBpZiBvcGVyYXRpb24gZmFpbHMgKGUuZy4gaW1hZ2UgaXMgbmVpdGhlciBQTkcgbm9yIEpQRUcpIGNhbmNlbCBhbGwgcGVuZGluZyBldmVudHNcblx0XHR9LCA5OTkpO1xuXG5cblx0XHRmdW5jdGlvbiBfdXBkYXRlSW5mbyhpbmZvKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWluZm8pIHtcblx0XHRcdFx0XHRpbmZvID0gdGhpcy5leGVjKCdJbWFnZScsICdnZXRJbmZvJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNpemUgPSBpbmZvLnNpemU7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBpbmZvLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGluZm8uaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLnR5cGUgPSBpbmZvLnR5cGU7XG5cdFx0XHRcdHRoaXMubWV0YSA9IGluZm8ubWV0YTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgZmlsZSBuYW1lLCBvbmx5IGlmIGVtcHR5XG5cdFx0XHRcdGlmICh0aGlzLm5hbWUgPT09ICcnKSB7XG5cdFx0XHRcdFx0dGhpcy5uYW1lID0gaW5mby5uYW1lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignZXJyb3InLCBleC5jb2RlKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2xvYWQoc3JjKSB7XG5cdFx0XHR2YXIgc3JjVHlwZSA9IEJhc2ljLnR5cGVPZihzcmMpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBpZiBzb3VyY2UgaXMgSW1hZ2Vcblx0XHRcdFx0aWYgKHNyYyBpbnN0YW5jZW9mIEltYWdlKSB7XG5cdFx0XHRcdFx0aWYgKCFzcmMuc2l6ZSkgeyAvLyBvbmx5IHByZWxvYWRlZCBpbWFnZSBvYmplY3RzIGNhbiBiZSB1c2VkIGFzIHNvdXJjZVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2xvYWRGcm9tSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiBzb3VyY2UgaXMgby5CbG9iL28uRmlsZVxuXHRcdFx0XHRlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdFx0aWYgKCF+QmFzaWMuaW5BcnJheShzcmMudHlwZSwgWydpbWFnZS9qcGVnJywgJ2ltYWdlL3BuZyddKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkltYWdlRXJyb3IuV1JPTkdfRk9STUFUKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2xvYWRGcm9tQmxvYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIG5hdGl2ZSBibG9iL2ZpbGVcblx0XHRcdFx0ZWxzZSBpZiAoQmFzaWMuaW5BcnJheShzcmNUeXBlLCBbJ2Jsb2InLCAnZmlsZSddKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRfbG9hZC5jYWxsKHRoaXMsIG5ldyBGaWxlKG51bGwsIHNyYyksIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgU3RyaW5nXG5cdFx0XHRcdGVsc2UgaWYgKHNyY1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Ly8gaWYgZGF0YVVybCBTdHJpbmdcblx0XHRcdFx0XHRpZiAoc3JjLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGE6Jykge1xuXHRcdFx0XHRcdFx0X2xvYWQuY2FsbCh0aGlzLCBuZXcgQmxvYihudWxsLCB7IGRhdGE6IHNyYyB9KSwgYXJndW1lbnRzWzFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZWxzZSBhc3N1bWUgVXJsLCBlaXRoZXIgcmVsYXRpdmUgb3IgYWJzb2x1dGVcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdF9sb2FkRnJvbVVybC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiBzb3VyY2Ugc2VlbXMgdG8gYmUgYW4gaW1nIG5vZGVcblx0XHRcdFx0ZWxzZSBpZiAoc3JjVHlwZSA9PT0gJ25vZGUnICYmIHNyYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuXHRcdFx0XHRcdF9sb2FkLmNhbGwodGhpcywgc3JjLnNyYywgYXJndW1lbnRzWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uVFlQRV9NSVNNQVRDSF9FUlIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdC8vIGZvciBub3cgc2ltcGx5IHRyaWdnZXIgZXJyb3IgZXZlbnRcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdlcnJvcicsIGV4LmNvZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2xvYWRGcm9tSW1hZ2UoaW1nLCBleGFjdCkge1xuXHRcdFx0dmFyIHJ1bnRpbWUgPSB0aGlzLmNvbm5lY3RSdW50aW1lKGltZy5ydWlkKTtcblx0XHRcdHRoaXMucnVpZCA9IHJ1bnRpbWUudWlkO1xuXHRcdFx0cnVudGltZS5leGVjLmNhbGwodGhpcywgJ0ltYWdlJywgJ2xvYWRGcm9tSW1hZ2UnLCBpbWcsIChCYXNpYy50eXBlT2YoZXhhY3QpID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBleGFjdCkpO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2xvYWRGcm9tQmxvYihibG9iLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdHNlbGYubmFtZSA9IGJsb2IubmFtZSB8fCAnJztcblxuXHRcdFx0ZnVuY3Rpb24gZXhlYyhydW50aW1lKSB7XG5cdFx0XHRcdHNlbGYucnVpZCA9IHJ1bnRpbWUudWlkO1xuXHRcdFx0XHRydW50aW1lLmV4ZWMuY2FsbChzZWxmLCAnSW1hZ2UnLCAnbG9hZEZyb21CbG9iJywgYmxvYik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChibG9iLmlzRGV0YWNoZWQoKSkge1xuXHRcdFx0XHR0aGlzLmJpbmQoJ1J1bnRpbWVJbml0JywgZnVuY3Rpb24oZSwgcnVudGltZSkge1xuXHRcdFx0XHRcdGV4ZWMocnVudGltZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIGNvbnZlcnQgdG8gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdGlmIChvcHRpb25zICYmIHR5cGVvZihvcHRpb25zLnJlcXVpcmVkX2NhcHMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdG9wdGlvbnMucmVxdWlyZWRfY2FwcyA9IFJ1bnRpbWUucGFyc2VDYXBzKG9wdGlvbnMucmVxdWlyZWRfY2Fwcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNvbm5lY3RSdW50aW1lKEJhc2ljLmV4dGVuZCh7XG5cdFx0XHRcdFx0cmVxdWlyZWRfY2Fwczoge1xuXHRcdFx0XHRcdFx0YWNjZXNzX2ltYWdlX2JpbmFyeTogdHJ1ZSxcblx0XHRcdFx0XHRcdHJlc2l6ZV9pbWFnZTogdHJ1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgb3B0aW9ucykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXhlYyh0aGlzLmNvbm5lY3RSdW50aW1lKGJsb2IucnVpZCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2xvYWRGcm9tVXJsKHVybCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB4aHI7XG5cblx0XHRcdHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0XHR4aHIub3BlbignZ2V0JywgdXJsKTtcblx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cblx0XHRcdHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoZSk7XG5cdFx0XHR9O1xuXG5cdFx0XHR4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9sb2FkRnJvbUJsb2IuY2FsbChzZWxmLCB4aHIucmVzcG9uc2UsIHRydWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcihlKTtcblx0XHRcdH07XG5cblx0XHRcdHhoci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0eGhyLmRlc3Ryb3koKTtcblx0XHRcdH07XG5cblx0XHRcdHhoci5iaW5kKCdSdW50aW1lRXJyb3InLCBmdW5jdGlvbihlLCBlcnIpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdSdW50aW1lRXJyb3InLCBlcnIpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHhoci5zZW5kKG51bGwsIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxuXG5cdC8vIHZpcnR1YWwgd29ybGQgd2lsbCBjcmFzaCBvbiB5b3UgaWYgaW1hZ2UgaGFzIGEgcmVzb2x1dGlvbiBoaWdoZXIgdGhhbiB0aGlzOlxuXHRJbWFnZS5NQVhfUkVTSVpFX1dJRFRIID0gODE5Mjtcblx0SW1hZ2UuTUFYX1JFU0laRV9IRUlHSFQgPSA4MTkyOyBcblxuXHRJbWFnZS5wcm90b3R5cGUgPSBFdmVudFRhcmdldC5pbnN0YW5jZTtcblxuXHRyZXR1cm4gSW1hZ2U7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS9SdW50aW1lLmpzXG5cbi8qKlxuICogUnVudGltZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKmdsb2JhbCBGaWxlOnRydWUgKi9cblxuLyoqXG5EZWZpbmVzIGNvbnN0cnVjdG9yIGZvciBIVE1MNSBydW50aW1lLlxuXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9SdW50aW1lXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvUnVudGltZVwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL3J1bnRpbWUvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCJcbl0sIGZ1bmN0aW9uKEJhc2ljLCB4LCBSdW50aW1lLCBFbnYpIHtcblx0XG5cdHZhciB0eXBlID0gXCJodG1sNVwiLCBleHRlbnNpb25zID0ge307XG5cdFxuXHRmdW5jdGlvbiBIdG1sNVJ1bnRpbWUob3B0aW9ucykge1xuXHRcdHZhciBJID0gdGhpc1xuXHRcdCwgVGVzdCA9IFJ1bnRpbWUuY2FwVGVzdFxuXHRcdCwgVHJ1ZSA9IFJ1bnRpbWUuY2FwVHJ1ZVxuXHRcdDtcblxuXHRcdHZhciBjYXBzID0gQmFzaWMuZXh0ZW5kKHtcblx0XHRcdFx0YWNjZXNzX2JpbmFyeTogVGVzdCh3aW5kb3cuRmlsZVJlYWRlciB8fCB3aW5kb3cuRmlsZSAmJiB3aW5kb3cuRmlsZS5nZXRBc0RhdGFVUkwpLFxuXHRcdFx0XHRhY2Nlc3NfaW1hZ2VfYmluYXJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gSS5jYW4oJ2FjY2Vzc19iaW5hcnknKSAmJiAhIWV4dGVuc2lvbnMuSW1hZ2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRpc3BsYXlfbWVkaWE6IFRlc3QoXG5cdFx0XHRcdFx0KEVudi5jYW4oJ2NyZWF0ZV9jYW52YXMnKSB8fCBFbnYuY2FuKCd1c2VfZGF0YV91cmlfb3ZlcjMya2InKSkgJiYgXG5cdFx0XHRcdFx0ZGVmaW5lZCgnbW94aWUvaW1hZ2UvSW1hZ2UnKVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRkb19jb3JzOiBUZXN0KHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSksXG5cdFx0XHRcdGRyYWdfYW5kX2Ryb3A6IFRlc3QoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBjb21lcyBkaXJlY3RseSBmcm9tIE1vZGVybml6cjogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tL1xuXHRcdFx0XHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0XHQvLyBJRSBoYXMgc3VwcG9ydCBmb3IgZHJhZyBhbmQgZHJvcCBzaW5jZSB2ZXJzaW9uIDUsIGJ1dCBkb2Vzbid0IHN1cHBvcnQgZHJvcHBpbmcgZmlsZXMgZnJvbSBkZXNrdG9wXG5cdFx0XHRcdFx0cmV0dXJuICgoJ2RyYWdnYWJsZScgaW4gZGl2KSB8fCAoJ29uZHJhZ3N0YXJ0JyBpbiBkaXYgJiYgJ29uZHJvcCcgaW4gZGl2KSkgJiYgXG5cdFx0XHRcdFx0XHQoRW52LmJyb3dzZXIgIT09ICdJRScgfHwgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDksICc+JykpO1xuXHRcdFx0XHR9KCkpLFxuXHRcdFx0XHRmaWx0ZXJfYnlfZXh0ZW5zaW9uOiBUZXN0KGZ1bmN0aW9uKCkgeyAvLyBpZiB5b3Uga25vdyBob3cgdG8gZmVhdHVyZS1kZXRlY3QgdGhpcywgcGxlYXNlIHN1Z2dlc3Rcblx0XHRcdFx0XHRyZXR1cm4gIShcblx0XHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0Nocm9tZScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDI4LCAnPCcpKSB8fCBcblx0XHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0lFJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMTAsICc8JykpIHx8IFxuXHRcdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnU2FmYXJpJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgNywgJzwnKSkgfHxcblx0XHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0ZpcmVmb3gnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAzNywgJzwnKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KCkpLFxuXHRcdFx0XHRyZXR1cm5fcmVzcG9uc2VfaGVhZGVyczogVHJ1ZSxcblx0XHRcdFx0cmV0dXJuX3Jlc3BvbnNlX3R5cGU6IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiAhIXdpbmRvdy5KU09OKSB7IC8vIHdlIGNhbiBmYWtlIHRoaXMgb25lIGV2ZW4gaWYgaXQncyBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9IFxuXHRcdFx0XHRcdHJldHVybiBFbnYuY2FuKCdyZXR1cm5fcmVzcG9uc2VfdHlwZScsIHJlc3BvbnNlVHlwZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJldHVybl9zdGF0dXNfY29kZTogVHJ1ZSxcblx0XHRcdFx0cmVwb3J0X3VwbG9hZF9wcm9ncmVzczogVGVzdCh3aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgbmV3IFhNTEh0dHBSZXF1ZXN0KCkudXBsb2FkKSxcblx0XHRcdFx0cmVzaXplX2ltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gSS5jYW4oJ2FjY2Vzc19iaW5hcnknKSAmJiBFbnYuY2FuKCdjcmVhdGVfY2FudmFzJyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdF9maWxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gRW52LmNhbigndXNlX2ZpbGVpbnB1dCcpICYmIHdpbmRvdy5GaWxlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RfZm9sZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gSS5jYW4oJ3NlbGVjdF9maWxlJykgJiYgKFxuXHRcdFx0XHRcdFx0RW52LmJyb3dzZXIgPT09ICdDaHJvbWUnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAyMSwgJz49JykgfHxcblx0XHRcdFx0XHRcdEVudi5icm93c2VyID09PSAnRmlyZWZveCcgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDQyLCAnPj0nKSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9GaXJlZm94L1JlbGVhc2VzLzQyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0X211bHRpcGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBpdCBpcyBidWdneSBvbiBTYWZhcmkgV2luZG93cyBhbmQgaU9TXG5cdFx0XHRcdFx0cmV0dXJuIEkuY2FuKCdzZWxlY3RfZmlsZScpICYmXG5cdFx0XHRcdFx0XHQhKEVudi5icm93c2VyID09PSAnU2FmYXJpJyAmJiBFbnYub3MgPT09ICdXaW5kb3dzJykgJiZcblx0XHRcdFx0XHRcdCEoRW52Lm9zID09PSAnaU9TJyAmJiBFbnYudmVyQ29tcChFbnYub3NWZXJzaW9uLCBcIjcuMC4wXCIsICc+JykgJiYgRW52LnZlckNvbXAoRW52Lm9zVmVyc2lvbiwgXCI4LjAuMFwiLCAnPCcpKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VuZF9iaW5hcnlfc3RyaW5nOiBUZXN0KHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAobmV3IFhNTEh0dHBSZXF1ZXN0KCkuc2VuZEFzQmluYXJ5IHx8ICh3aW5kb3cuVWludDhBcnJheSAmJiB3aW5kb3cuQXJyYXlCdWZmZXIpKSksXG5cdFx0XHRcdHNlbmRfY3VzdG9tX2hlYWRlcnM6IFRlc3Qod2luZG93LlhNTEh0dHBSZXF1ZXN0KSxcblx0XHRcdFx0c2VuZF9tdWx0aXBhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiAhISh3aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgbmV3IFhNTEh0dHBSZXF1ZXN0KCkudXBsb2FkICYmIHdpbmRvdy5Gb3JtRGF0YSkgfHwgSS5jYW4oJ3NlbmRfYmluYXJ5X3N0cmluZycpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzbGljZV9ibG9iOiBUZXN0KHdpbmRvdy5GaWxlICYmIChGaWxlLnByb3RvdHlwZS5tb3pTbGljZSB8fCBGaWxlLnByb3RvdHlwZS53ZWJraXRTbGljZSB8fCBGaWxlLnByb3RvdHlwZS5zbGljZSkpLFxuXHRcdFx0XHRzdHJlYW1fdXBsb2FkOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiBJLmNhbignc2xpY2VfYmxvYicpICYmIEkuY2FuKCdzZW5kX211bHRpcGFydCcpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdW1tb25fZmlsZV9kaWFsb2c6IGZ1bmN0aW9uKCkgeyAvLyB5ZWFoLi4uIHNvbWUgZGlydHkgc25pZmZpbmcgaGVyZS4uLlxuXHRcdFx0XHRcdHJldHVybiBJLmNhbignc2VsZWN0X2ZpbGUnKSAmJiAoXG5cdFx0XHRcdFx0XHQoRW52LmJyb3dzZXIgPT09ICdGaXJlZm94JyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgNCwgJz49JykpIHx8XG5cdFx0XHRcdFx0XHQoRW52LmJyb3dzZXIgPT09ICdPcGVyYScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDEyLCAnPj0nKSkgfHxcblx0XHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0lFJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMTAsICc+PScpKSB8fFxuXHRcdFx0XHRcdFx0ISF+QmFzaWMuaW5BcnJheShFbnYuYnJvd3NlciwgWydDaHJvbWUnLCAnU2FmYXJpJywgJ0VkZ2UnXSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cGxvYWRfZmlsZXNpemU6IFRydWUsXG5cdFx0XHRcdHVzZV9odHRwX21ldGhvZDogVHJ1ZVxuXHRcdFx0fSwgXG5cdFx0XHRhcmd1bWVudHNbMl1cblx0XHQpO1xuXG5cdFx0UnVudGltZS5jYWxsKHRoaXMsIG9wdGlvbnMsIChhcmd1bWVudHNbMV0gfHwgdHlwZSksIGNhcHMpO1xuXG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXG5cdFx0XHRpbml0IDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcIkluaXRcIik7XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiAoZnVuY3Rpb24oZGVzdHJveSkgeyAvLyBleHRlbmQgZGVmYXVsdCBkZXN0cm95IG1ldGhvZFxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVzdHJveS5jYWxsKEkpO1xuXHRcdFx0XHRcdGRlc3Ryb3kgPSBJID0gbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdH0odGhpcy5kZXN0cm95KSlcblx0XHR9KTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLmdldFNoaW0oKSwgZXh0ZW5zaW9ucyk7XG5cdH1cblxuXHRSdW50aW1lLmFkZENvbnN0cnVjdG9yKHR5cGUsIEh0bWw1UnVudGltZSk7XG5cblx0cmV0dXJuIGV4dGVuc2lvbnM7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS9maWxlL0Jsb2IuanNcblxuLyoqXG4gKiBCbG9iLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvZmlsZS9CbG9iXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvZmlsZS9CbG9iXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L1J1bnRpbWVcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmxvYikge1xuXG5cdGZ1bmN0aW9uIEhUTUw1QmxvYigpIHtcblx0XHRmdW5jdGlvbiB3M2NCbG9iU2xpY2UoYmxvYiwgc3RhcnQsIGVuZCkge1xuXHRcdFx0dmFyIGJsb2JTbGljZTtcblxuXHRcdFx0aWYgKHdpbmRvdy5GaWxlLnByb3RvdHlwZS5zbGljZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGJsb2Iuc2xpY2UoKTtcdC8vIGRlcHJpY2F0ZWQgdmVyc2lvbiB3aWxsIHRocm93IFdST05HX0FSR1VNRU5UU19FUlIgZXhjZXB0aW9uXG5cdFx0XHRcdFx0cmV0dXJuIGJsb2Iuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBkZXByaWNhdGVkIHNsaWNlIG1ldGhvZFxuXHRcdFx0XHRcdHJldHVybiBibG9iLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG5cdFx0XHRcdH1cblx0XHRcdC8vIHNsaWNlIG1ldGhvZCBnb3QgcHJlZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTY3MlxuXHRcdFx0fSBlbHNlIGlmICgoYmxvYlNsaWNlID0gd2luZG93LkZpbGUucHJvdG90eXBlLndlYmtpdFNsaWNlIHx8IHdpbmRvdy5GaWxlLnByb3RvdHlwZS5tb3pTbGljZSkpIHtcblx0XHRcdFx0cmV0dXJuIGJsb2JTbGljZS5jYWxsKGJsb2IsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIG9yIHRocm93IHNvbWUgZXhjZXB0aW9uXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zbGljZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBCbG9iKHRoaXMuZ2V0UnVudGltZSgpLnVpZCwgdzNjQmxvYlNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuQmxvYiA9IEhUTUw1QmxvYik7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvY29yZS91dGlscy9FdmVudHMuanNcblxuLyoqXG4gKiBFdmVudHMuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9jb3JlL3V0aWxzL0V2ZW50cycsIFtcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnXG5dLCBmdW5jdGlvbihCYXNpYykge1xuXHR2YXIgZXZlbnRoYXNoID0ge30sIHVpZCA9ICdtb3hpZV8nICsgQmFzaWMuZ3VpZCgpO1xuXHRcblx0Ly8gSUUgVzNDIGxpa2UgZXZlbnQgZnVuY3Ncblx0ZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG5cdFx0dGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuXHRcdHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHRBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIHNwZWNpZmllZCBvYmplY3QgYW5kIHN0b3JlIHJlZmVyZW5jZSB0byB0aGUgaGFuZGxlclxuXHRpbiBvYmplY3RzIGludGVybmFsIFBsdXBsb2FkIHJlZ2lzdHJ5IChAc2VlIHJlbW92ZUV2ZW50KS5cblx0XG5cdEBtZXRob2QgYWRkRXZlbnRcblx0QGZvciBVdGlsc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvLlxuXHRAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlbnQgb2NjdXJzLlxuXHRAcGFyYW0ge1N0cmluZ30gW2tleV0gdGhhdCBtaWdodCBiZSB1c2VkIHRvIGFkZCBzcGVjaWZpdHkgdG8gdGhlIGV2ZW50IHJlY29yZC5cblx0Ki9cblx0dmFyIGFkZEV2ZW50ID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaywga2V5KSB7XG5cdFx0dmFyIGZ1bmMsIGV2ZW50cztcblx0XHRcdFx0XHRcblx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0Ly8gQWRkIGV2ZW50IGxpc3RlbmVyXG5cdFx0aWYgKG9iai5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRmdW5jID0gY2FsbGJhY2s7XG5cdFx0XHRcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmMsIGZhbHNlKTtcblx0XHR9IGVsc2UgaWYgKG9iai5hdHRhY2hFdmVudCkge1xuXHRcdFx0ZnVuYyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXZ0ID0gd2luZG93LmV2ZW50O1xuXG5cdFx0XHRcdGlmICghZXZ0LnRhcmdldCkge1xuXHRcdFx0XHRcdGV2dC50YXJnZXQgPSBldnQuc3JjRWxlbWVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV2dC5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuXHRcdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFByb3BhZ2F0aW9uO1xuXG5cdFx0XHRcdGNhbGxiYWNrKGV2dCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGZ1bmMpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBMb2cgZXZlbnQgaGFuZGxlciB0byBvYmplY3RzIGludGVybmFsIG1PeGllIHJlZ2lzdHJ5XG5cdFx0aWYgKCFvYmpbdWlkXSkge1xuXHRcdFx0b2JqW3VpZF0gPSBCYXNpYy5ndWlkKCk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmICghZXZlbnRoYXNoLmhhc093blByb3BlcnR5KG9ialt1aWRdKSkge1xuXHRcdFx0ZXZlbnRoYXNoW29ialt1aWRdXSA9IHt9O1xuXHRcdH1cblx0XHRcblx0XHRldmVudHMgPSBldmVudGhhc2hbb2JqW3VpZF1dO1xuXHRcdFxuXHRcdGlmICghZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRldmVudHNbbmFtZV0gPSBbXTtcblx0XHR9XG5cdFx0XHRcdFxuXHRcdGV2ZW50c1tuYW1lXS5wdXNoKHtcblx0XHRcdGZ1bmM6IGZ1bmMsXG5cdFx0XHRvcmlnOiBjYWxsYmFjaywgLy8gc3RvcmUgb3JpZ2luYWwgY2FsbGJhY2sgZm9yIElFXG5cdFx0XHRrZXk6IGtleVxuXHRcdH0pO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHRSZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBzcGVjaWZpZWQgb2JqZWN0LiBJZiB0aGlyZCBhcmd1bWVudCAoY2FsbGJhY2spXG5cdGlzIG5vdCBzcGVjaWZpZWQgcmVtb3ZlIGFsbCBldmVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG5cdFxuXHRAbWV0aG9kIHJlbW92ZUV2ZW50XG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG9iaiBET00gZWxlbWVudCB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIocykgZnJvbS5cblx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiBldmVudCBsaXN0ZW5lciB0byByZW1vdmUuXG5cdEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBbY2FsbGJhY2tdIG1pZ2h0IGJlIGEgY2FsbGJhY2sgb3IgdW5pcXVlIGtleSB0byBtYXRjaC5cblx0Ki9cblx0dmFyIHJlbW92ZUV2ZW50ID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuXHRcdHZhciB0eXBlLCB1bmRlZjtcblx0XHRcblx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFxuXHRcdGlmIChvYmpbdWlkXSAmJiBldmVudGhhc2hbb2JqW3VpZF1dICYmIGV2ZW50aGFzaFtvYmpbdWlkXV1bbmFtZV0pIHtcblx0XHRcdHR5cGUgPSBldmVudGhhc2hbb2JqW3VpZF1dW25hbWVdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFx0XG5cdFx0Zm9yICh2YXIgaSA9IHR5cGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdC8vIHVuZGVmaW5lZCBvciBub3QsIGtleSBzaG91bGQgbWF0Y2hcblx0XHRcdGlmICh0eXBlW2ldLm9yaWcgPT09IGNhbGxiYWNrIHx8IHR5cGVbaV0ua2V5ID09PSBjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAob2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB0eXBlW2ldLmZ1bmMsIGZhbHNlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvYmouZGV0YWNoRXZlbnQpIHtcblx0XHRcdFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJytuYW1lLCB0eXBlW2ldLmZ1bmMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR0eXBlW2ldLm9yaWcgPSBudWxsO1xuXHRcdFx0XHR0eXBlW2ldLmZ1bmMgPSBudWxsO1xuXHRcdFx0XHR0eXBlLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIElmIGNhbGxiYWNrIHdhcyBwYXNzZWQgd2UgYXJlIGRvbmUgaGVyZSwgb3RoZXJ3aXNlIHByb2NlZWRcblx0XHRcdFx0aWYgKGNhbGxiYWNrICE9PSB1bmRlZikge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIElmIGV2ZW50IGFycmF5IGdvdCBlbXB0eSwgcmVtb3ZlIGl0XG5cdFx0aWYgKCF0eXBlLmxlbmd0aCkge1xuXHRcdFx0ZGVsZXRlIGV2ZW50aGFzaFtvYmpbdWlkXV1bbmFtZV07XG5cdFx0fVxuXHRcdFxuXHRcdC8vIElmIG1PeGllIHJlZ2lzdHJ5IGhhcyBiZWNvbWUgZW1wdHksIHJlbW92ZSBpdFxuXHRcdGlmIChCYXNpYy5pc0VtcHR5T2JqKGV2ZW50aGFzaFtvYmpbdWlkXV0pKSB7XG5cdFx0XHRkZWxldGUgZXZlbnRoYXNoW29ialt1aWRdXTtcblx0XHRcdFxuXHRcdFx0Ly8gSUUgZG9lc24ndCBsZXQgeW91IHJlbW92ZSBET00gb2JqZWN0IHByb3BlcnR5IHdpdGggLSBkZWxldGVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlbGV0ZSBvYmpbdWlkXTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRvYmpbdWlkXSA9IHVuZGVmO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0UmVtb3ZlIGFsbCBraW5kIG9mIGV2ZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgb2JqZWN0XG5cdFxuXHRAbWV0aG9kIHJlbW92ZUFsbEV2ZW50c1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmcm9tLlxuXHRAcGFyYW0ge1N0cmluZ30gW2tleV0gdW5pcXVlIGtleSB0byBtYXRjaCwgd2hlbiByZW1vdmluZyBldmVudHMuXG5cdCovXG5cdHZhciByZW1vdmVBbGxFdmVudHMgPSBmdW5jdGlvbihvYmosIGtleSkge1x0XHRcblx0XHRpZiAoIW9iaiB8fCAhb2JqW3VpZF0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0QmFzaWMuZWFjaChldmVudGhhc2hbb2JqW3VpZF1dLCBmdW5jdGlvbihldmVudHMsIG5hbWUpIHtcblx0XHRcdHJlbW92ZUV2ZW50KG9iaiwgbmFtZSwga2V5KTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdGFkZEV2ZW50OiBhZGRFdmVudCxcblx0XHRyZW1vdmVFdmVudDogcmVtb3ZlRXZlbnQsXG5cdFx0cmVtb3ZlQWxsRXZlbnRzOiByZW1vdmVBbGxFdmVudHNcblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ZpbGUvRmlsZUlucHV0LmpzXG5cbi8qKlxuICogRmlsZUlucHV0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvZmlsZS9GaWxlSW5wdXRcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9maWxlL0ZpbGVJbnB1dFwiLCBbXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9SdW50aW1lXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRG9tXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FdmVudHNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL01pbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VudlwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBGaWxlLCBCYXNpYywgRG9tLCBFdmVudHMsIE1pbWUsIEVudikge1xuXHRcblx0ZnVuY3Rpb24gRmlsZUlucHV0KCkge1xuXHRcdHZhciBfb3B0aW9ucywgX2Jyb3dzZUJ0blpJbmRleDsgLy8gc2F2ZSBvcmlnaW5hbCB6LWluZGV4XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgY29tcCA9IHRoaXMsIEkgPSBjb21wLmdldFJ1bnRpbWUoKSwgaW5wdXQsIHNoaW1Db250YWluZXIsIG1pbWVzLCBicm93c2VCdXR0b24sIHpJbmRleCwgdG9wO1xuXG5cdFx0XHRcdF9vcHRpb25zID0gb3B0aW9ucztcblxuXHRcdFx0XHQvLyBmaWd1cmUgb3V0IGFjY2VwdCBzdHJpbmdcblx0XHRcdFx0bWltZXMgPSBfb3B0aW9ucy5hY2NlcHQubWltZXMgfHwgTWltZS5leHRMaXN0Mm1pbWVzKF9vcHRpb25zLmFjY2VwdCwgSS5jYW4oJ2ZpbHRlcl9ieV9leHRlbnNpb24nKSk7XG5cblx0XHRcdFx0c2hpbUNvbnRhaW5lciA9IEkuZ2V0U2hpbUNvbnRhaW5lcigpO1xuXG5cdFx0XHRcdHNoaW1Db250YWluZXIuaW5uZXJIVE1MID0gJzxpbnB1dCBpZD1cIicgKyBJLnVpZCArJ1wiIHR5cGU9XCJmaWxlXCIgc3R5bGU9XCJmb250LXNpemU6OTk5cHg7b3BhY2l0eTowO1wiJyArXG5cdFx0XHRcdFx0KF9vcHRpb25zLm11bHRpcGxlICYmIEkuY2FuKCdzZWxlY3RfbXVsdGlwbGUnKSA/ICdtdWx0aXBsZScgOiAnJykgKyBcblx0XHRcdFx0XHQoX29wdGlvbnMuZGlyZWN0b3J5ICYmIEkuY2FuKCdzZWxlY3RfZm9sZGVyJykgPyAnd2Via2l0ZGlyZWN0b3J5IGRpcmVjdG9yeScgOiAnJykgKyAvLyBDaHJvbWUgMTErXG5cdFx0XHRcdFx0KG1pbWVzID8gJyBhY2NlcHQ9XCInICsgbWltZXMuam9pbignLCcpICsgJ1wiJyA6ICcnKSArICcgLz4nO1xuXG5cdFx0XHRcdGlucHV0ID0gRG9tLmdldChJLnVpZCk7XG5cblx0XHRcdFx0Ly8gcHJlcGFyZSBmaWxlIGlucHV0IHRvIGJlIHBsYWNlZCB1bmRlcm5lYXRoIHRoZSBicm93c2VfYnV0dG9uIGVsZW1lbnRcblx0XHRcdFx0QmFzaWMuZXh0ZW5kKGlucHV0LnN0eWxlLCB7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0d2lkdGg6ICcxMDAlJyxcblx0XHRcdFx0XHRoZWlnaHQ6ICcxMDAlJ1xuXHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdGJyb3dzZUJ1dHRvbiA9IERvbS5nZXQoX29wdGlvbnMuYnJvd3NlX2J1dHRvbik7XG5cdFx0XHRcdF9icm93c2VCdG5aSW5kZXggPSBEb20uZ2V0U3R5bGUoYnJvd3NlQnV0dG9uLCAnei1pbmRleCcpIHx8ICdhdXRvJztcblxuXHRcdFx0XHQvLyBSb3V0ZSBjbGljayBldmVudCB0byB0aGUgaW5wdXRbdHlwZT1maWxlXSBlbGVtZW50IGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgc3VjaCBiZWhhdmlvclxuXHRcdFx0XHRpZiAoSS5jYW4oJ3N1bW1vbl9maWxlX2RpYWxvZycpKSB7XG5cdFx0XHRcdFx0aWYgKERvbS5nZXRTdHlsZShicm93c2VCdXR0b24sICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuXHRcdFx0XHRcdFx0YnJvd3NlQnV0dG9uLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoYnJvd3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5wdXQgPSBEb20uZ2V0KEkudWlkKTtcblx0XHRcdFx0XHRcdGlmIChpbnB1dCAmJiAhaW5wdXQuZGlzYWJsZWQpIHsgLy8gZm9yIHNvbWUgcmVhc29uIEZGICh1cCB0byA4LjAuMSBzbyBmYXIpIGxldHMgdG8gY2xpY2sgZGlzYWJsZWQgaW5wdXRbdHlwZT1maWxlXVxuXHRcdFx0XHRcdFx0XHRpbnB1dC5jbGljaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRcdGNvbXAuYmluZCgnUmVmcmVzaCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ekluZGV4ID0gcGFyc2VJbnQoX2Jyb3dzZUJ0blpJbmRleCwgMTApIHx8IDE7XG5cblx0XHRcdFx0XHRcdERvbS5nZXQoX29wdGlvbnMuYnJvd3NlX2J1dHRvbikuc3R5bGUuekluZGV4ID0gekluZGV4O1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRSdW50aW1lKCkuZ2V0U2hpbUNvbnRhaW5lcigpLnN0eWxlLnpJbmRleCA9IHpJbmRleCAtIDE7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBTaW5jZSB3ZSBoYXZlIHRvIHBsYWNlIGlucHV0W3R5cGU9ZmlsZV0gb24gdG9wIG9mIHRoZSBicm93c2VfYnV0dG9uIGZvciBzb21lIGJyb3dzZXJzLFxuXHRcdFx0XHRicm93c2VfYnV0dG9uIGxvc2VzIGludGVyYWN0aXZpdHksIHNvIHdlIHJlc3RvcmUgaXQgaGVyZSAqL1xuXHRcdFx0XHR0b3AgPSBJLmNhbignc3VtbW9uX2ZpbGVfZGlhbG9nJykgPyBicm93c2VCdXR0b24gOiBzaGltQ29udGFpbmVyO1xuXG5cdFx0XHRcdEV2ZW50cy5hZGRFdmVudCh0b3AsICdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjb21wLnRyaWdnZXIoJ21vdXNlZW50ZXInKTtcblx0XHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRcdEV2ZW50cy5hZGRFdmVudCh0b3AsICdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcignbW91c2VsZWF2ZScpO1xuXHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KHRvcCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcignbW91c2Vkb3duJyk7XG5cdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoRG9tLmdldChfb3B0aW9ucy5jb250YWluZXIpLCAnbW91c2V1cCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcignbW91c2V1cCcpO1xuXHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblxuXHRcdFx0XHRpbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHsgLy8gdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGhhbmRsZXIgZm9yIHRoaXNcblx0XHRcdFx0XHRjb21wLmZpbGVzID0gW107XG5cblx0XHRcdFx0XHRCYXNpYy5lYWNoKHRoaXMuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRcdHZhciByZWxhdGl2ZVBhdGggPSAnJztcblxuXHRcdFx0XHRcdFx0aWYgKF9vcHRpb25zLmRpcmVjdG9yeSkge1xuXHRcdFx0XHRcdFx0XHQvLyBmb2xkZXJzIGFyZSByZXByZXNlbnRlZCBieSBkb3RzLCBmaWx0ZXIgdGhlbSBvdXQgKENocm9tZSAxMSspXG5cdFx0XHRcdFx0XHRcdGlmIChmaWxlLm5hbWUgPT0gXCIuXCIpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBpZiBpdCBsb29rcyBsaWtlIGEgZm9sZGVyLi4uXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGZpbGUud2Via2l0UmVsYXRpdmVQYXRoKSB7XG5cdFx0XHRcdFx0XHRcdHJlbGF0aXZlUGF0aCA9ICcvJyArIGZpbGUud2Via2l0UmVsYXRpdmVQYXRoLnJlcGxhY2UoL15cXC8vLCAnJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZpbGUgPSBuZXcgRmlsZShJLnVpZCwgZmlsZSk7XG5cdFx0XHRcdFx0XHRmaWxlLnJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlUGF0aDtcblxuXHRcdFx0XHRcdFx0Y29tcC5maWxlcy5wdXNoKGZpbGUpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gY2xlYXJpbmcgdGhlIHZhbHVlIGVuYWJsZXMgdGhlIHVzZXIgdG8gc2VsZWN0IHRoZSBzYW1lIGZpbGUgYWdhaW4gaWYgdGhleSB3YW50IHRvXG5cdFx0XHRcdFx0aWYgKEVudi5icm93c2VyICE9PSAnSUUnICYmIEVudi5icm93c2VyICE9PSAnSUVNb2JpbGUnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gJyc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGluIElFIGlucHV0W3R5cGU9XCJmaWxlXCJdIGlzIHJlYWQtb25seSBzbyB0aGUgb25seSB3YXkgdG8gcmVzZXQgaXQgaXMgdG8gcmUtaW5zZXJ0IGl0XG5cdFx0XHRcdFx0XHR2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmUsIHRoaXMpO1xuXHRcdFx0XHRcdFx0Y2xvbmUub25jaGFuZ2UgPSBvbkNoYW5nZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoY29tcC5maWxlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNvbXAudHJpZ2dlcignY2hhbmdlJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIHJlYWR5IGV2ZW50IGlzIHBlcmZlY3RseSBhc3luY2hyb25vdXNcblx0XHRcdFx0Y29tcC50cmlnZ2VyKHtcblx0XHRcdFx0XHR0eXBlOiAncmVhZHknLFxuXHRcdFx0XHRcdGFzeW5jOiB0cnVlXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHNoaW1Db250YWluZXIgPSBudWxsO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRzZXRPcHRpb246IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRcdHZhciBJID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cdFx0XHRcdHZhciBpbnB1dCA9IERvbS5nZXQoSS51aWQpO1xuXG5cdFx0XHRcdHN3aXRjaCAobmFtZSkge1xuXHRcdFx0XHRcdGNhc2UgJ2FjY2VwdCc6XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1pbWVzID0gdmFsdWUubWltZXMgfHwgTWltZS5leHRMaXN0Mm1pbWVzKHZhbHVlLCBJLmNhbignZmlsdGVyX2J5X2V4dGVuc2lvbicpKTtcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCBtaW1lcy5qb2luKCcsJykpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhY2NlcHQnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGlyZWN0b3J5Jzpcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiBJLmNhbignc2VsZWN0X2ZvbGRlcicpKSB7XG5cdFx0XHRcdFx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSgnZGlyZWN0b3J5JywgJycpO1xuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ3dlYmtpdGRpcmVjdG9yeScsICcnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnZGlyZWN0b3J5Jyk7XG5cdFx0XHRcdFx0XHRcdGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnd2Via2l0ZGlyZWN0b3J5Jyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ211bHRpcGxlJzpcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiBJLmNhbignc2VsZWN0X211bHRpcGxlJykpIHtcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICcnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnbXVsdGlwbGUnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0XHRcdHZhciBJID0gdGhpcy5nZXRSdW50aW1lKCksIGlucHV0O1xuXG5cdFx0XHRcdGlmICgoaW5wdXQgPSBEb20uZ2V0KEkudWlkKSkpIHtcblx0XHRcdFx0XHRpbnB1dC5kaXNhYmxlZCA9ICEhc3RhdGU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgSSA9IHRoaXMuZ2V0UnVudGltZSgpXG5cdFx0XHRcdCwgc2hpbSA9IEkuZ2V0U2hpbSgpXG5cdFx0XHRcdCwgc2hpbUNvbnRhaW5lciA9IEkuZ2V0U2hpbUNvbnRhaW5lcigpXG5cdFx0XHRcdCwgY29udGFpbmVyID0gX29wdGlvbnMgJiYgRG9tLmdldChfb3B0aW9ucy5jb250YWluZXIpXG5cdFx0XHRcdCwgYnJvd3NlQnV0dG9uID0gX29wdGlvbnMgJiYgRG9tLmdldChfb3B0aW9ucy5icm93c2VfYnV0dG9uKVxuXHRcdFx0XHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY29udGFpbmVyKSB7XG5cdFx0XHRcdFx0RXZlbnRzLnJlbW92ZUFsbEV2ZW50cyhjb250YWluZXIsIHRoaXMudWlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGJyb3dzZUJ1dHRvbikge1xuXHRcdFx0XHRcdEV2ZW50cy5yZW1vdmVBbGxFdmVudHMoYnJvd3NlQnV0dG9uLCB0aGlzLnVpZCk7XG5cdFx0XHRcdFx0YnJvd3NlQnV0dG9uLnN0eWxlLnpJbmRleCA9IF9icm93c2VCdG5aSW5kZXg7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzaGltQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0RXZlbnRzLnJlbW92ZUFsbEV2ZW50cyhzaGltQ29udGFpbmVyLCB0aGlzLnVpZCk7XG5cdFx0XHRcdFx0c2hpbUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoaW0ucmVtb3ZlSW5zdGFuY2UodGhpcy51aWQpO1xuXG5cdFx0XHRcdF9vcHRpb25zID0gc2hpbUNvbnRhaW5lciA9IGNvbnRhaW5lciA9IGJyb3dzZUJ1dHRvbiA9IHNoaW0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVJbnB1dCA9IEZpbGVJbnB1dCk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS9maWxlL0ZpbGVEcm9wLmpzXG5cbi8qKlxuICogRmlsZURyb3AuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9maWxlL0ZpbGVEcm9wXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvZmlsZS9GaWxlRHJvcFwiLCBbXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9SdW50aW1lXCIsXG5cdCdtb3hpZS9maWxlL0ZpbGUnLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0RvbVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRXZlbnRzXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9NaW1lXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEZpbGUsIEJhc2ljLCBEb20sIEV2ZW50cywgTWltZSkge1xuXHRcblx0ZnVuY3Rpb24gRmlsZURyb3AoKSB7XG5cdFx0dmFyIF9maWxlcyA9IFtdLCBfYWxsb3dlZEV4dHMgPSBbXSwgX29wdGlvbnMsIF9ydWlkO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdFx0dmFyIGNvbXAgPSB0aGlzLCBkcm9wWm9uZTtcblxuXHRcdFx0XHRfb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRcdF9ydWlkID0gY29tcC5ydWlkOyAvLyBldmVyeSBkcm9wcGVkLWluIGZpbGUgc2hvdWxkIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHJ1bnRpbWVcblx0XHRcdFx0X2FsbG93ZWRFeHRzID0gX2V4dHJhY3RFeHRzKF9vcHRpb25zLmFjY2VwdCk7XG5cdFx0XHRcdGRyb3Bab25lID0gX29wdGlvbnMuY29udGFpbmVyO1xuXG5cdFx0XHRcdEV2ZW50cy5hZGRFdmVudChkcm9wWm9uZSwgJ2RyYWdvdmVyJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGlmICghX2hhc0ZpbGVzKGUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xuXHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KGRyb3Bab25lLCAnZHJvcCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRpZiAoIV9oYXNGaWxlcyhlKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0XHRfZmlsZXMgPSBbXTtcblxuXHRcdFx0XHRcdC8vIENocm9tZSAyMSsgYWNjZXB0cyBmb2xkZXJzIHZpYSBEcmFnJ24nRHJvcFxuXHRcdFx0XHRcdGlmIChlLmRhdGFUcmFuc2Zlci5pdGVtcyAmJiBlLmRhdGFUcmFuc2Zlci5pdGVtc1swXS53ZWJraXRHZXRBc0VudHJ5KSB7XG5cdFx0XHRcdFx0XHRfcmVhZEl0ZW1zKGUuZGF0YVRyYW5zZmVyLml0ZW1zLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y29tcC5maWxlcyA9IF9maWxlcztcblx0XHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKFwiZHJvcFwiKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRCYXNpYy5lYWNoKGUuZGF0YVRyYW5zZmVyLmZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHRcdFx0XHRcdF9hZGRGaWxlKGZpbGUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRjb21wLmZpbGVzID0gX2ZpbGVzO1xuXHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKFwiZHJvcFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoZHJvcFpvbmUsICdkcmFnZW50ZXInLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKFwiZHJhZ2VudGVyXCIpO1xuXHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KGRyb3Bab25lLCAnZHJhZ2xlYXZlJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcihcImRyYWdsZWF2ZVwiKTtcblx0XHRcdFx0fSwgY29tcC51aWQpO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdEV2ZW50cy5yZW1vdmVBbGxFdmVudHMoX29wdGlvbnMgJiYgRG9tLmdldChfb3B0aW9ucy5jb250YWluZXIpLCB0aGlzLnVpZCk7XG5cdFx0XHRcdF9ydWlkID0gX2ZpbGVzID0gX2FsbG93ZWRFeHRzID0gX29wdGlvbnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHRmdW5jdGlvbiBfaGFzRmlsZXMoZSkge1xuXHRcdFx0aWYgKCFlLmRhdGFUcmFuc2ZlciB8fCAhZS5kYXRhVHJhbnNmZXIudHlwZXMpIHsgLy8gZS5kYXRhVHJhbnNmZXIuZmlsZXMgaXMgbm90IGF2YWlsYWJsZSBpbiBHZWNrbyBkdXJpbmcgZHJhZ292ZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdHlwZXMgPSBCYXNpYy50b0FycmF5KGUuZGF0YVRyYW5zZmVyLnR5cGVzIHx8IFtdKTtcblxuXHRcdFx0cmV0dXJuIEJhc2ljLmluQXJyYXkoXCJGaWxlc1wiLCB0eXBlcykgIT09IC0xIHx8XG5cdFx0XHRcdEJhc2ljLmluQXJyYXkoXCJwdWJsaWMuZmlsZS11cmxcIiwgdHlwZXMpICE9PSAtMSB8fCAvLyBTYWZhcmkgPCA1XG5cdFx0XHRcdEJhc2ljLmluQXJyYXkoXCJhcHBsaWNhdGlvbi94LW1vei1maWxlXCIsIHR5cGVzKSAhPT0gLTEgLy8gR2Vja28gPCAxLjkuMiAoPCBGaXJlZm94IDMuNilcblx0XHRcdFx0O1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2FkZEZpbGUoZmlsZSwgcmVsYXRpdmVQYXRoKSB7XG5cdFx0XHRpZiAoX2lzQWNjZXB0YWJsZShmaWxlKSkge1xuXHRcdFx0XHR2YXIgZmlsZU9iaiA9IG5ldyBGaWxlKF9ydWlkLCBmaWxlKTtcblx0XHRcdFx0ZmlsZU9iai5yZWxhdGl2ZVBhdGggPSByZWxhdGl2ZVBhdGggfHwgJyc7XG5cdFx0XHRcdF9maWxlcy5wdXNoKGZpbGVPYmopO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFxuXHRcdGZ1bmN0aW9uIF9leHRyYWN0RXh0cyhhY2NlcHQpIHtcblx0XHRcdHZhciBleHRzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRbXS5wdXNoLmFwcGx5KGV4dHMsIGFjY2VwdFtpXS5leHRlbnNpb25zLnNwbGl0KC9cXHMqLFxccyovKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQmFzaWMuaW5BcnJheSgnKicsIGV4dHMpID09PSAtMSA/IGV4dHMgOiBbXTtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9pc0FjY2VwdGFibGUoZmlsZSkge1xuXHRcdFx0aWYgKCFfYWxsb3dlZEV4dHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGV4dCA9IE1pbWUuZ2V0RmlsZUV4dGVuc2lvbihmaWxlLm5hbWUpO1xuXHRcdFx0cmV0dXJuICFleHQgfHwgQmFzaWMuaW5BcnJheShleHQsIF9hbGxvd2VkRXh0cykgIT09IC0xO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3JlYWRJdGVtcyhpdGVtcywgY2IpIHtcblx0XHRcdHZhciBlbnRyaWVzID0gW107XG5cdFx0XHRCYXNpYy5lYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpO1xuXHRcdFx0XHQvLyBBZGRyZXNzICM5OTggKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zMzI1NzkpXG5cdFx0XHRcdGlmIChlbnRyeSkge1xuXHRcdFx0XHRcdC8vIGZpbGUoKSBmYWlscyBvbiBPU1ggd2hlbiB0aGUgZmlsZW5hbWUgY29udGFpbnMgYSBzcGVjaWFsIGNoYXJhY3RlciAoZS5nLiB1bWxhdXQpOiBzZWUgIzYxXG5cdFx0XHRcdFx0aWYgKGVudHJ5LmlzRmlsZSkge1xuXHRcdFx0XHRcdFx0X2FkZEZpbGUoaXRlbS5nZXRBc0ZpbGUoKSwgZW50cnkuZnVsbFBhdGgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbnRyaWVzLnB1c2goZW50cnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChlbnRyaWVzLmxlbmd0aCkge1xuXHRcdFx0XHRfcmVhZEVudHJpZXMoZW50cmllcywgY2IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9yZWFkRW50cmllcyhlbnRyaWVzLCBjYikge1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0XHRCYXNpYy5lYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0XHRcdHF1ZXVlLnB1c2goZnVuY3Rpb24oY2JjYikge1xuXHRcdFx0XHRcdF9yZWFkRW50cnkoZW50cnksIGNiY2IpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0QmFzaWMuaW5TZXJpZXMocXVldWUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfcmVhZEVudHJ5KGVudHJ5LCBjYikge1xuXHRcdFx0aWYgKGVudHJ5LmlzRmlsZSkge1xuXHRcdFx0XHRlbnRyeS5maWxlKGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRfYWRkRmlsZShmaWxlLCBlbnRyeS5mdWxsUGF0aCk7XG5cdFx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0fSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gZmlyZSBhbiBlcnJvciBldmVudCBtYXliZVxuXHRcdFx0XHRcdGNiKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuXHRcdFx0XHRfcmVhZERpckVudHJ5KGVudHJ5LCBjYik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYigpOyAvLyBub3QgZmlsZSwgbm90IGRpcmVjdG9yeT8gd2hhdCB0aGVuPy4uXG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfcmVhZERpckVudHJ5KGRpckVudHJ5LCBjYikge1xuXHRcdFx0dmFyIGVudHJpZXMgPSBbXSwgZGlyUmVhZGVyID0gZGlyRW50cnkuY3JlYXRlUmVhZGVyKCk7XG5cblx0XHRcdC8vIGtlZXAgcXVlcmluZyByZWN1cnNpdmVseSB0aWxsIG5vIG1vcmUgZW50cmllc1xuXHRcdFx0ZnVuY3Rpb24gZ2V0RW50cmllcyhjYmNiKSB7XG5cdFx0XHRcdGRpclJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbihtb3JlRW50cmllcykge1xuXHRcdFx0XHRcdGlmIChtb3JlRW50cmllcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFtdLnB1c2guYXBwbHkoZW50cmllcywgbW9yZUVudHJpZXMpO1xuXHRcdFx0XHRcdFx0Z2V0RW50cmllcyhjYmNiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2JjYigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgY2JjYik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIC4uLmFuZCB5b3UgdGhvdWdodCBGaWxlUmVhZGVyIHdhcyBjcmF6eS4uLlxuXHRcdFx0Z2V0RW50cmllcyhmdW5jdGlvbigpIHtcblx0XHRcdFx0X3JlYWRFbnRyaWVzKGVudHJpZXMsIGNiKTtcblx0XHRcdH0pOyBcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZURyb3AgPSBGaWxlRHJvcCk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS9maWxlL0ZpbGVSZWFkZXIuanNcblxuLyoqXG4gKiBGaWxlUmVhZGVyLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvZmlsZS9GaWxlUmVhZGVyXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvZmlsZS9GaWxlUmVhZGVyXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VuY29kZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgRW5jb2RlLCBCYXNpYykge1xuXHRcblx0ZnVuY3Rpb24gRmlsZVJlYWRlcigpIHtcblx0XHR2YXIgX2ZyLCBfY29udmVydFRvQmluYXJ5ID0gZmFsc2U7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXG5cdFx0XHRyZWFkOiBmdW5jdGlvbihvcCwgYmxvYikge1xuXHRcdFx0XHR2YXIgY29tcCA9IHRoaXM7XG5cblx0XHRcdFx0Y29tcC5yZXN1bHQgPSAnJztcblxuXHRcdFx0XHRfZnIgPSBuZXcgd2luZG93LkZpbGVSZWFkZXIoKTtcblxuXHRcdFx0XHRfZnIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKGUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfZnIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wLnJlc3VsdCA9IF9jb252ZXJ0VG9CaW5hcnkgPyBfdG9CaW5hcnkoX2ZyLnJlc3VsdCkgOiBfZnIucmVzdWx0O1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcihlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X2ZyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcihlLCBfZnIuZXJyb3IpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfZnIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRfZnIgPSBudWxsO1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcihlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZihfZnJbb3BdKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdF9jb252ZXJ0VG9CaW5hcnkgPSBmYWxzZTtcblx0XHRcdFx0XHRfZnJbb3BdKGJsb2IuZ2V0U291cmNlKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9wID09PSAncmVhZEFzQmluYXJ5U3RyaW5nJykgeyAvLyByZWFkQXNCaW5hcnlTdHJpbmcgaXMgZGVwcmljYXRlZCBpbiBnZW5lcmFsIGFuZCBuZXZlciBleGlzdGVkIGluIElFMTArXG5cdFx0XHRcdFx0X2NvbnZlcnRUb0JpbmFyeSA9IHRydWU7XG5cdFx0XHRcdFx0X2ZyLnJlYWRBc0RhdGFVUkwoYmxvYi5nZXRTb3VyY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF9mcikge1xuXHRcdFx0XHRcdF9mci5hYm9ydCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X2ZyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGZ1bmN0aW9uIF90b0JpbmFyeShzdHIpIHtcblx0XHRcdHJldHVybiBFbmNvZGUuYXRvYihzdHIuc3Vic3RyaW5nKHN0ci5pbmRleE9mKCdiYXNlNjQsJykgKyA3KSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVSZWFkZXIgPSBGaWxlUmVhZGVyKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L3hoci9YTUxIdHRwUmVxdWVzdC5qc1xuXG4vKipcbiAqIFhNTEh0dHBSZXF1ZXN0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qZ2xvYmFsIEFjdGl2ZVhPYmplY3Q6dHJ1ZSAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw1L3hoci9YTUxIdHRwUmVxdWVzdFxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw1L3hoci9YTUxIdHRwUmVxdWVzdFwiLCBbXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvTWltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvVXJsXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUveGhyL0Zvcm1EYXRhXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbnZcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmFzaWMsIE1pbWUsIFVybCwgRmlsZSwgQmxvYiwgRm9ybURhdGEsIHgsIEVudikge1xuXHRcblx0ZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3QoKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0LCBfeGhyXG5cdFx0LCBfZmlsZW5hbWVcblx0XHQ7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24obWV0YSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gdGhpc1xuXHRcdFx0XHQsIGlzR2Vja28yXzVfNiA9IChFbnYuYnJvd3NlciA9PT0gJ01vemlsbGEnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCA0LCAnPj0nKSAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgNywgJzwnKSlcblx0XHRcdFx0LCBpc0FuZHJvaWRCcm93c2VyID0gRW52LmJyb3dzZXIgPT09ICdBbmRyb2lkIEJyb3dzZXInXG5cdFx0XHRcdCwgbXVzdFNlbmRBc0JpbmFyeSA9IGZhbHNlXG5cdFx0XHRcdDtcblxuXHRcdFx0XHQvLyBleHRyYWN0IGZpbGUgbmFtZVxuXHRcdFx0XHRfZmlsZW5hbWUgPSBtZXRhLnVybC5yZXBsYWNlKC9eLis/XFwvKFtcXHdcXC1cXC5dKykkLywgJyQxJykudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRfeGhyID0gX2dldE5hdGl2ZVhIUigpO1xuXHRcdFx0XHRfeGhyLm9wZW4obWV0YS5tZXRob2QsIG1ldGEudXJsLCBtZXRhLmFzeW5jLCBtZXRhLnVzZXIsIG1ldGEucGFzc3dvcmQpO1xuXG5cblx0XHRcdFx0Ly8gcHJlcGFyZSBkYXRhIHRvIGJlIHNlbnRcblx0XHRcdFx0aWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdFx0aWYgKGRhdGEuaXNEZXRhY2hlZCgpKSB7XG5cdFx0XHRcdFx0XHRtdXN0U2VuZEFzQmluYXJ5ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGEuZ2V0U291cmNlKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5oYXNCbG9iKCkpIHtcblx0XHRcdFx0XHRcdGlmIChkYXRhLmdldEJsb2IoKS5pc0RldGFjaGVkKCkpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IF9wcmVwYXJlTXVsdGlwYXJ0LmNhbGwodGFyZ2V0LCBkYXRhKTsgLy8gX3hociBtdXN0IGJlIGluc3RhbnRpYXRlZCBhbmQgYmUgaW4gT1BFTkVEIHN0YXRlXG5cdFx0XHRcdFx0XHRcdG11c3RTZW5kQXNCaW5hcnkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICgoaXNHZWNrbzJfNV82IHx8IGlzQW5kcm9pZEJyb3dzZXIpICYmIEJhc2ljLnR5cGVPZihkYXRhLmdldEJsb2IoKS5nZXRTb3VyY2UoKSkgPT09ICdibG9iJyAmJiB3aW5kb3cuRmlsZVJlYWRlcikge1xuXHRcdFx0XHRcdFx0XHQvLyBHZWNrbyAyLzUvNiBjYW4ndCBzZW5kIGJsb2IgaW4gRm9ybURhdGE6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTE1MFxuXHRcdFx0XHRcdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXJzIChkZWZhdWx0IG9uZSBhbmQgRG9scGhpbikgc2VlbSB0byBoYXZlIHRoZSBzYW1lIGlzc3VlLCBzZWU6ICM2MTNcblx0XHRcdFx0XHRcdFx0X3ByZWxvYWRBbmRTZW5kLmNhbGwodGFyZ2V0LCBtZXRhLCBkYXRhKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuOyAvLyBfcHJlbG9hZEFuZFNlbmQgd2lsbCByZWludm9rZSBzZW5kKCkgd2l0aCB0cmFuc211dGF0ZWQgRm9ybURhdGEgPSVEXG5cdFx0XHRcdFx0XHR9XHRcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0cmFuc2ZlciBmaWVsZHMgdG8gcmVhbCBGb3JtRGF0YVxuXHRcdFx0XHRcdGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHsgLy8gaWYgc3RpbGwgYSBGb3JtRGF0YSwgZS5nLiBub3QgbWFuZ2xlZCBieSBfcHJlcGFyZU11bHRpcGFydCgpXG5cdFx0XHRcdFx0XHR2YXIgZmQgPSBuZXcgd2luZG93LkZvcm1EYXRhKCk7XG5cdFx0XHRcdFx0XHRkYXRhLmVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdFx0XHRcdGZkLmFwcGVuZChuYW1lLCB2YWx1ZS5nZXRTb3VyY2UoKSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmQuYXBwZW5kKG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRkYXRhID0gZmQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBpZiBYSFIgTDJcblx0XHRcdFx0aWYgKF94aHIudXBsb2FkKSB7XG5cdFx0XHRcdFx0aWYgKG1ldGEud2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0XHRcdFx0XHRfeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3hoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRfeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBhZGRpdGlvbmFsbHkgbGlzdGVuIHRvIHByb2dyZXNzIGV2ZW50c1xuXHRcdFx0XHRcdF94aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcihlKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdF94aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAnVXBsb2FkUHJvZ3Jlc3MnLFxuXHRcdFx0XHRcdFx0XHRsb2FkZWQ6IGUubG9hZGVkLFxuXHRcdFx0XHRcdFx0XHR0b3RhbDogZS50b3RhbFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIC4uLiBvdGhlcndpc2Ugc2ltdWxhdGUgWEhSIEwyXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3hoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBvblJlYWR5U3RhdGVDaGFuZ2UoKSB7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIGZha2UgTGV2ZWwgMiBldmVudHNcblx0XHRcdFx0XHRcdHN3aXRjaCAoX3hoci5yZWFkeVN0YXRlKSB7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjYXNlIDE6IC8vIFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRFxuXHRcdFx0XHRcdFx0XHRcdC8vIHJlYWR5c3RhdGVjaGFuZ2VkIGlzIGZpcmVkIHR3aWNlIGZvciBPUEVORUQgc3RhdGUgKGluIElFIGFuZCBNb3ppbGxhKSAtIG5ldVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gbG9va3MgbGlrZSBIRUFERVJTX1JFQ0VJVkVEIChzdGF0ZSAyKSBpcyBub3QgcmVwb3J0ZWQgaW4gT3BlcmEgKG9yIGl0J3Mgb2xkIHZlcnNpb25zKSAtIG5ldVxuXHRcdFx0XHRcdFx0XHRjYXNlIDI6IC8vIFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRURcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOiAvLyBYTUxIdHRwUmVxdWVzdC5MT0FESU5HIFxuXHRcdFx0XHRcdFx0XHRcdC8vIHRyeSB0byBmaXJlIHByb2dyZXNzIGV2ZW50IGZvciBub3QgWEhSIEwyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRvdGFsLCBsb2FkZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChVcmwuaGFzU2FtZU9yaWdpbihtZXRhLnVybCkpIHsgLy8gQ29udGVudC1MZW5ndGggbm90IGFjY2Vzc2libGUgZm9yIGNyb3NzLWRvbWFpbiBvbiBzb21lIGJyb3dzZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRvdGFsID0gX3hoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1MZW5ndGgnKSB8fCAwOyAvLyBvbGQgU2FmYXJpIHRocm93cyBhbiBleGNlcHRpb24gaGVyZVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoX3hoci5yZXNwb25zZVRleHQpIHsgLy8gcmVzcG9uc2VUZXh0IHdhcyBpbnRyb2R1Y2VkIGluIElFN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsb2FkZWQgPSBfeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBjYXRjaChleCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG90YWwgPSBsb2FkZWQgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldC50cmlnZ2VyKHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdwcm9ncmVzcycsXG5cdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGhDb21wdXRhYmxlOiAhIXRvdGFsLFxuXHRcdFx0XHRcdFx0XHRcdFx0dG90YWw6IHBhcnNlSW50KHRvdGFsLCAxMCksXG5cdFx0XHRcdFx0XHRcdFx0XHRsb2FkZWQ6IGxvYWRlZFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjYXNlIDQ6IC8vIFhNTEh0dHBSZXF1ZXN0LkRPTkVcblx0XHRcdFx0XHRcdFx0XHQvLyByZWxlYXNlIHJlYWR5c3RhdGVjaGFuZ2UgaGFuZGxlciAobW9zdGx5IGZvciBJRSlcblx0XHRcdFx0XHRcdFx0XHRfeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB1c3VhbGx5IHN0YXR1cyAwIGlzIHJldHVybmVkIHdoZW4gc2VydmVyIGlzIHVucmVhY2hhYmxlLCBidXQgRkYgYWxzbyBmYWlscyB0byBzdGF0dXMgMCBmb3IgNDA4IHRpbWVvdXRcblx0XHRcdFx0XHRcdFx0XHRpZiAoX3hoci5zdGF0dXMgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldC50cmlnZ2VyKCdlcnJvcicpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcignbG9hZCcpO1xuXHRcdFx0XHRcdFx0XHRcdH1cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cblx0XHRcdFx0Ly8gc2V0IHJlcXVlc3QgaGVhZGVyc1xuXHRcdFx0XHRpZiAoIUJhc2ljLmlzRW1wdHlPYmoobWV0YS5oZWFkZXJzKSkge1xuXHRcdFx0XHRcdEJhc2ljLmVhY2gobWV0YS5oZWFkZXJzLCBmdW5jdGlvbih2YWx1ZSwgaGVhZGVyKSB7XG5cdFx0XHRcdFx0XHRfeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXF1ZXN0IHJlc3BvbnNlIHR5cGVcblx0XHRcdFx0aWYgKFwiXCIgIT09IG1ldGEucmVzcG9uc2VUeXBlICYmICdyZXNwb25zZVR5cGUnIGluIF94aHIpIHtcblx0XHRcdFx0XHRpZiAoJ2pzb24nID09PSBtZXRhLnJlc3BvbnNlVHlwZSAmJiAhRW52LmNhbigncmV0dXJuX3Jlc3BvbnNlX3R5cGUnLCAnanNvbicpKSB7IC8vIHdlIGNhbiBmYWtlIHRoaXMgb25lXG5cdFx0XHRcdFx0XHRfeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0Jztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X3hoci5yZXNwb25zZVR5cGUgPSBtZXRhLnJlc3BvbnNlVHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZW5kIC4uLlxuXHRcdFx0XHRpZiAoIW11c3RTZW5kQXNCaW5hcnkpIHtcblx0XHRcdFx0XHRfeGhyLnNlbmQoZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKF94aHIuc2VuZEFzQmluYXJ5KSB7IC8vIEdlY2tvXG5cdFx0XHRcdFx0XHRfeGhyLnNlbmRBc0JpbmFyeShkYXRhKTtcblx0XHRcdFx0XHR9IGVsc2UgeyAvLyBvdGhlciBicm93c2VycyBoYXZpbmcgc3VwcG9ydCBmb3IgdHlwZWQgYXJyYXlzXG5cdFx0XHRcdFx0XHQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG1pbWljIEdlY2tvJ3Mgc2VuZEFzQmluYXJ5XG5cdFx0XHRcdFx0XHRcdHZhciB1aThhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR1aThhW2ldID0gKGRhdGEuY2hhckNvZGVBdChpKSAmIDB4ZmYpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdF94aHIuc2VuZCh1aThhLmJ1ZmZlcik7XG5cdFx0XHRcdFx0XHR9KCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldC50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcblx0XHRcdH0sXG5cblx0XHRcdGdldFN0YXR1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGFjY29yZGluZyB0byBXM0Mgc3BlYyBpdCBzaG91bGQgcmV0dXJuIDAgZm9yIHJlYWR5U3RhdGUgPCAzLCBidXQgaW5zdGVhZCBpdCB0aHJvd3MgYW4gZXhjZXB0aW9uXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKF94aHIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBfeGhyLnN0YXR1cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2goZXgpIHt9XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0UmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHR2YXIgSSA9IHRoaXMuZ2V0UnVudGltZSgpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0c3dpdGNoIChyZXNwb25zZVR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2Jsb2InOlxuXHRcdFx0XHRcdFx0XHR2YXIgZmlsZSA9IG5ldyBGaWxlKEkudWlkLCBfeGhyLnJlc3BvbnNlKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIHRyeSB0byBleHRyYWN0IGZpbGUgbmFtZSBmcm9tIGNvbnRlbnQtZGlzcG9zaXRpb24gaWYgcG9zc2libGUgKG1pZ2h0IGJlIC0gbm90LCBpZiBDT1JTIGZvciBleGFtcGxlKVx0XG5cdFx0XHRcdFx0XHRcdHZhciBkaXNwb3NpdGlvbiA9IF94aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKTtcblx0XHRcdFx0XHRcdFx0aWYgKGRpc3Bvc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXh0cmFjdCBmaWxlbmFtZSBmcm9tIHJlc3BvbnNlIGhlYWRlciBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBkaXNwb3NpdGlvbi5tYXRjaCgvZmlsZW5hbWU9KFtcXCdcXFwiJ10pKFteXFwxXSspXFwxLyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfZmlsZW5hbWUgPSBtYXRjaFsyXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZmlsZS5uYW1lID0gX2ZpbGVuYW1lO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHByZS13ZWJraXQgT3BlcmEgZG9lc24ndCBzZXQgdHlwZSBwcm9wZXJ0eSBvbiB0aGUgYmxvYiByZXNwb25zZVxuXHRcdFx0XHRcdFx0XHRpZiAoIWZpbGUudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdGZpbGUudHlwZSA9IE1pbWUuZ2V0RmlsZU1pbWUoX2ZpbGVuYW1lKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmlsZTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnanNvbic6XG5cdFx0XHRcdFx0XHRcdGlmICghRW52LmNhbigncmV0dXJuX3Jlc3BvbnNlX3R5cGUnLCAnanNvbicpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIF94aHIuc3RhdHVzID09PSAyMDAgJiYgISF3aW5kb3cuSlNPTiA/IEpTT04ucGFyc2UoX3hoci5yZXNwb25zZVRleHQpIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gX3hoci5yZXNwb25zZTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZG9jdW1lbnQnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gX2dldERvY3VtZW50KF94aHIpO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gX3hoci5yZXNwb25zZVRleHQgIT09ICcnID8gX3hoci5yZXNwb25zZVRleHQgOiBudWxsOyAvLyBhZ2FpbnN0IHRoZSBzcGVjcywgYnV0IGZvciBjb25zaXN0ZW5jeSBhY3Jvc3MgdGhlIHJ1bnRpbWVzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cdFx0XHRcdFxuXHRcdFx0fSxcblxuXHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblx0XHRcdFx0fSBjYXRjaChleCkge31cblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3hocikge1xuXHRcdFx0XHRcdF94aHIuYWJvcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYgPSBfZmlsZW5hbWUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHQvLyBoZXJlIHdlIGdvLi4uIHVnbHkgZml4IGZvciB1Z2x5IGJ1Z1xuXHRcdGZ1bmN0aW9uIF9wcmVsb2FkQW5kU2VuZChtZXRhLCBkYXRhKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcywgYmxvYiwgZnI7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gZ2V0IG9yaWdpbmFsIGJsb2Jcblx0XHRcdGJsb2IgPSBkYXRhLmdldEJsb2IoKS5nZXRTb3VyY2UoKTtcblx0XHRcdFxuXHRcdFx0Ly8gcHJlbG9hZCBibG9iIGluIG1lbW9yeSB0byBiZSBzZW50IGFzIGJpbmFyeSBzdHJpbmdcblx0XHRcdGZyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG5cdFx0XHRmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gb3ZlcndyaXRlIG9yaWdpbmFsIGJsb2Jcblx0XHRcdFx0ZGF0YS5hcHBlbmQoZGF0YS5nZXRCbG9iTmFtZSgpLCBuZXcgQmxvYihudWxsLCB7XG5cdFx0XHRcdFx0dHlwZTogYmxvYi50eXBlLFxuXHRcdFx0XHRcdGRhdGE6IGZyLnJlc3VsdFxuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdC8vIGludm9rZSBzZW5kIG9wZXJhdGlvbiBhZ2FpblxuXHRcdFx0XHRzZWxmLnNlbmQuY2FsbCh0YXJnZXQsIG1ldGEsIGRhdGEpO1xuXHRcdFx0fTtcblx0XHRcdGZyLnJlYWRBc0JpbmFyeVN0cmluZyhibG9iKTtcblx0XHR9XG5cblx0XHRcblx0XHRmdW5jdGlvbiBfZ2V0TmF0aXZlWEhSKCkge1xuXHRcdFx0aWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAhKEVudi5icm93c2VyID09PSAnSUUnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCA4LCAnPCcpKSkgeyAvLyBJRTcgaGFzIG5hdGl2ZSBYSFIgYnV0IGl0J3MgYnVnZ3lcblx0XHRcdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHByb2dJRHMgPSBbJ01zeG1sMi5YTUxIVFRQLjYuMCcsICdNaWNyb3NvZnQuWE1MSFRUUCddOyAvLyBpZiA2LjAgYXZhaWxhYmxlLCB1c2UgaXQsIG90aGVyd2lzZSBmYWlsYmFjayB0byBkZWZhdWx0IDMuMFxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ0lEcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KHByb2dJRHNbaV0pO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBAY3JlZGl0cyBTZXJnZXkgSWxpbnNreVx0KGh0dHA6Ly93d3cuaWxpbnNreS5jb20vKVxuXHRcdGZ1bmN0aW9uIF9nZXREb2N1bWVudCh4aHIpIHtcblx0XHRcdHZhciByWE1MID0geGhyLnJlc3BvbnNlWE1MO1xuXHRcdFx0dmFyIHJUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdFxuXHRcdFx0Ly8gVHJ5IHBhcnNpbmcgcmVzcG9uc2VUZXh0IChAc2VlOiBodHRwOi8vd3d3LmlsaW5za3kuY29tL2FydGljbGVzL1hNTEh0dHBSZXF1ZXN0LyNidWdzLWllLXJlc3BvbnNlWE1MLWNvbnRlbnQtdHlwZSlcblx0XHRcdGlmIChFbnYuYnJvd3NlciA9PT0gJ0lFJyAmJiByVGV4dCAmJiByWE1MICYmICFyWE1MLmRvY3VtZW50RWxlbWVudCAmJiAvW15cXC9dK1xcL1teXFwrXStcXCt4bWwvLnRlc3QoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpKSkge1xuXHRcdFx0XHRyWE1MID0gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcblx0XHRcdFx0clhNTC5hc3luYyA9IGZhbHNlO1xuXHRcdFx0XHRyWE1MLnZhbGlkYXRlT25QYXJzZSA9IGZhbHNlO1xuXHRcdFx0XHRyWE1MLmxvYWRYTUwoclRleHQpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIENoZWNrIGlmIHRoZXJlIGlzIG5vIGVycm9yIGluIGRvY3VtZW50XG5cdFx0XHRpZiAoclhNTCkge1xuXHRcdFx0XHRpZiAoKEVudi5icm93c2VyID09PSAnSUUnICYmIHJYTUwucGFyc2VFcnJvciAhPT0gMCkgfHwgIXJYTUwuZG9jdW1lbnRFbGVtZW50IHx8IHJYTUwuZG9jdW1lbnRFbGVtZW50LnRhZ05hbWUgPT09IFwicGFyc2VyZXJyb3JcIikge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gclhNTDtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9wcmVwYXJlTXVsdGlwYXJ0KGZkKSB7XG5cdFx0XHR2YXIgYm91bmRhcnkgPSAnLS0tLW1veGllYm91bmRhcnknICsgbmV3IERhdGUoKS5nZXRUaW1lKClcblx0XHRcdCwgZGFzaGRhc2ggPSAnLS0nXG5cdFx0XHQsIGNybGYgPSAnXFxyXFxuJ1xuXHRcdFx0LCBtdWx0aXBhcnQgPSAnJ1xuXHRcdFx0LCBJID0gdGhpcy5nZXRSdW50aW1lKClcblx0XHRcdDtcblxuXHRcdFx0aWYgKCFJLmNhbignc2VuZF9iaW5hcnlfc3RyaW5nJykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IHguUnVudGltZUVycm9yKHguUnVudGltZUVycm9yLk5PVF9TVVBQT1JURURfRVJSKTtcblx0XHRcdH1cblxuXHRcdFx0X3hoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIGJvdW5kYXJ5KTtcblxuXHRcdFx0Ly8gYXBwZW5kIG11bHRpcGFydCBwYXJhbWV0ZXJzXG5cdFx0XHRmZC5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdC8vIEZpcmVmb3ggMy42IGZhaWxlZCB0byBjb252ZXJ0IG11bHRpYnl0ZSBjaGFyYWN0ZXJzIHRvIFVURi04IGluIHNlbmRBc0JpbmFyeSgpLCBcblx0XHRcdFx0Ly8gc28gd2UgdHJ5IGl0IGhlcmUgb3Vyc2VsdmVzIHdpdGg6IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG5cdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHQvLyBCdWlsZCBSRkMyMzg4IGJsb2Jcblx0XHRcdFx0XHRtdWx0aXBhcnQgKz0gZGFzaGRhc2ggKyBib3VuZGFyeSArIGNybGYgK1xuXHRcdFx0XHRcdFx0J0NvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIicgKyBuYW1lICsgJ1wiOyBmaWxlbmFtZT1cIicgKyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodmFsdWUubmFtZSB8fCAnYmxvYicpKSArICdcIicgKyBjcmxmICtcblx0XHRcdFx0XHRcdCdDb250ZW50LVR5cGU6ICcgKyAodmFsdWUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykgKyBjcmxmICsgY3JsZiArXG5cdFx0XHRcdFx0XHR2YWx1ZS5nZXRTb3VyY2UoKSArIGNybGY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bXVsdGlwYXJ0ICs9IGRhc2hkYXNoICsgYm91bmRhcnkgKyBjcmxmICtcblx0XHRcdFx0XHRcdCdDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCInICsgbmFtZSArICdcIicgKyBjcmxmICsgY3JsZiArXG5cdFx0XHRcdFx0XHR1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSArIGNybGY7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRtdWx0aXBhcnQgKz0gZGFzaGRhc2ggKyBib3VuZGFyeSArIGRhc2hkYXNoICsgY3JsZjtcblxuXHRcdFx0cmV0dXJuIG11bHRpcGFydDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdCk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS91dGlscy9CaW5hcnlSZWFkZXIuanNcblxuLyoqXG4gKiBCaW5hcnlSZWFkZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS91dGlscy9CaW5hcnlSZWFkZXJcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS91dGlscy9CaW5hcnlSZWFkZXJcIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIlxuXSwgZnVuY3Rpb24oQmFzaWMpIHtcblxuXHRcblx0ZnVuY3Rpb24gQmluYXJ5UmVhZGVyKGRhdGEpIHtcblx0XHRpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHRBcnJheUJ1ZmZlclJlYWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRVVEYxNlN0cmluZ1JlYWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fVxuXG5cdEJhc2ljLmV4dGVuZChCaW5hcnlSZWFkZXIucHJvdG90eXBlLCB7XG5cdFx0XG5cdFx0bGl0dGxlRW5kaWFuOiBmYWxzZSxcblxuXG5cdFx0cmVhZDogZnVuY3Rpb24oaWR4LCBzaXplKSB7XG5cdFx0XHR2YXIgc3VtLCBtdiwgaTtcblxuXHRcdFx0aWYgKGlkeCArIHNpemUgPiB0aGlzLmxlbmd0aCgpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgb3V0c2lkZSB0aGUgc291cmNlIGJvdW5kYXJpZXMuXCIpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRtdiA9IHRoaXMubGl0dGxlRW5kaWFuIFxuXHRcdFx0XHQ/IDAgXG5cdFx0XHRcdDogLTggKiAoc2l6ZSAtIDEpXG5cdFx0XHQ7XG5cblx0XHRcdGZvciAoaSA9IDAsIHN1bSA9IDA7IGkgPCBzaXplOyBpKyspIHtcblx0XHRcdFx0c3VtIHw9ICh0aGlzLnJlYWRCeXRlQXQoaWR4ICsgaSkgPDwgTWF0aC5hYnMobXYgKyBpKjgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdW07XG5cdFx0fSxcblxuXG5cdFx0d3JpdGU6IGZ1bmN0aW9uKGlkeCwgbnVtLCBzaXplKSB7XG5cdFx0XHR2YXIgbXYsIGksIHN0ciA9ICcnO1xuXG5cdFx0XHRpZiAoaWR4ID4gdGhpcy5sZW5ndGgoKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIHRyeWluZyB0byB3cml0ZSBvdXRzaWRlIHRoZSBzb3VyY2UgYm91bmRhcmllcy5cIik7XG5cdFx0XHR9XG5cblx0XHRcdG12ID0gdGhpcy5saXR0bGVFbmRpYW4gXG5cdFx0XHRcdD8gMCBcblx0XHRcdFx0OiAtOCAqIChzaXplIC0gMSlcblx0XHRcdDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuXHRcdFx0XHR0aGlzLndyaXRlQnl0ZUF0KGlkeCArIGksIChudW0gPj4gTWF0aC5hYnMobXYgKyBpKjgpKSAmIDI1NSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXG5cdFx0QllURTogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkKGlkeCwgMSk7XG5cdFx0fSxcblxuXG5cdFx0U0hPUlQ6IGZ1bmN0aW9uKGlkeCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVhZChpZHgsIDIpO1xuXHRcdH0sXG5cblxuXHRcdExPTkc6IGZ1bmN0aW9uKGlkeCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVhZChpZHgsIDQpO1xuXHRcdH0sXG5cblxuXHRcdFNMT05HOiBmdW5jdGlvbihpZHgpIHsgLy8gMidzIGNvbXBsZW1lbnQgbm90YXRpb25cblx0XHRcdHZhciBudW0gPSB0aGlzLnJlYWQoaWR4LCA0KTtcblx0XHRcdHJldHVybiAobnVtID4gMjE0NzQ4MzY0NyA/IG51bSAtIDQyOTQ5NjcyOTYgOiBudW0pO1xuXHRcdH0sXG5cblxuXHRcdENIQVI6IGZ1bmN0aW9uKGlkeCkge1xuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkKGlkeCwgMSkpO1xuXHRcdH0sXG5cblxuXHRcdFNUUklORzogZnVuY3Rpb24oaWR4LCBjb3VudCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXNBcnJheSgnQ0hBUicsIGlkeCwgY291bnQpLmpvaW4oJycpO1xuXHRcdH0sXG5cblxuXHRcdGFzQXJyYXk6IGZ1bmN0aW9uKHR5cGUsIGlkeCwgY291bnQpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhbHVlc1tpXSA9IHRoaXNbdHlwZV0oaWR4ICsgaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdH1cblx0fSk7XG5cblxuXHRmdW5jdGlvbiBBcnJheUJ1ZmZlclJlYWRlcihkYXRhKSB7XG5cdFx0dmFyIF9kdiA9IG5ldyBEYXRhVmlldyhkYXRhKTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRcblx0XHRcdHJlYWRCeXRlQXQ6IGZ1bmN0aW9uKGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gX2R2LmdldFVpbnQ4KGlkeCk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdHdyaXRlQnl0ZUF0OiBmdW5jdGlvbihpZHgsIHZhbHVlKSB7XG5cdFx0XHRcdF9kdi5zZXRVaW50OChpZHgsIHZhbHVlKTtcblx0XHRcdH0sXG5cdFx0XHRcblxuXHRcdFx0U0VHTUVOVDogZnVuY3Rpb24oaWR4LCBzaXplLCB2YWx1ZSkge1xuXHRcdFx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YS5zbGljZShpZHgsIGlkeCArIHNpemUpO1xuXG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGEuc2xpY2UoaWR4KTtcblxuXHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcigpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1x0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0dmFyIGFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgLSBzaXplICsgdmFsdWUuYnl0ZUxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdGlmIChpZHggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXJyLnNldChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIGlkeCkpLCAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRhcnIuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgaWR4KTtcblx0XHRcdFx0XHRcdFx0YXJyLnNldChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKGlkeCArIHNpemUpKSwgaWR4ICsgdmFsdWUuYnl0ZUxlbmd0aCk7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5jbGVhcigpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gYXJyLmJ1ZmZlcjtcblx0XHRcdFx0XHRcdFx0X2R2ID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlZmF1bHQ6IHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdGxlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhID8gZGF0YS5ieXRlTGVuZ3RoIDogMDtcblx0XHRcdH0sXG5cblxuXHRcdFx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfZHYgPSBkYXRhID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gVVRGMTZTdHJpbmdSZWFkZXIoZGF0YSkge1xuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRcblx0XHRcdHJlYWRCeXRlQXQ6IGZ1bmN0aW9uKGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YS5jaGFyQ29kZUF0KGlkeCk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdHdyaXRlQnl0ZUF0OiBmdW5jdGlvbihpZHgsIHZhbHVlKSB7XG5cdFx0XHRcdHB1dHN0cihTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlKSwgaWR4LCAxKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0U0VHTUVOVDogZnVuY3Rpb24oaWR4LCBsZW5ndGgsIHNlZ21lbnQpIHtcblx0XHRcdFx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGEuc3Vic3RyKGlkeCk7XG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGEuc3Vic3RyKGlkeCwgbGVuZ3RoKTtcblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRwdXRzdHIoc2VnbWVudCAhPT0gbnVsbCA/IHNlZ21lbnQgOiAnJywgaWR4LCBsZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblxuXHRcdFx0bGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGEgPyBkYXRhLmxlbmd0aCA6IDA7XG5cdFx0XHR9LCBcblxuXHRcdFx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXG5cdFx0ZnVuY3Rpb24gcHV0c3RyKHNlZ21lbnQsIGlkeCwgbGVuZ3RoKSB7XG5cdFx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gbGVuZ3RoIDogZGF0YS5sZW5ndGggLSBpZHggLSAxO1xuXHRcdFx0ZGF0YSA9IGRhdGEuc3Vic3RyKDAsIGlkeCkgKyBzZWdtZW50ICsgZGF0YS5zdWJzdHIobGVuZ3RoICsgaWR4KTtcblx0XHR9XG5cdH1cblxuXG5cdHJldHVybiBCaW5hcnlSZWFkZXI7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS9pbWFnZS9KUEVHSGVhZGVycy5qc1xuXG4vKipcbiAqIEpQRUdIZWFkZXJzLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG4gXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0pQRUdIZWFkZXJzXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSlBFR0hlYWRlcnNcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvdXRpbHMvQmluYXJ5UmVhZGVyXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCJcbl0sIGZ1bmN0aW9uKEJpbmFyeVJlYWRlciwgeCkge1xuXHRcblx0cmV0dXJuIGZ1bmN0aW9uIEpQRUdIZWFkZXJzKGRhdGEpIHtcblx0XHR2YXIgaGVhZGVycyA9IFtdLCBfYnIsIGlkeCwgbWFya2VyLCBsZW5ndGggPSAwO1xuXG5cdFx0X2JyID0gbmV3IEJpbmFyeVJlYWRlcihkYXRhKTtcblxuXHRcdC8vIENoZWNrIGlmIGRhdGEgaXMganBlZ1xuXHRcdGlmIChfYnIuU0hPUlQoMCkgIT09IDB4RkZEOCkge1xuXHRcdFx0X2JyLmNsZWFyKCk7XG5cdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdH1cblxuXHRcdGlkeCA9IDI7XG5cblx0XHR3aGlsZSAoaWR4IDw9IF9ici5sZW5ndGgoKSkge1xuXHRcdFx0bWFya2VyID0gX2JyLlNIT1JUKGlkeCk7XG5cblx0XHRcdC8vIG9taXQgUlNUIChyZXN0YXJ0KSBtYXJrZXJzXG5cdFx0XHRpZiAobWFya2VyID49IDB4RkZEMCAmJiBtYXJrZXIgPD0gMHhGRkQ3KSB7XG5cdFx0XHRcdGlkeCArPSAyO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm8gaGVhZGVycyBhbGxvd2VkIGFmdGVyIFNPUyBtYXJrZXJcblx0XHRcdGlmIChtYXJrZXIgPT09IDB4RkZEQSB8fCBtYXJrZXIgPT09IDB4RkZEOSkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0bGVuZ3RoID0gX2JyLlNIT1JUKGlkeCArIDIpICsgMjtcblxuXHRcdFx0Ly8gQVBQbiBtYXJrZXIgZGV0ZWN0ZWRcblx0XHRcdGlmIChtYXJrZXIgPj0gMHhGRkUxICYmIG1hcmtlciA8PSAweEZGRUYpIHtcblx0XHRcdFx0aGVhZGVycy5wdXNoKHtcblx0XHRcdFx0XHRoZXg6IG1hcmtlcixcblx0XHRcdFx0XHRuYW1lOiAnQVBQJyArIChtYXJrZXIgJiAweDAwMEYpLFxuXHRcdFx0XHRcdHN0YXJ0OiBpZHgsXG5cdFx0XHRcdFx0bGVuZ3RoOiBsZW5ndGgsXG5cdFx0XHRcdFx0c2VnbWVudDogX2JyLlNFR01FTlQoaWR4LCBsZW5ndGgpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZHggKz0gbGVuZ3RoO1xuXHRcdH1cblxuXHRcdF9ici5jbGVhcigpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlYWRlcnM6IGhlYWRlcnMsXG5cblx0XHRcdHJlc3RvcmU6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0dmFyIG1heCwgaSwgYnI7XG5cblx0XHRcdFx0YnIgPSBuZXcgQmluYXJ5UmVhZGVyKGRhdGEpO1xuXG5cdFx0XHRcdGlkeCA9IGJyLlNIT1JUKDIpID09IDB4RkZFMCA/IDQgKyBici5TSE9SVCg0KSA6IDI7XG5cblx0XHRcdFx0Zm9yIChpID0gMCwgbWF4ID0gaGVhZGVycy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdGJyLlNFR01FTlQoaWR4LCAwLCBoZWFkZXJzW2ldLnNlZ21lbnQpO1xuXHRcdFx0XHRcdGlkeCArPSBoZWFkZXJzW2ldLmxlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRhdGEgPSBici5TRUdNRU5UKCk7XG5cdFx0XHRcdGJyLmNsZWFyKCk7XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fSxcblxuXHRcdFx0c3RyaXA6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0dmFyIGJyLCBoZWFkZXJzLCBqcGVnSGVhZGVycywgaTtcblxuXHRcdFx0XHRqcGVnSGVhZGVycyA9IG5ldyBKUEVHSGVhZGVycyhkYXRhKTtcblx0XHRcdFx0aGVhZGVycyA9IGpwZWdIZWFkZXJzLmhlYWRlcnM7XG5cdFx0XHRcdGpwZWdIZWFkZXJzLnB1cmdlKCk7XG5cblx0XHRcdFx0YnIgPSBuZXcgQmluYXJ5UmVhZGVyKGRhdGEpO1xuXG5cdFx0XHRcdGkgPSBoZWFkZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGJyLlNFR01FTlQoaGVhZGVyc1tpXS5zdGFydCwgaGVhZGVyc1tpXS5sZW5ndGgsICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0ZGF0YSA9IGJyLlNFR01FTlQoKTtcblx0XHRcdFx0YnIuY2xlYXIoKTtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG1heCA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyc1tpXS5uYW1lID09PSBuYW1lLnRvVXBwZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRcdGFycmF5LnB1c2goaGVhZGVyc1tpXS5zZWdtZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbihuYW1lLCBzZWdtZW50KSB7XG5cdFx0XHRcdHZhciBhcnJheSA9IFtdLCBpLCBpaSwgbWF4O1xuXG5cdFx0XHRcdGlmICh0eXBlb2Yoc2VnbWVudCkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0YXJyYXkucHVzaChzZWdtZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcnJheSA9IHNlZ21lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSBpaSA9IDAsIG1heCA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyc1tpXS5uYW1lID09PSBuYW1lLnRvVXBwZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRcdGhlYWRlcnNbaV0uc2VnbWVudCA9IGFycmF5W2lpXTtcblx0XHRcdFx0XHRcdGhlYWRlcnNbaV0ubGVuZ3RoID0gYXJyYXlbaWldLmxlbmd0aDtcblx0XHRcdFx0XHRcdGlpKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpaSA+PSBhcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0cHVyZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzID0gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ltYWdlL0V4aWZQYXJzZXIuanNcblxuLyoqXG4gKiBFeGlmUGFyc2VyLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvRXhpZlBhcnNlclxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0V4aWZQYXJzZXJcIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L3V0aWxzL0JpbmFyeVJlYWRlclwiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiXG5dLCBmdW5jdGlvbihCYXNpYywgQmluYXJ5UmVhZGVyLCB4KSB7XG5cdFxuXHRmdW5jdGlvbiBFeGlmUGFyc2VyKGRhdGEpIHtcblx0XHR2YXIgX19zdXBlcl9fLCB0YWdzLCB0YWdEZXNjcywgb2Zmc2V0cywgaWR4LCBUaWZmO1xuXHRcdFxuXHRcdEJpbmFyeVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xuXG5cdFx0dGFncyA9IHtcblx0XHRcdHRpZmY6IHtcblx0XHRcdFx0Lypcblx0XHRcdFx0VGhlIGltYWdlIG9yaWVudGF0aW9uIHZpZXdlZCBpbiB0ZXJtcyBvZiByb3dzIGFuZCBjb2x1bW5zLlxuXG5cdFx0XHRcdDEgPSBUaGUgMHRoIHJvdyBpcyBhdCB0aGUgdmlzdWFsIHRvcCBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIGxlZnQtaGFuZCBzaWRlLlxuXHRcdFx0XHQyID0gVGhlIDB0aCByb3cgaXMgYXQgdGhlIHZpc3VhbCB0b3Agb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCByaWdodC1oYW5kIHNpZGUuXG5cdFx0XHRcdDMgPSBUaGUgMHRoIHJvdyBpcyBhdCB0aGUgdmlzdWFsIGJvdHRvbSBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIHJpZ2h0LWhhbmQgc2lkZS5cblx0XHRcdFx0NCA9IFRoZSAwdGggcm93IGlzIGF0IHRoZSB2aXN1YWwgYm90dG9tIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgbGVmdC1oYW5kIHNpZGUuXG5cdFx0XHRcdDUgPSBUaGUgMHRoIHJvdyBpcyB0aGUgdmlzdWFsIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgdG9wLlxuXHRcdFx0XHQ2ID0gVGhlIDB0aCByb3cgaXMgdGhlIHZpc3VhbCByaWdodC1oYW5kIHNpZGUgb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCB0b3AuXG5cdFx0XHRcdDcgPSBUaGUgMHRoIHJvdyBpcyB0aGUgdmlzdWFsIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIGJvdHRvbS5cblx0XHRcdFx0OCA9IFRoZSAwdGggcm93IGlzIHRoZSB2aXN1YWwgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCBib3R0b20uXG5cdFx0XHRcdCovXG5cdFx0XHRcdDB4MDExMjogJ09yaWVudGF0aW9uJyxcblx0XHRcdFx0MHgwMTBFOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG5cdFx0XHRcdDB4MDEwRjogJ01ha2UnLFxuXHRcdFx0XHQweDAxMTA6ICdNb2RlbCcsXG5cdFx0XHRcdDB4MDEzMTogJ1NvZnR3YXJlJyxcblx0XHRcdFx0MHg4NzY5OiAnRXhpZklGRFBvaW50ZXInLFxuXHRcdFx0XHQweDg4MjU6XHQnR1BTSW5mb0lGRFBvaW50ZXInXG5cdFx0XHR9LFxuXHRcdFx0ZXhpZjoge1xuXHRcdFx0XHQweDkwMDA6ICdFeGlmVmVyc2lvbicsXG5cdFx0XHRcdDB4QTAwMTogJ0NvbG9yU3BhY2UnLFxuXHRcdFx0XHQweEEwMDI6ICdQaXhlbFhEaW1lbnNpb24nLFxuXHRcdFx0XHQweEEwMDM6ICdQaXhlbFlEaW1lbnNpb24nLFxuXHRcdFx0XHQweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJyxcblx0XHRcdFx0MHg4MjlBOiAnRXhwb3N1cmVUaW1lJyxcblx0XHRcdFx0MHg4MjlEOiAnRk51bWJlcicsXG5cdFx0XHRcdDB4ODgyNzogJ0lTT1NwZWVkUmF0aW5ncycsXG5cdFx0XHRcdDB4OTIwMTogJ1NodXR0ZXJTcGVlZFZhbHVlJyxcblx0XHRcdFx0MHg5MjAyOiAnQXBlcnR1cmVWYWx1ZSdcdCxcblx0XHRcdFx0MHg5MjA3OiAnTWV0ZXJpbmdNb2RlJyxcblx0XHRcdFx0MHg5MjA4OiAnTGlnaHRTb3VyY2UnLFxuXHRcdFx0XHQweDkyMDk6ICdGbGFzaCcsXG5cdFx0XHRcdDB4OTIwQTogJ0ZvY2FsTGVuZ3RoJyxcblx0XHRcdFx0MHhBNDAyOiAnRXhwb3N1cmVNb2RlJyxcblx0XHRcdFx0MHhBNDAzOiAnV2hpdGVCYWxhbmNlJyxcblx0XHRcdFx0MHhBNDA2OiAnU2NlbmVDYXB0dXJlVHlwZScsXG5cdFx0XHRcdDB4QTQwNDogJ0RpZ2l0YWxab29tUmF0aW8nLFxuXHRcdFx0XHQweEE0MDg6ICdDb250cmFzdCcsXG5cdFx0XHRcdDB4QTQwOTogJ1NhdHVyYXRpb24nLFxuXHRcdFx0XHQweEE0MEE6ICdTaGFycG5lc3MnXG5cdFx0XHR9LFxuXHRcdFx0Z3BzOiB7XG5cdFx0XHRcdDB4MDAwMDogJ0dQU1ZlcnNpb25JRCcsXG5cdFx0XHRcdDB4MDAwMTogJ0dQU0xhdGl0dWRlUmVmJyxcblx0XHRcdFx0MHgwMDAyOiAnR1BTTGF0aXR1ZGUnLFxuXHRcdFx0XHQweDAwMDM6ICdHUFNMb25naXR1ZGVSZWYnLFxuXHRcdFx0XHQweDAwMDQ6ICdHUFNMb25naXR1ZGUnXG5cdFx0XHR9LFxuXG5cdFx0XHR0aHVtYjoge1xuXHRcdFx0XHQweDAyMDE6ICdKUEVHSW50ZXJjaGFuZ2VGb3JtYXQnLFxuXHRcdFx0XHQweDAyMDI6ICdKUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGgnXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRhZ0Rlc2NzID0ge1xuXHRcdFx0J0NvbG9yU3BhY2UnOiB7XG5cdFx0XHRcdDE6ICdzUkdCJyxcblx0XHRcdFx0MDogJ1VuY2FsaWJyYXRlZCdcblx0XHRcdH0sXG5cblx0XHRcdCdNZXRlcmluZ01vZGUnOiB7XG5cdFx0XHRcdDA6ICdVbmtub3duJyxcblx0XHRcdFx0MTogJ0F2ZXJhZ2UnLFxuXHRcdFx0XHQyOiAnQ2VudGVyV2VpZ2h0ZWRBdmVyYWdlJyxcblx0XHRcdFx0MzogJ1Nwb3QnLFxuXHRcdFx0XHQ0OiAnTXVsdGlTcG90Jyxcblx0XHRcdFx0NTogJ1BhdHRlcm4nLFxuXHRcdFx0XHQ2OiAnUGFydGlhbCcsXG5cdFx0XHRcdDI1NTogJ090aGVyJ1xuXHRcdFx0fSxcblxuXHRcdFx0J0xpZ2h0U291cmNlJzoge1xuXHRcdFx0XHQxOiAnRGF5bGlnaHQnLFxuXHRcdFx0XHQyOiAnRmxpb3Jlc2NlbnQnLFxuXHRcdFx0XHQzOiAnVHVuZ3N0ZW4nLFxuXHRcdFx0XHQ0OiAnRmxhc2gnLFxuXHRcdFx0XHQ5OiAnRmluZSB3ZWF0aGVyJyxcblx0XHRcdFx0MTA6ICdDbG91ZHkgd2VhdGhlcicsXG5cdFx0XHRcdDExOiAnU2hhZGUnLFxuXHRcdFx0XHQxMjogJ0RheWxpZ2h0IGZsdW9yZXNjZW50IChEIDU3MDAgLSA3MTAwSyknLFxuXHRcdFx0XHQxMzogJ0RheSB3aGl0ZSBmbHVvcmVzY2VudCAoTiA0NjAwIC01NDAwSyknLFxuXHRcdFx0XHQxNDogJ0Nvb2wgd2hpdGUgZmx1b3Jlc2NlbnQgKFcgMzkwMCAtIDQ1MDBLKScsXG5cdFx0XHRcdDE1OiAnV2hpdGUgZmx1b3Jlc2NlbnQgKFdXIDMyMDAgLSAzNzAwSyknLFxuXHRcdFx0XHQxNzogJ1N0YW5kYXJkIGxpZ2h0IEEnLFxuXHRcdFx0XHQxODogJ1N0YW5kYXJkIGxpZ2h0IEInLFxuXHRcdFx0XHQxOTogJ1N0YW5kYXJkIGxpZ2h0IEMnLFxuXHRcdFx0XHQyMDogJ0Q1NScsXG5cdFx0XHRcdDIxOiAnRDY1Jyxcblx0XHRcdFx0MjI6ICdENzUnLFxuXHRcdFx0XHQyMzogJ0Q1MCcsXG5cdFx0XHRcdDI0OiAnSVNPIHN0dWRpbyB0dW5nc3RlbicsXG5cdFx0XHRcdDI1NTogJ090aGVyJ1xuXHRcdFx0fSxcblxuXHRcdFx0J0ZsYXNoJzoge1xuXHRcdFx0XHQweDAwMDA6ICdGbGFzaCBkaWQgbm90IGZpcmUnLFxuXHRcdFx0XHQweDAwMDE6ICdGbGFzaCBmaXJlZCcsXG5cdFx0XHRcdDB4MDAwNTogJ1N0cm9iZSByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDA3OiAnU3Ryb2JlIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG5cdFx0XHRcdDB4MDAwOTogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUnLFxuXHRcdFx0XHQweDAwMEQ6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDBGOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDEwOiAnRmxhc2ggZGlkIG5vdCBmaXJlLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUnLFxuXHRcdFx0XHQweDAwMTg6ICdGbGFzaCBkaWQgbm90IGZpcmUsIGF1dG8gbW9kZScsXG5cdFx0XHRcdDB4MDAxOTogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUnLFxuXHRcdFx0XHQweDAwMUQ6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDFGOiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDIwOiAnTm8gZmxhc2ggZnVuY3Rpb24nLFxuXHRcdFx0XHQweDAwNDE6ICdGbGFzaCBmaXJlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG5cdFx0XHRcdDB4MDA0NTogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDQ3OiAnRmxhc2ggZmlyZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG5cdFx0XHRcdDB4MDA0OTogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnLFxuXHRcdFx0XHQweDAwNEQ6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDRGOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDU5OiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG5cdFx0XHRcdDB4MDA1RDogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnLFxuXHRcdFx0XHQweDAwNUY6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnXG5cdFx0XHR9LFxuXG5cdFx0XHQnRXhwb3N1cmVNb2RlJzoge1xuXHRcdFx0XHQwOiAnQXV0byBleHBvc3VyZScsXG5cdFx0XHRcdDE6ICdNYW51YWwgZXhwb3N1cmUnLFxuXHRcdFx0XHQyOiAnQXV0byBicmFja2V0J1xuXHRcdFx0fSxcblxuXHRcdFx0J1doaXRlQmFsYW5jZSc6IHtcblx0XHRcdFx0MDogJ0F1dG8gd2hpdGUgYmFsYW5jZScsXG5cdFx0XHRcdDE6ICdNYW51YWwgd2hpdGUgYmFsYW5jZSdcblx0XHRcdH0sXG5cblx0XHRcdCdTY2VuZUNhcHR1cmVUeXBlJzoge1xuXHRcdFx0XHQwOiAnU3RhbmRhcmQnLFxuXHRcdFx0XHQxOiAnTGFuZHNjYXBlJyxcblx0XHRcdFx0MjogJ1BvcnRyYWl0Jyxcblx0XHRcdFx0MzogJ05pZ2h0IHNjZW5lJ1xuXHRcdFx0fSxcblxuXHRcdFx0J0NvbnRyYXN0Jzoge1xuXHRcdFx0XHQwOiAnTm9ybWFsJyxcblx0XHRcdFx0MTogJ1NvZnQnLFxuXHRcdFx0XHQyOiAnSGFyZCdcblx0XHRcdH0sXG5cblx0XHRcdCdTYXR1cmF0aW9uJzoge1xuXHRcdFx0XHQwOiAnTm9ybWFsJyxcblx0XHRcdFx0MTogJ0xvdyBzYXR1cmF0aW9uJyxcblx0XHRcdFx0MjogJ0hpZ2ggc2F0dXJhdGlvbidcblx0XHRcdH0sXG5cblx0XHRcdCdTaGFycG5lc3MnOiB7XG5cdFx0XHRcdDA6ICdOb3JtYWwnLFxuXHRcdFx0XHQxOiAnU29mdCcsXG5cdFx0XHRcdDI6ICdIYXJkJ1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gR1BTIHJlbGF0ZWRcblx0XHRcdCdHUFNMYXRpdHVkZVJlZic6IHtcblx0XHRcdFx0TjogJ05vcnRoIGxhdGl0dWRlJyxcblx0XHRcdFx0UzogJ1NvdXRoIGxhdGl0dWRlJ1xuXHRcdFx0fSxcblxuXHRcdFx0J0dQU0xvbmdpdHVkZVJlZic6IHtcblx0XHRcdFx0RTogJ0Vhc3QgbG9uZ2l0dWRlJyxcblx0XHRcdFx0VzogJ1dlc3QgbG9uZ2l0dWRlJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRvZmZzZXRzID0ge1xuXHRcdFx0dGlmZkhlYWRlcjogMTBcblx0XHR9O1xuXHRcdFxuXHRcdGlkeCA9IG9mZnNldHMudGlmZkhlYWRlcjtcblxuXHRcdF9fc3VwZXJfXyA9IHtcblx0XHRcdGNsZWFyOiB0aGlzLmNsZWFyXG5cdFx0fTtcblxuXHRcdC8vIFB1YmxpYyBmdW5jdGlvbnNcblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0XG5cdFx0XHRyZWFkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gRXhpZlBhcnNlci5wcm90b3R5cGUucmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLklOVkFMSURfTUVUQV9FUlIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdHdyaXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gRXhpZlBhcnNlci5wcm90b3R5cGUud3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5JTlZBTElEX01FVEFfRVJSKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXG5cdFx0XHRVTkRFRklORUQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5CWVRFLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdFJBVElPTkFMOiBmdW5jdGlvbihpZHgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuTE9ORyhpZHgpIC8gdGhpcy5MT05HKGlkeCArIDQpXG5cdFx0XHR9LFxuXG5cblx0XHRcdFNSQVRJT05BTDogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLlNMT05HKGlkeCkgLyB0aGlzLlNMT05HKGlkeCArIDQpXG5cdFx0XHR9LFxuXG5cdFx0XHRBU0NJSTogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLkNIQVIoaWR4KTtcblx0XHRcdH0sXG5cblx0XHRcdFRJRkY6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gVGlmZiB8fCBudWxsO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRFWElGOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIEV4aWYgPSBudWxsO1xuXG5cdFx0XHRcdGlmIChvZmZzZXRzLmV4aWZJRkQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0RXhpZiA9IGV4dHJhY3RUYWdzLmNhbGwodGhpcywgb2Zmc2V0cy5leGlmSUZELCB0YWdzLmV4aWYpO1xuXHRcdFx0XHRcdH0gY2F0Y2goZXgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZpeCBmb3JtYXR0aW5nIG9mIHNvbWUgdGFnc1xuXHRcdFx0XHRcdGlmIChFeGlmLkV4aWZWZXJzaW9uICYmIEJhc2ljLnR5cGVPZihFeGlmLkV4aWZWZXJzaW9uKSA9PT0gJ2FycmF5Jykge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGV4aWZWZXJzaW9uID0gJyc7IGkgPCBFeGlmLkV4aWZWZXJzaW9uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGV4aWZWZXJzaW9uICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoRXhpZi5FeGlmVmVyc2lvbltpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRFeGlmLkV4aWZWZXJzaW9uID0gZXhpZlZlcnNpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIEV4aWY7XG5cdFx0XHR9LFxuXG5cblx0XHRcdEdQUzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBHUFMgPSBudWxsO1xuXG5cdFx0XHRcdGlmIChvZmZzZXRzLmdwc0lGRCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRHUFMgPSBleHRyYWN0VGFncy5jYWxsKHRoaXMsIG9mZnNldHMuZ3BzSUZELCB0YWdzLmdwcyk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlPUyBkZXZpY2VzIChhbmQgcHJvYmFibHkgc29tZSBvdGhlcnMpIGRvIG5vdCBwdXQgaW4gR1BTVmVyc2lvbklEIHRhZyAod2h5Py4uKVxuXHRcdFx0XHRcdGlmIChHUFMuR1BTVmVyc2lvbklEICYmIEJhc2ljLnR5cGVPZihHUFMuR1BTVmVyc2lvbklEKSA9PT0gJ2FycmF5Jykge1xuXHRcdFx0XHRcdFx0R1BTLkdQU1ZlcnNpb25JRCA9IEdQUy5HUFNWZXJzaW9uSUQuam9pbignLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBHUFM7XG5cdFx0XHR9LFxuXG5cblx0XHRcdHRodW1iOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKG9mZnNldHMuSUZEMSkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgSUZEMVRhZ3MgPSBleHRyYWN0VGFncy5jYWxsKHRoaXMsIG9mZnNldHMuSUZEMSwgdGFncy50aHVtYik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICgnSlBFR0ludGVyY2hhbmdlRm9ybWF0JyBpbiBJRkQxVGFncykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5TRUdNRU5UKG9mZnNldHMudGlmZkhlYWRlciArIElGRDFUYWdzLkpQRUdJbnRlcmNoYW5nZUZvcm1hdCwgSUZEMVRhZ3MuSlBFR0ludGVyY2hhbmdlRm9ybWF0TGVuZ3RoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoIChleCkge31cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cblxuXHRcdFx0c2V0RXhpZjogZnVuY3Rpb24odGFnLCB2YWx1ZSkge1xuXHRcdFx0XHQvLyBSaWdodCBub3cgb25seSBzZXR0aW5nIG9mIHdpZHRoL2hlaWdodCBpcyBwb3NzaWJsZVxuXHRcdFx0XHRpZiAodGFnICE9PSAnUGl4ZWxYRGltZW5zaW9uJyAmJiB0YWcgIT09ICdQaXhlbFlEaW1lbnNpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0XHRcdHJldHVybiBzZXRUYWcuY2FsbCh0aGlzLCAnZXhpZicsIHRhZywgdmFsdWUpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9fc3VwZXJfXy5jbGVhcigpO1xuXHRcdFx0XHRkYXRhID0gdGFncyA9IHRhZ0Rlc2NzID0gVGlmZiA9IG9mZnNldHMgPSBfX3N1cGVyX18gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHQvLyBDaGVjayBpZiB0aGF0J3MgQVBQMSBhbmQgdGhhdCBpdCBoYXMgRVhJRlxuXHRcdGlmICh0aGlzLlNIT1JUKDApICE9PSAweEZGRTEgfHwgdGhpcy5TVFJJTkcoNCwgNSkudG9VcHBlckNhc2UoKSAhPT0gXCJFWElGXFwwXCIpIHtcblx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLklOVkFMSURfTUVUQV9FUlIpO1xuXHRcdH1cblxuXHRcdC8vIFNldCByZWFkIG9yZGVyIG9mIG11bHRpLWJ5dGUgZGF0YVxuXHRcdHRoaXMubGl0dGxlRW5kaWFuID0gKHRoaXMuU0hPUlQoaWR4KSA9PSAweDQ5NDkpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgYWx3YXlzIHByZXNlbnQgYnl0ZXMgYXJlIGluZGVlZCBwcmVzZW50XG5cdFx0aWYgKHRoaXMuU0hPUlQoaWR4Kz0yKSAhPT0gMHgwMDJBKSB7XG5cdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5JTlZBTElEX01FVEFfRVJSKTtcblx0XHR9XG5cblx0XHRvZmZzZXRzLklGRDAgPSBvZmZzZXRzLnRpZmZIZWFkZXIgKyB0aGlzLkxPTkcoaWR4ICs9IDIpO1xuXHRcdFRpZmYgPSBleHRyYWN0VGFncy5jYWxsKHRoaXMsIG9mZnNldHMuSUZEMCwgdGFncy50aWZmKTtcblxuXHRcdGlmICgnRXhpZklGRFBvaW50ZXInIGluIFRpZmYpIHtcblx0XHRcdG9mZnNldHMuZXhpZklGRCA9IG9mZnNldHMudGlmZkhlYWRlciArIFRpZmYuRXhpZklGRFBvaW50ZXI7XG5cdFx0XHRkZWxldGUgVGlmZi5FeGlmSUZEUG9pbnRlcjtcblx0XHR9XG5cblx0XHRpZiAoJ0dQU0luZm9JRkRQb2ludGVyJyBpbiBUaWZmKSB7XG5cdFx0XHRvZmZzZXRzLmdwc0lGRCA9IG9mZnNldHMudGlmZkhlYWRlciArIFRpZmYuR1BTSW5mb0lGRFBvaW50ZXI7XG5cdFx0XHRkZWxldGUgVGlmZi5HUFNJbmZvSUZEUG9pbnRlcjtcblx0XHR9XG5cblx0XHRpZiAoQmFzaWMuaXNFbXB0eU9iaihUaWZmKSkge1xuXHRcdFx0VGlmZiA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZSBhIHRodW1iIGFzIHdlbGxcblx0XHR2YXIgSUZEMU9mZnNldCA9IHRoaXMuTE9ORyhvZmZzZXRzLklGRDAgKyB0aGlzLlNIT1JUKG9mZnNldHMuSUZEMCkgKiAxMiArIDIpO1xuXHRcdGlmIChJRkQxT2Zmc2V0KSB7XG5cdFx0XHRvZmZzZXRzLklGRDEgPSBvZmZzZXRzLnRpZmZIZWFkZXIgKyBJRkQxT2Zmc2V0O1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFRhZ3MoSUZEX29mZnNldCwgdGFnczJleHRyYWN0KSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXM7XG5cdFx0XHR2YXIgbGVuZ3RoLCBpLCB0YWcsIHR5cGUsIGNvdW50LCBzaXplLCBvZmZzZXQsIHZhbHVlLCB2YWx1ZXMgPSBbXSwgaGFzaCA9IHt9O1xuXHRcdFx0XG5cdFx0XHR2YXIgdHlwZXMgPSB7XG5cdFx0XHRcdDEgOiAnQllURScsXG5cdFx0XHRcdDcgOiAnVU5ERUZJTkVEJyxcblx0XHRcdFx0MiA6ICdBU0NJSScsXG5cdFx0XHRcdDMgOiAnU0hPUlQnLFxuXHRcdFx0XHQ0IDogJ0xPTkcnLFxuXHRcdFx0XHQ1IDogJ1JBVElPTkFMJyxcblx0XHRcdFx0OSA6ICdTTE9ORycsXG5cdFx0XHRcdDEwOiAnU1JBVElPTkFMJ1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHNpemVzID0ge1xuXHRcdFx0XHQnQllURScgXHRcdDogMSxcblx0XHRcdFx0J1VOREVGSU5FRCdcdDogMSxcblx0XHRcdFx0J0FTQ0lJJ1x0XHQ6IDEsXG5cdFx0XHRcdCdTSE9SVCdcdFx0OiAyLFxuXHRcdFx0XHQnTE9ORycgXHRcdDogNCxcblx0XHRcdFx0J1JBVElPTkFMJyBcdDogOCxcblx0XHRcdFx0J1NMT05HJ1x0XHQ6IDQsXG5cdFx0XHRcdCdTUkFUSU9OQUwnXHQ6IDhcblx0XHRcdH07XG5cblx0XHRcdGxlbmd0aCA9IGRhdGEuU0hPUlQoSUZEX29mZnNldCk7XG5cblx0XHRcdC8vIFRoZSBzaXplIG9mIEFQUDEgaW5jbHVkaW5nIGFsbCB0aGVzZSBlbGVtZW50cyBzaGFsbCBub3QgZXhjZWVkIHRoZSA2NCBLYnl0ZXMgc3BlY2lmaWVkIGluIHRoZSBKUEVHIHN0YW5kYXJkLlxuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFsdWVzID0gW107XG5cblx0XHRcdFx0Ly8gU2V0IGJpbmFyeSByZWFkZXIgcG9pbnRlciB0byBiZWdpbm5pbmcgb2YgdGhlIG5leHQgdGFnXG5cdFx0XHRcdG9mZnNldCA9IElGRF9vZmZzZXQgKyAyICsgaSoxMjtcblxuXHRcdFx0XHR0YWcgPSB0YWdzMmV4dHJhY3RbZGF0YS5TSE9SVChvZmZzZXQpXTtcblxuXHRcdFx0XHRpZiAodGFnID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb250aW51ZTsgLy8gTm90IHRoZSB0YWcgd2UgcmVxdWVzdGVkXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0eXBlID0gdHlwZXNbZGF0YS5TSE9SVChvZmZzZXQrPTIpXTtcblx0XHRcdFx0Y291bnQgPSBkYXRhLkxPTkcob2Zmc2V0Kz0yKTtcblx0XHRcdFx0c2l6ZSA9IHNpemVzW3R5cGVdO1xuXG5cdFx0XHRcdGlmICghc2l6ZSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLklOVkFMSURfTUVUQV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0Ly8gdGFnIGNhbiBvbmx5IGZpdCA0IGJ5dGVzIG9mIGRhdGEsIGlmIGRhdGEgaXMgbGFyZ2VyIHdlIHNob3VsZCBsb29rIG91dHNpZGVcblx0XHRcdFx0aWYgKHNpemUgKiBjb3VudCA+IDQpIHtcblx0XHRcdFx0XHQvLyBpbnN0ZWFkIG9mIGRhdGEgdGFnIGNvbnRhaW5zIGFuIG9mZnNldCBvZiB0aGUgZGF0YVxuXHRcdFx0XHRcdG9mZnNldCA9IGRhdGEuTE9ORyhvZmZzZXQpICsgb2Zmc2V0cy50aWZmSGVhZGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaW4gY2FzZSB3ZSBsZWZ0IHRoZSBib3VuZGFyaWVzIG9mIGRhdGEgdGhyb3cgYW4gZWFybHkgZXhjZXB0aW9uXG5cdFx0XHRcdGlmIChvZmZzZXQgKyBzaXplICogY291bnQgPj0gdGhpcy5sZW5ndGgoKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLklOVkFMSURfTUVUQV9FUlIpO1xuXHRcdFx0XHR9IFxuXG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FyZSBmb3IgdGhlIHN0cmluZ1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ0FTQ0lJJykge1xuXHRcdFx0XHRcdGhhc2hbdGFnXSA9IEJhc2ljLnRyaW0oZGF0YS5TVFJJTkcob2Zmc2V0LCBjb3VudCkucmVwbGFjZSgvXFwwJC8sICcnKSk7IC8vIHN0cmlwIHRyYWlsaW5nIE5VTExcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBkYXRhLmFzQXJyYXkodHlwZSwgb2Zmc2V0LCBjb3VudCk7XG5cdFx0XHRcdFx0dmFsdWUgPSAoY291bnQgPT0gMSA/IHZhbHVlc1swXSA6IHZhbHVlcyk7XG5cblx0XHRcdFx0XHRpZiAodGFnRGVzY3MuaGFzT3duUHJvcGVydHkodGFnKSAmJiB0eXBlb2YgdmFsdWUgIT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdGhhc2hbdGFnXSA9IHRhZ0Rlc2NzW3RhZ11bdmFsdWVdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRoYXNoW3RhZ10gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXG5cdFx0Ly8gQXQgdGhlIG1vbWVudCBvbmx5IHNldHRpbmcgb2Ygc2ltcGxlIChMT05HKSB2YWx1ZXMsIHRoYXQgZG8gbm90IHJlcXVpcmUgb2Zmc2V0IHJlY2FsY3VsYXRpb24sIGlzIHN1cHBvcnRlZFxuXHRcdGZ1bmN0aW9uIHNldFRhZyhpZmQsIHRhZywgdmFsdWUpIHtcblx0XHRcdHZhciBvZmZzZXQsIGxlbmd0aCwgdGFnT2Zmc2V0LCB2YWx1ZU9mZnNldCA9IDA7XG5cblx0XHRcdC8vIElmIHRhZyBuYW1lIHBhc3NlZCB0cmFuc2xhdGUgaW50byBoZXgga2V5XG5cdFx0XHRpZiAodHlwZW9mKHRhZykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHZhciB0bXBUYWdzID0gdGFnc1tpZmQudG9Mb3dlckNhc2UoKV07XG5cdFx0XHRcdGZvciAodmFyIGhleCBpbiB0bXBUYWdzKSB7XG5cdFx0XHRcdFx0aWYgKHRtcFRhZ3NbaGV4XSA9PT0gdGFnKSB7XG5cdFx0XHRcdFx0XHR0YWcgPSBoZXg7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9mZnNldCA9IG9mZnNldHNbaWZkLnRvTG93ZXJDYXNlKCkgKyAnSUZEJ107XG5cdFx0XHRsZW5ndGggPSB0aGlzLlNIT1JUKG9mZnNldCk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGFnT2Zmc2V0ID0gb2Zmc2V0ICsgMTIgKiBpICsgMjtcblxuXHRcdFx0XHRpZiAodGhpcy5TSE9SVCh0YWdPZmZzZXQpID09IHRhZykge1xuXHRcdFx0XHRcdHZhbHVlT2Zmc2V0ID0gdGFnT2Zmc2V0ICsgODtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXZhbHVlT2Zmc2V0KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy53cml0ZSh2YWx1ZU9mZnNldCwgdmFsdWUsIDQpO1xuXHRcdFx0fSBjYXRjaChleCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdEV4aWZQYXJzZXIucHJvdG90eXBlID0gQmluYXJ5UmVhZGVyLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gRXhpZlBhcnNlcjtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ltYWdlL0pQRUcuanNcblxuLyoqXG4gKiBKUEVHLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSlBFR1xuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0pQRUdcIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0pQRUdIZWFkZXJzXCIsXG5cdFwibW94aWUvcnVudGltZS9odG1sNS91dGlscy9CaW5hcnlSZWFkZXJcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0V4aWZQYXJzZXJcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIHgsIEpQRUdIZWFkZXJzLCBCaW5hcnlSZWFkZXIsIEV4aWZQYXJzZXIpIHtcblx0XG5cdGZ1bmN0aW9uIEpQRUcoZGF0YSkge1xuXHRcdHZhciBfYnIsIF9obSwgX2VwLCBfaW5mbztcblxuXHRcdF9iciA9IG5ldyBCaW5hcnlSZWFkZXIoZGF0YSk7XG5cblx0XHQvLyBjaGVjayBpZiBpdCBpcyBqcGVnXG5cdFx0aWYgKF9ici5TSE9SVCgwKSAhPT0gMHhGRkQ4KSB7XG5cdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdH1cblxuXHRcdC8vIGJhY2t1cCBoZWFkZXJzXG5cdFx0X2htID0gbmV3IEpQRUdIZWFkZXJzKGRhdGEpO1xuXG5cdFx0Ly8gZXh0cmFjdCBleGlmIGluZm9cblx0XHR0cnkge1xuXHRcdFx0X2VwID0gbmV3IEV4aWZQYXJzZXIoX2htLmdldCgnYXBwMScpWzBdKTtcblx0XHR9IGNhdGNoKGV4KSB7fVxuXG5cdFx0Ly8gZ2V0IGRpbWVuc2lvbnNcblx0XHRfaW5mbyA9IF9nZXREaW1lbnNpb25zLmNhbGwodGhpcyk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0dHlwZTogJ2ltYWdlL2pwZWcnLFxuXG5cdFx0XHRzaXplOiBfYnIubGVuZ3RoKCksXG5cblx0XHRcdHdpZHRoOiBfaW5mbyAmJiBfaW5mby53aWR0aCB8fCAwLFxuXG5cdFx0XHRoZWlnaHQ6IF9pbmZvICYmIF9pbmZvLmhlaWdodCB8fCAwLFxuXG5cdFx0XHRzZXRFeGlmOiBmdW5jdGlvbih0YWcsIHZhbHVlKSB7XG5cdFx0XHRcdGlmICghX2VwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBvciB0aHJvdyBhbiBleGNlcHRpb25cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChCYXNpYy50eXBlT2YodGFnKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRCYXNpYy5lYWNoKHRhZywgZnVuY3Rpb24odmFsdWUsIHRhZykge1xuXHRcdFx0XHRcdFx0X2VwLnNldEV4aWYodGFnLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2VwLnNldEV4aWYodGFnLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1cGRhdGUgaW50ZXJuYWwgaGVhZGVyc1xuXHRcdFx0XHRfaG0uc2V0KCdhcHAxJywgX2VwLlNFR01FTlQoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHR3cml0ZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBpZiBubyBhcmd1bWVudHMgcGFzc2VkLCB1cGRhdGUgaGVhZGVycyBpbnRlcm5hbGx5XG5cdFx0XHRcdFx0cmV0dXJuIF9obS5yZXN0b3JlKGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBfaG0ucmVzdG9yZShhcmd1bWVudHNbMF0pO1xuXHRcdFx0fSxcblxuXHRcdFx0c3RyaXBIZWFkZXJzOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBfaG0uc3RyaXAoZGF0YSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRwdXJnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9wdXJnZS5jYWxsKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKF9lcCkge1xuXHRcdFx0dGhpcy5tZXRhID0ge1xuXHRcdFx0XHR0aWZmOiBfZXAuVElGRigpLFxuXHRcdFx0XHRleGlmOiBfZXAuRVhJRigpLFxuXHRcdFx0XHRncHM6IF9lcC5HUFMoKSxcblx0XHRcdFx0dGh1bWI6IF9nZXRUaHVtYigpXG5cdFx0XHR9O1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2dldERpbWVuc2lvbnMoYnIpIHtcblx0XHRcdHZhciBpZHggPSAwXG5cdFx0XHQsIG1hcmtlclxuXHRcdFx0LCBsZW5ndGhcblx0XHRcdDtcblxuXHRcdFx0aWYgKCFicikge1xuXHRcdFx0XHRiciA9IF9icjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZXhhbWluZSBhbGwgdGhyb3VnaCB0aGUgZW5kLCBzaW5jZSBzb21lIGltYWdlcyBtaWdodCBoYXZlIHZlcnkgbGFyZ2UgQVBQIHNlZ21lbnRzXG5cdFx0XHR3aGlsZSAoaWR4IDw9IGJyLmxlbmd0aCgpKSB7XG5cdFx0XHRcdG1hcmtlciA9IGJyLlNIT1JUKGlkeCArPSAyKTtcblxuXHRcdFx0XHRpZiAobWFya2VyID49IDB4RkZDMCAmJiBtYXJrZXIgPD0gMHhGRkMzKSB7IC8vIFNPRm5cblx0XHRcdFx0XHRpZHggKz0gNTsgLy8gbWFya2VyICgyIGJ5dGVzKSArIGxlbmd0aCAoMiBieXRlcykgKyBTYW1wbGUgcHJlY2lzaW9uICgxIGJ5dGUpXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGhlaWdodDogYnIuU0hPUlQoaWR4KSxcblx0XHRcdFx0XHRcdHdpZHRoOiBici5TSE9SVChpZHggKz0gMilcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxlbmd0aCA9IGJyLlNIT1JUKGlkeCArPSAyKTtcblx0XHRcdFx0aWR4ICs9IGxlbmd0aCAtIDI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9nZXRUaHVtYigpIHtcblx0XHRcdHZhciBkYXRhID0gIF9lcC50aHVtYigpXG5cdFx0XHQsIGJyXG5cdFx0XHQsIGluZm9cblx0XHRcdDtcblxuXHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0YnIgPSBuZXcgQmluYXJ5UmVhZGVyKGRhdGEpO1xuXHRcdFx0XHRpbmZvID0gX2dldERpbWVuc2lvbnMoYnIpO1xuXHRcdFx0XHRici5jbGVhcigpO1xuXG5cdFx0XHRcdGlmIChpbmZvKSB7XG5cdFx0XHRcdFx0aW5mby5kYXRhID0gZGF0YTtcblx0XHRcdFx0XHRyZXR1cm4gaW5mbztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfcHVyZ2UoKSB7XG5cdFx0XHRpZiAoIV9lcCB8fCAhX2htIHx8ICFfYnIpIHsgXG5cdFx0XHRcdHJldHVybjsgLy8gaWdub3JlIGFueSByZXBlYXRpbmcgcHVyZ2UgcmVxdWVzdHNcblx0XHRcdH1cblx0XHRcdF9lcC5jbGVhcigpO1xuXHRcdFx0X2htLnB1cmdlKCk7XG5cdFx0XHRfYnIuY2xlYXIoKTtcblx0XHRcdF9pbmZvID0gX2htID0gX2VwID0gX2JyID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gSlBFRztcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ltYWdlL1BORy5qc1xuXG4vKipcbiAqIFBORy5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL1BOR1xuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL1BOR1wiLCBbXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvdXRpbHMvQmluYXJ5UmVhZGVyXCJcbl0sIGZ1bmN0aW9uKHgsIEJhc2ljLCBCaW5hcnlSZWFkZXIpIHtcblx0XG5cdGZ1bmN0aW9uIFBORyhkYXRhKSB7XG5cdFx0dmFyIF9iciwgX2htLCBfZXAsIF9pbmZvO1xuXG5cdFx0X2JyID0gbmV3IEJpbmFyeVJlYWRlcihkYXRhKTtcblxuXHRcdC8vIGNoZWNrIGlmIGl0J3MgcG5nXG5cdFx0KGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGlkeCA9IDAsIGkgPSAwXG5cdFx0XHQsIHNpZ25hdHVyZSA9IFsweDg5NTAsIDB4NEU0NywgMHgwRDBBLCAweDFBMEFdXG5cdFx0XHQ7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyssIGlkeCArPSAyKSB7XG5cdFx0XHRcdGlmIChzaWduYXR1cmVbaV0gIT0gX2JyLlNIT1JUKGlkeCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSgpKTtcblxuXHRcdGZ1bmN0aW9uIF9nZXREaW1lbnNpb25zKCkge1xuXHRcdFx0dmFyIGNodW5rLCBpZHg7XG5cblx0XHRcdGNodW5rID0gX2dldENodW5rQXQuY2FsbCh0aGlzLCA4KTtcblxuXHRcdFx0aWYgKGNodW5rLnR5cGUgPT0gJ0lIRFInKSB7XG5cdFx0XHRcdGlkeCA9IGNodW5rLnN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHdpZHRoOiBfYnIuTE9ORyhpZHgpLFxuXHRcdFx0XHRcdGhlaWdodDogX2JyLkxPTkcoaWR4ICs9IDQpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfcHVyZ2UoKSB7XG5cdFx0XHRpZiAoIV9icikge1xuXHRcdFx0XHRyZXR1cm47IC8vIGlnbm9yZSBhbnkgcmVwZWF0aW5nIHB1cmdlIHJlcXVlc3RzXG5cdFx0XHR9XG5cdFx0XHRfYnIuY2xlYXIoKTtcblx0XHRcdGRhdGEgPSBfaW5mbyA9IF9obSA9IF9lcCA9IF9iciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0X2luZm8gPSBfZ2V0RGltZW5zaW9ucy5jYWxsKHRoaXMpO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdHR5cGU6ICdpbWFnZS9wbmcnLFxuXG5cdFx0XHRzaXplOiBfYnIubGVuZ3RoKCksXG5cblx0XHRcdHdpZHRoOiBfaW5mby53aWR0aCxcblxuXHRcdFx0aGVpZ2h0OiBfaW5mby5oZWlnaHQsXG5cblx0XHRcdHB1cmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X3B1cmdlLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBmb3IgUE5HIHdlIGNhbiBzYWZlbHkgdHJpZ2dlciBwdXJnZSBhdXRvbWF0aWNhbGx5LCBhcyB3ZSBkbyBub3Qga2VlcCBhbnkgZGF0YSBmb3IgbGF0ZXJcblx0XHRfcHVyZ2UuY2FsbCh0aGlzKTtcblxuXHRcdGZ1bmN0aW9uIF9nZXRDaHVua0F0KGlkeCkge1xuXHRcdFx0dmFyIGxlbmd0aCwgdHlwZSwgc3RhcnQsIENSQztcblxuXHRcdFx0bGVuZ3RoID0gX2JyLkxPTkcoaWR4KTtcblx0XHRcdHR5cGUgPSBfYnIuU1RSSU5HKGlkeCArPSA0LCA0KTtcblx0XHRcdHN0YXJ0ID0gaWR4ICs9IDQ7XG5cdFx0XHRDUkMgPSBfYnIuTE9ORyhpZHggKyBsZW5ndGgpO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRsZW5ndGg6IGxlbmd0aCxcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRDUkM6IENSQ1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gUE5HO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDUvaW1hZ2UvSW1hZ2VJbmZvLmpzXG5cbi8qKlxuICogSW1hZ2VJbmZvLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSW1hZ2VJbmZvXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSW1hZ2VJbmZvXCIsIFtcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9KUEVHXCIsXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9QTkdcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIHgsIEpQRUcsIFBORykge1xuXHQvKipcblx0T3B0aW9uYWwgaW1hZ2UgaW52ZXN0aWdhdGlvbiB0b29sIGZvciBIVE1MNSBydW50aW1lLiBQcm92aWRlcyB0aGUgZm9sbG93aW5nIGZlYXR1cmVzOlxuXHQtIGFiaWxpdHkgdG8gZGlzdGluZ3Vpc2ggaW1hZ2UgdHlwZSAoSlBFRyBvciBQTkcpIGJ5IHNpZ25hdHVyZVxuXHQtIGFiaWxpdHkgdG8gZXh0cmFjdCBpbWFnZSB3aWR0aC9oZWlnaHQgZGlyZWN0bHkgZnJvbSBpdCdzIGludGVybmFscywgd2l0aG91dCBwcmVsb2FkaW5nIGluIG1lbW9yeSAoZmFzdClcblx0LSBhYmlsaXR5IHRvIGV4dHJhY3QgQVBQIGhlYWRlcnMgZnJvbSBKUEVHcyAoRXhpZiwgR1BTLCBldGMpXG5cdC0gYWJpbGl0eSB0byByZXBsYWNlIHdpZHRoL2hlaWdodCB0YWdzIGluIGV4dHJhY3RlZCBKUEVHIGhlYWRlcnNcblx0LSBhYmlsaXR5IHRvIHJlc3RvcmUgQVBQIGhlYWRlcnMsIHRoYXQgd2VyZSBmb3IgZXhhbXBsZSBzdHJpcHBlZCBkdXJpbmcgaW1hZ2UgbWFuaXB1bGF0aW9uXG5cblx0QGNsYXNzIEltYWdlSW5mb1xuXHRAY29uc3RydWN0b3Jcblx0QHBhcmFtIHtTdHJpbmd9IGRhdGEgSW1hZ2Ugc291cmNlIGFzIGJpbmFyeSBzdHJpbmdcblx0Ki9cblx0cmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR2YXIgX2NzID0gW0pQRUcsIFBOR10sIF9pbWc7XG5cblx0XHQvLyBmaWd1cmUgb3V0IHRoZSBmb3JtYXQsIHRocm93OiBJbWFnZUVycm9yLldST05HX0ZPUk1BVCBpZiBub3Qgc3VwcG9ydGVkXG5cdFx0X2ltZyA9IChmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgX2NzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBfY3NbaV0oZGF0YSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5pbmZvKGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkltYWdlRXJyb3IuV1JPTkdfRk9STUFUKTtcblx0XHR9KCkpO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0SW1hZ2UgTWltZSBUeXBlIGV4dHJhY3RlZCBmcm9tIGl0J3MgZGVwdGhzXG5cblx0XHRcdEBwcm9wZXJ0eSB0eXBlXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0QGRlZmF1bHQgJydcblx0XHRcdCovXG5cdFx0XHR0eXBlOiAnJyxcblxuXHRcdFx0LyoqXG5cdFx0XHRJbWFnZSBzaXplIGluIGJ5dGVzXG5cblx0XHRcdEBwcm9wZXJ0eSBzaXplXG5cdFx0XHRAdHlwZSB7TnVtYmVyfVxuXHRcdFx0QGRlZmF1bHQgMFxuXHRcdFx0Ki9cblx0XHRcdHNpemU6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0SW1hZ2Ugd2lkdGggZXh0cmFjdGVkIGZyb20gaW1hZ2Ugc291cmNlXG5cblx0XHRcdEBwcm9wZXJ0eSB3aWR0aFxuXHRcdFx0QHR5cGUge051bWJlcn1cblx0XHRcdEBkZWZhdWx0IDBcblx0XHRcdCovXG5cdFx0XHR3aWR0aDogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHRJbWFnZSBoZWlnaHQgZXh0cmFjdGVkIGZyb20gaW1hZ2Ugc291cmNlXG5cblx0XHRcdEBwcm9wZXJ0eSBoZWlnaHRcblx0XHRcdEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHRAZGVmYXVsdCAwXG5cdFx0XHQqL1xuXHRcdFx0aGVpZ2h0OiAwLFxuXG5cdFx0XHQvKipcblx0XHRcdFNldHMgRXhpZiB0YWcuIEN1cnJlbnRseSBhcHBsaWNhYmxlIG9ubHkgZm9yIHdpZHRoIGFuZCBoZWlnaHQgdGFncy4gT2J2aW91c2x5IHdvcmtzIG9ubHkgd2l0aCBKUEVHcy5cblxuXHRcdFx0QG1ldGhvZCBzZXRFeGlmXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gdGFnIFRhZyB0byBzZXRcblx0XHRcdEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFZhbHVlIHRvIGFzc2lnbiB0byB0aGUgdGFnXG5cdFx0XHQqL1xuXHRcdFx0c2V0RXhpZjogZnVuY3Rpb24oKSB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXN0b3JlcyBoZWFkZXJzIHRvIHRoZSBzb3VyY2UuXG5cblx0XHRcdEBtZXRob2Qgd3JpdGVIZWFkZXJzXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gZGF0YSBJbWFnZSBzb3VyY2UgYXMgYmluYXJ5IHN0cmluZ1xuXHRcdFx0QHJldHVybiB7U3RyaW5nfSBVcGRhdGVkIGJpbmFyeSBzdHJpbmdcblx0XHRcdCovXG5cdFx0XHR3cml0ZUhlYWRlcnM6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFN0cmlwIGFsbCBoZWFkZXJzIGZyb20gdGhlIHNvdXJjZS5cblxuXHRcdFx0QG1ldGhvZCBzdHJpcEhlYWRlcnNcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBkYXRhIEltYWdlIHNvdXJjZSBhcyBiaW5hcnkgc3RyaW5nXG5cdFx0XHRAcmV0dXJuIHtTdHJpbmd9IFVwZGF0ZWQgYmluYXJ5IHN0cmluZ1xuXHRcdFx0Ki9cblx0XHRcdHN0cmlwSGVhZGVyczogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0RGlzcG9zZSByZXNvdXJjZXMuXG5cblx0XHRcdEBtZXRob2QgcHVyZ2Vcblx0XHRcdCovXG5cdFx0XHRwdXJnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIF9pbWcpO1xuXG5cdFx0dGhpcy5wdXJnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0X2ltZy5wdXJnZSgpO1xuXHRcdFx0X2ltZyA9IG51bGw7XG5cdFx0fTtcblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ltYWdlL1Jlc2l6ZXJDYW52YXMuanNcblxuLyoqXG4gKiBSZXNpemVyQ2FudmFzLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuICogUmVzaXplcyBpbWFnZS9jYW52YXMgdXNpbmcgY2FudmFzXG4gKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvUmVzaXplckNhbnZhc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBzY2FsZShpbWFnZSwgcmF0aW8pIHtcbiAgICAgICAgdmFyIHNXID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBkVyA9IE1hdGguZmxvb3Ioc1cgKiByYXRpbyk7XG4gICAgICAgIHZhciBzY2FsZUNhcHBlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChyYXRpbyA8IDAuNSB8fCByYXRpbyA+IDIpIHtcbiAgICAgICAgICAgIHJhdGlvID0gcmF0aW8gPCAwLjUgPyAwLjUgOiAyO1xuICAgICAgICAgICAgc2NhbGVDYXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRDYW52YXMgPSBfc2NhbGUoaW1hZ2UsIHJhdGlvKTtcblxuICAgICAgICBpZiAoc2NhbGVDYXBwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZSh0Q2FudmFzLCBkVyAvIHRDYW52YXMud2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRDYW52YXM7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIF9zY2FsZShpbWFnZSwgcmF0aW8pIHtcbiAgICAgICAgdmFyIHNXID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBzSCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgdmFyIGRXID0gTWF0aC5mbG9vcihzVyAqIHJhdGlvKTtcbiAgICAgICAgdmFyIGRIID0gTWF0aC5mbG9vcihzSCAqIHJhdGlvKTtcblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGRXO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZEg7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBzVywgc0gsIDAsIDAsIGRXLCBkSCk7XG5cbiAgICAgICAgaW1hZ2UgPSBudWxsOyAvLyBqdXN0IGluIGNhc2VcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICB9O1xuXG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS9pbWFnZS9JbWFnZS5qc1xuXG4vKipcbiAqIEltYWdlLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSW1hZ2VcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9JbWFnZVwiLCBbXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW5jb2RlXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlXCIsXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9JbWFnZUluZm9cIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL1Jlc2l6ZXJDYW52YXNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL01pbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VudlwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgeCwgRW5jb2RlLCBCbG9iLCBGaWxlLCBJbWFnZUluZm8sIFJlc2l6ZXJDYW52YXMsIE1pbWUsIEVudikge1xuXG5cdGZ1bmN0aW9uIEhUTUw1SW1hZ2UoKSB7XG5cdFx0dmFyIG1lID0gdGhpc1xuXHRcdCwgX2ltZywgX2ltZ0luZm8sIF9jYW52YXMsIF9iaW5TdHIsIF9ibG9iXG5cdFx0LCBfbW9kaWZpZWQgPSBmYWxzZSAvLyBpcyBzZXQgdHJ1ZSB3aGVuZXZlciBpbWFnZSBpcyBtb2RpZmllZFxuXHRcdCwgX3ByZXNlcnZlSGVhZGVycyA9IHRydWVcblx0XHQ7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0bG9hZEZyb21CbG9iOiBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHRcdHZhciBJID0gdGhpcy5nZXRSdW50aW1lKClcblx0XHRcdFx0LCBhc0JpbmFyeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdHJ1ZVxuXHRcdFx0XHQ7XG5cblx0XHRcdFx0aWYgKCFJLmNhbignYWNjZXNzX2JpbmFyeScpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguUnVudGltZUVycm9yKHguUnVudGltZUVycm9yLk5PVF9TVVBQT1JURURfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9ibG9iID0gYmxvYjtcblxuXHRcdFx0XHRpZiAoYmxvYi5pc0RldGFjaGVkKCkpIHtcblx0XHRcdFx0XHRfYmluU3RyID0gYmxvYi5nZXRTb3VyY2UoKTtcblx0XHRcdFx0XHRfcHJlbG9hZC5jYWxsKHRoaXMsIF9iaW5TdHIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfcmVhZEFzRGF0YVVybC5jYWxsKHRoaXMsIGJsb2IuZ2V0U291cmNlKCksIGZ1bmN0aW9uKGRhdGFVcmwpIHtcblx0XHRcdFx0XHRcdGlmIChhc0JpbmFyeSkge1xuXHRcdFx0XHRcdFx0XHRfYmluU3RyID0gX3RvQmluYXJ5KGRhdGFVcmwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X3ByZWxvYWQuY2FsbCh0aGlzLCBkYXRhVXJsKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0bG9hZEZyb21JbWFnZTogZnVuY3Rpb24oaW1nLCBleGFjdCkge1xuXHRcdFx0XHR0aGlzLm1ldGEgPSBpbWcubWV0YTtcblxuXHRcdFx0XHRfYmxvYiA9IG5ldyBGaWxlKG51bGwsIHtcblx0XHRcdFx0XHRuYW1lOiBpbWcubmFtZSxcblx0XHRcdFx0XHRzaXplOiBpbWcuc2l6ZSxcblx0XHRcdFx0XHR0eXBlOiBpbWcudHlwZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfcHJlbG9hZC5jYWxsKHRoaXMsIGV4YWN0ID8gKF9iaW5TdHIgPSBpbWcuZ2V0QXNCaW5hcnlTdHJpbmcoKSkgOiBpbWcuZ2V0QXNEYXRhVVJMKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0SW5mbzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBJID0gdGhpcy5nZXRSdW50aW1lKCksIGluZm87XG5cblx0XHRcdFx0aWYgKCFfaW1nSW5mbyAmJiBfYmluU3RyICYmIEkuY2FuKCdhY2Nlc3NfaW1hZ2VfYmluYXJ5JykpIHtcblx0XHRcdFx0XHRfaW1nSW5mbyA9IG5ldyBJbWFnZUluZm8oX2JpblN0cik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0aGlzIHN0dWZmIGJlbG93IGlzIGRlZmluaXRlbHkgaGF2aW5nIGZ1biB3aXRoIGl0c2VsZlxuXHRcdFx0XHRpbmZvID0ge1xuXHRcdFx0XHRcdHdpZHRoOiBfZ2V0SW1nKCkud2lkdGggfHwgMCxcblx0XHRcdFx0XHRoZWlnaHQ6IF9nZXRJbWcoKS5oZWlnaHQgfHwgMCxcblx0XHRcdFx0XHR0eXBlOiBfYmxvYi50eXBlIHx8IE1pbWUuZ2V0RmlsZU1pbWUoX2Jsb2IubmFtZSksXG5cdFx0XHRcdFx0c2l6ZTogX2JpblN0ciAmJiBfYmluU3RyLmxlbmd0aCB8fCBfYmxvYi5zaXplIHx8IDAsXG5cdFx0XHRcdFx0bmFtZTogX2Jsb2IubmFtZSB8fCAnJyxcblx0XHRcdFx0XHRtZXRhOiBudWxsXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKF9wcmVzZXJ2ZUhlYWRlcnMpIHtcblx0XHRcdFx0XHRpbmZvLm1ldGEgPSBfaW1nSW5mbyAmJiBfaW1nSW5mby5tZXRhIHx8IHRoaXMubWV0YSB8fCB7fTtcblxuXHRcdFx0XHRcdC8vIGlmIGRhdGEgd2FzIHRha2VuIGZyb20gSW1hZ2VJbmZvIGl0IHdpbGwgYmUgYSBiaW5hcnkgc3RyaW5nLCBzbyB3ZSBjb252ZXJ0IGl0IHRvIGJsb2Jcblx0XHRcdFx0XHRpZiAoaW5mby5tZXRhICYmIGluZm8ubWV0YS50aHVtYiAmJiAhKGluZm8ubWV0YS50aHVtYi5kYXRhIGluc3RhbmNlb2YgQmxvYikpIHtcblx0XHRcdFx0XHRcdGluZm8ubWV0YS50aHVtYi5kYXRhID0gbmV3IEJsb2IobnVsbCwge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAnaW1hZ2UvanBlZycsXG5cdFx0XHRcdFx0XHRcdGRhdGE6IGluZm8ubWV0YS50aHVtYi5kYXRhXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gaW5mbztcblx0XHRcdH0sXG5cblxuXHRcdFx0cmVzaXplOiBmdW5jdGlvbihyZWN0LCByYXRpbywgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGg7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodDtcblxuXHRcdFx0XHRjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZShfZ2V0SW1nKCksIHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuXHRcdFx0XHRfY2FudmFzID0gUmVzaXplckNhbnZhcy5zY2FsZShjYW52YXMsIHJhdGlvKTtcblxuXHRcdFx0XHRfcHJlc2VydmVIZWFkZXJzID0gb3B0aW9ucy5wcmVzZXJ2ZUhlYWRlcnM7XG5cblx0XHRcdFx0Ly8gcm90YXRlIGlmIHJlcXVpcmVkLCBhY2NvcmRpbmcgdG8gb3JpZW50YXRpb24gdGFnXG5cdFx0XHRcdGlmICghX3ByZXNlcnZlSGVhZGVycykge1xuXHRcdFx0XHRcdHZhciBvcmllbnRhdGlvbiA9ICh0aGlzLm1ldGEgJiYgdGhpcy5tZXRhLnRpZmYgJiYgdGhpcy5tZXRhLnRpZmYuT3JpZW50YXRpb24pIHx8IDE7XG5cdFx0XHRcdFx0X2NhbnZhcyA9IF9yb3RhdGVUb09yaWVudGFpb24oX2NhbnZhcywgb3JpZW50YXRpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy53aWR0aCA9IF9jYW52YXMud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQ7XG5cblx0XHRcdFx0X21vZGlmaWVkID0gdHJ1ZTtcblxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ1Jlc2l6ZScpO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0QXNDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIV9jYW52YXMpIHtcblx0XHRcdFx0XHRfY2FudmFzID0gX2dldENhbnZhcygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9jYW52YXMuaWQgPSB0aGlzLnVpZCArICdfY2FudmFzJztcblx0XHRcdFx0cmV0dXJuIF9jYW52YXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBc0Jsb2I6IGZ1bmN0aW9uKHR5cGUsIHF1YWxpdHkpIHtcblx0XHRcdFx0aWYgKHR5cGUgIT09IHRoaXMudHlwZSkge1xuXHRcdFx0XHRcdF9tb2RpZmllZCA9IHRydWU7IC8vIHJlY29uc2lkZXIgdGhlIHN0YXRlXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBGaWxlKG51bGwsIHtcblx0XHRcdFx0XHRcdG5hbWU6IF9ibG9iLm5hbWUgfHwgJycsXG5cdFx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdFx0ZGF0YTogbWUuZ2V0QXNEYXRhVVJMKHR5cGUsIHF1YWxpdHkpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5ldyBGaWxlKG51bGwsIHtcblx0XHRcdFx0XHRuYW1lOiBfYmxvYi5uYW1lIHx8ICcnLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0ZGF0YTogbWUuZ2V0QXNCaW5hcnlTdHJpbmcodHlwZSwgcXVhbGl0eSlcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBc0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIHF1YWxpdHkgPSBhcmd1bWVudHNbMV0gfHwgOTA7XG5cblx0XHRcdFx0Ly8gaWYgaW1hZ2UgaGFzIG5vdCBiZWVuIG1vZGlmaWVkLCByZXR1cm4gdGhlIHNvdXJjZSByaWdodCBhd2F5XG5cdFx0XHRcdGlmICghX21vZGlmaWVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9pbWcuc3JjO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHdlIGhhdmUgYSBjYW52YXMgdG8gd29yayB3aXRoXG5cdFx0XHRcdF9nZXRDYW52YXMoKTtcblxuXHRcdFx0XHRpZiAoJ2ltYWdlL2pwZWcnICE9PSB0eXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9jYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Ly8gb2xkZXIgR2Vja29zIHVzZWQgdG8gcmVzdWx0IGluIGFuIGV4Y2VwdGlvbiBvbiBxdWFsaXR5IGFyZ3VtZW50XG5cdFx0XHRcdFx0XHRyZXR1cm4gX2NhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCBxdWFsaXR5LzEwMCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBfY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2V0QXNCaW5hcnlTdHJpbmc6IGZ1bmN0aW9uKHR5cGUsIHF1YWxpdHkpIHtcblx0XHRcdFx0Ly8gaWYgaW1hZ2UgaGFzIG5vdCBiZWVuIG1vZGlmaWVkLCByZXR1cm4gdGhlIHNvdXJjZSByaWdodCBhd2F5XG5cdFx0XHRcdGlmICghX21vZGlmaWVkKSB7XG5cdFx0XHRcdFx0Ly8gaWYgaW1hZ2Ugd2FzIG5vdCBsb2FkZWQgZnJvbSBiaW5hcnkgc3RyaW5nXG5cdFx0XHRcdFx0aWYgKCFfYmluU3RyKSB7XG5cdFx0XHRcdFx0XHRfYmluU3RyID0gX3RvQmluYXJ5KG1lLmdldEFzRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBfYmluU3RyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCdpbWFnZS9qcGVnJyAhPT0gdHlwZSkge1xuXHRcdFx0XHRcdF9iaW5TdHIgPSBfdG9CaW5hcnkobWUuZ2V0QXNEYXRhVVJMKHR5cGUsIHF1YWxpdHkpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgZGF0YVVybDtcblxuXHRcdFx0XHRcdC8vIGlmIGpwZWdcblx0XHRcdFx0XHRpZiAoIXF1YWxpdHkpIHtcblx0XHRcdFx0XHRcdHF1YWxpdHkgPSA5MDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhIGNhbnZhcyB0byB3b3JrIHdpdGhcblx0XHRcdFx0XHRfZ2V0Q2FudmFzKCk7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Ly8gb2xkZXIgR2Vja29zIHVzZWQgdG8gcmVzdWx0IGluIGFuIGV4Y2VwdGlvbiBvbiBxdWFsaXR5IGFyZ3VtZW50XG5cdFx0XHRcdFx0XHRkYXRhVXJsID0gX2NhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCBxdWFsaXR5LzEwMCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdGRhdGFVcmwgPSBfY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9iaW5TdHIgPSBfdG9CaW5hcnkoZGF0YVVybCk7XG5cblx0XHRcdFx0XHRpZiAoX2ltZ0luZm8pIHtcblx0XHRcdFx0XHRcdF9iaW5TdHIgPSBfaW1nSW5mby5zdHJpcEhlYWRlcnMoX2JpblN0cik7XG5cblx0XHRcdFx0XHRcdGlmIChfcHJlc2VydmVIZWFkZXJzKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBkaW1lbnNpb25zIGluZm8gaW4gZXhpZlxuXHRcdFx0XHRcdFx0XHRpZiAoX2ltZ0luZm8ubWV0YSAmJiBfaW1nSW5mby5tZXRhLmV4aWYpIHtcblx0XHRcdFx0XHRcdFx0XHRfaW1nSW5mby5zZXRFeGlmKHtcblx0XHRcdFx0XHRcdFx0XHRcdFBpeGVsWERpbWVuc2lvbjogdGhpcy53aWR0aCxcblx0XHRcdFx0XHRcdFx0XHRcdFBpeGVsWURpbWVuc2lvbjogdGhpcy5oZWlnaHRcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHJlLWluamVjdCB0aGUgaGVhZGVyc1xuXHRcdFx0XHRcdFx0XHRfYmluU3RyID0gX2ltZ0luZm8ud3JpdGVIZWFkZXJzKF9iaW5TdHIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyB3aWxsIGJlIHJlLWNyZWF0ZWQgZnJvbSBmcmVzaCBvbiBuZXh0IGdldEluZm8gY2FsbFxuXHRcdFx0XHRcdFx0X2ltZ0luZm8ucHVyZ2UoKTtcblx0XHRcdFx0XHRcdF9pbWdJbmZvID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfbW9kaWZpZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRyZXR1cm4gX2JpblN0cjtcblx0XHRcdH0sXG5cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtZSA9IG51bGw7XG5cdFx0XHRcdF9wdXJnZS5jYWxsKHRoaXMpO1xuXHRcdFx0XHR0aGlzLmdldFJ1bnRpbWUoKS5nZXRTaGltKCkucmVtb3ZlSW5zdGFuY2UodGhpcy51aWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHRmdW5jdGlvbiBfZ2V0SW1nKCkge1xuXHRcdFx0aWYgKCFfY2FudmFzICYmICFfaW1nKSB7XG5cdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9jYW52YXMgfHwgX2ltZztcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9nZXRDYW52YXMoKSB7XG5cdFx0XHR2YXIgY2FudmFzID0gX2dldEltZygpO1xuXHRcdFx0aWYgKGNhbnZhcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdjYW52YXMnKSB7XG5cdFx0XHRcdHJldHVybiBjYW52YXM7XG5cdFx0XHR9XG5cdFx0XHRfY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0XHRfY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXHRcdFx0X2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cdFx0XHRyZXR1cm4gX2NhbnZhcztcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF90b0JpbmFyeShzdHIpIHtcblx0XHRcdHJldHVybiBFbmNvZGUuYXRvYihzdHIuc3Vic3RyaW5nKHN0ci5pbmRleE9mKCdiYXNlNjQsJykgKyA3KSk7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfdG9EYXRhVXJsKHN0ciwgdHlwZSkge1xuXHRcdFx0cmV0dXJuICdkYXRhOicgKyAodHlwZSB8fCAnJykgKyAnO2Jhc2U2NCwnICsgRW5jb2RlLmJ0b2Eoc3RyKTtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9wcmVsb2FkKHN0cikge1xuXHRcdFx0dmFyIGNvbXAgPSB0aGlzO1xuXG5cdFx0XHRfaW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRfaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0X3B1cmdlLmNhbGwodGhpcyk7XG5cdFx0XHRcdGNvbXAudHJpZ2dlcignZXJyb3InLCB4LkltYWdlRXJyb3IuV1JPTkdfRk9STUFUKTtcblx0XHRcdH07XG5cdFx0XHRfaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb21wLnRyaWdnZXIoJ2xvYWQnKTtcblx0XHRcdH07XG5cblx0XHRcdF9pbWcuc3JjID0gc3RyLnN1YnN0cigwLCA1KSA9PSAnZGF0YTonID8gc3RyIDogX3RvRGF0YVVybChzdHIsIF9ibG9iLnR5cGUpO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3JlYWRBc0RhdGFVcmwoZmlsZSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBjb21wID0gdGhpcywgZnI7XG5cblx0XHRcdC8vIHVzZSBGaWxlUmVhZGVyIGlmIGl0J3MgYXZhaWxhYmxlXG5cdFx0XHRpZiAod2luZG93LkZpbGVSZWFkZXIpIHtcblx0XHRcdFx0ZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKGNvbXAsIHRoaXMucmVzdWx0KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZnIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcignZXJyb3InLCB4LkltYWdlRXJyb3IuV1JPTkdfRk9STUFUKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZnIucmVhZEFzRGF0YVVSTChmaWxlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZpbGUuZ2V0QXNEYXRhVVJMKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCogVHJhbnNmb3JtIGNhbnZhcyBjb29yZGluYXRpb24gYWNjb3JkaW5nIHRvIHNwZWNpZmllZCBmcmFtZSBzaXplIGFuZCBvcmllbnRhdGlvblxuXHRcdCogT3JpZW50YXRpb24gdmFsdWUgaXMgZnJvbSBFWElGIHRhZ1xuXHRcdCogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG5cdFx0Ki9cblx0XHRmdW5jdGlvbiBfcm90YXRlVG9PcmllbnRhaW9uKGltZywgb3JpZW50YXRpb24pIHtcblx0XHRcdHZhciBSQURJQU5TID0gTWF0aC5QSS8xODA7XG5cdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHR2YXIgd2lkdGggPSBpbWcud2lkdGg7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuXHRcdFx0aWYgKEJhc2ljLmluQXJyYXkob3JpZW50YXRpb24sIFs1LDYsNyw4XSkgPiAtMSkge1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSBoZWlnaHQ7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSB3aWR0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdDEgPSBUaGUgMHRoIHJvdyBpcyBhdCB0aGUgdmlzdWFsIHRvcCBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIGxlZnQtaGFuZCBzaWRlLlxuXHRcdFx0MiA9IFRoZSAwdGggcm93IGlzIGF0IHRoZSB2aXN1YWwgdG9wIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgcmlnaHQtaGFuZCBzaWRlLlxuXHRcdFx0MyA9IFRoZSAwdGggcm93IGlzIGF0IHRoZSB2aXN1YWwgYm90dG9tIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgcmlnaHQtaGFuZCBzaWRlLlxuXHRcdFx0NCA9IFRoZSAwdGggcm93IGlzIGF0IHRoZSB2aXN1YWwgYm90dG9tIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgbGVmdC1oYW5kIHNpZGUuXG5cdFx0XHQ1ID0gVGhlIDB0aCByb3cgaXMgdGhlIHZpc3VhbCBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIHRvcC5cblx0XHRcdDYgPSBUaGUgMHRoIHJvdyBpcyB0aGUgdmlzdWFsIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIHRvcC5cblx0XHRcdDcgPSBUaGUgMHRoIHJvdyBpcyB0aGUgdmlzdWFsIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIGJvdHRvbS5cblx0XHRcdDggPSBUaGUgMHRoIHJvdyBpcyB0aGUgdmlzdWFsIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgYm90dG9tLlxuXHRcdFx0Ki9cblx0XHRcdHN3aXRjaCAob3JpZW50YXRpb24pIHtcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdC8vIGhvcml6b250YWwgZmxpcFxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuXHRcdFx0XHRcdGN0eC5zY2FsZSgtMSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHQvLyAxODAgcm90YXRlIGxlZnRcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0XHRcdGN0eC5yb3RhdGUoMTgwICogUkFESUFOUyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHQvLyB2ZXJ0aWNhbCBmbGlwXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQpO1xuXHRcdFx0XHRcdGN0eC5zY2FsZSgxLCAtMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNTpcblx0XHRcdFx0XHQvLyB2ZXJ0aWNhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSg5MCAqIFJBRElBTlMpO1xuXHRcdFx0XHRcdGN0eC5zY2FsZSgxLCAtMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNjpcblx0XHRcdFx0XHQvLyA5MCByb3RhdGUgcmlnaHRcblx0XHRcdFx0XHRjdHgucm90YXRlKDkwICogUkFESUFOUyk7XG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCAtaGVpZ2h0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA3OlxuXHRcdFx0XHRcdC8vIGhvcml6b250YWwgZmxpcCArIDkwIHJvdGF0ZSByaWdodFxuXHRcdFx0XHRcdGN0eC5yb3RhdGUoOTAgKiBSQURJQU5TKTtcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHdpZHRoLCAtaGVpZ2h0KTtcblx0XHRcdFx0XHRjdHguc2NhbGUoLTEsIDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0Ly8gOTAgcm90YXRlIGxlZnRcblx0XHRcdFx0XHRjdHgucm90YXRlKC05MCAqIFJBRElBTlMpO1xuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoLXdpZHRoLCAwKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0cmV0dXJuIGNhbnZhcztcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9wdXJnZSgpIHtcblx0XHRcdGlmIChfaW1nSW5mbykge1xuXHRcdFx0XHRfaW1nSW5mby5wdXJnZSgpO1xuXHRcdFx0XHRfaW1nSW5mbyA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdF9iaW5TdHIgPSBfaW1nID0gX2NhbnZhcyA9IF9ibG9iID0gbnVsbDtcblx0XHRcdF9tb2RpZmllZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5JbWFnZSA9IEhUTUw1SW1hZ2UpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvZmxhc2gvUnVudGltZS5qc1xuXG4vKipcbiAqIFJ1bnRpbWUuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLypnbG9iYWwgQWN0aXZlWE9iamVjdDp0cnVlICovXG5cbi8qKlxuRGVmaW5lcyBjb25zdHJ1Y3RvciBmb3IgRmxhc2ggcnVudGltZS5cblxuQGNsYXNzIG1veGllL3J1bnRpbWUvZmxhc2gvUnVudGltZVxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2ZsYXNoL1J1bnRpbWVcIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VudlwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRG9tXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvcnVudGltZS9SdW50aW1lXCJcbl0sIGZ1bmN0aW9uKEJhc2ljLCBFbnYsIERvbSwgeCwgUnVudGltZSkge1xuXHRcblx0dmFyIHR5cGUgPSAnZmxhc2gnLCBleHRlbnNpb25zID0ge307XG5cblx0LyoqXG5cdEdldCB0aGUgdmVyc2lvbiBvZiB0aGUgRmxhc2ggUGxheWVyXG5cblx0QG1ldGhvZCBnZXRTaGltVmVyc2lvblxuXHRAcHJpdmF0ZVxuXHRAcmV0dXJuIHtOdW1iZXJ9IEZsYXNoIFBsYXllciB2ZXJzaW9uXG5cdCovXG5cdGZ1bmN0aW9uIGdldFNoaW1WZXJzaW9uKCkge1xuXHRcdHZhciB2ZXJzaW9uO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZlcnNpb24gPSBuYXZpZ2F0b3IucGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoJ107XG5cdFx0XHR2ZXJzaW9uID0gdmVyc2lvbi5kZXNjcmlwdGlvbjtcblx0XHR9IGNhdGNoIChlMSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmVyc2lvbiA9IG5ldyBBY3RpdmVYT2JqZWN0KCdTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaCcpLkdldFZhcmlhYmxlKCckdmVyc2lvbicpO1xuXHRcdFx0fSBjYXRjaCAoZTIpIHtcblx0XHRcdFx0dmVyc2lvbiA9ICcwLjAnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2ZXJzaW9uID0gdmVyc2lvbi5tYXRjaCgvXFxkKy9nKTtcblx0XHRyZXR1cm4gcGFyc2VGbG9hdCh2ZXJzaW9uWzBdICsgJy4nICsgdmVyc2lvblsxXSk7XG5cdH1cblxuXG5cdC8qKlxuXHRDcm9zcy1icm93c2VyIFNXRiByZW1vdmFsXG4gICAgXHQtIEVzcGVjaWFsbHkgbmVlZGVkIHRvIHNhZmVseSBhbmQgY29tcGxldGVseSByZW1vdmUgYSBTV0YgaW4gSW50ZXJuZXQgRXhwbG9yZXJcblxuICAgXHRPcmlnaW5hdGVkIGZyb20gU1dGT2JqZWN0IHYyLjIgPGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9zd2ZvYmplY3QvPiBcblx0Ki9cblx0ZnVuY3Rpb24gcmVtb3ZlU1dGKGlkKSB7XG4gICAgICAgIHZhciBvYmogPSBEb20uZ2V0KGlkKTtcbiAgICAgICAgaWYgKG9iaiAmJiBvYmoubm9kZU5hbWUgPT0gXCJPQkpFQ1RcIikge1xuICAgICAgICAgICAgaWYgKEVudi5icm93c2VyID09PSAnSUUnKSB7XG4gICAgICAgICAgICAgICAgb2JqLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gb25Jbml0KCl7XG4gICAgICAgICAgICAgICAgXHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvbXM1MzQzNjAodj12cy44NSkuYXNweFxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT2JqZWN0SW5JRShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG9uSW5pdCwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuXHRmdW5jdGlvbiByZW1vdmVPYmplY3RJbklFKGlkKSB7XG4gICAgICAgIHZhciBvYmogPSBEb20uZ2V0KGlkKTtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtpXSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmoucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG5cdC8qKlxuXHRDb25zdHJ1Y3RvciBmb3IgdGhlIEZsYXNoIFJ1bnRpbWVcblxuXHRAY2xhc3MgRmxhc2hSdW50aW1lXG5cdEBleHRlbmRzIFJ1bnRpbWVcblx0Ki9cblx0ZnVuY3Rpb24gRmxhc2hSdW50aW1lKG9wdGlvbnMpIHtcblx0XHR2YXIgSSA9IHRoaXMsIGluaXRUaW1lcjtcblxuXHRcdG9wdGlvbnMgPSBCYXNpYy5leHRlbmQoeyBzd2ZfdXJsOiBFbnYuc3dmX3VybCB9LCBvcHRpb25zKTtcblxuXHRcdFJ1bnRpbWUuY2FsbCh0aGlzLCBvcHRpb25zLCB0eXBlLCB7XG5cdFx0XHRhY2Nlc3NfYmluYXJ5OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0YWNjZXNzX2ltYWdlX2JpbmFyeTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEkubW9kZSA9PT0gJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdGRpc3BsYXlfbWVkaWE6IFJ1bnRpbWUuY2FwVGVzdChkZWZpbmVkKCdtb3hpZS9pbWFnZS9JbWFnZScpKSxcblx0XHRcdGRvX2NvcnM6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdGRyYWdfYW5kX2Ryb3A6IGZhbHNlLFxuXHRcdFx0cmVwb3J0X3VwbG9hZF9wcm9ncmVzczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBJLm1vZGUgPT09ICdjbGllbnQnO1xuXHRcdFx0fSxcblx0XHRcdHJlc2l6ZV9pbWFnZTogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX2hlYWRlcnM6IGZhbHNlLFxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX3R5cGU6IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRpZiAocmVzcG9uc2VUeXBlID09PSAnanNvbicgJiYgISF3aW5kb3cuSlNPTikge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IFxuXHRcdFx0XHRyZXR1cm4gIUJhc2ljLmFycmF5RGlmZihyZXNwb25zZVR5cGUsIFsnJywgJ3RleHQnLCAnZG9jdW1lbnQnXSkgfHwgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuX3N0YXR1c19jb2RlOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdHJldHVybiBJLm1vZGUgPT09ICdicm93c2VyJyB8fCAhQmFzaWMuYXJyYXlEaWZmKGNvZGUsIFsyMDAsIDQwNF0pO1xuXHRcdFx0fSxcblx0XHRcdHNlbGVjdF9maWxlOiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRzZWxlY3RfbXVsdGlwbGU6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdHNlbmRfYmluYXJ5X3N0cmluZzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEkubW9kZSA9PT0gJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRfYnJvd3Nlcl9jb29raWVzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9jdXN0b21faGVhZGVyczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEkubW9kZSA9PT0gJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRfbXVsdGlwYXJ0OiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRzbGljZV9ibG9iOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0c3RyZWFtX3VwbG9hZDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEkubW9kZSA9PT0gJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdHN1bW1vbl9maWxlX2RpYWxvZzogZmFsc2UsXG5cdFx0XHR1cGxvYWRfZmlsZXNpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRcdFx0cmV0dXJuIEJhc2ljLnBhcnNlU2l6ZVN0cihzaXplKSA8PSAyMDk3MTUyIHx8IEkubW9kZSA9PT0gJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0dXNlX2h0dHBfbWV0aG9kOiBmdW5jdGlvbihtZXRob2RzKSB7XG5cdFx0XHRcdHJldHVybiAhQmFzaWMuYXJyYXlEaWZmKG1ldGhvZHMsIFsnR0VUJywgJ1BPU1QnXSk7XG5cdFx0XHR9XG5cdFx0fSwgeyBcblx0XHRcdC8vIGNhcGFiaWxpdGllcyB0aGF0IHJlcXVpcmUgc3BlY2lmaWMgbW9kZVxuXHRcdFx0YWNjZXNzX2JpbmFyeTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0YWNjZXNzX2ltYWdlX2JpbmFyeTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0cmVwb3J0X3VwbG9hZF9wcm9ncmVzczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX3R5cGU6IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gQmFzaWMuYXJyYXlEaWZmKHJlc3BvbnNlVHlwZSwgWycnLCAndGV4dCcsICdqc29uJywgJ2RvY3VtZW50J10pID8gJ2Jyb3dzZXInIDogWydjbGllbnQnLCAnYnJvd3NlciddO1xuXHRcdFx0fSxcblx0XHRcdHJldHVybl9zdGF0dXNfY29kZTogZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gQmFzaWMuYXJyYXlEaWZmKGNvZGUsIFsyMDAsIDQwNF0pID8gJ2Jyb3dzZXInIDogWydjbGllbnQnLCAnYnJvd3NlciddO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRfYmluYXJ5X3N0cmluZzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9icm93c2VyX2Nvb2tpZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICdicm93c2VyJyA6ICdjbGllbnQnO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRfY3VzdG9tX2hlYWRlcnM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICdicm93c2VyJyA6ICdjbGllbnQnO1xuXHRcdFx0fSxcblx0XHRcdHNsaWNlX2Jsb2I6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICdicm93c2VyJyA6ICdjbGllbnQnO1xuXHRcdFx0fSxcblx0XHRcdHN0cmVhbV91cGxvYWQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICdjbGllbnQnIDogJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdHVwbG9hZF9maWxlc2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gQmFzaWMucGFyc2VTaXplU3RyKHNpemUpID49IDIwOTcxNTIgPyAnY2xpZW50JyA6ICdicm93c2VyJztcblx0XHRcdH1cblx0XHR9LCAnY2xpZW50Jyk7XG5cblxuXHRcdC8vIG1pbmltYWwgcmVxdWlyZW1lbnQgZm9yIEZsYXNoIFBsYXllciB2ZXJzaW9uXG5cdFx0aWYgKGdldFNoaW1WZXJzaW9uKCkgPCAxMS4zKSB7XG5cdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdEVudi5sb2coXCJcXHRGbGFzaCBkaWRuJ3QgbWVldCBtaW5pbWFsIHZlcnNpb24gcmVxdWlyZW1lbnQgKDExLjMpLlwiKTtcdFxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1vZGUgPSBmYWxzZTsgLy8gd2l0aCBmYWxzeSBtb2RlLCBydW50aW1lIHdvbid0IG9wZXJhYmxlLCBubyBtYXR0ZXIgd2hhdCB0aGUgbW9kZSB3YXMgYmVmb3JlXG5cdFx0fVxuXG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXG5cdFx0XHRnZXRTaGltOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIERvbS5nZXQodGhpcy51aWQpO1xuXHRcdFx0fSxcblxuXHRcdFx0c2hpbUV4ZWM6IGZ1bmN0aW9uKGNvbXBvbmVudCwgYWN0aW9uKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdFx0XHRyZXR1cm4gSS5nZXRTaGltKCkuZXhlYyh0aGlzLnVpZCwgY29tcG9uZW50LCBhY3Rpb24sIGFyZ3MpO1xuXHRcdFx0fSxcblxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBodG1sLCBlbCwgY29udGFpbmVyO1xuXG5cdFx0XHRcdGNvbnRhaW5lciA9IHRoaXMuZ2V0U2hpbUNvbnRhaW5lcigpO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCB0aGUgbWluaW1hbCBoZWlnaHQsIHNoaW1zIGFyZSBub3QgaW5pdGlhbGl6ZWQgaW4gb2xkZXIgYnJvd3NlcnMgKGUuZyBGRjMuNiwgSUU2LDcsOCwgU2FmYXJpIDQuMCw1LjAsIGV0Yylcblx0XHRcdFx0QmFzaWMuZXh0ZW5kKGNvbnRhaW5lci5zdHlsZSwge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdHRvcDogJy04cHgnLFxuXHRcdFx0XHRcdGxlZnQ6ICctOHB4Jyxcblx0XHRcdFx0XHR3aWR0aDogJzlweCcsXG5cdFx0XHRcdFx0aGVpZ2h0OiAnOXB4Jyxcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbidcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gaW5zZXJ0IGZsYXNoIG9iamVjdFxuXHRcdFx0XHRodG1sID0gJzxvYmplY3QgaWQ9XCInICsgdGhpcy51aWQgKyAnXCIgdHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCIgZGF0YT1cIicgKyAgb3B0aW9ucy5zd2ZfdXJsICsgJ1wiICc7XG5cblx0XHRcdFx0aWYgKEVudi5icm93c2VyID09PSAnSUUnKSB7XG5cdFx0XHRcdFx0aHRtbCArPSAnY2xhc3NpZD1cImNsc2lkOmQyN2NkYjZlLWFlNmQtMTFjZi05NmI4LTQ0NDU1MzU0MDAwMFwiICc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRodG1sICs9ICd3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgc3R5bGU9XCJvdXRsaW5lOjBcIj4nICArXG5cdFx0XHRcdFx0JzxwYXJhbSBuYW1lPVwibW92aWVcIiB2YWx1ZT1cIicgKyBvcHRpb25zLnN3Zl91cmwgKyAnXCIgLz4nICtcblx0XHRcdFx0XHQnPHBhcmFtIG5hbWU9XCJmbGFzaHZhcnNcIiB2YWx1ZT1cInVpZD0nICsgZXNjYXBlKHRoaXMudWlkKSArICcmdGFyZ2V0PScgKyBFbnYuZ2xvYmFsX2V2ZW50X2Rpc3BhdGNoZXIgKyAnXCIgLz4nICtcblx0XHRcdFx0XHQnPHBhcmFtIG5hbWU9XCJ3bW9kZVwiIHZhbHVlPVwidHJhbnNwYXJlbnRcIiAvPicgK1xuXHRcdFx0XHRcdCc8cGFyYW0gbmFtZT1cImFsbG93c2NyaXB0YWNjZXNzXCIgdmFsdWU9XCJhbHdheXNcIiAvPicgK1xuXHRcdFx0XHQnPC9vYmplY3Q+JztcblxuXHRcdFx0XHRpZiAoRW52LmJyb3dzZXIgPT09ICdJRScpIHtcblx0XHRcdFx0XHRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG5cdFx0XHRcdFx0ZWwub3V0ZXJIVE1MID0gaHRtbDtcblx0XHRcdFx0XHRlbCA9IGNvbnRhaW5lciA9IG51bGw7IC8vIGp1c3QgaW4gY2FzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSW5pdCBpcyBkaXNwYXRjaGVkIGJ5IHRoZSBzaGltXG5cdFx0XHRcdGluaXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKEkgJiYgIUkuaW5pdGlhbGl6ZWQpIHsgLy8gcnVudGltZSBtaWdodCBiZSBhbHJlYWR5IGRlc3Ryb3llZCBieSB0aGlzIG1vbWVudFxuXHRcdFx0XHRcdFx0SS50cmlnZ2VyKFwiRXJyb3JcIiwgbmV3IHguUnVudGltZUVycm9yKHguUnVudGltZUVycm9yLk5PVF9JTklUX0VSUikpO1xuXG5cdFx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRcdEVudi5sb2coXCJcXHRGbGFzaCBmYWlsZWQgdG8gaW5pdGlhbGl6ZSB3aXRoaW4gYSBzcGVjaWZpZWQgcGVyaW9kIG9mIHRpbWUgKHR5cGljYWxseSA1cykuXCIpO1x0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCA1MDAwKTtcblx0XHRcdH0sXG5cblx0XHRcdGRlc3Ryb3k6IChmdW5jdGlvbihkZXN0cm95KSB7IC8vIGV4dGVuZCBkZWZhdWx0IGRlc3Ryb3kgbWV0aG9kXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZW1vdmVTV0YoSS51aWQpOyAvLyBTV0YgcmVtb3ZhbCByZXF1aXJlcyBzcGVjaWFsIGNhcmUgaW4gSUVcblxuXHRcdFx0XHRcdGRlc3Ryb3kuY2FsbChJKTtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoaW5pdFRpbWVyKTsgLy8gaW5pdGlhbGl6YXRpb24gY2hlY2sgbWlnaHQgYmUgc3RpbGwgb253YWl0XG5cdFx0XHRcdFx0b3B0aW9ucyA9IGluaXRUaW1lciA9IGRlc3Ryb3kgPSBJID0gbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdH0odGhpcy5kZXN0cm95KSlcblxuXHRcdH0sIGV4dGVuc2lvbnMpO1xuXHR9XG5cblx0UnVudGltZS5hZGRDb25zdHJ1Y3Rvcih0eXBlLCBGbGFzaFJ1bnRpbWUpO1xuXG5cdHJldHVybiBleHRlbnNpb25zO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvZmxhc2gvZmlsZS9CbG9iLmpzXG5cbi8qKlxuICogQmxvYi5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2ZsYXNoL2ZpbGUvQmxvYlxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2ZsYXNoL2ZpbGUvQmxvYlwiLCBbXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9SdW50aW1lXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJsb2IpIHtcblxuXHR2YXIgRmxhc2hCbG9iID0ge1xuXHRcdHNsaWNlOiBmdW5jdGlvbihibG9iLCBzdGFydCwgZW5kLCB0eXBlKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpO1xuXG5cdFx0XHRpZiAoc3RhcnQgPCAwKSB7XG5cdFx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoYmxvYi5zaXplICsgc3RhcnQsIDApO1xuXHRcdFx0fSBlbHNlIGlmIChzdGFydCA+IDApIHtcblx0XHRcdFx0c3RhcnQgPSBNYXRoLm1pbihzdGFydCwgYmxvYi5zaXplKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVuZCA8IDApIHtcblx0XHRcdFx0ZW5kID0gTWF0aC5tYXgoYmxvYi5zaXplICsgZW5kLCAwKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID4gMCkge1xuXHRcdFx0XHRlbmQgPSBNYXRoLm1pbihlbmQsIGJsb2Iuc2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGJsb2IgPSBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ0Jsb2InLCAnc2xpY2UnLCBzdGFydCwgZW5kLCB0eXBlIHx8ICcnKTtcblxuXHRcdFx0aWYgKGJsb2IpIHtcblx0XHRcdFx0YmxvYiA9IG5ldyBCbG9iKHNlbGYudWlkLCBibG9iKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBibG9iO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuQmxvYiA9IEZsYXNoQmxvYik7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVJbnB1dC5qc1xuXG4vKipcbiAqIEZpbGVJbnB1dC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2ZsYXNoL2ZpbGUvRmlsZUlucHV0XG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlSW5wdXRcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvUnVudGltZVwiLFxuXHRcIm1veGllL2ZpbGUvRmlsZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgRmlsZSwgQmFzaWMpIHtcblx0XG5cdHZhciBGaWxlSW5wdXQgPSB7XHRcdFxuXHRcdGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdHZhciBjb21wID0gdGhpcywgSSA9IHRoaXMuZ2V0UnVudGltZSgpO1xuXG5cdFx0XHR0aGlzLmJpbmQoXCJDaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBmaWxlcyA9IEkuc2hpbUV4ZWMuY2FsbChjb21wLCAnRmlsZUlucHV0JywgJ2dldEZpbGVzJyk7XG5cdFx0XHRcdGNvbXAuZmlsZXMgPSBbXTtcblx0XHRcdFx0QmFzaWMuZWFjaChmaWxlcywgZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRcdGNvbXAuZmlsZXMucHVzaChuZXcgRmlsZShJLnVpZCwgZmlsZSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sIDk5OSk7XG5cblx0XHRcdHRoaXMuZ2V0UnVudGltZSgpLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ZpbGVJbnB1dCcsICdpbml0Jywge1xuXHRcdFx0XHRhY2NlcHQ6IG9wdGlvbnMuYWNjZXB0LFxuXHRcdFx0XHRtdWx0aXBsZTogb3B0aW9ucy5tdWx0aXBsZVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMudHJpZ2dlcigncmVhZHknKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVJbnB1dCA9IEZpbGVJbnB1dCk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVSZWFkZXIuanNcblxuLyoqXG4gKiBGaWxlUmVhZGVyLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlUmVhZGVyXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlUmVhZGVyXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VuY29kZVwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBFbmNvZGUpIHtcblxuXHRmdW5jdGlvbiBfZm9ybWF0RGF0YShkYXRhLCBvcCkge1xuXHRcdHN3aXRjaCAob3ApIHtcblx0XHRcdGNhc2UgJ3JlYWRBc1RleHQnOlxuXHRcdFx0XHRyZXR1cm4gRW5jb2RlLmF0b2IoZGF0YSwgJ3V0ZjgnKTtcblx0XHRcdGNhc2UgJ3JlYWRBc0JpbmFyeVN0cmluZyc6XG5cdFx0XHRcdHJldHVybiBFbmNvZGUuYXRvYihkYXRhKTtcblx0XHRcdGNhc2UgJ3JlYWRBc0RhdGFVUkwnOlxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgRmlsZVJlYWRlciA9IHtcblx0XHRyZWFkOiBmdW5jdGlvbihvcCwgYmxvYikge1xuXHRcdFx0dmFyIGNvbXAgPSB0aGlzO1xuXG5cdFx0XHRjb21wLnJlc3VsdCA9ICcnO1xuXG5cdFx0XHQvLyBzcGVjaWFsIHByZWZpeCBmb3IgRGF0YVVSTCByZWFkIG1vZGVcblx0XHRcdGlmIChvcCA9PT0gJ3JlYWRBc0RhdGFVUkwnKSB7XG5cdFx0XHRcdGNvbXAucmVzdWx0ID0gJ2RhdGE6JyArIChibG9iLnR5cGUgfHwgJycpICsgJztiYXNlNjQsJztcblx0XHRcdH1cblxuXHRcdFx0Y29tcC5iaW5kKCdQcm9ncmVzcycsIGZ1bmN0aW9uKGUsIGRhdGEpIHtcblx0XHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0XHRjb21wLnJlc3VsdCArPSBfZm9ybWF0RGF0YShkYXRhLCBvcCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDk5OSk7XG5cblx0XHRcdHJldHVybiBjb21wLmdldFJ1bnRpbWUoKS5zaGltRXhlYy5jYWxsKHRoaXMsICdGaWxlUmVhZGVyJywgJ3JlYWRBc0Jhc2U2NCcsIGJsb2IudWlkKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVSZWFkZXIgPSBGaWxlUmVhZGVyKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2ZsYXNoL2ZpbGUvRmlsZVJlYWRlclN5bmMuanNcblxuLyoqXG4gKiBGaWxlUmVhZGVyU3luYy5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2ZsYXNoL2ZpbGUvRmlsZVJlYWRlclN5bmNcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVSZWFkZXJTeW5jXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VuY29kZVwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBFbmNvZGUpIHtcblx0XG5cdGZ1bmN0aW9uIF9mb3JtYXREYXRhKGRhdGEsIG9wKSB7XG5cdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0Y2FzZSAncmVhZEFzVGV4dCc6XG5cdFx0XHRcdHJldHVybiBFbmNvZGUuYXRvYihkYXRhLCAndXRmOCcpO1xuXHRcdFx0Y2FzZSAncmVhZEFzQmluYXJ5U3RyaW5nJzpcblx0XHRcdFx0cmV0dXJuIEVuY29kZS5hdG9iKGRhdGEpO1xuXHRcdFx0Y2FzZSAncmVhZEFzRGF0YVVSTCc6XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBGaWxlUmVhZGVyU3luYyA9IHtcblx0XHRyZWFkOiBmdW5jdGlvbihvcCwgYmxvYikge1xuXHRcdFx0dmFyIHJlc3VsdCwgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpO1xuXG5cdFx0XHRyZXN1bHQgPSBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ZpbGVSZWFkZXJTeW5jJywgJ3JlYWRBc0Jhc2U2NCcsIGJsb2IudWlkKTtcblx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdHJldHVybiBudWxsOyAvLyBvciB0aHJvdyBleFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzcGVjaWFsIHByZWZpeCBmb3IgRGF0YVVSTCByZWFkIG1vZGVcblx0XHRcdGlmIChvcCA9PT0gJ3JlYWRBc0RhdGFVUkwnKSB7XG5cdFx0XHRcdHJlc3VsdCA9ICdkYXRhOicgKyAoYmxvYi50eXBlIHx8ICcnKSArICc7YmFzZTY0LCcgKyByZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfZm9ybWF0RGF0YShyZXN1bHQsIG9wLCBibG9iLnR5cGUpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZVJlYWRlclN5bmMgPSBGaWxlUmVhZGVyU3luYyk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9mbGFzaC9ydW50aW1lL1RyYW5zcG9ydGVyLmpzXG5cbi8qKlxuICogVHJhbnNwb3J0ZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9mbGFzaC9ydW50aW1lL1RyYW5zcG9ydGVyXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvZmxhc2gvcnVudGltZS9UcmFuc3BvcnRlclwiLCBbXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9SdW50aW1lXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJsb2IpIHtcblxuXHR2YXIgVHJhbnNwb3J0ZXIgPSB7XG5cdFx0Z2V0QXNCbG9iOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpXG5cdFx0XHQsIGJsb2IgPSBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ1RyYW5zcG9ydGVyJywgJ2dldEFzQmxvYicsIHR5cGUpXG5cdFx0XHQ7XG5cdFx0XHRpZiAoYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJsb2Ioc2VsZi51aWQsIGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5UcmFuc3BvcnRlciA9IFRyYW5zcG9ydGVyKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2ZsYXNoL3hoci9YTUxIdHRwUmVxdWVzdC5qc1xuXG4vKipcbiAqIFhNTEh0dHBSZXF1ZXN0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvZmxhc2gveGhyL1hNTEh0dHBSZXF1ZXN0XG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvZmxhc2gveGhyL1hNTEh0dHBSZXF1ZXN0XCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlUmVhZGVyU3luY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlUmVhZGVyU3luY1wiLFxuXHRcIm1veGllL3hoci9Gb3JtRGF0YVwiLFxuXHRcIm1veGllL3J1bnRpbWUvVHJhbnNwb3J0ZXJcIixcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL3J1bnRpbWUvVHJhbnNwb3J0ZXJcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmFzaWMsIEJsb2IsIEZpbGUsIEZpbGVSZWFkZXJTeW5jLCBGaWxlUmVhZGVyU3luY0ZsYXNoLCBGb3JtRGF0YSwgVHJhbnNwb3J0ZXIsIFRyYW5zcG9ydGVyRmxhc2gpIHtcblx0XG5cdHZhciBYTUxIdHRwUmVxdWVzdCA9IHtcblxuXHRcdHNlbmQ6IGZ1bmN0aW9uKG1ldGEsIGRhdGEpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLCBzZWxmID0gdGFyZ2V0LmdldFJ1bnRpbWUoKTtcblxuXHRcdFx0ZnVuY3Rpb24gc2VuZCgpIHtcblx0XHRcdFx0bWV0YS50cmFuc3BvcnQgPSBzZWxmLm1vZGU7XG5cdFx0XHRcdHNlbGYuc2hpbUV4ZWMuY2FsbCh0YXJnZXQsICdYTUxIdHRwUmVxdWVzdCcsICdzZW5kJywgbWV0YSwgZGF0YSk7XG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gYXBwZW5kQmxvYihuYW1lLCBibG9iKSB7XG5cdFx0XHRcdHNlbGYuc2hpbUV4ZWMuY2FsbCh0YXJnZXQsICdYTUxIdHRwUmVxdWVzdCcsICdhcHBlbmRCbG9iJywgbmFtZSwgYmxvYi51aWQpO1xuXHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdFx0c2VuZCgpO1xuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIGF0dGFjaEJsb2IoYmxvYiwgY2IpIHtcblx0XHRcdFx0dmFyIHRyID0gbmV3IFRyYW5zcG9ydGVyKCk7XG5cblx0XHRcdFx0dHIuYmluZChcIlRyYW5zcG9ydGluZ0NvbXBsZXRlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNiKHRoaXMucmVzdWx0KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dHIudHJhbnNwb3J0KGJsb2IuZ2V0U291cmNlKCksIGJsb2IudHlwZSwge1xuXHRcdFx0XHRcdHJ1aWQ6IHNlbGYudWlkXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IG92ZXIgdGhlIGhlYWRlcnMgaWYgYW55XG5cdFx0XHRpZiAoIUJhc2ljLmlzRW1wdHlPYmoobWV0YS5oZWFkZXJzKSkge1xuXHRcdFx0XHRCYXNpYy5lYWNoKG1ldGEuaGVhZGVycywgZnVuY3Rpb24odmFsdWUsIGhlYWRlcikge1xuXHRcdFx0XHRcdHNlbGYuc2hpbUV4ZWMuY2FsbCh0YXJnZXQsICdYTUxIdHRwUmVxdWVzdCcsICdzZXRSZXF1ZXN0SGVhZGVyJywgaGVhZGVyLCB2YWx1ZS50b1N0cmluZygpKTsgLy8gU2lsdmVybGlnaHQgZG9lc24ndCBhY2NlcHQgaW50ZWdlcnMgaW50byB0aGUgYXJndW1lbnRzIG9mIHR5cGUgb2JqZWN0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cmFuc2ZlciBvdmVyIG11bHRpcGFydCBwYXJhbXMgYW5kIGJsb2IgaXRzZWxmXG5cdFx0XHRpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdHZhciBibG9iRmllbGQ7XG5cdFx0XHRcdGRhdGEuZWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRcdGJsb2JGaWVsZCA9IG5hbWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuc2hpbUV4ZWMuY2FsbCh0YXJnZXQsICdYTUxIdHRwUmVxdWVzdCcsICdhcHBlbmQnLCBuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoIWRhdGEuaGFzQmxvYigpKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IG51bGw7XG5cdFx0XHRcdFx0c2VuZCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBibG9iID0gZGF0YS5nZXRCbG9iKCk7XG5cdFx0XHRcdFx0aWYgKGJsb2IuaXNEZXRhY2hlZCgpKSB7XG5cdFx0XHRcdFx0XHRhdHRhY2hCbG9iKGJsb2IsIGZ1bmN0aW9uKGF0dGFjaGVkQmxvYikge1xuXHRcdFx0XHRcdFx0XHRibG9iLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0YXBwZW5kQmxvYihibG9iRmllbGQsIGF0dGFjaGVkQmxvYik7XHRcdFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFwcGVuZEJsb2IoYmxvYkZpZWxkLCBibG9iKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0aWYgKGRhdGEuaXNEZXRhY2hlZCgpKSB7XG5cdFx0XHRcdFx0YXR0YWNoQmxvYihkYXRhLCBmdW5jdGlvbihhdHRhY2hlZEJsb2IpIHtcblx0XHRcdFx0XHRcdGRhdGEuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0ZGF0YSA9IGF0dGFjaGVkQmxvYi51aWQ7XG5cdFx0XHRcdFx0XHRzZW5kKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGEudWlkO1xuXHRcdFx0XHRcdHNlbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VuZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHR2YXIgZnJzLCBibG9iLCBzZWxmID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cblx0XHRcdGJsb2IgPSBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ1hNTEh0dHBSZXF1ZXN0JywgJ2dldFJlc3BvbnNlQXNCbG9iJyk7XG5cblx0XHRcdGlmIChibG9iKSB7XG5cdFx0XHRcdGJsb2IgPSBuZXcgRmlsZShzZWxmLnVpZCwgYmxvYik7XG5cblx0XHRcdFx0aWYgKCdibG9iJyA9PT0gcmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJsb2I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkgeyBcblx0XHRcdFx0XHRmcnMgPSBuZXcgRmlsZVJlYWRlclN5bmMoKTtcblxuXHRcdFx0XHRcdGlmICghIX5CYXNpYy5pbkFycmF5KHJlc3BvbnNlVHlwZSwgW1wiXCIsIFwidGV4dFwiXSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmcnMucmVhZEFzVGV4dChibG9iKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCdqc29uJyA9PT0gcmVzcG9uc2VUeXBlICYmICEhd2luZG93LkpTT04pIHtcblx0XHRcdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGZycy5yZWFkQXNUZXh0KGJsb2IpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0YmxvYi5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHRhYm9ydDogZnVuY3Rpb24odXBsb2FkX2NvbXBsZXRlX2ZsYWcpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cblx0XHRcdHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnWE1MSHR0cFJlcXVlc3QnLCAnYWJvcnQnKTtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJyk7XG5cdFx0XHQvLyB0aGlzLmRpc3BhdGNoRXZlbnQoJ3Byb2dyZXNzJyk7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoJ2Fib3J0Jyk7XG5cblx0XHRcdC8vaWYgKCF1cGxvYWRfY29tcGxldGVfZmxhZykge1xuXHRcdFx0XHQvLyB0aGlzLmRpc3BhdGNoRXZlbnQoJ3VwbG9hZHByb2dyZXNzJyk7XG5cdFx0XHQvL31cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIChleHRlbnNpb25zLlhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3QpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvZmxhc2gvaW1hZ2UvSW1hZ2UuanNcblxuLyoqXG4gKiBJbWFnZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2ZsYXNoL2ltYWdlL0ltYWdlXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvZmxhc2gvaW1hZ2UvSW1hZ2VcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9ydW50aW1lL1RyYW5zcG9ydGVyXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlUmVhZGVyU3luY1wiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgVHJhbnNwb3J0ZXIsIEJsb2IsIEZpbGVSZWFkZXJTeW5jKSB7XG5cdFxuXHR2YXIgSW1hZ2UgPSB7XG5cdFx0bG9hZEZyb21CbG9iOiBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHR2YXIgY29tcCA9IHRoaXMsIHNlbGYgPSBjb21wLmdldFJ1bnRpbWUoKTtcblxuXHRcdFx0ZnVuY3Rpb24gZXhlYyhzcmNCbG9iKSB7XG5cdFx0XHRcdHNlbGYuc2hpbUV4ZWMuY2FsbChjb21wLCAnSW1hZ2UnLCAnbG9hZEZyb21CbG9iJywgc3JjQmxvYi51aWQpO1xuXHRcdFx0XHRjb21wID0gc2VsZiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChibG9iLmlzRGV0YWNoZWQoKSkgeyAvLyBiaW5hcnkgc3RyaW5nXG5cdFx0XHRcdHZhciB0ciA9IG5ldyBUcmFuc3BvcnRlcigpO1xuXHRcdFx0XHR0ci5iaW5kKFwiVHJhbnNwb3J0aW5nQ29tcGxldGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZXhlYyh0ci5yZXN1bHQuZ2V0U291cmNlKCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dHIudHJhbnNwb3J0KGJsb2IuZ2V0U291cmNlKCksIGJsb2IudHlwZSwgeyBydWlkOiBzZWxmLnVpZCB9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4ZWMoYmxvYi5nZXRTb3VyY2UoKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGxvYWRGcm9tSW1hZ2U6IGZ1bmN0aW9uKGltZykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblx0XHRcdHJldHVybiBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ltYWdlJywgJ2xvYWRGcm9tSW1hZ2UnLCBpbWcudWlkKTtcblx0XHR9LFxuXG5cdFx0Z2V0SW5mbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpXG5cdFx0XHQsIGluZm8gPSBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ltYWdlJywgJ2dldEluZm8nKVxuXHRcdFx0O1xuXG5cdFx0XHRpZiAoaW5mby5tZXRhICYmIGluZm8ubWV0YS50aHVtYiAmJiBpbmZvLm1ldGEudGh1bWIuZGF0YSAmJiAhKHNlbGYubWV0YS50aHVtYi5kYXRhIGluc3RhbmNlb2YgQmxvYikpIHtcblx0XHRcdFx0aW5mby5tZXRhLnRodW1iLmRhdGEgPSBuZXcgQmxvYihzZWxmLnVpZCwgaW5mby5tZXRhLnRodW1iLmRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluZm87XG5cdFx0fSxcblxuXHRcdGdldEFzQmxvYjogZnVuY3Rpb24odHlwZSwgcXVhbGl0eSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLmdldFJ1bnRpbWUoKVxuXHRcdFx0LCBibG9iID0gc2VsZi5zaGltRXhlYy5jYWxsKHRoaXMsICdJbWFnZScsICdnZXRBc0Jsb2InLCB0eXBlLCBxdWFsaXR5KVxuXHRcdFx0O1xuXHRcdFx0aWYgKGJsb2IpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBCbG9iKHNlbGYudWlkLCBibG9iKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHRnZXRBc0RhdGFVUkw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLmdldFJ1bnRpbWUoKVxuXHRcdFx0LCBibG9iID0gc2VsZi5JbWFnZS5nZXRBc0Jsb2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHRcdFx0LCBmcnNcblx0XHRcdDtcblx0XHRcdGlmICghYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGZycyA9IG5ldyBGaWxlUmVhZGVyU3luYygpO1xuXHRcdFx0cmV0dXJuIGZycy5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuSW1hZ2UgPSBJbWFnZSk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lLmpzXG5cbi8qKlxuICogUnVuVGltZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKmdsb2JhbCBBY3RpdmVYT2JqZWN0OnRydWUgKi9cblxuLyoqXG5EZWZpbmVzIGNvbnN0cnVjdG9yIGZvciBTaWx2ZXJsaWdodCBydW50aW1lLlxuXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvUnVudGltZVwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCIsXG5cdFwibW94aWUvY29yZS91dGlscy9Eb21cIixcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIEVudiwgRG9tLCB4LCBSdW50aW1lKSB7XG5cdFxuXHR2YXIgdHlwZSA9IFwic2lsdmVybGlnaHRcIiwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGlzSW5zdGFsbGVkKHZlcnNpb24pIHtcblx0XHR2YXIgaXNWZXJzaW9uU3VwcG9ydGVkID0gZmFsc2UsIGNvbnRyb2wgPSBudWxsLCBhY3R1YWxWZXIsXG5cdFx0XHRhY3R1YWxWZXJBcnJheSwgcmVxVmVyQXJyYXksIHJlcXVpcmVkVmVyc2lvblBhcnQsIGFjdHVhbFZlcnNpb25QYXJ0LCBpbmRleCA9IDA7XG5cblx0XHR0cnkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29udHJvbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdBZ0NvbnRyb2wuQWdDb250cm9sJyk7XG5cblx0XHRcdFx0aWYgKGNvbnRyb2wuSXNWZXJzaW9uU3VwcG9ydGVkKHZlcnNpb24pKSB7XG5cdFx0XHRcdFx0aXNWZXJzaW9uU3VwcG9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRyb2wgPSBudWxsO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR2YXIgcGx1Z2luID0gbmF2aWdhdG9yLnBsdWdpbnNbXCJTaWx2ZXJsaWdodCBQbHVnLUluXCJdO1xuXG5cdFx0XHRcdGlmIChwbHVnaW4pIHtcblx0XHRcdFx0XHRhY3R1YWxWZXIgPSBwbHVnaW4uZGVzY3JpcHRpb247XG5cblx0XHRcdFx0XHRpZiAoYWN0dWFsVmVyID09PSBcIjEuMC4zMDIyNi4yXCIpIHtcblx0XHRcdFx0XHRcdGFjdHVhbFZlciA9IFwiMi4wLjMwMjI2LjJcIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRhY3R1YWxWZXJBcnJheSA9IGFjdHVhbFZlci5zcGxpdChcIi5cIik7XG5cblx0XHRcdFx0XHR3aGlsZSAoYWN0dWFsVmVyQXJyYXkubGVuZ3RoID4gMykge1xuXHRcdFx0XHRcdFx0YWN0dWFsVmVyQXJyYXkucG9wKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d2hpbGUgKCBhY3R1YWxWZXJBcnJheS5sZW5ndGggPCA0KSB7XG5cdFx0XHRcdFx0XHRhY3R1YWxWZXJBcnJheS5wdXNoKDApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlcVZlckFycmF5ID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG5cblx0XHRcdFx0XHR3aGlsZSAocmVxVmVyQXJyYXkubGVuZ3RoID4gNCkge1xuXHRcdFx0XHRcdFx0cmVxVmVyQXJyYXkucG9wKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0cmVxdWlyZWRWZXJzaW9uUGFydCA9IHBhcnNlSW50KHJlcVZlckFycmF5W2luZGV4XSwgMTApO1xuXHRcdFx0XHRcdFx0YWN0dWFsVmVyc2lvblBhcnQgPSBwYXJzZUludChhY3R1YWxWZXJBcnJheVtpbmRleF0sIDEwKTtcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0fSB3aGlsZSAoaW5kZXggPCByZXFWZXJBcnJheS5sZW5ndGggJiYgcmVxdWlyZWRWZXJzaW9uUGFydCA9PT0gYWN0dWFsVmVyc2lvblBhcnQpO1xuXG5cdFx0XHRcdFx0aWYgKHJlcXVpcmVkVmVyc2lvblBhcnQgPD0gYWN0dWFsVmVyc2lvblBhcnQgJiYgIWlzTmFOKHJlcXVpcmVkVmVyc2lvblBhcnQpKSB7XG5cdFx0XHRcdFx0XHRpc1ZlcnNpb25TdXBwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUyKSB7XG5cdFx0XHRpc1ZlcnNpb25TdXBwb3J0ZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXNWZXJzaW9uU3VwcG9ydGVkO1xuXHR9XG5cblx0LyoqXG5cdENvbnN0cnVjdG9yIGZvciB0aGUgU2lsdmVybGlnaHQgUnVudGltZVxuXG5cdEBjbGFzcyBTaWx2ZXJsaWdodFJ1bnRpbWVcblx0QGV4dGVuZHMgUnVudGltZVxuXHQqL1xuXHRmdW5jdGlvbiBTaWx2ZXJsaWdodFJ1bnRpbWUob3B0aW9ucykge1xuXHRcdHZhciBJID0gdGhpcywgaW5pdFRpbWVyO1xuXG5cdFx0b3B0aW9ucyA9IEJhc2ljLmV4dGVuZCh7IHhhcF91cmw6IEVudi54YXBfdXJsIH0sIG9wdGlvbnMpO1xuXG5cdFx0UnVudGltZS5jYWxsKHRoaXMsIG9wdGlvbnMsIHR5cGUsIHtcblx0XHRcdGFjY2Vzc19iaW5hcnk6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdGFjY2Vzc19pbWFnZV9iaW5hcnk6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdGRpc3BsYXlfbWVkaWE6IFJ1bnRpbWUuY2FwVGVzdChkZWZpbmVkKCdtb3hpZS9pbWFnZS9JbWFnZScpKSxcblx0XHRcdGRvX2NvcnM6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdGRyYWdfYW5kX2Ryb3A6IGZhbHNlLFxuXHRcdFx0cmVwb3J0X3VwbG9hZF9wcm9ncmVzczogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0cmVzaXplX2ltYWdlOiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRyZXR1cm5fcmVzcG9uc2VfaGVhZGVyczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEkubW9kZSA9PT0gJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX3R5cGU6IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRpZiAocmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gISF3aW5kb3cuSlNPTjtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJldHVybl9zdGF0dXNfY29kZTogZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gSS5tb2RlID09PSAnY2xpZW50JyB8fCAhQmFzaWMuYXJyYXlEaWZmKGNvZGUsIFsyMDAsIDQwNF0pO1xuXHRcdFx0fSxcblx0XHRcdHNlbGVjdF9maWxlOiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRzZWxlY3RfbXVsdGlwbGU6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdHNlbmRfYmluYXJ5X3N0cmluZzogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0c2VuZF9icm93c2VyX2Nvb2tpZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBJLm1vZGUgPT09ICdicm93c2VyJztcblx0XHRcdH0sXG5cdFx0XHRzZW5kX2N1c3RvbV9oZWFkZXJzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnY2xpZW50Jztcblx0XHRcdH0sXG5cdFx0XHRzZW5kX211bHRpcGFydDogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0c2xpY2VfYmxvYjogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0c3RyZWFtX3VwbG9hZDogdHJ1ZSxcblx0XHRcdHN1bW1vbl9maWxlX2RpYWxvZzogZmFsc2UsXG5cdFx0XHR1cGxvYWRfZmlsZXNpemU6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdHVzZV9odHRwX21ldGhvZDogZnVuY3Rpb24obWV0aG9kcykge1xuXHRcdFx0XHRyZXR1cm4gSS5tb2RlID09PSAnY2xpZW50JyB8fCAhQmFzaWMuYXJyYXlEaWZmKG1ldGhvZHMsIFsnR0VUJywgJ1BPU1QnXSk7XG5cdFx0XHR9XG5cdFx0fSwgeyBcblx0XHRcdC8vIGNhcGFiaWxpdGllcyB0aGF0IHJlcXVpcmUgc3BlY2lmaWMgbW9kZVxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX2hlYWRlcnM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICdjbGllbnQnIDogJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdHJldHVybl9zdGF0dXNfY29kZTogZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gQmFzaWMuYXJyYXlEaWZmKGNvZGUsIFsyMDAsIDQwNF0pID8gJ2NsaWVudCcgOiBbJ2NsaWVudCcsICdicm93c2VyJ107XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9icm93c2VyX2Nvb2tpZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICdicm93c2VyJyA6ICdjbGllbnQnO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRfY3VzdG9tX2hlYWRlcnM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICdjbGllbnQnIDogJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdHVzZV9odHRwX21ldGhvZDogZnVuY3Rpb24obWV0aG9kcykge1xuXHRcdFx0XHRyZXR1cm4gQmFzaWMuYXJyYXlEaWZmKG1ldGhvZHMsIFsnR0VUJywgJ1BPU1QnXSkgPyAnY2xpZW50JyA6IFsnY2xpZW50JywgJ2Jyb3dzZXInXTtcblx0XHRcdH1cblx0XHR9KTtcblxuXG5cdFx0Ly8gbWluaW1hbCByZXF1aXJlbWVudFxuXHRcdGlmICghaXNJbnN0YWxsZWQoJzIuMC4zMTAwNS4wJykgfHwgRW52LmJyb3dzZXIgPT09ICdPcGVyYScpIHtcblx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0RW52LmxvZyhcIlxcdFNpbHZlcmxpZ2h0IGlzIG5vdCBpbnN0YWxsZWQgb3IgbWluaW1hbCB2ZXJzaW9uICgyLjAuMzEwMDUuMCkgcmVxdWlyZW1lbnQgbm90IG1ldCAobm90IGxpa2VseSkuXCIpO1x0XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9kZSA9IGZhbHNlO1xuXHRcdH1cblxuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdGdldFNoaW06IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gRG9tLmdldCh0aGlzLnVpZCkuY29udGVudC5Nb3hpZTtcblx0XHRcdH0sXG5cblx0XHRcdHNoaW1FeGVjOiBmdW5jdGlvbihjb21wb25lbnQsIGFjdGlvbikge1xuXHRcdFx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRcdFx0cmV0dXJuIEkuZ2V0U2hpbSgpLmV4ZWModGhpcy51aWQsIGNvbXBvbmVudCwgYWN0aW9uLCBhcmdzKTtcblx0XHRcdH0sXG5cblx0XHRcdGluaXQgOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNvbnRhaW5lcjtcblxuXHRcdFx0XHRjb250YWluZXIgPSB0aGlzLmdldFNoaW1Db250YWluZXIoKTtcblxuXHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gJzxvYmplY3QgaWQ9XCInICsgdGhpcy51aWQgKyAnXCIgZGF0YT1cImRhdGE6YXBwbGljYXRpb24veC1zaWx2ZXJsaWdodCxcIiB0eXBlPVwiYXBwbGljYXRpb24veC1zaWx2ZXJsaWdodC0yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHN0eWxlPVwib3V0bGluZTpub25lO1wiPicgK1xuXHRcdFx0XHRcdCc8cGFyYW0gbmFtZT1cInNvdXJjZVwiIHZhbHVlPVwiJyArIG9wdGlvbnMueGFwX3VybCArICdcIi8+JyArXG5cdFx0XHRcdFx0JzxwYXJhbSBuYW1lPVwiYmFja2dyb3VuZFwiIHZhbHVlPVwiVHJhbnNwYXJlbnRcIi8+JyArXG5cdFx0XHRcdFx0JzxwYXJhbSBuYW1lPVwid2luZG93bGVzc1wiIHZhbHVlPVwidHJ1ZVwiLz4nICtcblx0XHRcdFx0XHQnPHBhcmFtIG5hbWU9XCJlbmFibGVodG1sYWNjZXNzXCIgdmFsdWU9XCJ0cnVlXCIvPicgK1xuXHRcdFx0XHRcdCc8cGFyYW0gbmFtZT1cImluaXRQYXJhbXNcIiB2YWx1ZT1cInVpZD0nICsgdGhpcy51aWQgKyAnLHRhcmdldD0nICsgRW52Lmdsb2JhbF9ldmVudF9kaXNwYXRjaGVyICsgJ1wiLz4nICtcblx0XHRcdFx0Jzwvb2JqZWN0Pic7XG5cblx0XHRcdFx0Ly8gSW5pdCBpcyBkaXNwYXRjaGVkIGJ5IHRoZSBzaGltXG5cdFx0XHRcdGluaXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKEkgJiYgIUkuaW5pdGlhbGl6ZWQpIHsgLy8gcnVudGltZSBtaWdodCBiZSBhbHJlYWR5IGRlc3Ryb3llZCBieSB0aGlzIG1vbWVudFxuXHRcdFx0XHRcdFx0SS50cmlnZ2VyKFwiRXJyb3JcIiwgbmV3IHguUnVudGltZUVycm9yKHguUnVudGltZUVycm9yLk5PVF9JTklUX0VSUikpO1xuXG5cdFx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRcdEVudi5sb2coXCJcXFNpbHZlcmxpZ2h0IGZhaWxlZCB0byBpbml0aWFsaXplIHdpdGhpbiBhIHNwZWNpZmllZCBwZXJpb2Qgb2YgdGltZSAoNS0xMHMpLlwiKTtcdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgRW52Lk9TICE9PSAnV2luZG93cyc/IDEwMDAwIDogNTAwMCk7IC8vIGdpdmUgaXQgbW9yZSB0aW1lIHRvIGluaXRpYWxpemUgaW4gbm9uIFdpbmRvd3MgT1MgKGxpa2UgTWFjKVxuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogKGZ1bmN0aW9uKGRlc3Ryb3kpIHsgLy8gZXh0ZW5kIGRlZmF1bHQgZGVzdHJveSBtZXRob2Rcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlc3Ryb3kuY2FsbChJKTtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoaW5pdFRpbWVyKTsgLy8gaW5pdGlhbGl6YXRpb24gY2hlY2sgbWlnaHQgYmUgc3RpbGwgb253YWl0XG5cdFx0XHRcdFx0b3B0aW9ucyA9IGluaXRUaW1lciA9IGRlc3Ryb3kgPSBJID0gbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdH0odGhpcy5kZXN0cm95KSlcblxuXHRcdH0sIGV4dGVuc2lvbnMpO1xuXHR9XG5cblx0UnVudGltZS5hZGRDb25zdHJ1Y3Rvcih0eXBlLCBTaWx2ZXJsaWdodFJ1bnRpbWUpOyBcblxuXHRyZXR1cm4gZXh0ZW5zaW9ucztcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvQmxvYi5qc1xuXG4vKipcbiAqIEJsb2IuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0Jsb2JcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0Jsb2JcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL2ZpbGUvQmxvYlwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgQmxvYikge1xuXHRyZXR1cm4gKGV4dGVuc2lvbnMuQmxvYiA9IEJhc2ljLmV4dGVuZCh7fSwgQmxvYikpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlSW5wdXQuanNcblxuLyoqXG4gKiBGaWxlSW5wdXQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVJbnB1dFxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZUlucHV0XCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEZpbGUsIEJhc2ljKSB7XG5cblx0ZnVuY3Rpb24gdG9GaWx0ZXJzKGFjY2VwdCkge1xuXHRcdHZhciBmaWx0ZXIgPSAnJztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZmlsdGVyICs9IChmaWx0ZXIgIT09ICcnID8gJ3wnIDogJycpICsgYWNjZXB0W2ldLnRpdGxlICsgXCIgfCAqLlwiICsgYWNjZXB0W2ldLmV4dGVuc2lvbnMucmVwbGFjZSgvLC9nLCAnOyouJyk7XG5cdFx0fVxuXHRcdHJldHVybiBmaWx0ZXI7XG5cdH1cblxuXHRcblx0dmFyIEZpbGVJbnB1dCA9IHtcblx0XHRpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHR2YXIgY29tcCA9IHRoaXMsIEkgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblxuXHRcdFx0dGhpcy5iaW5kKFwiQ2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZmlsZXMgPSBJLnNoaW1FeGVjLmNhbGwoY29tcCwgJ0ZpbGVJbnB1dCcsICdnZXRGaWxlcycpO1xuXHRcdFx0XHRjb21wLmZpbGVzID0gW107XG5cdFx0XHRcdEJhc2ljLmVhY2goZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRjb21wLmZpbGVzLnB1c2gobmV3IEZpbGUoSS51aWQsIGZpbGUpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCA5OTkpO1xuXHRcdFx0XG5cdFx0XHRJLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ZpbGVJbnB1dCcsICdpbml0JywgdG9GaWx0ZXJzKG9wdGlvbnMuYWNjZXB0KSwgb3B0aW9ucy5tdWx0aXBsZSk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3JlYWR5Jyk7XG5cdFx0fSxcblxuXHRcdHNldE9wdGlvbjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmIChuYW1lID09ICdhY2NlcHQnKSB7XG5cdFx0XHRcdHZhbHVlID0gdG9GaWx0ZXJzKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZ2V0UnVudGltZSgpLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ZpbGVJbnB1dCcsICdzZXRPcHRpb24nLCBuYW1lLCB2YWx1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5GaWxlSW5wdXQgPSBGaWxlSW5wdXQpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlRHJvcC5qc1xuXG4vKipcbiAqIEZpbGVEcm9wLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlRHJvcFxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZURyb3BcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRG9tXCIsIFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRXZlbnRzXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIERvbSwgRXZlbnRzKSB7XG5cblx0Ly8gbm90IGV4YWN0bHkgdXNlZnVsLCBzaW5jZSB3b3JrcyBvbmx5IGluIHNhZmFyaSAoLi4uY3JpY2tldHMuLi4pXG5cdHZhciBGaWxlRHJvcCA9IHtcblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb21wID0gdGhpcywgc2VsZiA9IGNvbXAuZ2V0UnVudGltZSgpLCBkcm9wWm9uZTtcblxuXHRcdFx0ZHJvcFpvbmUgPSBzZWxmLmdldFNoaW1Db250YWluZXIoKTtcblxuXHRcdFx0RXZlbnRzLmFkZEV2ZW50KGRyb3Bab25lLCAnZHJhZ292ZXInLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0ZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5Jztcblx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0RXZlbnRzLmFkZEV2ZW50KGRyb3Bab25lLCAnZHJhZ2VudGVyJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHZhciBmbGFnID0gRG9tLmdldChzZWxmLnVpZCkuZHJhZ0VudGVyKGUpO1xuXHRcdFx0XHQvLyBJZiBoYW5kbGVkLCB0aGVuIHN0b3AgcHJvcGFnYXRpb24gb2YgZXZlbnQgaW4gRE9NXG5cdFx0XHRcdGlmIChmbGFnKSB7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRFdmVudHMuYWRkRXZlbnQoZHJvcFpvbmUsICdkcm9wJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHZhciBmbGFnID0gRG9tLmdldChzZWxmLnVpZCkuZHJhZ0Ryb3AoZSk7XG5cdFx0XHRcdC8vIElmIGhhbmRsZWQsIHRoZW4gc3RvcCBwcm9wYWdhdGlvbiBvZiBldmVudCBpbiBET01cblx0XHRcdFx0aWYgKGZsYWcpIHtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdHJldHVybiBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ZpbGVEcm9wJywgJ2luaXQnKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVEcm9wID0gRmlsZURyb3ApO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlUmVhZGVyLmpzXG5cbi8qKlxuICogRmlsZVJlYWRlci5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZVJlYWRlclxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZVJlYWRlclwiLCBbXG5cdFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlUmVhZGVyXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJhc2ljLCBGaWxlUmVhZGVyKSB7XG5cdHJldHVybiAoZXh0ZW5zaW9ucy5GaWxlUmVhZGVyID0gQmFzaWMuZXh0ZW5kKHt9LCBGaWxlUmVhZGVyKSk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVSZWFkZXJTeW5jLmpzXG5cbi8qKlxuICogRmlsZVJlYWRlclN5bmMuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVSZWFkZXJTeW5jXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlUmVhZGVyU3luY1wiLCBbXG5cdFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlUmVhZGVyU3luY1wiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgRmlsZVJlYWRlclN5bmMpIHtcblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVSZWFkZXJTeW5jID0gQmFzaWMuZXh0ZW5kKHt9LCBGaWxlUmVhZGVyU3luYykpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvc2lsdmVybGlnaHQvcnVudGltZS9UcmFuc3BvcnRlci5qc1xuXG4vKipcbiAqIFRyYW5zcG9ydGVyLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvcnVudGltZS9UcmFuc3BvcnRlclxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L3J1bnRpbWUvVHJhbnNwb3J0ZXJcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL3J1bnRpbWUvVHJhbnNwb3J0ZXJcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmFzaWMsIFRyYW5zcG9ydGVyKSB7XG5cdHJldHVybiAoZXh0ZW5zaW9ucy5UcmFuc3BvcnRlciA9IEJhc2ljLmV4dGVuZCh7fSwgVHJhbnNwb3J0ZXIpKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL3NpbHZlcmxpZ2h0L3hoci9YTUxIdHRwUmVxdWVzdC5qc1xuXG4vKipcbiAqIFhNTEh0dHBSZXF1ZXN0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQveGhyL1hNTEh0dHBSZXF1ZXN0XG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQveGhyL1hNTEh0dHBSZXF1ZXN0XCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC94aHIvWE1MSHR0cFJlcXVlc3RcIixcblx0XCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZVJlYWRlclN5bmNcIixcblx0XCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L3J1bnRpbWUvVHJhbnNwb3J0ZXJcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmFzaWMsIFhNTEh0dHBSZXF1ZXN0LCBGaWxlUmVhZGVyU3luY1NpbHZlcmxpZ2h0LCBUcmFuc3BvcnRlclNpbHZlcmxpZ2h0KSB7XG5cdHJldHVybiAoZXh0ZW5zaW9ucy5YTUxIdHRwUmVxdWVzdCA9IEJhc2ljLmV4dGVuZCh7fSwgWE1MSHR0cFJlcXVlc3QpKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL3NpbHZlcmxpZ2h0L2ltYWdlL0ltYWdlLmpzXG5cbi8qKlxuICogSW1hZ2UuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cbiBcbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvaW1hZ2UvSW1hZ2VcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9pbWFnZS9JbWFnZVwiLCBbXG5cdFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2ZpbGUvQmxvYlwiLFxuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvaW1hZ2UvSW1hZ2VcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmFzaWMsIEJsb2IsIEltYWdlKSB7XG5cdHJldHVybiAoZXh0ZW5zaW9ucy5JbWFnZSA9IEJhc2ljLmV4dGVuZCh7fSwgSW1hZ2UsIHtcblxuXHRcdGdldEluZm86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLmdldFJ1bnRpbWUoKVxuXHRcdFx0LCBncnBzID0gWyd0aWZmJywgJ2V4aWYnLCAnZ3BzJywgJ3RodW1iJ11cblx0XHRcdCwgaW5mbyA9IHsgbWV0YToge30gfVxuXHRcdFx0LCByYXdJbmZvID0gc2VsZi5zaGltRXhlYy5jYWxsKHRoaXMsICdJbWFnZScsICdnZXRJbmZvJylcblx0XHRcdDtcblxuXHRcdFx0aWYgKHJhd0luZm8ubWV0YSkge1xuXHRcdFx0XHRCYXNpYy5lYWNoKGdycHMsIGZ1bmN0aW9uKGdycCkge1xuXHRcdFx0XHRcdHZhciBtZXRhID0gcmF3SW5mby5tZXRhW2dycF1cblx0XHRcdFx0XHQsIHRhZ1xuXHRcdFx0XHRcdCwgaVxuXHRcdFx0XHRcdCwgbGVuZ3RoXG5cdFx0XHRcdFx0LCB2YWx1ZVxuXHRcdFx0XHRcdDtcblx0XHRcdFx0XHRpZiAobWV0YSAmJiBtZXRhLmtleXMpIHtcblx0XHRcdFx0XHRcdGluZm8ubWV0YVtncnBdID0ge307XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSBtZXRhLmtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dGFnID0gbWV0YS5rZXlzW2ldO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG1ldGFbdGFnXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gY29udmVydCBudW1iZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKC9eKFxcZHxbMS05XVxcZCspJC8udGVzdCh2YWx1ZSkpIHsgLy8gaW50ZWdlciAobWFrZSBzdXJlIGRvZXNuJ3Qgc3RhcnQgd2l0aCB6ZXJvKVxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoL15cXGQqXFwuXFxkKyQvLnRlc3QodmFsdWUpKSB7IC8vIGRvdWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aW5mby5tZXRhW2dycF1bdGFnXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBzYXZlIHRodW1iIGRhdGEgYXMgYmxvYlxuXHRcdFx0XHRpZiAoaW5mby5tZXRhICYmIGluZm8ubWV0YS50aHVtYiAmJiBpbmZvLm1ldGEudGh1bWIuZGF0YSAmJiAhKHNlbGYubWV0YS50aHVtYi5kYXRhIGluc3RhbmNlb2YgQmxvYikpIHtcblx0XHRcdFx0XHRpbmZvLm1ldGEudGh1bWIuZGF0YSA9IG5ldyBCbG9iKHNlbGYudWlkLCBpbmZvLm1ldGEudGh1bWIuZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aW5mby53aWR0aCA9IHBhcnNlSW50KHJhd0luZm8ud2lkdGgsIDEwKTtcblx0XHRcdGluZm8uaGVpZ2h0ID0gcGFyc2VJbnQocmF3SW5mby5oZWlnaHQsIDEwKTtcblx0XHRcdGluZm8uc2l6ZSA9IHBhcnNlSW50KHJhd0luZm8uc2l6ZSwgMTApO1xuXHRcdFx0aW5mby50eXBlID0gcmF3SW5mby50eXBlO1xuXHRcdFx0aW5mby5uYW1lID0gcmF3SW5mby5uYW1lO1xuXG5cdFx0XHRyZXR1cm4gaW5mbztcblx0XHR9LFxuXG5cdFx0cmVzaXplOiBmdW5jdGlvbihyZWN0LCByYXRpbywgb3B0cykge1xuXHRcdFx0dGhpcy5nZXRSdW50aW1lKCkuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnSW1hZ2UnLCAncmVzaXplJywgcmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCByYXRpbywgb3B0cy5wcmVzZXJ2ZUhlYWRlcnMsIG9wdHMucmVzYW1wbGUpO1xuXHRcdH1cblx0fSkpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDQvUnVudGltZS5qc1xuXG4vKipcbiAqIFJ1bnRpbWUuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLypnbG9iYWwgRmlsZTp0cnVlICovXG5cbi8qKlxuRGVmaW5lcyBjb25zdHJ1Y3RvciBmb3IgSFRNTDQgcnVudGltZS5cblxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDQvUnVudGltZVxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw0L1J1bnRpbWVcIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VudlwiXG5dLCBmdW5jdGlvbihCYXNpYywgeCwgUnVudGltZSwgRW52KSB7XG5cdFxuXHR2YXIgdHlwZSA9ICdodG1sNCcsIGV4dGVuc2lvbnMgPSB7fTtcblxuXHRmdW5jdGlvbiBIdG1sNFJ1bnRpbWUob3B0aW9ucykge1xuXHRcdHZhciBJID0gdGhpc1xuXHRcdCwgVGVzdCA9IFJ1bnRpbWUuY2FwVGVzdFxuXHRcdCwgVHJ1ZSA9IFJ1bnRpbWUuY2FwVHJ1ZVxuXHRcdDtcblxuXHRcdFJ1bnRpbWUuY2FsbCh0aGlzLCBvcHRpb25zLCB0eXBlLCB7XG5cdFx0XHRhY2Nlc3NfYmluYXJ5OiBUZXN0KHdpbmRvdy5GaWxlUmVhZGVyIHx8IHdpbmRvdy5GaWxlICYmIEZpbGUuZ2V0QXNEYXRhVVJMKSxcblx0XHRcdGFjY2Vzc19pbWFnZV9iaW5hcnk6IGZhbHNlLFxuXHRcdFx0ZGlzcGxheV9tZWRpYTogVGVzdChcblx0XHRcdFx0KEVudi5jYW4oJ2NyZWF0ZV9jYW52YXMnKSB8fCBFbnYuY2FuKCd1c2VfZGF0YV91cmlfb3ZlcjMya2InKSkgJiYgXG5cdFx0XHRcdGRlZmluZWQoJ21veGllL2ltYWdlL0ltYWdlJylcblx0XHRcdCksXG5cdFx0XHRkb19jb3JzOiBmYWxzZSxcblx0XHRcdGRyYWdfYW5kX2Ryb3A6IGZhbHNlLFxuXHRcdFx0ZmlsdGVyX2J5X2V4dGVuc2lvbjogVGVzdChmdW5jdGlvbigpIHsgLy8gaWYgeW91IGtub3cgaG93IHRvIGZlYXR1cmUtZGV0ZWN0IHRoaXMsIHBsZWFzZSBzdWdnZXN0XG5cdFx0XHRcdHJldHVybiAhKFxuXHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0Nocm9tZScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDI4LCAnPCcpKSB8fCBcblx0XHRcdFx0XHQoRW52LmJyb3dzZXIgPT09ICdJRScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDEwLCAnPCcpKSB8fCBcblx0XHRcdFx0XHQoRW52LmJyb3dzZXIgPT09ICdTYWZhcmknICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCA3LCAnPCcpKSB8fFxuXHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0ZpcmVmb3gnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAzNywgJzwnKSlcblx0XHRcdFx0KTtcblx0XHRcdH0oKSksXG5cdFx0XHRyZXNpemVfaW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5JbWFnZSAmJiBJLmNhbignYWNjZXNzX2JpbmFyeScpICYmIEVudi5jYW4oJ2NyZWF0ZV9jYW52YXMnKTtcblx0XHRcdH0sXG5cdFx0XHRyZXBvcnRfdXBsb2FkX3Byb2dyZXNzOiBmYWxzZSxcblx0XHRcdHJldHVybl9yZXNwb25zZV9oZWFkZXJzOiBmYWxzZSxcblx0XHRcdHJldHVybl9yZXNwb25zZV90eXBlOiBmdW5jdGlvbihyZXNwb25zZVR5cGUpIHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmICEhd2luZG93LkpTT04pIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBcblx0XHRcdFx0cmV0dXJuICEhfkJhc2ljLmluQXJyYXkocmVzcG9uc2VUeXBlLCBbJ3RleHQnLCAnZG9jdW1lbnQnLCAnJ10pO1xuXHRcdFx0fSxcblx0XHRcdHJldHVybl9zdGF0dXNfY29kZTogZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gIUJhc2ljLmFycmF5RGlmZihjb2RlLCBbMjAwLCA0MDRdKTtcblx0XHRcdH0sXG5cdFx0XHRzZWxlY3RfZmlsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBFbnYuY2FuKCd1c2VfZmlsZWlucHV0Jyk7XG5cdFx0XHR9LFxuXHRcdFx0c2VsZWN0X211bHRpcGxlOiBmYWxzZSxcblx0XHRcdHNlbmRfYmluYXJ5X3N0cmluZzogZmFsc2UsXG5cdFx0XHRzZW5kX2N1c3RvbV9oZWFkZXJzOiBmYWxzZSxcblx0XHRcdHNlbmRfbXVsdGlwYXJ0OiB0cnVlLFxuXHRcdFx0c2xpY2VfYmxvYjogZmFsc2UsXG5cdFx0XHRzdHJlYW1fdXBsb2FkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIEkuY2FuKCdzZWxlY3RfZmlsZScpO1xuXHRcdFx0fSxcblx0XHRcdHN1bW1vbl9maWxlX2RpYWxvZzogZnVuY3Rpb24oKSB7IC8vIHllYWguLi4gc29tZSBkaXJ0eSBzbmlmZmluZyBoZXJlLi4uXG5cdFx0XHRcdHJldHVybiBJLmNhbignc2VsZWN0X2ZpbGUnKSAmJiAoXG5cdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnRmlyZWZveCcgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDQsICc+PScpKSB8fFxuXHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ09wZXJhJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMTIsICc+PScpKSB8fFxuXHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0lFJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMTAsICc+PScpKSB8fFxuXHRcdFx0XHRcdCEhfkJhc2ljLmluQXJyYXkoRW52LmJyb3dzZXIsIFsnQ2hyb21lJywgJ1NhZmFyaSddKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSxcblx0XHRcdHVwbG9hZF9maWxlc2l6ZTogVHJ1ZSxcblx0XHRcdHVzZV9odHRwX21ldGhvZDogZnVuY3Rpb24obWV0aG9kcykge1xuXHRcdFx0XHRyZXR1cm4gIUJhc2ljLmFycmF5RGlmZihtZXRob2RzLCBbJ0dFVCcsICdQT1NUJ10pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0aW5pdCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJJbml0XCIpO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogKGZ1bmN0aW9uKGRlc3Ryb3kpIHsgLy8gZXh0ZW5kIGRlZmF1bHQgZGVzdHJveSBtZXRob2Rcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlc3Ryb3kuY2FsbChJKTtcblx0XHRcdFx0XHRkZXN0cm95ID0gSSA9IG51bGw7XG5cdFx0XHRcdH07XG5cdFx0XHR9KHRoaXMuZGVzdHJveSkpXG5cdFx0fSk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcy5nZXRTaGltKCksIGV4dGVuc2lvbnMpO1xuXHR9XG5cblx0UnVudGltZS5hZGRDb25zdHJ1Y3Rvcih0eXBlLCBIdG1sNFJ1bnRpbWUpO1xuXG5cdHJldHVybiBleHRlbnNpb25zO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDQvZmlsZS9GaWxlSW5wdXQuanNcblxuLyoqXG4gKiBGaWxlSW5wdXQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNC9maWxlL0ZpbGVJbnB1dFxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw0L2ZpbGUvRmlsZUlucHV0XCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9Eb21cIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0V2ZW50c1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvTWltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEZpbGUsIEJhc2ljLCBEb20sIEV2ZW50cywgTWltZSwgRW52KSB7XG5cdFxuXHRmdW5jdGlvbiBGaWxlSW5wdXQoKSB7XG5cdFx0dmFyIF91aWQsIF9taW1lcyA9IFtdLCBfb3B0aW9ucywgX2Jyb3dzZUJ0blpJbmRleDsgLy8gc2F2ZSBvcmlnaW5hbCB6LWluZGV4O1xuXG5cdFx0ZnVuY3Rpb24gYWRkSW5wdXQoKSB7XG5cdFx0XHR2YXIgY29tcCA9IHRoaXMsIEkgPSBjb21wLmdldFJ1bnRpbWUoKSwgc2hpbUNvbnRhaW5lciwgYnJvd3NlQnV0dG9uLCBjdXJyRm9ybSwgZm9ybSwgaW5wdXQsIHVpZDtcblxuXHRcdFx0dWlkID0gQmFzaWMuZ3VpZCgndWlkXycpO1xuXG5cdFx0XHRzaGltQ29udGFpbmVyID0gSS5nZXRTaGltQ29udGFpbmVyKCk7IC8vIHdlIGdldCBuZXcgcmVmIGV2ZXJ5IHRpbWUgdG8gYXZvaWQgbWVtb3J5IGxlYWtzIGluIElFXG5cblx0XHRcdGlmIChfdWlkKSB7IC8vIG1vdmUgcHJldmlvdXMgZm9ybSBvdXQgb2YgdGhlIHZpZXdcblx0XHRcdFx0Y3VyckZvcm0gPSBEb20uZ2V0KF91aWQgKyAnX2Zvcm0nKTtcblx0XHRcdFx0aWYgKGN1cnJGb3JtKSB7XG5cdFx0XHRcdFx0QmFzaWMuZXh0ZW5kKGN1cnJGb3JtLnN0eWxlLCB7IHRvcDogJzEwMCUnIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJ1aWxkIGZvcm0gaW4gRE9NLCBzaW5jZSBpbm5lckhUTUwgdmVyc2lvbiBub3QgYWJsZSB0byBzdWJtaXQgZmlsZSBmb3Igc29tZSByZWFzb25cblx0XHRcdGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cdFx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnaWQnLCB1aWQgKyAnX2Zvcm0nKTtcblx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAncG9zdCcpO1xuXHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2VuY3R5cGUnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpO1xuXHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2VuY29kaW5nJywgJ211bHRpcGFydC9mb3JtLWRhdGEnKTtcblxuXHRcdFx0QmFzaWMuZXh0ZW5kKGZvcm0uc3R5bGUsIHtcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0XHRoZWlnaHQ6ICcxMDAlJ1xuXHRcdFx0fSk7XG5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCB1aWQpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSgnYWNjZXB0JywgX21pbWVzLmpvaW4oJywnKSk7XG5cblx0XHRcdEJhc2ljLmV4dGVuZChpbnB1dC5zdHlsZSwge1xuXHRcdFx0XHRmb250U2l6ZTogJzk5OXB4Jyxcblx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0fSk7XG5cblx0XHRcdGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXHRcdFx0c2hpbUNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcblxuXHRcdFx0Ly8gcHJlcGFyZSBmaWxlIGlucHV0IHRvIGJlIHBsYWNlZCB1bmRlcm5lYXRoIHRoZSBicm93c2VfYnV0dG9uIGVsZW1lbnRcblx0XHRcdEJhc2ljLmV4dGVuZChpbnB1dC5zdHlsZSwge1xuXHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0XHRoZWlnaHQ6ICcxMDAlJ1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChFbnYuYnJvd3NlciA9PT0gJ0lFJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMTAsICc8JykpIHtcblx0XHRcdFx0QmFzaWMuZXh0ZW5kKGlucHV0LnN0eWxlLCB7XG5cdFx0XHRcdFx0ZmlsdGVyIDogXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEob3BhY2l0eT0wKVwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkgeyAvLyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgaGFuZGxlciBmb3IgdGhpc1xuXHRcdFx0XHR2YXIgZmlsZTtcblxuXHRcdFx0XHRpZiAoIXRoaXMudmFsdWUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5maWxlcykgeyAvLyBjaGVjayBpZiBicm93c2VyIGlzIGZyZXNoIGVub3VnaFxuXHRcdFx0XHRcdGZpbGUgPSB0aGlzLmZpbGVzWzBdO1xuXG5cdFx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IGZpbGVzIChJRTEwIGZvciBleGFtcGxlIGhhbmdzIGlmIHlvdSB0cnkgdG8gc2VuZCB0aGVtIHZpYSBYSFIpXG5cdFx0XHRcdFx0aWYgKGZpbGUuc2l6ZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Zm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcm0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaWxlID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogdGhpcy52YWx1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWxlID0gbmV3IEZpbGUoSS51aWQsIGZpbGUpO1xuXG5cdFx0XHRcdC8vIGNsZWFyIGV2ZW50IGhhbmRsZXJcblx0XHRcdFx0dGhpcy5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge307IFxuXHRcdFx0XHRhZGRJbnB1dC5jYWxsKGNvbXApOyBcblxuXHRcdFx0XHRjb21wLmZpbGVzID0gW2ZpbGVdO1xuXG5cdFx0XHRcdC8vIHN1YnN0aXR1dGUgYWxsIGlkcyB3aXRoIGZpbGUgdWlkcyAoY29uc2lkZXIgZmlsZS51aWQgcmVhZC1vbmx5IC0gd2UgY2Fubm90IGRvIGl0IHRoZSBvdGhlciB3YXkgYXJvdW5kKVxuXHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ2lkJywgZmlsZS51aWQpO1xuXHRcdFx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnaWQnLCBmaWxlLnVpZCArICdfZm9ybScpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29tcC50cmlnZ2VyKCdjaGFuZ2UnKTtcblxuXHRcdFx0XHRpbnB1dCA9IGZvcm0gPSBudWxsO1xuXHRcdFx0fTtcblxuXG5cdFx0XHQvLyByb3V0ZSBjbGljayBldmVudCB0byB0aGUgaW5wdXRcblx0XHRcdGlmIChJLmNhbignc3VtbW9uX2ZpbGVfZGlhbG9nJykpIHtcblx0XHRcdFx0YnJvd3NlQnV0dG9uID0gRG9tLmdldChfb3B0aW9ucy5icm93c2VfYnV0dG9uKTtcblx0XHRcdFx0RXZlbnRzLnJlbW92ZUV2ZW50KGJyb3dzZUJ1dHRvbiwgJ2NsaWNrJywgY29tcC51aWQpO1xuXHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoYnJvd3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0aWYgKGlucHV0ICYmICFpbnB1dC5kaXNhYmxlZCkgeyAvLyBmb3Igc29tZSByZWFzb24gRkYgKHVwIHRvIDguMC4xIHNvIGZhcikgbGV0cyB0byBjbGljayBkaXNhYmxlZCBpbnB1dFt0eXBlPWZpbGVdXG5cdFx0XHRcdFx0XHRpbnB1dC5jbGljaygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH0sIGNvbXAudWlkKTtcblx0XHRcdH1cblxuXHRcdFx0X3VpZCA9IHVpZDtcblxuXHRcdFx0c2hpbUNvbnRhaW5lciA9IGN1cnJGb3JtID0gYnJvd3NlQnV0dG9uID0gbnVsbDtcblx0XHR9XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgY29tcCA9IHRoaXMsIEkgPSBjb21wLmdldFJ1bnRpbWUoKSwgc2hpbUNvbnRhaW5lcjtcblxuXHRcdFx0XHQvLyBmaWd1cmUgb3V0IGFjY2VwdCBzdHJpbmdcblx0XHRcdFx0X29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0XHRfbWltZXMgPSBvcHRpb25zLmFjY2VwdC5taW1lcyB8fCBNaW1lLmV4dExpc3QybWltZXMob3B0aW9ucy5hY2NlcHQsIEkuY2FuKCdmaWx0ZXJfYnlfZXh0ZW5zaW9uJykpO1xuXG5cdFx0XHRcdHNoaW1Db250YWluZXIgPSBJLmdldFNoaW1Db250YWluZXIoKTtcblxuXHRcdFx0XHQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGJyb3dzZUJ1dHRvbiwgekluZGV4LCB0b3A7XG5cblx0XHRcdFx0XHRicm93c2VCdXR0b24gPSBEb20uZ2V0KG9wdGlvbnMuYnJvd3NlX2J1dHRvbik7XG5cdFx0XHRcdFx0X2Jyb3dzZUJ0blpJbmRleCA9IERvbS5nZXRTdHlsZShicm93c2VCdXR0b24sICd6LWluZGV4JykgfHwgJ2F1dG8nO1xuXG5cdFx0XHRcdFx0Ly8gUm91dGUgY2xpY2sgZXZlbnQgdG8gdGhlIGlucHV0W3R5cGU9ZmlsZV0gZWxlbWVudCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHN1Y2ggYmVoYXZpb3Jcblx0XHRcdFx0XHRpZiAoSS5jYW4oJ3N1bW1vbl9maWxlX2RpYWxvZycpKSB7XG5cdFx0XHRcdFx0XHRpZiAoRG9tLmdldFN0eWxlKGJyb3dzZUJ1dHRvbiwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG5cdFx0XHRcdFx0XHRcdGJyb3dzZUJ1dHRvbi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdFx0XHRcdFx0XHR9XHRcdFx0XHRcdFx0XG5cblx0XHRcdFx0XHRcdGNvbXAuYmluZCgnUmVmcmVzaCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR6SW5kZXggPSBwYXJzZUludChfYnJvd3NlQnRuWkluZGV4LCAxMCkgfHwgMTtcblxuXHRcdFx0XHRcdFx0XHREb20uZ2V0KF9vcHRpb25zLmJyb3dzZV9idXR0b24pLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcblx0XHRcdFx0XHRcdFx0dGhpcy5nZXRSdW50aW1lKCkuZ2V0U2hpbUNvbnRhaW5lcigpLnN0eWxlLnpJbmRleCA9IHpJbmRleCAtIDE7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBTaW5jZSB3ZSBoYXZlIHRvIHBsYWNlIGlucHV0W3R5cGU9ZmlsZV0gb24gdG9wIG9mIHRoZSBicm93c2VfYnV0dG9uIGZvciBzb21lIGJyb3dzZXJzLFxuXHRcdFx0XHRcdGJyb3dzZV9idXR0b24gbG9zZXMgaW50ZXJhY3Rpdml0eSwgc28gd2UgcmVzdG9yZSBpdCBoZXJlICovXG5cdFx0XHRcdFx0dG9wID0gSS5jYW4oJ3N1bW1vbl9maWxlX2RpYWxvZycpID8gYnJvd3NlQnV0dG9uIDogc2hpbUNvbnRhaW5lcjtcblxuXHRcdFx0XHRcdEV2ZW50cy5hZGRFdmVudCh0b3AsICdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGNvbXAudHJpZ2dlcignbW91c2VlbnRlcicpO1xuXHRcdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRcdEV2ZW50cy5hZGRFdmVudCh0b3AsICdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdtb3VzZWxlYXZlJyk7XG5cdFx0XHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KHRvcCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdtb3VzZWRvd24nKTtcblx0XHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoRG9tLmdldChvcHRpb25zLmNvbnRhaW5lciksICdtb3VzZXVwJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRjb21wLnRyaWdnZXIoJ21vdXNldXAnKTtcblx0XHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdFx0XHRicm93c2VCdXR0b24gPSBudWxsO1xuXHRcdFx0XHR9KCkpO1xuXG5cdFx0XHRcdGFkZElucHV0LmNhbGwodGhpcyk7XG5cblx0XHRcdFx0c2hpbUNvbnRhaW5lciA9IG51bGw7XG5cblx0XHRcdFx0Ly8gdHJpZ2dlciByZWFkeSBldmVudCBhc3luY2hyb25vdXNseVxuXHRcdFx0XHRjb21wLnRyaWdnZXIoe1xuXHRcdFx0XHRcdHR5cGU6ICdyZWFkeScsXG5cdFx0XHRcdFx0YXN5bmM6IHRydWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRPcHRpb246IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRcdHZhciBJID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cdFx0XHRcdHZhciBpbnB1dDtcblxuXHRcdFx0XHRpZiAobmFtZSA9PSAnYWNjZXB0Jykge1xuXHRcdFx0XHRcdF9taW1lcyA9IHZhbHVlLm1pbWVzIHx8IE1pbWUuZXh0TGlzdDJtaW1lcyh2YWx1ZSwgSS5jYW4oJ2ZpbHRlcl9ieV9leHRlbnNpb24nKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1cGRhdGUgY3VycmVudCBpbnB1dFxuXHRcdFx0XHRpbnB1dCA9IERvbS5nZXQoX3VpZClcblx0XHRcdFx0aWYgKGlucHV0KSB7XG5cdFx0XHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCBfbWltZXMuam9pbignLCcpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdFx0aWYgKChpbnB1dCA9IERvbS5nZXQoX3VpZCkpKSB7XG5cdFx0XHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAhIXN0YXRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIEkgPSB0aGlzLmdldFJ1bnRpbWUoKVxuXHRcdFx0XHQsIHNoaW0gPSBJLmdldFNoaW0oKVxuXHRcdFx0XHQsIHNoaW1Db250YWluZXIgPSBJLmdldFNoaW1Db250YWluZXIoKVxuXHRcdFx0XHQsIGNvbnRhaW5lciA9IF9vcHRpb25zICYmIERvbS5nZXQoX29wdGlvbnMuY29udGFpbmVyKVxuXHRcdFx0XHQsIGJyb3dzZUJ1dHRvbiA9IF9vcHRpb25zICYmIERvbS5nZXQoX29wdGlvbnMuYnJvd3NlX2J1dHRvbilcblx0XHRcdFx0O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNvbnRhaW5lcikge1xuXHRcdFx0XHRcdEV2ZW50cy5yZW1vdmVBbGxFdmVudHMoY29udGFpbmVyLCB0aGlzLnVpZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChicm93c2VCdXR0b24pIHtcblx0XHRcdFx0XHRFdmVudHMucmVtb3ZlQWxsRXZlbnRzKGJyb3dzZUJ1dHRvbiwgdGhpcy51aWQpO1xuXHRcdFx0XHRcdGJyb3dzZUJ1dHRvbi5zdHlsZS56SW5kZXggPSBfYnJvd3NlQnRuWkluZGV4OyAvLyByZXNldCB0byBvcmlnaW5hbCB2YWx1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc2hpbUNvbnRhaW5lcikge1xuXHRcdFx0XHRcdEV2ZW50cy5yZW1vdmVBbGxFdmVudHMoc2hpbUNvbnRhaW5lciwgdGhpcy51aWQpO1xuXHRcdFx0XHRcdHNoaW1Db250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaGltLnJlbW92ZUluc3RhbmNlKHRoaXMudWlkKTtcblxuXHRcdFx0XHRfdWlkID0gX21pbWVzID0gX29wdGlvbnMgPSBzaGltQ29udGFpbmVyID0gY29udGFpbmVyID0gYnJvd3NlQnV0dG9uID0gc2hpbSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZUlucHV0ID0gRmlsZUlucHV0KTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw0L2ZpbGUvRmlsZVJlYWRlci5qc1xuXG4vKipcbiAqIEZpbGVSZWFkZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNC9maWxlL0ZpbGVSZWFkZXJcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNC9maWxlL0ZpbGVSZWFkZXJcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvaHRtbDQvUnVudGltZVwiLFxuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvZmlsZS9GaWxlUmVhZGVyXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEZpbGVSZWFkZXIpIHtcblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVSZWFkZXIgPSBGaWxlUmVhZGVyKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw0L3hoci9YTUxIdHRwUmVxdWVzdC5qc1xuXG4vKipcbiAqIFhNTEh0dHBSZXF1ZXN0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDQveGhyL1hNTEh0dHBSZXF1ZXN0XG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDQveGhyL1hNTEh0dHBSZXF1ZXN0XCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9Eb21cIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL1VybFwiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRXZlbnRzXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUveGhyL0Zvcm1EYXRhXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJhc2ljLCBEb20sIFVybCwgeCwgRXZlbnRzLCBCbG9iLCBGb3JtRGF0YSkge1xuXHRcblx0ZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3QoKSB7XG5cdFx0dmFyIF9zdGF0dXMsIF9yZXNwb25zZSwgX2lmcmFtZTtcblxuXHRcdGZ1bmN0aW9uIGNsZWFudXAoY2IpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLCB1aWQsIGZvcm0sIGlucHV0cywgaSwgaGFzRmlsZSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIV9pZnJhbWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1aWQgPSBfaWZyYW1lLmlkLnJlcGxhY2UoL19pZnJhbWUkLywgJycpO1xuXG5cdFx0XHRmb3JtID0gRG9tLmdldCh1aWQgKyAnX2Zvcm0nKTtcblx0XHRcdGlmIChmb3JtKSB7XG5cdFx0XHRcdGlucHV0cyA9IGZvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XG5cdFx0XHRcdGkgPSBpbnB1dHMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGlucHV0c1tpXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnaGlkZGVuJzpcblx0XHRcdFx0XHRcdFx0aW5wdXRzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5wdXRzW2ldKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdFx0XHRcdFx0aGFzRmlsZSA9IHRydWU7IC8vIGZsYWcgdGhlIGNhc2UgZm9yIGxhdGVyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpbnB1dHMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIWhhc0ZpbGUpIHsgLy8gd2UgbmVlZCB0byBrZWVwIHRoZSBmb3JtIGZvciBzYWtlIG9mIHBvc3NpYmxlIHJldHJpZXNcblx0XHRcdFx0XHRmb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9ybSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9ybSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdpdGhvdXQgdGltZW91dCwgcmVxdWVzdCBpcyBtYXJrZWQgYXMgY2FuY2VsZWQgKGluIGNvbnNvbGUpXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRFdmVudHMucmVtb3ZlRXZlbnQoX2lmcmFtZSwgJ2xvYWQnLCB0YXJnZXQudWlkKTtcblx0XHRcdFx0aWYgKF9pZnJhbWUucGFyZW50Tm9kZSkgeyAvLyAjMzgyXG5cdFx0XHRcdFx0X2lmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9pZnJhbWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgc2hpbSBjb250YWluZXIgaGFzIGFueSBvdGhlciBjaGlsZHJlbiwgaWYgLSBub3QsIHJlbW92ZSBpdCBhcyB3ZWxsXG5cdFx0XHRcdHZhciBzaGltQ29udGFpbmVyID0gdGFyZ2V0LmdldFJ1bnRpbWUoKS5nZXRTaGltQ29udGFpbmVyKCk7XG5cdFx0XHRcdGlmICghc2hpbUNvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRzaGltQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2hpbUNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaGltQ29udGFpbmVyID0gX2lmcmFtZSA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHR9LCAxKTtcblx0XHR9XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24obWV0YSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcywgSSA9IHRhcmdldC5nZXRSdW50aW1lKCksIHVpZCwgZm9ybSwgaW5wdXQsIGJsb2I7XG5cblx0XHRcdFx0X3N0YXR1cyA9IF9yZXNwb25zZSA9IG51bGw7XG5cblx0XHRcdFx0ZnVuY3Rpb24gY3JlYXRlSWZyYW1lKCkge1xuXHRcdFx0XHRcdHZhciBjb250YWluZXIgPSBJLmdldFNoaW1Db250YWluZXIoKSB8fCBkb2N1bWVudC5ib2R5XG5cdFx0XHRcdFx0LCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jylcblx0XHRcdFx0XHQ7XG5cblx0XHRcdFx0XHQvLyBJRSA2IHdvbid0IGJlIGFibGUgdG8gc2V0IHRoZSBuYW1lIHVzaW5nIHNldEF0dHJpYnV0ZSBvciBpZnJhbWUubmFtZVxuXHRcdFx0XHRcdHRlbXAuaW5uZXJIVE1MID0gJzxpZnJhbWUgaWQ9XCInICsgdWlkICsgJ19pZnJhbWVcIiBuYW1lPVwiJyArIHVpZCArICdfaWZyYW1lXCIgc3JjPVwiamF2YXNjcmlwdDomcXVvdDsmcXVvdDtcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPjwvaWZyYW1lPic7XG5cdFx0XHRcdFx0X2lmcmFtZSA9IHRlbXAuZmlyc3RDaGlsZDtcblx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoX2lmcmFtZSk7XG5cblx0XHRcdFx0XHQvKiBfaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5pbmZvKF9pZnJhbWUucmVhZHlTdGF0ZSk7XG5cdFx0XHRcdFx0fTsqL1xuXG5cdFx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KF9pZnJhbWUsICdsb2FkJywgZnVuY3Rpb24oKSB7IC8vIF9pZnJhbWUub25sb2FkIGRvZXNuJ3Qgd29yayBpbiBJRSBsdGUgOFxuXHRcdFx0XHRcdFx0dmFyIGVsO1xuXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRlbCA9IF9pZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudCB8fCBfaWZyYW1lLmNvbnRlbnREb2N1bWVudCB8fCB3aW5kb3cuZnJhbWVzW19pZnJhbWUuaWRdLmRvY3VtZW50O1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRyeSB0byBkZXRlY3Qgc29tZSBzdGFuZGFyZCBlcnJvciBwYWdlc1xuXHRcdFx0XHRcdFx0XHRpZiAoL140KDBbMC05XXwxWzAtN118MlsyMzQ2XSlcXHMvLnRlc3QoZWwudGl0bGUpKSB7IC8vIHRlc3QgaWYgdGl0bGUgc3RhcnRzIHdpdGggNHh4IEhUVFAgZXJyb3Jcblx0XHRcdFx0XHRcdFx0XHRfc3RhdHVzID0gZWwudGl0bGUucmVwbGFjZSgvXihcXGQrKS4qJC8sICckMScpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdF9zdGF0dXMgPSAyMDA7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZ2V0IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHRcdF9yZXNwb25zZSA9IEJhc2ljLnRyaW0oZWwuYm9keS5pbm5lckhUTUwpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmaXJlIHRoZXNlIGF0IGxlYXN0IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcih7XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiAncHJvZ3Jlc3MnLFxuXHRcdFx0XHRcdFx0XHRcdFx0bG9hZGVkOiBfcmVzcG9uc2UubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRcdFx0dG90YWw6IF9yZXNwb25zZS5sZW5ndGhcblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChibG9iKSB7IC8vIGlmIHdlIHdlcmUgdXBsb2FkaW5nIGEgZmlsZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiAndXBsb2FkcHJvZ3Jlc3MnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsb2FkZWQ6IGJsb2Iuc2l6ZSB8fCAxMDI1LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0b3RhbDogYmxvYi5zaXplIHx8IDEwMjVcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdFx0aWYgKFVybC5oYXNTYW1lT3JpZ2luKG1ldGEudXJsKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIHJlc3BvbnNlIGlzIHNlbnQgd2l0aCBlcnJvciBjb2RlLCBpZnJhbWUgaW4gSUUgZ2V0cyByZWRpcmVjdGVkIHRvIHJlczovL2llZnJhbWUuZGxsL2h0dHBfeC5odG1cblx0XHRcdFx0XHRcdFx0XHQvLyB3aGljaCBvYnZpb3VzbHkgcmVzdWx0cyB0byBjcm9zcyBkb21haW4gZXJyb3IgKHd0Zj8pXG5cdFx0XHRcdFx0XHRcdFx0X3N0YXR1cyA9IDQwNDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjbGVhbnVwLmNhbGwodGFyZ2V0LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldC50cmlnZ2VyKCdlcnJvcicpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjbGVhbnVwLmNhbGwodGFyZ2V0LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoJ2xvYWQnKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0sIHRhcmdldC51aWQpO1xuXHRcdFx0XHR9IC8vIGVuZCBjcmVhdGVJZnJhbWVcblxuXHRcdFx0XHQvLyBwcmVwYXJlIGRhdGEgdG8gYmUgc2VudCBhbmQgY29udmVydCBpZiByZXF1aXJlZFxuXHRcdFx0XHRpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhICYmIGRhdGEuaGFzQmxvYigpKSB7XG5cdFx0XHRcdFx0YmxvYiA9IGRhdGEuZ2V0QmxvYigpO1xuXHRcdFx0XHRcdHVpZCA9IGJsb2IudWlkO1xuXHRcdFx0XHRcdGlucHV0ID0gRG9tLmdldCh1aWQpO1xuXHRcdFx0XHRcdGZvcm0gPSBEb20uZ2V0KHVpZCArICdfZm9ybScpO1xuXHRcdFx0XHRcdGlmICghZm9ybSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLk5PVF9GT1VORF9FUlIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1aWQgPSBCYXNpYy5ndWlkKCd1aWRfJyk7XG5cblx0XHRcdFx0XHRmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXHRcdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdpZCcsIHVpZCArICdfZm9ybScpO1xuXHRcdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCBtZXRhLm1ldGhvZCk7XG5cdFx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2VuY3R5cGUnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpO1xuXHRcdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdlbmNvZGluZycsICdtdWx0aXBhcnQvZm9ybS1kYXRhJyk7XG5cblx0XHRcdFx0XHRJLmdldFNoaW1Db250YWluZXIoKS5hcHBlbmRDaGlsZChmb3JtKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNldCB1cGxvYWQgdGFyZ2V0XG5cdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCd0YXJnZXQnLCB1aWQgKyAnX2lmcmFtZScpO1xuXG5cdFx0XHRcdGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdFx0XHRkYXRhLmVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGlucHV0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCduYW1lJywgbmFtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBoaWRkZW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXG5cdFx0XHRcdFx0XHRcdEJhc2ljLmV4dGVuZChoaWRkZW4sIHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlIDogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA6IG5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgOiB2YWx1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCBpbnB1dFt0eXBlPVwiZmlsZVwiXSwgaWYgaXQncyB0aGVyZSwgY29tZXMgbGFzdFxuXHRcdFx0XHRcdFx0XHRpZiAoaW5wdXQpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3JtLmluc2VydEJlZm9yZShoaWRkZW4sIGlucHV0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRmb3JtLmFwcGVuZENoaWxkKGhpZGRlbik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNldCBkZXN0aW5hdGlvbiB1cmxcblx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIiwgbWV0YS51cmwpO1xuXG5cdFx0XHRcdGNyZWF0ZUlmcmFtZSgpO1xuXHRcdFx0XHRmb3JtLnN1Ym1pdCgpO1xuXHRcdFx0XHR0YXJnZXQudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRTdGF0dXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX3N0YXR1cztcblx0XHRcdH0sXG5cblx0XHRcdGdldFJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZVR5cGUpIHtcblx0XHRcdFx0aWYgKCdqc29uJyA9PT0gcmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdFx0Ly8gc3RyaXAgb2ZmIDxwcmU+Li48L3ByZT4gdGFncyB0aGF0IG1pZ2h0IGJlIGVuY2xvc2luZyB0aGUgcmVzcG9uc2Vcblx0XHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKF9yZXNwb25zZSkgPT09ICdzdHJpbmcnICYmICEhd2luZG93LkpTT04pIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKF9yZXNwb25zZS5yZXBsYWNlKC9eXFxzKjxwcmVbXj5dKj4vLCAnJykucmVwbGFjZSgvPFxcL3ByZT5cXHMqJC8sICcnKSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IFxuXHRcdFx0XHR9IGVsc2UgaWYgKCdkb2N1bWVudCcgPT09IHJlc3BvbnNlVHlwZSkge1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIF9yZXNwb25zZTtcblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IHRoaXM7XG5cblx0XHRcdFx0aWYgKF9pZnJhbWUgJiYgX2lmcmFtZS5jb250ZW50V2luZG93KSB7XG5cdFx0XHRcdFx0aWYgKF9pZnJhbWUuY29udGVudFdpbmRvdy5zdG9wKSB7IC8vIEZpcmVGb3gvU2FmYXJpL0Nocm9tZVxuXHRcdFx0XHRcdFx0X2lmcmFtZS5jb250ZW50V2luZG93LnN0b3AoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKF9pZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5leGVjQ29tbWFuZCkgeyAvLyBJRVxuXHRcdFx0XHRcdFx0X2lmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKCdTdG9wJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9pZnJhbWUuc3JjID0gXCJhYm91dDpibGFua1wiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsZWFudXAuY2FsbCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyB0YXJnZXQuZGlzcGF0Y2hFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpO1xuXHRcdFx0XHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50KCdhYm9ydCcpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5YTUxIdHRwUmVxdWVzdCA9IFhNTEh0dHBSZXF1ZXN0KTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw0L2ltYWdlL0ltYWdlLmpzXG5cbi8qKlxuICogSW1hZ2UuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNC9pbWFnZS9JbWFnZVxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw0L2ltYWdlL0ltYWdlXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0ltYWdlXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEltYWdlKSB7XG5cdHJldHVybiAoZXh0ZW5zaW9ucy5JbWFnZSA9IEltYWdlKTtcbn0pO1xuXG5leHBvc2UoW1wibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFwibW94aWUvY29yZS91dGlscy9FbmNvZGVcIixcIm1veGllL2NvcmUvdXRpbHMvRW52XCIsXCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcIm1veGllL2NvcmUvdXRpbHMvRG9tXCIsXCJtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0XCIsXCJtb3hpZS9ydW50aW1lL1J1bnRpbWVcIixcIm1veGllL3J1bnRpbWUvUnVudGltZUNsaWVudFwiLFwibW94aWUvZmlsZS9CbG9iXCIsXCJtb3hpZS9jb3JlL0kxOG5cIixcIm1veGllL2NvcmUvdXRpbHMvTWltZVwiLFwibW94aWUvZmlsZS9GaWxlSW5wdXRcIixcIm1veGllL2ZpbGUvRmlsZVwiLFwibW94aWUvZmlsZS9GaWxlRHJvcFwiLFwibW94aWUvZmlsZS9GaWxlUmVhZGVyXCIsXCJtb3hpZS9jb3JlL3V0aWxzL1VybFwiLFwibW94aWUvcnVudGltZS9SdW50aW1lVGFyZ2V0XCIsXCJtb3hpZS94aHIvRm9ybURhdGFcIixcIm1veGllL3hoci9YTUxIdHRwUmVxdWVzdFwiLFwibW94aWUvcnVudGltZS9UcmFuc3BvcnRlclwiLFwibW94aWUvaW1hZ2UvSW1hZ2VcIixcIm1veGllL2NvcmUvdXRpbHMvRXZlbnRzXCIsXCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL1Jlc2l6ZXJDYW52YXNcIl0pO1xufSkodGhpcyk7XG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGx1cGxvYWQvbW94aWUuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBQbHVwbG9hZCAtIG11bHRpLXJ1bnRpbWUgRmlsZSBVcGxvYWRlclxuICogdjIuMy4xXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICpcbiAqIERhdGU6IDIwMTctMDItMDZcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHZhciBleHRyYWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHt9O1xuXHRcdGZhY3RvcnkuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBjdHgucGx1cGxvYWQ7XG5cdH07XG5cdFxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoXCJwbHVwbG9hZFwiLCBbJy4vbW94aWUnXSwgZXh0cmFjdCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXh0cmFjdChyZXF1aXJlKCcuLi8uLi8uLi9qcy1zZGstbWFzdGVyIDIvc3JjL21veGllJykpO1xuXHR9IGVsc2Uge1xuXHRcdGdsb2JhbC5wbHVwbG9hZCA9IGV4dHJhY3QoZ2xvYmFsLm1veGllKTtcblx0fVxufSh0aGlzIHx8IHdpbmRvdywgZnVuY3Rpb24obW94aWUpIHtcbi8qKlxuICogUGx1cGxvYWQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuOyhmdW5jdGlvbihleHBvcnRzLCBvLCB1bmRlZikge1xuXG52YXIgZGVsYXkgPSB3aW5kb3cuc2V0VGltZW91dDtcbnZhciBmaWxlRmlsdGVycyA9IHt9O1xudmFyIHUgPSBvLmNvcmUudXRpbHM7XG52YXIgUnVudGltZSA9IG8ucnVudGltZS5SdW50aW1lO1xuXG4vLyBjb252ZXJ0IHBsdXBsb2FkIGZlYXR1cmVzIHRvIGNhcHMgYWNjZXB0YWJsZSBieSBtT3hpZVxuZnVuY3Rpb24gbm9ybWFsaXplQ2FwcyhzZXR0aW5ncykge1xuXHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5yZXF1aXJlZF9mZWF0dXJlcywgY2FwcyA9IHt9O1xuXG5cdGZ1bmN0aW9uIHJlc29sdmUoZmVhdHVyZSwgdmFsdWUsIHN0cmljdCkge1xuXHRcdC8vIEZlYXR1cmUgbm90YXRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIGNhcHMgKHRoaXMgdGhpbmcgaGVyZSBpcyByZXF1aXJlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcblx0XHR2YXIgbWFwID0ge1xuXHRcdFx0Y2h1bmtzOiAnc2xpY2VfYmxvYicsXG5cdFx0XHRqcGdyZXNpemU6ICdzZW5kX2JpbmFyeV9zdHJpbmcnLFxuXHRcdFx0cG5ncmVzaXplOiAnc2VuZF9iaW5hcnlfc3RyaW5nJyxcblx0XHRcdHByb2dyZXNzOiAncmVwb3J0X3VwbG9hZF9wcm9ncmVzcycsXG5cdFx0XHRtdWx0aV9zZWxlY3Rpb246ICdzZWxlY3RfbXVsdGlwbGUnLFxuXHRcdFx0ZHJhZ2Ryb3A6ICdkcmFnX2FuZF9kcm9wJyxcblx0XHRcdGRyb3BfZWxlbWVudDogJ2RyYWdfYW5kX2Ryb3AnLFxuXHRcdFx0aGVhZGVyczogJ3NlbmRfY3VzdG9tX2hlYWRlcnMnLFxuXHRcdFx0dXJsc3RyZWFtX3VwbG9hZDogJ3NlbmRfYmluYXJ5X3N0cmluZycsXG5cdFx0XHRjYW5TZW5kQmluYXJ5OiAnc2VuZF9iaW5hcnknLFxuXHRcdFx0dHJpZ2dlckRpYWxvZzogJ3N1bW1vbl9maWxlX2RpYWxvZydcblx0XHR9O1xuXG5cdFx0aWYgKG1hcFtmZWF0dXJlXSkge1xuXHRcdFx0Y2Fwc1ttYXBbZmVhdHVyZV1dID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICghc3RyaWN0KSB7XG5cdFx0XHRjYXBzW2ZlYXR1cmVdID0gdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHR5cGVvZihmZWF0dXJlcykgPT09ICdzdHJpbmcnKSB7XG5cdFx0cGx1cGxvYWQuZWFjaChmZWF0dXJlcy5zcGxpdCgvXFxzKixcXHMqLyksIGZ1bmN0aW9uKGZlYXR1cmUpIHtcblx0XHRcdHJlc29sdmUoZmVhdHVyZSwgdHJ1ZSk7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mKGZlYXR1cmVzKSA9PT0gJ29iamVjdCcpIHtcblx0XHRwbHVwbG9hZC5lYWNoKGZlYXR1cmVzLCBmdW5jdGlvbih2YWx1ZSwgZmVhdHVyZSkge1xuXHRcdFx0cmVzb2x2ZShmZWF0dXJlLCB2YWx1ZSk7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZmVhdHVyZXMgPT09IHRydWUpIHtcblx0XHQvLyBjaGVjayBzZXR0aW5ncyBmb3IgcmVxdWlyZWQgZmVhdHVyZXNcblx0XHRpZiAoc2V0dGluZ3MuY2h1bmtfc2l6ZSAmJiBzZXR0aW5ncy5jaHVua19zaXplID4gMCkge1xuXHRcdFx0Y2Fwcy5zbGljZV9ibG9iID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIXBsdXBsb2FkLmlzRW1wdHlPYmooc2V0dGluZ3MucmVzaXplKSB8fCBzZXR0aW5ncy5tdWx0aXBhcnQgPT09IGZhbHNlKSB7XG5cdFx0XHRjYXBzLnNlbmRfYmluYXJ5X3N0cmluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRpbmdzLmh0dHBfbWV0aG9kKSB7XG4gICAgICAgICAgICBjYXBzLnVzZV9odHRwX21ldGhvZCA9IHNldHRpbmdzLmh0dHBfbWV0aG9kO1xuICAgICAgICB9XG5cblx0XHRwbHVwbG9hZC5lYWNoKHNldHRpbmdzLCBmdW5jdGlvbih2YWx1ZSwgZmVhdHVyZSkge1xuXHRcdFx0cmVzb2x2ZShmZWF0dXJlLCAhIXZhbHVlLCB0cnVlKTsgLy8gc3RyaWN0IGNoZWNrXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gY2Fwcztcbn1cblxuLyoqXG4gKiBAbW9kdWxlIHBsdXBsb2FkXG4gKiBAc3RhdGljXG4gKi9cbnZhciBwbHVwbG9hZCA9IHtcblx0LyoqXG5cdCAqIFBsdXBsb2FkIHZlcnNpb24gd2lsbCBiZSByZXBsYWNlZCBvbiBidWlsZC5cblx0ICpcblx0ICogQHByb3BlcnR5IFZFUlNJT05cblx0ICogQGZvciBQbHVwbG9hZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0VkVSU0lPTiA6ICcyLjMuMScsXG5cblx0LyoqXG5cdCAqIFRoZSBzdGF0ZSBvZiB0aGUgcXVldWUgYmVmb3JlIGl0IGhhcyBzdGFydGVkIGFuZCBhZnRlciBpdCBoYXMgZmluaXNoZWRcblx0ICpcblx0ICogQHByb3BlcnR5IFNUT1BQRURcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdFNUT1BQRUQgOiAxLFxuXG5cdC8qKlxuXHQgKiBVcGxvYWQgcHJvY2VzcyBpcyBydW5uaW5nXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBTVEFSVEVEXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRTVEFSVEVEIDogMixcblxuXHQvKipcblx0ICogRmlsZSBpcyBxdWV1ZWQgZm9yIHVwbG9hZFxuXHQgKlxuXHQgKiBAcHJvcGVydHkgUVVFVUVEXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRRVUVVRUQgOiAxLFxuXG5cdC8qKlxuXHQgKiBGaWxlIGlzIGJlaW5nIHVwbG9hZGVkXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBVUExPQURJTkdcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdFVQTE9BRElORyA6IDIsXG5cblx0LyoqXG5cdCAqIEZpbGUgaGFzIGZhaWxlZCB0byBiZSB1cGxvYWRlZFxuXHQgKlxuXHQgKiBAcHJvcGVydHkgRkFJTEVEXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRGQUlMRUQgOiA0LFxuXG5cdC8qKlxuXHQgKiBGaWxlIGhhcyBiZWVuIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseVxuXHQgKlxuXHQgKiBAcHJvcGVydHkgRE9ORVxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0RE9ORSA6IDUsXG5cblx0Ly8gRXJyb3IgY29uc3RhbnRzIHVzZWQgYnkgdGhlIEVycm9yIGV2ZW50XG5cblx0LyoqXG5cdCAqIEdlbmVyaWMgZXJyb3IgZm9yIGV4YW1wbGUgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBpbnNpZGUgU2lsdmVybGlnaHQuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBHRU5FUklDX0VSUk9SXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRHRU5FUklDX0VSUk9SIDogLTEwMCxcblxuXHQvKipcblx0ICogSFRUUCB0cmFuc3BvcnQgZXJyb3IuIEZvciBleGFtcGxlIGlmIHRoZSBzZXJ2ZXIgcHJvZHVjZXMgYSBIVFRQIHN0YXR1cyBvdGhlciB0aGFuIDIwMC5cblx0ICpcblx0ICogQHByb3BlcnR5IEhUVFBfRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdEhUVFBfRVJST1IgOiAtMjAwLFxuXG5cdC8qKlxuXHQgKiBHZW5lcmljIEkvTyBlcnJvci4gRm9yIGV4YW1wbGUgaWYgaXQgd2Fzbid0IHBvc3NpYmxlIHRvIG9wZW4gdGhlIGZpbGUgc3RyZWFtIG9uIGxvY2FsIG1hY2hpbmUuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBJT19FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0SU9fRVJST1IgOiAtMzAwLFxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgU0VDVVJJVFlfRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdFNFQ1VSSVRZX0VSUk9SIDogLTQwMCxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6YXRpb24gZXJyb3IuIFdpbGwgYmUgdHJpZ2dlcmVkIGlmIG5vIHJ1bnRpbWUgd2FzIGluaXRpYWxpemVkLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgSU5JVF9FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0SU5JVF9FUlJPUiA6IC01MDAsXG5cblx0LyoqXG5cdCAqIEZpbGUgc2l6ZSBlcnJvci4gSWYgdGhlIHVzZXIgc2VsZWN0cyBhIGZpbGUgdGhhdCBpcyB0b28gbGFyZ2UgaXQgd2lsbCBiZSBibG9ja2VkIGFuZCBhbiBlcnJvciBvZiB0aGlzIHR5cGUgd2lsbCBiZSB0cmlnZ2VyZWQuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBGSUxFX1NJWkVfRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdEZJTEVfU0laRV9FUlJPUiA6IC02MDAsXG5cblx0LyoqXG5cdCAqIEZpbGUgZXh0ZW5zaW9uIGVycm9yLiBJZiB0aGUgdXNlciBzZWxlY3RzIGEgZmlsZSB0aGF0IGlzbid0IHZhbGlkIGFjY29yZGluZyB0byB0aGUgZmlsdGVycyBzZXR0aW5nLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgRklMRV9FWFRFTlNJT05fRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdEZJTEVfRVhURU5TSU9OX0VSUk9SIDogLTYwMSxcblxuXHQvKipcblx0ICogRHVwbGljYXRlIGZpbGUgZXJyb3IuIElmIHByZXZlbnRfZHVwbGljYXRlcyBpcyBzZXQgdG8gdHJ1ZSBhbmQgdXNlciBzZWxlY3RzIHRoZSBzYW1lIGZpbGUgYWdhaW4uXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBGSUxFX0RVUExJQ0FURV9FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0RklMRV9EVVBMSUNBVEVfRVJST1IgOiAtNjAyLFxuXG5cdC8qKlxuXHQgKiBSdW50aW1lIHdpbGwgdHJ5IHRvIGRldGVjdCBpZiBpbWFnZSBpcyBwcm9wZXIgb25lLiBPdGhlcndpc2Ugd2lsbCB0aHJvdyB0aGlzIGVycm9yLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgSU1BR0VfRk9STUFUX0VSUk9SXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRJTUFHRV9GT1JNQVRfRVJST1IgOiAtNzAwLFxuXG5cdC8qKlxuXHQgKiBXaGlsZSB3b3JraW5nIG9uIGZpbGVzIHJ1bnRpbWUgbWF5IHJ1biBvdXQgb2YgbWVtb3J5IGFuZCB3aWxsIHRocm93IHRoaXMgZXJyb3IuXG5cdCAqXG5cdCAqIEBzaW5jZSAyLjEuMlxuXHQgKiBAcHJvcGVydHkgTUVNT1JZX0VSUk9SXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRNRU1PUllfRVJST1IgOiAtNzAxLFxuXG5cdC8qKlxuXHQgKiBFYWNoIHJ1bnRpbWUgaGFzIGFuIHVwcGVyIGxpbWl0IG9uIGEgZGltZW5zaW9uIG9mIHRoZSBpbWFnZSBpdCBjYW4gaGFuZGxlLiBJZiBiaWdnZXIsIHdpbGwgdGhyb3cgdGhpcyBlcnJvci5cblx0ICpcblx0ICogQHByb3BlcnR5IElNQUdFX0RJTUVOU0lPTlNfRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdElNQUdFX0RJTUVOU0lPTlNfRVJST1IgOiAtNzAyLFxuXG5cdC8qKlxuXHQgKiBNaW1lIHR5cGUgbG9va3VwIHRhYmxlLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgbWltZVR5cGVzXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAZmluYWxcblx0ICovXG5cdG1pbWVUeXBlcyA6IHUuTWltZS5taW1lcyxcblxuXHQvKipcblx0ICogSW4gc29tZSBjYXNlcyBzbmlmZmluZyBpcyB0aGUgb25seSB3YXkgYXJvdW5kIDooXG5cdCAqL1xuXHR1YTogdS5FbnYsXG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRydWUgdHlwZSBvZiB0aGUgYnVpbHQtaW4gb2JqZWN0IChiZXR0ZXIgdmVyc2lvbiBvZiB0eXBlb2YpLlxuXHQgKiBAY3JlZGl0cyBBbmd1cyBDcm9sbCAoaHR0cDovL2phdmFzY3JpcHR3ZWJsb2cud29yZHByZXNzLmNvbS8pXG5cdCAqXG5cdCAqIEBtZXRob2QgdHlwZU9mXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IG8gT2JqZWN0IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IE9iamVjdCBbW0NsYXNzXV1cblx0ICovXG5cdHR5cGVPZjogdS5CYXNpYy50eXBlT2YsXG5cblx0LyoqXG5cdCAqIEV4dGVuZHMgdGhlIHNwZWNpZmllZCBvYmplY3Qgd2l0aCBhbm90aGVyIG9iamVjdC5cblx0ICpcblx0ICogQG1ldGhvZCBleHRlbmRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0byBleHRlbmQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0Li59IG9iaiBNdWx0aXBsZSBvYmplY3RzIHRvIGV4dGVuZCB3aXRoLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFNhbWUgYXMgdGFyZ2V0LCB0aGUgZXh0ZW5kZWQgb2JqZWN0LlxuXHQgKi9cblx0ZXh0ZW5kIDogdS5CYXNpYy5leHRlbmQsXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhbiB1bmlxdWUgSUQuIFRoaXMgaXMgOTkuOTklIHVuaXF1ZSBzaW5jZSBpdCB0YWtlcyB0aGUgY3VycmVudCB0aW1lIGFuZCA1IHJhbmRvbSBudW1iZXJzLlxuXHQgKiBUaGUgb25seSB3YXkgYSB1c2VyIHdvdWxkIGJlIGFibGUgdG8gZ2V0IHRoZSBzYW1lIElEIGlzIGlmIHRoZSB0d28gcGVyc29ucyBhdCB0aGUgc2FtZSBleGFjdCBtaWxsaXNlY29uZCBtYW5hZ2VzXG5cdCAqIHRvIGdldCA1IHRoZSBzYW1lIHJhbmRvbSBudW1iZXJzIGJldHdlZW4gMC02NTUzNSBpdCBhbHNvIHVzZXMgYSBjb3VudGVyIHNvIGVhY2ggY2FsbCB3aWxsIGJlIGd1YXJhbnRlZWQgdG8gYmUgcGFnZSB1bmlxdWUuXG5cdCAqIEl0J3MgbW9yZSBwcm9iYWJsZSBmb3IgdGhlIGVhcnRoIHRvIGJlIGhpdCB3aXRoIGFuIGFzdGVyaW9kLiBZb3UgY2FuIGFsc28gaWYgeW91IHdhbnQgdG8gYmUgMTAwJSBzdXJlIHNldCB0aGUgcGx1cGxvYWQuZ3VpZFByZWZpeCBwcm9wZXJ0eVxuXHQgKiB0byBhbiB1c2VyIHVuaXF1ZSBrZXkuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ3VpZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVmlydHVhbGx5IHVuaXF1ZSBpZC5cblx0ICovXG5cdGd1aWQgOiB1LkJhc2ljLmd1aWQsXG5cblx0LyoqXG5cdCAqIEdldCBhcnJheSBvZiBET00gRWxlbWVudHMgYnkgdGhlaXIgaWRzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgSWRlbnRpZmllciBvZiB0aGUgRE9NIEVsZW1lbnRcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCovXG5cdGdldEFsbCA6IGZ1bmN0aW9uIGdldChpZHMpIHtcblx0XHR2YXIgZWxzID0gW10sIGVsO1xuXG5cdFx0aWYgKHBsdXBsb2FkLnR5cGVPZihpZHMpICE9PSAnYXJyYXknKSB7XG5cdFx0XHRpZHMgPSBbaWRzXTtcblx0XHR9XG5cblx0XHR2YXIgaSA9IGlkcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0ZWwgPSBwbHVwbG9hZC5nZXQoaWRzW2ldKTtcblx0XHRcdGlmIChlbCkge1xuXHRcdFx0XHRlbHMucHVzaChlbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVscy5sZW5ndGggPyBlbHMgOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHRHZXQgRE9NIGVsZW1lbnQgYnkgaWRcblxuXHRAbWV0aG9kIGdldFxuXHRAcGFyYW0ge1N0cmluZ30gaWQgSWRlbnRpZmllciBvZiB0aGUgRE9NIEVsZW1lbnRcblx0QHJldHVybiB7Tm9kZX1cblx0Ki9cblx0Z2V0OiB1LkRvbS5nZXQsXG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtIGluIGFycmF5L29iamVjdC4gSWYgeW91IHJldHVybiBmYWxzZSBpbiB0aGVcblx0ICogY2FsbGJhY2sgaXQgd2lsbCBicmVhayB0aGUgbG9vcC5cblx0ICpcblx0ICogQG1ldGhvZCBlYWNoXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gaXRlcmF0ZS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBpdGVtLlxuXHQgKi9cblx0ZWFjaCA6IHUuQmFzaWMuZWFjaCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWJzb2x1dGUgeCwgeSBwb3NpdGlvbiBvZiBhbiBFbGVtZW50LiBUaGUgcG9zaXRpb24gd2lsbCBiZSByZXR1cm5lZCBpbiBhIG9iamVjdCB3aXRoIHgsIHkgZmllbGRzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFBvc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBIVE1MIGVsZW1lbnQgb3IgZWxlbWVudCBpZCB0byBnZXQgeCwgeSBwb3NpdGlvbiBmcm9tLlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3QgT3B0aW9uYWwgcm9vdCBlbGVtZW50IHRvIHN0b3AgY2FsY3VsYXRpb25zIGF0LlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IEFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBvYmplY3Qgd2l0aCB4LCB5IGZpZWxkcy5cblx0ICovXG5cdGdldFBvcyA6IHUuRG9tLmdldFBvcyxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgc3BlY2lmaWVkIG5vZGUgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFNpemVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBnZXQgdGhlIHNpemUgb2YuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggYSB3IGFuZCBoIHByb3BlcnR5LlxuXHQgKi9cblx0Z2V0U2l6ZSA6IHUuRG9tLmdldFNpemUsXG5cblx0LyoqXG5cdCAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBzdHJpbmcuXG5cdCAqXG5cdCAqIEBtZXRob2QgeG1sRW5jb2RlXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHMgU3RyaW5nIHRvIGVuY29kZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBFbmNvZGVkIHN0cmluZy5cblx0ICovXG5cdHhtbEVuY29kZSA6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciB4bWxFbmNvZGVDaGFycyA9IHsnPCcgOiAnbHQnLCAnPicgOiAnZ3QnLCAnJicgOiAnYW1wJywgJ1wiJyA6ICdxdW90JywgJ1xcJycgOiAnIzM5J30sIHhtbEVuY29kZVJlZ0V4cCA9IC9bPD4mXFxcIlxcJ10vZztcblxuXHRcdHJldHVybiBzdHIgPyAoJycgKyBzdHIpLnJlcGxhY2UoeG1sRW5jb2RlUmVnRXhwLCBmdW5jdGlvbihjaHIpIHtcblx0XHRcdHJldHVybiB4bWxFbmNvZGVDaGFyc1tjaHJdID8gJyYnICsgeG1sRW5jb2RlQ2hhcnNbY2hyXSArICc7JyA6IGNocjtcblx0XHR9KSA6IHN0cjtcblx0fSxcblxuXHQvKipcblx0ICogRm9yY2VzIGFueXRoaW5nIGludG8gYW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBtZXRob2QgdG9BcnJheVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHdpdGggbGVuZ3RoIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGl0ZW1zLlxuXHQgKi9cblx0dG9BcnJheSA6IHUuQmFzaWMudG9BcnJheSxcblxuXHQvKipcblx0ICogRmluZCBhbiBlbGVtZW50IGluIGFycmF5IGFuZCByZXR1cm4gaXRzIGluZGV4IGlmIHByZXNlbnQsIG90aGVyd2lzZSByZXR1cm4gLTEuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5BcnJheVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IG5lZWRsZSBFbGVtZW50IHRvIGZpbmRcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXlcblx0ICogQHJldHVybiB7SW50fSBJbmRleCBvZiB0aGUgZWxlbWVudCwgb3IgLTEgaWYgbm90IGZvdW5kXG5cdCAqL1xuXHRpbkFycmF5IDogdS5CYXNpYy5pbkFycmF5LFxuXG5cdC8qKlxuXHRSZWNpZXZlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyAodXN1YWxseSBhc3luYykgdG8gY2FsbCBpbiBzZXF1ZW5jZSwgZWFjaCAgZnVuY3Rpb25cblx0cmVjZWl2ZXMgYSBjYWxsYmFjayBhcyBmaXJzdCBhcmd1bWVudCB0aGF0IGl0IHNob3VsZCBjYWxsLCB3aGVuIGl0IGNvbXBsZXRlcy4gRmluYWxseSxcblx0YWZ0ZXIgZXZlcnl0aGluZyBpcyBjb21wbGV0ZSwgbWFpbiBjYWxsYmFjayBpcyBjYWxsZWQuIFBhc3NpbmcgdHJ1dGh5IHZhbHVlIHRvIHRoZVxuXHRjYWxsYmFjayBhcyBhIGZpcnN0IGFyZ3VtZW50IHdpbGwgaW50ZXJydXB0IHRoZSBzZXF1ZW5jZSBhbmQgaW52b2tlIG1haW4gY2FsbGJhY2tcblx0aW1tZWRpYXRlbHkuXG5cblx0QG1ldGhvZCBpblNlcmllc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7QXJyYXl9IHF1ZXVlIEFycmF5IG9mIGZ1bmN0aW9ucyB0byBjYWxsIGluIHNlcXVlbmNlXG5cdEBwYXJhbSB7RnVuY3Rpb259IGNiIE1haW4gY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgaW4gdGhlIGVuZCwgb3IgaW4gY2FzZSBvZiBlcnJvclxuXHQqL1xuXHRpblNlcmllczogdS5CYXNpYy5pblNlcmllcyxcblxuXHQvKipcblx0ICogRXh0ZW5kcyB0aGUgbGFuZ3VhZ2UgcGFjayBvYmplY3Qgd2l0aCBuZXcgaXRlbXMuXG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkSTE4blxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrIExhbmd1YWdlIHBhY2sgaXRlbXMgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuZGVkIGxhbmd1YWdlIHBhY2sgb2JqZWN0LlxuXHQgKi9cblx0YWRkSTE4biA6IG8uY29yZS5JMThuLmFkZEkxOG4sXG5cblx0LyoqXG5cdCAqIFRyYW5zbGF0ZXMgdGhlIHNwZWNpZmllZCBzdHJpbmcgYnkgY2hlY2tpbmcgZm9yIHRoZSBlbmdsaXNoIHN0cmluZyBpbiB0aGUgbGFuZ3VhZ2UgcGFjayBsb29rdXAuXG5cdCAqXG5cdCAqIEBtZXRob2QgdHJhbnNsYXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gbG9vayBmb3IuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVHJhbnNsYXRlZCBzdHJpbmcgb3IgdGhlIGlucHV0IHN0cmluZyBpZiBpdCB3YXNuJ3QgZm91bmQuXG5cdCAqL1xuXHR0cmFuc2xhdGUgOiBvLmNvcmUuSTE4bi50cmFuc2xhdGUsXG5cblx0LyoqXG5cdCAqIFBzZXVkbyBzcHJpbnRmIGltcGxlbWVudGF0aW9uIC0gc2ltcGxlIHdheSB0byByZXBsYWNlIHRva2VucyB3aXRoIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHdpdGggdG9rZW5zXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHdpdGggcmVwbGFjZWQgdG9rZW5zXG5cdCAqL1xuXHRzcHJpbnRmIDogdS5CYXNpYy5zcHJpbnRmLFxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGVtcHR5LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGlzRW1wdHlPYmpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byBjaGVjay5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGlzRW1wdHlPYmogOiB1LkJhc2ljLmlzRW1wdHlPYmosXG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBzcGVjaWZpZWQgRE9NIGVsZW1lbnQgaGFzIHNwZWNpZmllZCBjbGFzcy5cblx0ICpcblx0ICogQG1ldGhvZCBoYXNDbGFzc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWVcblx0ICovXG5cdGhhc0NsYXNzIDogdS5Eb20uaGFzQ2xhc3MsXG5cblx0LyoqXG5cdCAqIEFkZHMgc3BlY2lmaWVkIGNsYXNzTmFtZSB0byBzcGVjaWZpZWQgRE9NIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkQ2xhc3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IGxpa2Ugb2JqZWN0IHRvIGFkZCBoYW5kbGVyIHRvLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBDbGFzcyBuYW1lXG5cdCAqL1xuXHRhZGRDbGFzcyA6IHUuRG9tLmFkZENsYXNzLFxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHNwZWNpZmllZCBjbGFzc05hbWUgZnJvbSBzcGVjaWZpZWQgRE9NIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2xhc3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IGxpa2Ugb2JqZWN0IHRvIGFkZCBoYW5kbGVyIHRvLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBDbGFzcyBuYW1lXG5cdCAqL1xuXHRyZW1vdmVDbGFzcyA6IHUuRG9tLnJlbW92ZUNsYXNzLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ2l2ZW4gY29tcHV0ZWQgc3R5bGUgb2YgYSBET00gZWxlbWVudC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRTdHlsZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFN0eWxlIHlvdSB3YW50IHRvIGdldCBmcm9tIHRoZSBET00gZWxlbWVudFxuXHQgKi9cblx0Z2V0U3R5bGUgOiB1LkRvbS5nZXRTdHlsZSxcblxuXHQvKipcblx0ICogQWRkcyBhbiBldmVudCBoYW5kbGVyIHRvIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGFuZCBzdG9yZSByZWZlcmVuY2UgdG8gdGhlIGhhbmRsZXJcblx0ICogaW4gb2JqZWN0cyBpbnRlcm5hbCBQbHVwbG9hZCByZWdpc3RyeSAoQHNlZSByZW1vdmVFdmVudCkuXG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkRXZlbnRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IGxpa2Ugb2JqZWN0IHRvIGFkZCBoYW5kbGVyIHRvLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIHRvIGFkZCBldmVudCBsaXN0ZW5lciB0by5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGV2ZW50IG9jY3Vycy5cblx0ICogQHBhcmFtIHtTdHJpbmd9IChvcHRpb25hbCkga2V5IHRoYXQgbWlnaHQgYmUgdXNlZCB0byBhZGQgc3BlY2lmaXR5IHRvIHRoZSBldmVudCByZWNvcmQuXG5cdCAqL1xuXHRhZGRFdmVudCA6IHUuRXZlbnRzLmFkZEV2ZW50LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBzcGVjaWZpZWQgb2JqZWN0LiBJZiB0aGlyZCBhcmd1bWVudCAoY2FsbGJhY2spXG5cdCAqIGlzIG5vdCBzcGVjaWZpZWQgcmVtb3ZlIGFsbCBldmVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlRXZlbnRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcihzKSBmcm9tLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIGV2ZW50IGxpc3RlbmVyIHRvIHJlbW92ZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IChvcHRpb25hbCkgbWlnaHQgYmUgYSBjYWxsYmFjayBvciB1bmlxdWUga2V5IHRvIG1hdGNoLlxuXHQgKi9cblx0cmVtb3ZlRXZlbnQ6IHUuRXZlbnRzLnJlbW92ZUV2ZW50LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIGtpbmQgb2YgZXZlbnRzIGZyb20gdGhlIHNwZWNpZmllZCBvYmplY3Rcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVBbGxFdmVudHNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZnJvbS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IChvcHRpb25hbCkgdW5pcXVlIGtleSB0byBtYXRjaCwgd2hlbiByZW1vdmluZyBldmVudHMuXG5cdCAqL1xuXHRyZW1vdmVBbGxFdmVudHM6IHUuRXZlbnRzLnJlbW92ZUFsbEV2ZW50cyxcblxuXHQvKipcblx0ICogQ2xlYW5zIHRoZSBzcGVjaWZpZWQgbmFtZSBmcm9tIG5hdGlvbmFsIGNoYXJhY3RlcnMgKGRpYWNyaXRpY3MpLiBUaGUgcmVzdWx0IHdpbGwgYmUgYSBuYW1lIHdpdGggb25seSBhLXosIDAtOSBhbmQgXy5cblx0ICpcblx0ICogQG1ldGhvZCBjbGVhbk5hbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gcyBTdHJpbmcgdG8gY2xlYW4gdXAuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQ2xlYW5lZCBzdHJpbmcuXG5cdCAqL1xuXHRjbGVhbk5hbWUgOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIGksIGxvb2t1cDtcblxuXHRcdC8vIFJlcGxhY2UgZGlhY3JpdGljc1xuXHRcdGxvb2t1cCA9IFtcblx0XHRcdC9bXFwzMDAtXFwzMDZdL2csICdBJywgL1tcXDM0MC1cXDM0Nl0vZywgJ2EnLFxuXHRcdFx0L1xcMzA3L2csICdDJywgL1xcMzQ3L2csICdjJyxcblx0XHRcdC9bXFwzMTAtXFwzMTNdL2csICdFJywgL1tcXDM1MC1cXDM1M10vZywgJ2UnLFxuXHRcdFx0L1tcXDMxNC1cXDMxN10vZywgJ0knLCAvW1xcMzU0LVxcMzU3XS9nLCAnaScsXG5cdFx0XHQvXFwzMjEvZywgJ04nLCAvXFwzNjEvZywgJ24nLFxuXHRcdFx0L1tcXDMyMi1cXDMzMF0vZywgJ08nLCAvW1xcMzYyLVxcMzcwXS9nLCAnbycsXG5cdFx0XHQvW1xcMzMxLVxcMzM0XS9nLCAnVScsIC9bXFwzNzEtXFwzNzRdL2csICd1J1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbG9va3VwLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKGxvb2t1cFtpXSwgbG9va3VwW2kgKyAxXSk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVwbGFjZSB3aGl0ZXNwYWNlXG5cdFx0bmFtZSA9IG5hbWUucmVwbGFjZSgvXFxzKy9nLCAnXycpO1xuXG5cdFx0Ly8gUmVtb3ZlIGFueXRoaW5nIGVsc2Vcblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC9bXmEtejAtOV9cXC1cXC5dKy9naSwgJycpO1xuXG5cdFx0cmV0dXJuIG5hbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIGZ1bGwgdXJsIG91dCBvZiBhIGJhc2UgVVJMIGFuZCBhbiBvYmplY3Qgd2l0aCBpdGVtcyB0byBhcHBlbmQgYXMgcXVlcnkgc3RyaW5nIGl0ZW1zLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGJ1aWxkVXJsXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybCBCYXNlIFVSTCB0byBhcHBlbmQgcXVlcnkgc3RyaW5nIGl0ZW1zIHRvLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbXMgTmFtZS92YWx1ZSBvYmplY3QgdG8gc2VyaWFsaXplIGFzIGEgcXVlcnlzdHJpbmcuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHdpdGggdXJsICsgc2VyaWFsaXplZCBxdWVyeSBzdHJpbmcgaXRlbXMuXG5cdCAqL1xuXHRidWlsZFVybDogZnVuY3Rpb24odXJsLCBpdGVtcykge1xuXHRcdHZhciBxdWVyeSA9ICcnO1xuXG5cdFx0cGx1cGxvYWQuZWFjaChpdGVtcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdHF1ZXJ5ICs9IChxdWVyeSA/ICcmJyA6ICcnKSArIGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVlcnkpIHtcblx0XHRcdHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA+IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVybDtcblx0fSxcblxuXHQvKipcblx0ICogRm9ybWF0cyB0aGUgc3BlY2lmaWVkIG51bWJlciBhcyBhIHNpemUgc3RyaW5nIGZvciBleGFtcGxlIDEwMjQgYmVjb21lcyAxIEtCLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGZvcm1hdFNpemVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBTaXplIHRvIGZvcm1hdCBhcyBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gRm9ybWF0dGVkIHNpemUgc3RyaW5nLlxuXHQgKi9cblx0Zm9ybWF0U2l6ZSA6IGZ1bmN0aW9uKHNpemUpIHtcblxuXHRcdGlmIChzaXplID09PSB1bmRlZiB8fCAvXFxELy50ZXN0KHNpemUpKSB7XG5cdFx0XHRyZXR1cm4gcGx1cGxvYWQudHJhbnNsYXRlKCdOL0EnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByb3VuZChudW0sIHByZWNpc2lvbikge1xuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQobnVtICogTWF0aC5wb3coMTAsIHByZWNpc2lvbikpIC8gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG5cdFx0fVxuXG5cdFx0dmFyIGJvdW5kYXJ5ID0gTWF0aC5wb3coMTAyNCwgNCk7XG5cblx0XHQvLyBUQlxuXHRcdGlmIChzaXplID4gYm91bmRhcnkpIHtcblx0XHRcdHJldHVybiByb3VuZChzaXplIC8gYm91bmRhcnksIDEpICsgXCIgXCIgKyBwbHVwbG9hZC50cmFuc2xhdGUoJ3RiJyk7XG5cdFx0fVxuXG5cdFx0Ly8gR0Jcblx0XHRpZiAoc2l6ZSA+IChib3VuZGFyeS89MTAyNCkpIHtcblx0XHRcdHJldHVybiByb3VuZChzaXplIC8gYm91bmRhcnksIDEpICsgXCIgXCIgKyBwbHVwbG9hZC50cmFuc2xhdGUoJ2diJyk7XG5cdFx0fVxuXG5cdFx0Ly8gTUJcblx0XHRpZiAoc2l6ZSA+IChib3VuZGFyeS89MTAyNCkpIHtcblx0XHRcdHJldHVybiByb3VuZChzaXplIC8gYm91bmRhcnksIDEpICsgXCIgXCIgKyBwbHVwbG9hZC50cmFuc2xhdGUoJ21iJyk7XG5cdFx0fVxuXG5cdFx0Ly8gS0Jcblx0XHRpZiAoc2l6ZSA+IDEwMjQpIHtcblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKHNpemUgLyAxMDI0KSArIFwiIFwiICsgcGx1cGxvYWQudHJhbnNsYXRlKCdrYicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzaXplICsgXCIgXCIgKyBwbHVwbG9hZC50cmFuc2xhdGUoJ2InKTtcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIHNwZWNpZmllZCBzaXplIHN0cmluZyBpbnRvIGEgYnl0ZSB2YWx1ZS4gRm9yIGV4YW1wbGUgMTBrYiBiZWNvbWVzIDEwMjQwLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHBhcnNlU2l6ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gc2l6ZSBTdHJpbmcgdG8gcGFyc2Ugb3IgbnVtYmVyIHRvIGp1c3QgcGFzcyB0aHJvdWdoLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFNpemUgaW4gYnl0ZXMuXG5cdCAqL1xuXHRwYXJzZVNpemUgOiB1LkJhc2ljLnBhcnNlU2l6ZVN0cixcblxuXG5cdC8qKlxuXHQgKiBBIHdheSB0byBwcmVkaWN0IHdoYXQgcnVudGltZSB3aWxsIGJlIGNob29zZW4gaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgd2l0aCB0aGVcblx0ICogc3BlY2lmaWVkIHNldHRpbmdzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHByZWRpY3RSdW50aW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBjb25maWcgUGx1cGxvYWQgc2V0dGluZ3MgdG8gY2hlY2tcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtydW50aW1lc10gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcnVudGltZXMgdG8gY2hlY2sgYWdhaW5zdFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFR5cGUgb2YgY29tcGF0aWJsZSBydW50aW1lXG5cdCAqL1xuXHRwcmVkaWN0UnVudGltZSA6IGZ1bmN0aW9uKGNvbmZpZywgcnVudGltZXMpIHtcblx0XHR2YXIgdXAsIHJ1bnRpbWU7XG5cblx0XHR1cCA9IG5ldyBwbHVwbG9hZC5VcGxvYWRlcihjb25maWcpO1xuXHRcdHJ1bnRpbWUgPSBSdW50aW1lLnRoYXRDYW4odXAuZ2V0T3B0aW9uKCkucmVxdWlyZWRfZmVhdHVyZXMsIHJ1bnRpbWVzIHx8IGNvbmZpZy5ydW50aW1lcyk7XG5cdFx0dXAuZGVzdHJveSgpO1xuXHRcdHJldHVybiBydW50aW1lO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBmaWx0ZXIgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGZpbGUgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuXHQgKiBJZiBjYWxsYmFjayByZXR1cm5zIGZhbHNlLCBmaWxlIHdpbGwgbm90IGJlIGFkZGVkLlxuXHQgKlxuXHQgKiBDYWxsYmFjayByZWNlaXZlcyB0d28gYXJndW1lbnRzOiBhIHZhbHVlIGZvciB0aGUgZmlsdGVyIGFzIGl0IHdhcyBzcGVjaWZpZWQgaW4gc2V0dGluZ3MuZmlsdGVyc1xuXHQgKiBhbmQgYSBmaWxlIHRvIGJlIGZpbHRlcmVkLiBDYWxsYmFjayBpcyBleGVjdXRlZCBpbiB0aGUgY29udGV4dCBvZiB1cGxvYWRlciBpbnN0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBhZGRGaWxlRmlsdGVyXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZmlsdGVyIGJ5IHdoaWNoIGl0IGNhbiBiZSByZWZlcmVuY2VkIGluIHNldHRpbmdzLmZpbHRlcnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNiIENhbGxiYWNrIC0gdGhlIGFjdHVhbCByb3V0aW5lIHRoYXQgZXZlcnkgYWRkZWQgZmlsZSBtdXN0IHBhc3Ncblx0ICovXG5cdGFkZEZpbGVGaWx0ZXI6IGZ1bmN0aW9uKG5hbWUsIGNiKSB7XG5cdFx0ZmlsZUZpbHRlcnNbbmFtZV0gPSBjYjtcblx0fVxufTtcblxuXG5wbHVwbG9hZC5hZGRGaWxlRmlsdGVyKCdtaW1lX3R5cGVzJywgZnVuY3Rpb24oZmlsdGVycywgZmlsZSwgY2IpIHtcblx0aWYgKGZpbHRlcnMubGVuZ3RoICYmICFmaWx0ZXJzLnJlZ2V4cC50ZXN0KGZpbGUubmFtZSkpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ0Vycm9yJywge1xuXHRcdFx0Y29kZSA6IHBsdXBsb2FkLkZJTEVfRVhURU5TSU9OX0VSUk9SLFxuXHRcdFx0bWVzc2FnZSA6IHBsdXBsb2FkLnRyYW5zbGF0ZSgnRmlsZSBleHRlbnNpb24gZXJyb3IuJyksXG5cdFx0XHRmaWxlIDogZmlsZVxuXHRcdH0pO1xuXHRcdGNiKGZhbHNlKTtcblx0fSBlbHNlIHtcblx0XHRjYih0cnVlKTtcblx0fVxufSk7XG5cblxucGx1cGxvYWQuYWRkRmlsZUZpbHRlcignbWF4X2ZpbGVfc2l6ZScsIGZ1bmN0aW9uKG1heFNpemUsIGZpbGUsIGNiKSB7XG5cdHZhciB1bmRlZjtcblxuXHRtYXhTaXplID0gcGx1cGxvYWQucGFyc2VTaXplKG1heFNpemUpO1xuXG5cdC8vIEludmFsaWQgZmlsZSBzaXplXG5cdGlmIChmaWxlLnNpemUgIT09IHVuZGVmICYmIG1heFNpemUgJiYgZmlsZS5zaXplID4gbWF4U2l6ZSkge1xuXHRcdHRoaXMudHJpZ2dlcignRXJyb3InLCB7XG5cdFx0XHRjb2RlIDogcGx1cGxvYWQuRklMRV9TSVpFX0VSUk9SLFxuXHRcdFx0bWVzc2FnZSA6IHBsdXBsb2FkLnRyYW5zbGF0ZSgnRmlsZSBzaXplIGVycm9yLicpLFxuXHRcdFx0ZmlsZSA6IGZpbGVcblx0XHR9KTtcblx0XHRjYihmYWxzZSk7XG5cdH0gZWxzZSB7XG5cdFx0Y2IodHJ1ZSk7XG5cdH1cbn0pO1xuXG5cbnBsdXBsb2FkLmFkZEZpbGVGaWx0ZXIoJ3ByZXZlbnRfZHVwbGljYXRlcycsIGZ1bmN0aW9uKHZhbHVlLCBmaWxlLCBjYikge1xuXHRpZiAodmFsdWUpIHtcblx0XHR2YXIgaWkgPSB0aGlzLmZpbGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoaWktLSkge1xuXHRcdFx0Ly8gQ29tcGFyZSBieSBuYW1lIGFuZCBzaXplIChzaXplIG1pZ2h0IGJlIDAgb3IgdW5kZWZpbmVkLCBidXQgc3RpbGwgZXF1aXZhbGVudCBmb3IgYm90aClcblx0XHRcdGlmIChmaWxlLm5hbWUgPT09IHRoaXMuZmlsZXNbaWldLm5hbWUgJiYgZmlsZS5zaXplID09PSB0aGlzLmZpbGVzW2lpXS5zaXplKSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignRXJyb3InLCB7XG5cdFx0XHRcdFx0Y29kZSA6IHBsdXBsb2FkLkZJTEVfRFVQTElDQVRFX0VSUk9SLFxuXHRcdFx0XHRcdG1lc3NhZ2UgOiBwbHVwbG9hZC50cmFuc2xhdGUoJ0R1cGxpY2F0ZSBmaWxlIGVycm9yLicpLFxuXHRcdFx0XHRcdGZpbGUgOiBmaWxlXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjYihmYWxzZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y2IodHJ1ZSk7XG59KTtcblxuXG4vKipcbkBjbGFzcyBVcGxvYWRlclxuQGNvbnN0cnVjdG9yXG5cbkBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBvcHRpb24gY2hlY2sgZG9jdW1lbnRhdGlvbi5cblx0QHBhcmFtIHtTdHJpbmd8RE9NRWxlbWVudH0gc2V0dGluZ3MuYnJvd3NlX2J1dHRvbiBpZCBvZiB0aGUgRE9NIGVsZW1lbnQgb3IgRE9NIGVsZW1lbnQgaXRzZWxmIHRvIHVzZSBhcyBmaWxlIGRpYWxvZyB0cmlnZ2VyLlxuXHRAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtzZXR0aW5ncy5jaHVua19zaXplPTBdIENodW5rIHNpemUgaW4gYnl0ZXMgdG8gc2xpY2UgdGhlIGZpbGUgaW50by4gU2hvcmN1dHMgd2l0aCBiLCBrYiwgbWIsIGdiLCB0YiBzdWZmaXhlcyBhbHNvIHN1cHBvcnRlZC4gYGUuZy4gMjA0ODAwIG9yIFwiMjA0ODAwYlwiIG9yIFwiMjAwa2JcImAuIEJ5IGRlZmF1bHQgLSBkaXNhYmxlZC5cblx0QHBhcmFtIHtTdHJpbmd8RE9NRWxlbWVudH0gW3NldHRpbmdzLmNvbnRhaW5lcl0gaWQgb2YgdGhlIERPTSBlbGVtZW50IG9yIERPTSBlbGVtZW50IGl0c2VsZiB0aGF0IHdpbGwgYmUgdXNlZCB0byB3cmFwIHVwbG9hZGVyIHN0cnVjdHVyZXMuIERlZmF1bHRzIHRvIGltbWVkaWF0ZSBwYXJlbnQgb2YgdGhlIGBicm93c2VfYnV0dG9uYCBlbGVtZW50LlxuXHRAcGFyYW0ge1N0cmluZ3xET01FbGVtZW50fSBbc2V0dGluZ3MuZHJvcF9lbGVtZW50XSBpZCBvZiB0aGUgRE9NIGVsZW1lbnQgb3IgRE9NIGVsZW1lbnQgaXRzZWxmIHRvIHVzZSBhcyBhIGRyb3Agem9uZSBmb3IgRHJhZy1uLURyb3AuXG5cdEBwYXJhbSB7U3RyaW5nfSBbc2V0dGluZ3MuZmlsZV9kYXRhX25hbWU9XCJmaWxlXCJdIE5hbWUgZm9yIHRoZSBmaWxlIGZpZWxkIGluIE11bHRpcGFydCBmb3JtYXRlZCBtZXNzYWdlLlxuXHRAcGFyYW0ge09iamVjdH0gW3NldHRpbmdzLmZpbHRlcnM9e31dIFNldCBvZiBmaWxlIHR5cGUgZmlsdGVycy5cblx0XHRAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtzZXR0aW5ncy5maWx0ZXJzLm1heF9maWxlX3NpemU9MF0gTWF4aW11bSBmaWxlIHNpemUgdGhhdCB0aGUgdXNlciBjYW4gcGljaywgaW4gYnl0ZXMuIE9wdGlvbmFsbHkgc3VwcG9ydHMgYiwga2IsIG1iLCBnYiwgdGIgc3VmZml4ZXMuIGBlLmcuIFwiMTBtYlwiIG9yIFwiMWdiXCJgLiBCeSBkZWZhdWx0IC0gbm90IHNldC4gRGlzcGF0Y2hlcyBgcGx1cGxvYWQuRklMRV9TSVpFX0VSUk9SYC5cblx0XHRAcGFyYW0ge0FycmF5fSBbc2V0dGluZ3MuZmlsdGVycy5taW1lX3R5cGVzPVtdXSBMaXN0IG9mIGZpbGUgdHlwZXMgdG8gYWNjZXB0LCBlYWNoIG9uZSBkZWZpbmVkIGJ5IHRpdGxlIGFuZCBsaXN0IG9mIGV4dGVuc2lvbnMuIGBlLmcuIHt0aXRsZSA6IFwiSW1hZ2UgZmlsZXNcIiwgZXh0ZW5zaW9ucyA6IFwianBnLGpwZWcsZ2lmLHBuZ1wifWAuIERpc3BhdGNoZXMgYHBsdXBsb2FkLkZJTEVfRVhURU5TSU9OX0VSUk9SYFxuXHRcdEBwYXJhbSB7Qm9vbGVhbn0gW3NldHRpbmdzLmZpbHRlcnMucHJldmVudF9kdXBsaWNhdGVzPWZhbHNlXSBEbyBub3QgbGV0IGR1cGxpY2F0ZXMgaW50byB0aGUgcXVldWUuIERpc3BhdGNoZXMgYHBsdXBsb2FkLkZJTEVfRFVQTElDQVRFX0VSUk9SYC5cblx0QHBhcmFtIHtTdHJpbmd9IFtzZXR0aW5ncy5mbGFzaF9zd2ZfdXJsXSBVUkwgb2YgdGhlIEZsYXNoIHN3Zi5cblx0QHBhcmFtIHtPYmplY3R9IFtzZXR0aW5ncy5oZWFkZXJzXSBDdXN0b20gaGVhZGVycyB0byBzZW5kIHdpdGggdGhlIHVwbG9hZC4gSGFzaCBvZiBuYW1lL3ZhbHVlIHBhaXJzLlxuXHRAcGFyYW0ge1N0cmluZ30gW3NldHRpbmdzLmh0dHBfbWV0aG9kPVwiUE9TVFwiXSBIVFRQIG1ldGhvZCB0byB1c2UgZHVyaW5nIHVwbG9hZCAob25seSBQVVQgb3IgUE9TVCBhbGxvd2VkKS5cblx0QHBhcmFtIHtOdW1iZXJ9IFtzZXR0aW5ncy5tYXhfcmV0cmllcz0wXSBIb3cgbWFueSB0aW1lcyB0byByZXRyeSB0aGUgY2h1bmsgb3IgZmlsZSwgYmVmb3JlIHRyaWdnZXJpbmcgRXJyb3IgZXZlbnQuXG5cdEBwYXJhbSB7Qm9vbGVhbn0gW3NldHRpbmdzLm11bHRpcGFydD10cnVlXSBXaGV0aGVyIHRvIHNlbmQgZmlsZSBhbmQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGFzIE11bHRpcGFydCBmb3JtYXRlZCBtZXNzYWdlLlxuXHRAcGFyYW0ge09iamVjdH0gW3NldHRpbmdzLm11bHRpcGFydF9wYXJhbXNdIEhhc2ggb2Yga2V5L3ZhbHVlIHBhaXJzIHRvIHNlbmQgd2l0aCBldmVyeSBmaWxlIHVwbG9hZC5cblx0QHBhcmFtIHtCb29sZWFufSBbc2V0dGluZ3MubXVsdGlfc2VsZWN0aW9uPXRydWVdIEVuYWJsZSBhYmlsaXR5IHRvIHNlbGVjdCBtdWx0aXBsZSBmaWxlcyBhdCBvbmNlIGluIGZpbGUgZGlhbG9nLlxuXHRAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFtzZXR0aW5ncy5yZXF1aXJlZF9mZWF0dXJlc10gRWl0aGVyIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9yIGhhc2ggb2YgcmVxdWlyZWQgZmVhdHVyZXMgdGhhdCBjaG9zZW4gcnVudGltZSBzaG91bGQgYWJzb2x1dGVseSBwb3NzZXNzLlxuXHRAcGFyYW0ge09iamVjdH0gW3NldHRpbmdzLnJlc2l6ZV0gRW5hYmxlIHJlc2l6bmcgb2YgaW1hZ2VzIG9uIGNsaWVudC1zaWRlLiBBcHBsaWVzIHRvIGBpbWFnZS9qcGVnYCBhbmQgYGltYWdlL3BuZ2Agb25seS4gYGUuZy4ge3dpZHRoIDogMjAwLCBoZWlnaHQgOiAyMDAsIHF1YWxpdHkgOiA5MCwgY3JvcDogdHJ1ZX1gXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IFtzZXR0aW5ncy5yZXNpemUud2lkdGhdIElmIGltYWdlIGlzIGJpZ2dlciwgaXQgd2lsbCBiZSByZXNpemVkLlxuXHRcdEBwYXJhbSB7TnVtYmVyfSBbc2V0dGluZ3MucmVzaXplLmhlaWdodF0gSWYgaW1hZ2UgaXMgYmlnZ2VyLCBpdCB3aWxsIGJlIHJlc2l6ZWQuXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IFtzZXR0aW5ncy5yZXNpemUucXVhbGl0eT05MF0gQ29tcHJlc3Npb24gcXVhbGl0eSBmb3IganBlZ3MgKDEtMTAwKS5cblx0XHRAcGFyYW0ge0Jvb2xlYW59IFtzZXR0aW5ncy5yZXNpemUuY3JvcD1mYWxzZV0gV2hldGhlciB0byBjcm9wIGltYWdlcyB0byBleGFjdCBkaW1lbnNpb25zLiBCeSBkZWZhdWx0IHRoZXkgd2lsbCBiZSByZXNpemVkIHByb3BvcnRpb25hbGx5LlxuXHRAcGFyYW0ge1N0cmluZ30gW3NldHRpbmdzLnJ1bnRpbWVzPVwiaHRtbDUsZmxhc2gsc2lsdmVybGlnaHQsaHRtbDRcIl0gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgcnVudGltZXMsIHRoYXQgUGx1cGxvYWQgd2lsbCB0cnkgaW4gdHVybiwgbW92aW5nIHRvIHRoZSBuZXh0IGlmIHByZXZpb3VzIGZhaWxzLlxuXHRAcGFyYW0ge1N0cmluZ30gW3NldHRpbmdzLnNpbHZlcmxpZ2h0X3hhcF91cmxdIFVSTCBvZiB0aGUgU2lsdmVybGlnaHQgeGFwLlxuXHRAcGFyYW0ge0Jvb2xlYW59IFtzZXR0aW5ncy5zZW5kX2NodW5rX251bWJlcj10cnVlXSBXaGV0aGVyIHRvIHNlbmQgY2h1bmtzIGFuZCBjaHVuayBudW1iZXJzLCBvciB0b3RhbCBhbmQgb2Zmc2V0IGJ5dGVzLlxuXHRAcGFyYW0ge0Jvb2xlYW59IFtzZXR0aW5ncy5zZW5kX2ZpbGVfbmFtZT10cnVlXSBXaGV0aGVyIHRvIHNlbmQgZmlsZSBuYW1lIGFzIGFkZGl0aW9uYWwgYXJndW1lbnQgLSAnbmFtZScgKHJlcXVpcmVkIGZvciBjaHVua2VkIHVwbG9hZHMgYW5kIHNvbWUgb3RoZXIgY2FzZXMgd2hlcmUgZmlsZSBuYW1lIGNhbm5vdCBiZSBzZW50IHZpYSBub3JtYWwgd2F5cykuXG5cdEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy51cmwgVVJMIG9mIHRoZSBzZXJ2ZXItc2lkZSB1cGxvYWQgaGFuZGxlci5cblx0QHBhcmFtIHtCb29sZWFufSBbc2V0dGluZ3MudW5pcXVlX25hbWVzPWZhbHNlXSBJZiB0cnVlIHdpbGwgZ2VuZXJhdGUgdW5pcXVlIGZpbGVuYW1lcyBmb3IgdXBsb2FkZWQgZmlsZXMuXG5cbiovXG5wbHVwbG9hZC5VcGxvYWRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0LyoqXG5cdEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgUnVuVGltZSBoYXMgYmVlbiBpbml0aWFsaXplZC5cblxuXHRAZXZlbnQgSW5pdFxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIGFmdGVyIHRoZSBpbml0IGV2ZW50IGluY2FzZSB5b3UgbmVlZCB0byBwZXJmb3JtIGFjdGlvbnMgdGhlcmUuXG5cblx0QGV2ZW50IFBvc3RJbml0XG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hlbiB0aGUgb3B0aW9uIGlzIGNoYW5nZWQgaW4gdmlhIHVwbG9hZGVyLnNldE9wdGlvbigpLlxuXG5cdEBldmVudCBPcHRpb25DaGFuZ2VkXG5cdEBzaW5jZSAyLjFcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIG9wdGlvbiB0aGF0IHdhcyBjaGFuZ2VkXG5cdEBwYXJhbSB7TWl4ZWR9IHZhbHVlIE5ldyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBvcHRpb25cblx0QHBhcmFtIHtNaXhlZH0gb2xkVmFsdWUgUHJldmlvdXMgdmFsdWUgb2YgdGhlIG9wdGlvblxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hlbiB0aGUgc2lsdmVybGlnaHQvZmxhc2ggb3Igb3RoZXIgc2hpbSBuZWVkcyB0byBtb3ZlLlxuXG5cdEBldmVudCBSZWZyZXNoXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hlbiB0aGUgb3ZlcmFsbCBzdGF0ZSBpcyBiZWluZyBjaGFuZ2VkIGZvciB0aGUgdXBsb2FkIHF1ZXVlLlxuXG5cdEBldmVudCBTdGF0ZUNoYW5nZWRcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIGJyb3dzZV9idXR0b24gaXMgY2xpY2tlZCBhbmQgYnJvd3NlIGRpYWxvZyBzaG93cy5cblxuXHRAZXZlbnQgQnJvd3NlXG5cdEBzaW5jZSAyLjEuMlxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIGZvciBldmVyeSBmaWx0ZXJlZCBmaWxlIGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgcXVldWUuXG5cblx0QGV2ZW50IEZpbGVGaWx0ZXJlZFxuXHRAc2luY2UgMi4xXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHRAcGFyYW0ge3BsdXBsb2FkLkZpbGV9IGZpbGUgQW5vdGhlciBmaWxlIHRoYXQgaGFzIHRvIGJlIGFkZGVkIHRvIHRoZSBxdWV1ZS5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIHdoZW4gdGhlIGZpbGUgcXVldWUgaXMgY2hhbmdlZC4gSW4gb3RoZXIgd29yZHMgd2hlbiBmaWxlcyBhcmUgYWRkZWQvcmVtb3ZlZCB0byB0aGUgZmlsZXMgYXJyYXkgb2YgdGhlIHVwbG9hZGVyIGluc3RhbmNlLlxuXG5cdEBldmVudCBRdWV1ZUNoYW5nZWRcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyBhZnRlciBmaWxlcyB3ZXJlIGZpbHRlcmVkIGFuZCBhZGRlZCB0byB0aGUgcXVldWUuXG5cblx0QGV2ZW50IEZpbGVzQWRkZWRcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7QXJyYXl9IGZpbGVzIEFycmF5IG9mIGZpbGUgb2JqZWN0cyB0aGF0IHdlcmUgYWRkZWQgdG8gcXVldWUgYnkgdGhlIHVzZXIuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIGZpbGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZS5cblxuXHRAZXZlbnQgRmlsZXNSZW1vdmVkXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHRAcGFyYW0ge0FycmF5fSBmaWxlcyBBcnJheSBvZiBmaWxlcyB0aGF0IGdvdCByZW1vdmVkLlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMganVzdCBiZWZvcmUgYSBmaWxlIGlzIHVwbG9hZGVkLiBDYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHVwbG9hZCBmb3IgdGhlIHNwZWNpZmllZCBmaWxlXG5cdGJ5IHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBoYW5kbGVyLlxuXG5cdEBldmVudCBCZWZvcmVVcGxvYWRcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7cGx1cGxvYWQuRmlsZX0gZmlsZSBGaWxlIHRvIGJlIHVwbG9hZGVkLlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hlbiBhIGZpbGUgaXMgdG8gYmUgdXBsb2FkZWQgYnkgdGhlIHJ1bnRpbWUuXG5cblx0QGV2ZW50IFVwbG9hZEZpbGVcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7cGx1cGxvYWQuRmlsZX0gZmlsZSBGaWxlIHRvIGJlIHVwbG9hZGVkLlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hpbGUgYSBmaWxlIGlzIGJlaW5nIHVwbG9hZGVkLiBVc2UgdGhpcyBldmVudCB0byB1cGRhdGUgdGhlIGN1cnJlbnQgZmlsZSB1cGxvYWQgcHJvZ3Jlc3MuXG5cblx0QGV2ZW50IFVwbG9hZFByb2dyZXNzXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHRAcGFyYW0ge3BsdXBsb2FkLkZpbGV9IGZpbGUgRmlsZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZC5cblx0ICovXG5cblx0LyoqXG5cdCogRmlyZXMganVzdCBiZWZvcmUgYSBjaHVuayBpcyB1cGxvYWRlZC4gVGhpcyBldmVudCBlbmFibGVzIHlvdSB0byBvdmVycmlkZSBzZXR0aW5nc1xuXHQqIG9uIHRoZSB1cGxvYWRlciBpbnN0YW5jZSBiZWZvcmUgdGhlIGNodW5rIGlzIHVwbG9hZGVkLlxuXHQqXG5cdCogQGV2ZW50IEJlZm9yZUNodW5rVXBsb2FkXG5cdCogQHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdCogQHBhcmFtIHtwbHVwbG9hZC5GaWxlfSBmaWxlIEZpbGUgdG8gYmUgdXBsb2FkZWQuXG5cdCogQHBhcmFtIHtPYmplY3R9IGFyZ3MgUE9TVCBwYXJhbXMgdG8gYmUgc2VudC5cblx0KiBAcGFyYW0ge0Jsb2J9IGNodW5rQmxvYiBDdXJyZW50IGJsb2IuXG5cdCogQHBhcmFtIHtvZmZzZXR9IG9mZnNldCBDdXJyZW50IG9mZnNldC5cblx0Ki9cblxuXHQvKipcblx0RmlyZXMgd2hlbiBmaWxlIGNodW5rIGlzIHVwbG9hZGVkLlxuXG5cdEBldmVudCBDaHVua1VwbG9hZGVkXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHRAcGFyYW0ge3BsdXBsb2FkLkZpbGV9IGZpbGUgRmlsZSB0aGF0IHRoZSBjaHVuayB3YXMgdXBsb2FkZWQgZm9yLlxuXHRAcGFyYW0ge09iamVjdH0gcmVzdWx0IE9iamVjdCB3aXRoIHJlc3BvbnNlIHByb3BlcnRpZXMuXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IHJlc3VsdC5vZmZzZXQgVGhlIGFtb3VudCBvZiBieXRlcyB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCBzbyBmYXIsIGluY2x1ZGluZyB0aGlzIGNodW5rLlxuXHRcdEBwYXJhbSB7TnVtYmVyfSByZXN1bHQudG90YWwgVGhlIHNpemUgb2YgdGhlIGZpbGUuXG5cdFx0QHBhcmFtIHtTdHJpbmd9IHJlc3VsdC5yZXNwb25zZSBUaGUgcmVzcG9uc2UgYm9keSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IHJlc3VsdC5zdGF0dXMgVGhlIEhUVFAgc3RhdHVzIGNvZGUgc2VudCBieSB0aGUgc2VydmVyLlxuXHRcdEBwYXJhbSB7U3RyaW5nfSByZXN1bHQucmVzcG9uc2VIZWFkZXJzIEFsbCB0aGUgcmVzcG9uc2UgaGVhZGVycyBhcyBhIHNpbmdsZSBzdHJpbmcuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIGEgZmlsZSBpcyBzdWNjZXNzZnVsbHkgdXBsb2FkZWQuXG5cblx0QGV2ZW50IEZpbGVVcGxvYWRlZFxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0QHBhcmFtIHtwbHVwbG9hZC5GaWxlfSBmaWxlIEZpbGUgdGhhdCB3YXMgdXBsb2FkZWQuXG5cdEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgT2JqZWN0IHdpdGggcmVzcG9uc2UgcHJvcGVydGllcy5cblx0XHRAcGFyYW0ge1N0cmluZ30gcmVzdWx0LnJlc3BvbnNlIFRoZSByZXNwb25zZSBib2R5IHNlbnQgYnkgdGhlIHNlcnZlci5cblx0XHRAcGFyYW0ge051bWJlcn0gcmVzdWx0LnN0YXR1cyBUaGUgSFRUUCBzdGF0dXMgY29kZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG5cdFx0QHBhcmFtIHtTdHJpbmd9IHJlc3VsdC5yZXNwb25zZUhlYWRlcnMgQWxsIHRoZSByZXNwb25zZSBoZWFkZXJzIGFzIGEgc2luZ2xlIHN0cmluZy5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIHdoZW4gYWxsIGZpbGVzIGluIGEgcXVldWUgYXJlIHVwbG9hZGVkLlxuXG5cdEBldmVudCBVcGxvYWRDb21wbGV0ZVxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0QHBhcmFtIHtBcnJheX0gZmlsZXMgQXJyYXkgb2YgZmlsZSBvYmplY3RzIHRoYXQgd2FzIGFkZGVkIHRvIHF1ZXVlL3NlbGVjdGVkIGJ5IHRoZSB1c2VyLlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hlbiBhIGVycm9yIG9jY3Vycy5cblxuXHRAZXZlbnQgRXJyb3Jcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7T2JqZWN0fSBlcnJvciBDb250YWlucyBjb2RlLCBtZXNzYWdlIGFuZCBzb21ldGltZXMgZmlsZSBhbmQgb3RoZXIgZGV0YWlscy5cblx0XHRAcGFyYW0ge051bWJlcn0gZXJyb3IuY29kZSBUaGUgcGx1cGxvYWQgZXJyb3IgY29kZS5cblx0XHRAcGFyYW0ge1N0cmluZ30gZXJyb3IubWVzc2FnZSBEZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IgKHVzZXMgaTE4bikuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIGRlc3Ryb3kgbWV0aG9kIGlzIGNhbGxlZC5cblxuXHRAZXZlbnQgRGVzdHJveVxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0ICovXG5cdHZhciB1aWQgPSBwbHVwbG9hZC5ndWlkKClcblx0LCBzZXR0aW5nc1xuXHQsIGZpbGVzID0gW11cblx0LCBwcmVmZXJyZWRfY2FwcyA9IHt9XG5cdCwgZmlsZUlucHV0cyA9IFtdXG5cdCwgZmlsZURyb3BzID0gW11cblx0LCBzdGFydFRpbWVcblx0LCB0b3RhbFxuXHQsIGRpc2FibGVkID0gZmFsc2Vcblx0LCB4aHJcblx0O1xuXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2RzXG5cdGZ1bmN0aW9uIHVwbG9hZE5leHQoKSB7XG5cdFx0dmFyIGZpbGUsIGNvdW50ID0gMCwgaTtcblxuXHRcdGlmICh0aGlzLnN0YXRlID09IHBsdXBsb2FkLlNUQVJURUQpIHtcblx0XHRcdC8vIEZpbmQgZmlyc3QgUVVFVUVEIGZpbGVcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIWZpbGUgJiYgZmlsZXNbaV0uc3RhdHVzID09IHBsdXBsb2FkLlFVRVVFRCkge1xuXHRcdFx0XHRcdGZpbGUgPSBmaWxlc1tpXTtcblx0XHRcdFx0XHRpZiAodGhpcy50cmlnZ2VyKFwiQmVmb3JlVXBsb2FkXCIsIGZpbGUpKSB7XG5cdFx0XHRcdFx0XHRmaWxlLnN0YXR1cyA9IHBsdXBsb2FkLlVQTE9BRElORztcblx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcihcIlVwbG9hZEZpbGVcIiwgZmlsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWxsIGZpbGVzIGFyZSBET05FIG9yIEZBSUxFRFxuXHRcdFx0aWYgKGNvdW50ID09IGZpbGVzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5zdGF0ZSAhPT0gcGx1cGxvYWQuU1RPUFBFRCkge1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSBwbHVwbG9hZC5TVE9QUEVEO1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcihcIlN0YXRlQ2hhbmdlZFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJVcGxvYWRDb21wbGV0ZVwiLCBmaWxlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBjYWxjRmlsZShmaWxlKSB7XG5cdFx0ZmlsZS5wZXJjZW50ID0gZmlsZS5zaXplID4gMCA/IE1hdGguY2VpbChmaWxlLmxvYWRlZCAvIGZpbGUuc2l6ZSAqIDEwMCkgOiAxMDA7XG5cdFx0Y2FsYygpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBjYWxjKCkge1xuXHRcdHZhciBpLCBmaWxlO1xuXHRcdHZhciBsb2FkZWQ7XG5cdFx0dmFyIGxvYWRlZER1cmluZ0N1cnJlbnRTZXNzaW9uID0gMDtcblxuXHRcdC8vIFJlc2V0IHN0YXRzXG5cdFx0dG90YWwucmVzZXQoKTtcblxuXHRcdC8vIENoZWNrIHN0YXR1cywgc2l6ZSwgbG9hZGVkIGV0YyBvbiBhbGwgZmlsZXNcblx0XHRmb3IgKGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZpbGUgPSBmaWxlc1tpXTtcblxuXHRcdFx0aWYgKGZpbGUuc2l6ZSAhPT0gdW5kZWYpIHtcblx0XHRcdFx0Ly8gV2UgY2FsY3VsYXRlIHRvdGFscyBiYXNlZCBvbiBvcmlnaW5hbCBmaWxlIHNpemVcblx0XHRcdFx0dG90YWwuc2l6ZSArPSBmaWxlLm9yaWdTaXplO1xuXG5cdFx0XHRcdC8vIFNpbmNlIHdlIGNhbm5vdCBwcmVkaWN0IGZpbGUgc2l6ZSBhZnRlciByZXNpemUsIHdlIGRvIG9wcG9zaXRlIGFuZFxuXHRcdFx0XHQvLyBpbnRlcnBvbGF0ZSBsb2FkZWQgYW1vdW50IHRvIG1hdGNoIG1hZ25pdHVkZSBvZiB0b3RhbFxuXHRcdFx0XHRsb2FkZWQgPSBmaWxlLmxvYWRlZCAqIGZpbGUub3JpZ1NpemUgLyBmaWxlLnNpemU7XG5cblx0XHRcdFx0aWYgKCFmaWxlLmNvbXBsZXRlVGltZXN0YW1wIHx8IGZpbGUuY29tcGxldGVUaW1lc3RhbXAgPiBzdGFydFRpbWUpIHtcblx0XHRcdFx0XHRsb2FkZWREdXJpbmdDdXJyZW50U2Vzc2lvbiArPSBsb2FkZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0b3RhbC5sb2FkZWQgKz0gbG9hZGVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG90YWwuc2l6ZSA9IHVuZGVmO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZmlsZS5zdGF0dXMgPT0gcGx1cGxvYWQuRE9ORSkge1xuXHRcdFx0XHR0b3RhbC51cGxvYWRlZCsrO1xuXHRcdFx0fSBlbHNlIGlmIChmaWxlLnN0YXR1cyA9PSBwbHVwbG9hZC5GQUlMRUQpIHtcblx0XHRcdFx0dG90YWwuZmFpbGVkKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b3RhbC5xdWV1ZWQrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBjb3VsZG4ndCBjYWxjdWxhdGUgYSB0b3RhbCBmaWxlIHNpemUgdGhlbiB1c2UgdGhlIG51bWJlciBvZiBmaWxlcyB0byBjYWxjIHBlcmNlbnRcblx0XHRpZiAodG90YWwuc2l6ZSA9PT0gdW5kZWYpIHtcblx0XHRcdHRvdGFsLnBlcmNlbnQgPSBmaWxlcy5sZW5ndGggPiAwID8gTWF0aC5jZWlsKHRvdGFsLnVwbG9hZGVkIC8gZmlsZXMubGVuZ3RoICogMTAwKSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvdGFsLmJ5dGVzUGVyU2VjID0gTWF0aC5jZWlsKGxvYWRlZER1cmluZ0N1cnJlbnRTZXNzaW9uIC8gKCgrbmV3IERhdGUoKSAtIHN0YXJ0VGltZSB8fCAxKSAvIDEwMDAuMCkpO1xuXHRcdFx0dG90YWwucGVyY2VudCA9IHRvdGFsLnNpemUgPiAwID8gTWF0aC5jZWlsKHRvdGFsLmxvYWRlZCAvIHRvdGFsLnNpemUgKiAxMDApIDogMDtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldFJVSUQoKSB7XG5cdFx0dmFyIGN0cmwgPSBmaWxlSW5wdXRzWzBdIHx8IGZpbGVEcm9wc1swXTtcblx0XHRpZiAoY3RybCkge1xuXHRcdFx0cmV0dXJuIGN0cmwuZ2V0UnVudGltZSgpLnVpZDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBydW50aW1lQ2FuKGZpbGUsIGNhcCkge1xuXHRcdGlmIChmaWxlLnJ1aWQpIHtcblx0XHRcdHZhciBpbmZvID0gUnVudGltZS5nZXRJbmZvKGZpbGUucnVpZCk7XG5cdFx0XHRpZiAoaW5mbykge1xuXHRcdFx0XHRyZXR1cm4gaW5mby5jYW4oY2FwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG5cdFx0dGhpcy5iaW5kKCdGaWxlc0FkZGVkIEZpbGVzUmVtb3ZlZCcsIGZ1bmN0aW9uKHVwKSB7XG5cdFx0XHR1cC50cmlnZ2VyKCdRdWV1ZUNoYW5nZWQnKTtcblx0XHRcdHVwLnJlZnJlc2goKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuYmluZCgnQ2FuY2VsVXBsb2FkJywgb25DYW5jZWxVcGxvYWQpO1xuXG5cdFx0dGhpcy5iaW5kKCdCZWZvcmVVcGxvYWQnLCBvbkJlZm9yZVVwbG9hZCk7XG5cblx0XHR0aGlzLmJpbmQoJ1VwbG9hZEZpbGUnLCBvblVwbG9hZEZpbGUpO1xuXG5cdFx0dGhpcy5iaW5kKCdVcGxvYWRQcm9ncmVzcycsIG9uVXBsb2FkUHJvZ3Jlc3MpO1xuXG5cdFx0dGhpcy5iaW5kKCdTdGF0ZUNoYW5nZWQnLCBvblN0YXRlQ2hhbmdlZCk7XG5cblx0XHR0aGlzLmJpbmQoJ1F1ZXVlQ2hhbmdlZCcsIGNhbGMpO1xuXG5cdFx0dGhpcy5iaW5kKCdFcnJvcicsIG9uRXJyb3IpO1xuXG5cdFx0dGhpcy5iaW5kKCdGaWxlVXBsb2FkZWQnLCBvbkZpbGVVcGxvYWRlZCk7XG5cblx0XHR0aGlzLmJpbmQoJ0Rlc3Ryb3knLCBvbkRlc3Ryb3kpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBpbml0Q29udHJvbHMoc2V0dGluZ3MsIGNiKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBpbml0ZWQgPSAwLCBxdWV1ZSA9IFtdO1xuXG5cdFx0Ly8gY29tbW9uIHNldHRpbmdzXG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRydW50aW1lX29yZGVyOiBzZXR0aW5ncy5ydW50aW1lcyxcblx0XHRcdHJlcXVpcmVkX2NhcHM6IHNldHRpbmdzLnJlcXVpcmVkX2ZlYXR1cmVzLFxuXHRcdFx0cHJlZmVycmVkX2NhcHM6IHByZWZlcnJlZF9jYXBzLFxuXHRcdFx0c3dmX3VybDogc2V0dGluZ3MuZmxhc2hfc3dmX3VybCxcblx0XHRcdHhhcF91cmw6IHNldHRpbmdzLnNpbHZlcmxpZ2h0X3hhcF91cmxcblx0XHR9O1xuXG5cdFx0Ly8gYWRkIHJ1bnRpbWUgc3BlY2lmaWMgb3B0aW9ucyBpZiBhbnlcblx0XHRwbHVwbG9hZC5lYWNoKHNldHRpbmdzLnJ1bnRpbWVzLnNwbGl0KC9cXHMqLFxccyovKSwgZnVuY3Rpb24ocnVudGltZSkge1xuXHRcdFx0aWYgKHNldHRpbmdzW3J1bnRpbWVdKSB7XG5cdFx0XHRcdG9wdGlvbnNbcnVudGltZV0gPSBzZXR0aW5nc1tydW50aW1lXTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGluaXRpYWxpemUgZmlsZSBwaWNrZXJzIC0gdGhlcmUgY2FuIGJlIG1hbnlcblx0XHRpZiAoc2V0dGluZ3MuYnJvd3NlX2J1dHRvbikge1xuXHRcdFx0cGx1cGxvYWQuZWFjaChzZXR0aW5ncy5icm93c2VfYnV0dG9uLCBmdW5jdGlvbihlbCkge1xuXHRcdFx0XHRxdWV1ZS5wdXNoKGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdFx0dmFyIGZpbGVJbnB1dCA9IG5ldyBvLmZpbGUuRmlsZUlucHV0KHBsdXBsb2FkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuXHRcdFx0XHRcdFx0YWNjZXB0OiBzZXR0aW5ncy5maWx0ZXJzLm1pbWVfdHlwZXMsXG5cdFx0XHRcdFx0XHRuYW1lOiBzZXR0aW5ncy5maWxlX2RhdGFfbmFtZSxcblx0XHRcdFx0XHRcdG11bHRpcGxlOiBzZXR0aW5ncy5tdWx0aV9zZWxlY3Rpb24sXG5cdFx0XHRcdFx0XHRjb250YWluZXI6IHNldHRpbmdzLmNvbnRhaW5lcixcblx0XHRcdFx0XHRcdGJyb3dzZV9idXR0b246IGVsXG5cdFx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdFx0ZmlsZUlucHV0Lm9ucmVhZHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBpbmZvID0gUnVudGltZS5nZXRJbmZvKHRoaXMucnVpZCk7XG5cblx0XHRcdFx0XHRcdC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0XHRwbHVwbG9hZC5leHRlbmQoc2VsZi5mZWF0dXJlcywge1xuXHRcdFx0XHRcdFx0XHRjaHVua3M6IGluZm8uY2FuKCdzbGljZV9ibG9iJyksXG5cdFx0XHRcdFx0XHRcdG11bHRpcGFydDogaW5mby5jYW4oJ3NlbmRfbXVsdGlwYXJ0JyksXG5cdFx0XHRcdFx0XHRcdG11bHRpX3NlbGVjdGlvbjogaW5mby5jYW4oJ3NlbGVjdF9tdWx0aXBsZScpXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aW5pdGVkKys7XG5cdFx0XHRcdFx0XHRmaWxlSW5wdXRzLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0XHRjYigpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRmaWxlSW5wdXQub25jaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkRmlsZSh0aGlzLmZpbGVzKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0ZmlsZUlucHV0LmJpbmQoJ21vdXNlZW50ZXIgbW91c2VsZWF2ZSBtb3VzZWRvd24gbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdGlmICghZGlzYWJsZWQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNldHRpbmdzLmJyb3dzZV9idXR0b25faG92ZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoJ21vdXNlZW50ZXInID09PSBlLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBsdXBsb2FkLmFkZENsYXNzKGVsLCBzZXR0aW5ncy5icm93c2VfYnV0dG9uX2hvdmVyKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCdtb3VzZWxlYXZlJyA9PT0gZS50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwbHVwbG9hZC5yZW1vdmVDbGFzcyhlbCwgc2V0dGluZ3MuYnJvd3NlX2J1dHRvbl9ob3Zlcik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKHNldHRpbmdzLmJyb3dzZV9idXR0b25fYWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCdtb3VzZWRvd24nID09PSBlLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBsdXBsb2FkLmFkZENsYXNzKGVsLCBzZXR0aW5ncy5icm93c2VfYnV0dG9uX2FjdGl2ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgnbW91c2V1cCcgPT09IGUudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGx1cGxvYWQucmVtb3ZlQ2xhc3MoZWwsIHNldHRpbmdzLmJyb3dzZV9idXR0b25fYWN0aXZlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGZpbGVJbnB1dC5iaW5kKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHNlbGYudHJpZ2dlcignQnJvd3NlJyk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmaWxlSW5wdXQuYmluZCgnZXJyb3IgcnVudGltZWVycm9yJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRmaWxlSW5wdXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGZpbGVJbnB1dC5pbml0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gaW5pdGlhbGl6ZSBkcm9wIHpvbmVzXG5cdFx0aWYgKHNldHRpbmdzLmRyb3BfZWxlbWVudCkge1xuXHRcdFx0cGx1cGxvYWQuZWFjaChzZXR0aW5ncy5kcm9wX2VsZW1lbnQsIGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRcdHF1ZXVlLnB1c2goZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHR2YXIgZmlsZURyb3AgPSBuZXcgby5maWxlLkZpbGVEcm9wKHBsdXBsb2FkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuXHRcdFx0XHRcdFx0ZHJvcF96b25lOiBlbFxuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdGZpbGVEcm9wLm9ucmVhZHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBpbmZvID0gUnVudGltZS5nZXRJbmZvKHRoaXMucnVpZCk7XG5cblx0XHRcdFx0XHRcdC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0XHRwbHVwbG9hZC5leHRlbmQoc2VsZi5mZWF0dXJlcywge1xuXHRcdFx0XHRcdFx0XHRjaHVua3M6IGluZm8uY2FuKCdzbGljZV9ibG9iJyksXG5cdFx0XHRcdFx0XHRcdG11bHRpcGFydDogaW5mby5jYW4oJ3NlbmRfbXVsdGlwYXJ0JyksXG5cdFx0XHRcdFx0XHRcdGRyYWdkcm9wOiBpbmZvLmNhbignZHJhZ19hbmRfZHJvcCcpXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aW5pdGVkKys7XG5cdFx0XHRcdFx0XHRmaWxlRHJvcHMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHRcdGNiKCk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGZpbGVEcm9wLm9uZHJvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRGaWxlKHRoaXMuZmlsZXMpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRmaWxlRHJvcC5iaW5kKCdlcnJvciBydW50aW1lZXJyb3InLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGZpbGVEcm9wID0gbnVsbDtcblx0XHRcdFx0XHRcdGNiKCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmaWxlRHJvcC5pbml0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cblx0XHRwbHVwbG9hZC5pblNlcmllcyhxdWV1ZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodHlwZW9mKGNiKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYihpbml0ZWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiByZXNpemVJbWFnZShibG9iLCBwYXJhbXMsIGNiKSB7XG5cdFx0dmFyIGltZyA9IG5ldyBvLmltYWdlLkltYWdlKCk7XG5cblx0XHR0cnkge1xuXHRcdFx0aW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBubyBtYW5pcHVsYXRpb24gcmVxdWlyZWQgaWYuLi5cblx0XHRcdFx0aWYgKHBhcmFtcy53aWR0aCA+IHRoaXMud2lkdGggJiZcblx0XHRcdFx0XHRwYXJhbXMuaGVpZ2h0ID4gdGhpcy5oZWlnaHQgJiZcblx0XHRcdFx0XHRwYXJhbXMucXVhbGl0eSA9PT0gdW5kZWYgJiZcblx0XHRcdFx0XHRwYXJhbXMucHJlc2VydmVfaGVhZGVycyAmJlxuXHRcdFx0XHRcdCFwYXJhbXMuY3JvcFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRyZXR1cm4gY2IoYmxvYik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb3RoZXJ3aXNlIGRvd25zaXplXG5cdFx0XHRcdGltZy5kb3duc2l6ZShwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQsIHBhcmFtcy5jcm9wLCBwYXJhbXMucHJlc2VydmVfaGVhZGVycyk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpbWcub25yZXNpemUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2IodGhpcy5nZXRBc0Jsb2IoYmxvYi50eXBlLCBwYXJhbXMucXVhbGl0eSkpO1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdH07XG5cblx0XHRcdGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNiKGJsb2IpO1xuXHRcdFx0fTtcblxuXHRcdFx0aW1nLmxvYWQoYmxvYik7XG5cdFx0fSBjYXRjaChleCkge1xuXHRcdFx0Y2IoYmxvYik7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBzZXRPcHRpb24ob3B0aW9uLCB2YWx1ZSwgaW5pdCkge1xuXHRcdHZhciBzZWxmID0gdGhpcywgcmVpbml0UmVxdWlyZWQgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIF9zZXRPcHRpb24ob3B0aW9uLCB2YWx1ZSwgaW5pdCkge1xuXHRcdFx0dmFyIG9sZFZhbHVlID0gc2V0dGluZ3Nbb3B0aW9uXTtcblxuXHRcdFx0c3dpdGNoIChvcHRpb24pIHtcblx0XHRcdFx0Y2FzZSAnbWF4X2ZpbGVfc2l6ZSc6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbiA9PT0gJ21heF9maWxlX3NpemUnKSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5tYXhfZmlsZV9zaXplID0gc2V0dGluZ3MuZmlsdGVycy5tYXhfZmlsZV9zaXplID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2NodW5rX3NpemUnOlxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9IHBsdXBsb2FkLnBhcnNlU2l6ZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHNldHRpbmdzW29wdGlvbl0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHNldHRpbmdzLnNlbmRfZmlsZV9uYW1lID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbXVsdGlwYXJ0Jzpcblx0XHRcdFx0XHRzZXR0aW5nc1tvcHRpb25dID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRcdFx0c2V0dGluZ3Muc2VuZF9maWxlX25hbWUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdodHRwX21ldGhvZCc6XG5cdFx0XHRcdFx0c2V0dGluZ3Nbb3B0aW9uXSA9IHZhbHVlLnRvVXBwZXJDYXNlKCkgPT09ICdQVVQnID8gJ1BVVCcgOiAnUE9TVCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndW5pcXVlX25hbWVzJzpcblx0XHRcdFx0XHRzZXR0aW5nc1tvcHRpb25dID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5zZW5kX2ZpbGVfbmFtZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2ZpbHRlcnMnOlxuXHRcdFx0XHRcdC8vIGZvciBzYWtlIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0XHRpZiAocGx1cGxvYWQudHlwZU9mKHZhbHVlKSA9PT0gJ2FycmF5Jykge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRcdG1pbWVfdHlwZXM6IHZhbHVlXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpbml0KSB7XG5cdFx0XHRcdFx0XHRwbHVwbG9hZC5leHRlbmQoc2V0dGluZ3MuZmlsdGVycywgdmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5maWx0ZXJzID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaWYgZmlsZSBmb3JtYXQgZmlsdGVycyBhcmUgYmVpbmcgdXBkYXRlZCwgcmVnZW5lcmF0ZSB0aGUgbWF0Y2hpbmcgZXhwcmVzc2lvbnNcblx0XHRcdFx0XHRpZiAodmFsdWUubWltZV90eXBlcykge1xuXHRcdFx0XHRcdFx0aWYgKHBsdXBsb2FkLnR5cGVPZih2YWx1ZS5taW1lX3R5cGVzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUubWltZV90eXBlcyA9IG8uY29yZS51dGlscy5NaW1lLm1pbWVzMmV4dExpc3QodmFsdWUubWltZV90eXBlcyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhbHVlLm1pbWVfdHlwZXMucmVnZXhwID0gKGZ1bmN0aW9uKGZpbHRlcnMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGV4dGVuc2lvbnNSZWdFeHAgPSBbXTtcblxuXHRcdFx0XHRcdFx0XHRwbHVwbG9hZC5lYWNoKGZpbHRlcnMsIGZ1bmN0aW9uKGZpbHRlcikge1xuXHRcdFx0XHRcdFx0XHRcdHBsdXBsb2FkLmVhY2goZmlsdGVyLmV4dGVuc2lvbnMuc3BsaXQoLywvKSwgZnVuY3Rpb24oZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoL15cXHMqXFwqXFxzKiQvLnRlc3QoZXh0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRleHRlbnNpb25zUmVnRXhwLnB1c2goJ1xcXFwuKicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1JlZ0V4cC5wdXNoKCdcXFxcLicgKyBleHQucmVwbGFjZShuZXcgUmVnRXhwKCdbJyArICgnL14kLiorP3woKVtde31cXFxcJy5yZXBsYWNlKC8uL2csICdcXFxcJCYnKSkgKyAnXScsICdnJyksICdcXFxcJCYnKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgUmVnRXhwKCcoJyArIGV4dGVuc2lvbnNSZWdFeHAuam9pbignfCcpICsgJykkJywgJ2knKTtcblx0XHRcdFx0XHRcdH0odmFsdWUubWltZV90eXBlcykpO1xuXG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5maWx0ZXJzLm1pbWVfdHlwZXMgPSB2YWx1ZS5taW1lX3R5cGVzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdyZXNpemUnOlxuXHRcdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0c2V0dGluZ3MucmVzaXplID0gcGx1cGxvYWQuZXh0ZW5kKHtcblx0XHRcdFx0XHRcdFx0cHJlc2VydmVfaGVhZGVyczogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Y3JvcDogZmFsc2Vcblx0XHRcdFx0XHRcdH0sIHZhbHVlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0dGluZ3MucmVzaXplID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3ByZXZlbnRfZHVwbGljYXRlcyc6XG5cdFx0XHRcdFx0c2V0dGluZ3MucHJldmVudF9kdXBsaWNhdGVzID0gc2V0dGluZ3MuZmlsdGVycy5wcmV2ZW50X2R1cGxpY2F0ZXMgPSAhIXZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIHJlaW5pdGlhbGlzYXRpb25cblx0XHRcdFx0Y2FzZSAnY29udGFpbmVyJzpcblx0XHRcdFx0Y2FzZSAnYnJvd3NlX2J1dHRvbic6XG5cdFx0XHRcdGNhc2UgJ2Ryb3BfZWxlbWVudCc6XG5cdFx0XHRcdFx0XHR2YWx1ZSA9ICdjb250YWluZXInID09PSBvcHRpb25cblx0XHRcdFx0XHRcdFx0PyBwbHVwbG9hZC5nZXQodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogcGx1cGxvYWQuZ2V0QWxsKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHQ7XG5cblx0XHRcdFx0Y2FzZSAncnVudGltZXMnOlxuXHRcdFx0XHRjYXNlICdtdWx0aV9zZWxlY3Rpb24nOlxuXHRcdFx0XHRjYXNlICdmbGFzaF9zd2ZfdXJsJzpcblx0XHRcdFx0Y2FzZSAnc2lsdmVybGlnaHRfeGFwX3VybCc6XG5cdFx0XHRcdFx0c2V0dGluZ3Nbb3B0aW9uXSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmICghaW5pdCkge1xuXHRcdFx0XHRcdFx0cmVpbml0UmVxdWlyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHNldHRpbmdzW29wdGlvbl0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpbml0KSB7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcignT3B0aW9uQ2hhbmdlZCcsIG9wdGlvbiwgdmFsdWUsIG9sZFZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mKG9wdGlvbikgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRwbHVwbG9hZC5lYWNoKG9wdGlvbiwgZnVuY3Rpb24odmFsdWUsIG9wdGlvbikge1xuXHRcdFx0XHRfc2V0T3B0aW9uKG9wdGlvbiwgdmFsdWUsIGluaXQpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9zZXRPcHRpb24ob3B0aW9uLCB2YWx1ZSwgaW5pdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGluaXQpIHtcblx0XHRcdC8vIE5vcm1hbGl6ZSB0aGUgbGlzdCBvZiByZXF1aXJlZCBjYXBhYmlsaXRpZXNcblx0XHRcdHNldHRpbmdzLnJlcXVpcmVkX2ZlYXR1cmVzID0gbm9ybWFsaXplQ2FwcyhwbHVwbG9hZC5leHRlbmQoe30sIHNldHRpbmdzKSk7XG5cblx0XHRcdC8vIENvbWUgdXAgd2l0aCB0aGUgbGlzdCBvZiBjYXBhYmlsaXRpZXMgdGhhdCBjYW4gYWZmZWN0IGRlZmF1bHQgbW9kZSBpbiBhIG11bHRpLW1vZGUgcnVudGltZXNcblx0XHRcdHByZWZlcnJlZF9jYXBzID0gbm9ybWFsaXplQ2FwcyhwbHVwbG9hZC5leHRlbmQoe30sIHNldHRpbmdzLCB7XG5cdFx0XHRcdHJlcXVpcmVkX2ZlYXR1cmVzOiB0cnVlXG5cdFx0XHR9KSk7XG5cdFx0fSBlbHNlIGlmIChyZWluaXRSZXF1aXJlZCkge1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdEZXN0cm95Jyk7XG5cblx0XHRcdGluaXRDb250cm9scy5jYWxsKHNlbGYsIHNldHRpbmdzLCBmdW5jdGlvbihpbml0ZWQpIHtcblx0XHRcdFx0aWYgKGluaXRlZCkge1xuXHRcdFx0XHRcdHNlbGYucnVudGltZSA9IFJ1bnRpbWUuZ2V0SW5mbyhnZXRSVUlEKCkpLnR5cGU7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdJbml0JywgeyBydW50aW1lOiBzZWxmLnJ1bnRpbWUgfSk7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdQb3N0SW5pdCcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcignRXJyb3InLCB7XG5cdFx0XHRcdFx0XHRjb2RlIDogcGx1cGxvYWQuSU5JVF9FUlJPUixcblx0XHRcdFx0XHRcdG1lc3NhZ2UgOiBwbHVwbG9hZC50cmFuc2xhdGUoJ0luaXQgZXJyb3IuJylcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBJbnRlcm5hbCBldmVudCBoYW5kbGVyc1xuXHRmdW5jdGlvbiBvbkJlZm9yZVVwbG9hZCh1cCwgZmlsZSkge1xuXHRcdC8vIEdlbmVyYXRlIHVuaXF1ZSB0YXJnZXQgZmlsZW5hbWVzXG5cdFx0aWYgKHVwLnNldHRpbmdzLnVuaXF1ZV9uYW1lcykge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBmaWxlLm5hbWUubWF0Y2goL1xcLihbXi5dKykkLyksIGV4dCA9IFwicGFydFwiO1xuXHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0ZXh0ID0gbWF0Y2hlc1sxXTtcblx0XHRcdH1cblx0XHRcdGZpbGUudGFyZ2V0X25hbWUgPSBmaWxlLmlkICsgJy4nICsgZXh0O1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gb25VcGxvYWRGaWxlKHVwLCBmaWxlKSB7XG5cdFx0dmFyIHVybCA9IHVwLnNldHRpbmdzLnVybFxuXHRcdCwgY2h1bmtTaXplID0gdXAuc2V0dGluZ3MuY2h1bmtfc2l6ZVxuXHRcdCwgcmV0cmllcyA9IHVwLnNldHRpbmdzLm1heF9yZXRyaWVzXG5cdFx0LCBmZWF0dXJlcyA9IHVwLmZlYXR1cmVzXG5cdFx0LCBvZmZzZXQgPSAwXG5cdFx0LCBibG9iXG5cdFx0O1xuXG5cdFx0Ly8gbWFrZSBzdXJlIHdlIHN0YXJ0IGF0IGEgcHJlZGljdGFibGUgb2Zmc2V0XG5cdFx0aWYgKGZpbGUubG9hZGVkKSB7XG5cdFx0XHRvZmZzZXQgPSBmaWxlLmxvYWRlZCA9IGNodW5rU2l6ZSA/IGNodW5rU2l6ZSAqIE1hdGguZmxvb3IoZmlsZS5sb2FkZWQgLyBjaHVua1NpemUpIDogMDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcblx0XHRcdGlmIChyZXRyaWVzLS0gPiAwKSB7XG5cdFx0XHRcdGRlbGF5KHVwbG9hZE5leHRDaHVuaywgMTAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaWxlLmxvYWRlZCA9IG9mZnNldDsgLy8gcmVzZXQgYWxsIHByb2dyZXNzXG5cblx0XHRcdFx0dXAudHJpZ2dlcignRXJyb3InLCB7XG5cdFx0XHRcdFx0Y29kZSA6IHBsdXBsb2FkLkhUVFBfRVJST1IsXG5cdFx0XHRcdFx0bWVzc2FnZSA6IHBsdXBsb2FkLnRyYW5zbGF0ZSgnSFRUUCBFcnJvci4nKSxcblx0XHRcdFx0XHRmaWxlIDogZmlsZSxcblx0XHRcdFx0XHRyZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQsXG5cdFx0XHRcdFx0c3RhdHVzIDogeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnM6IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGxvYWROZXh0Q2h1bmsoKSB7XG5cdFx0XHR2YXIgY2h1bmtCbG9iLCBhcmdzID0ge30sIGN1ckNodW5rU2l6ZTtcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgZmlsZSB3YXNuJ3QgY2FuY2VsbGVkIGFuZCB1cGxvYWQgaXMgbm90IHN0b3BwZWQgaW4gZ2VuZXJhbFxuXHRcdFx0aWYgKGZpbGUuc3RhdHVzICE9PSBwbHVwbG9hZC5VUExPQURJTkcgfHwgdXAuc3RhdGUgPT09IHBsdXBsb2FkLlNUT1BQRUQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZW5kIGFkZGl0aW9uYWwgJ25hbWUnIHBhcmFtZXRlciBvbmx5IGlmIHJlcXVpcmVkXG5cdFx0XHRpZiAodXAuc2V0dGluZ3Muc2VuZF9maWxlX25hbWUpIHtcblx0XHRcdFx0YXJncy5uYW1lID0gZmlsZS50YXJnZXRfbmFtZSB8fCBmaWxlLm5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaHVua1NpemUgJiYgZmVhdHVyZXMuY2h1bmtzICYmIGJsb2Iuc2l6ZSA+IGNodW5rU2l6ZSkgeyAvLyBibG9iIHdpbGwgYmUgb2YgdHlwZSBzdHJpbmcgaWYgaXQgd2FzIGxvYWRlZCBpbiBtZW1vcnlcblx0XHRcdFx0Y3VyQ2h1bmtTaXplID0gTWF0aC5taW4oY2h1bmtTaXplLCBibG9iLnNpemUgLSBvZmZzZXQpO1xuXHRcdFx0XHRjaHVua0Jsb2IgPSBibG9iLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY3VyQ2h1bmtTaXplKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1ckNodW5rU2l6ZSA9IGJsb2Iuc2l6ZTtcblx0XHRcdFx0Y2h1bmtCbG9iID0gYmxvYjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgY2h1bmtpbmcgaXMgZW5hYmxlZCBhZGQgY29ycmVzcG9uZGluZyBhcmdzLCBubyBtYXR0ZXIgaWYgZmlsZSBpcyBiaWdnZXIgdGhhbiBjaHVuayBvciBzbWFsbGVyXG5cdFx0XHRpZiAoY2h1bmtTaXplICYmIGZlYXR1cmVzLmNodW5rcykge1xuXHRcdFx0XHQvLyBTZXR1cCBxdWVyeSBzdHJpbmcgYXJndW1lbnRzXG5cdFx0XHRcdGlmICh1cC5zZXR0aW5ncy5zZW5kX2NodW5rX251bWJlcikge1xuXHRcdFx0XHRcdGFyZ3MuY2h1bmsgPSBNYXRoLmNlaWwob2Zmc2V0IC8gY2h1bmtTaXplKTtcblx0XHRcdFx0XHRhcmdzLmNodW5rcyA9IE1hdGguY2VpbChibG9iLnNpemUgLyBjaHVua1NpemUpO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBrZWVwIHN1cHBvcnQgZm9yIGV4cGVyaW1lbnRhbCBjaHVuayBmb3JtYXQsIGp1c3QgaW4gY2FzZVxuXHRcdFx0XHRcdGFyZ3Mub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0XHRcdGFyZ3MudG90YWwgPSBibG9iLnNpemU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHVwLnRyaWdnZXIoJ0JlZm9yZUNodW5rVXBsb2FkJywgZmlsZSwgYXJncywgY2h1bmtCbG9iLCBvZmZzZXQpKSB7XG5cdFx0XHRcdHVwbG9hZENodW5rKGFyZ3MsIGNodW5rQmxvYiwgY3VyQ2h1bmtTaXplKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGxvYWRDaHVuayhhcmdzLCBjaHVua0Jsb2IsIGN1ckNodW5rU2l6ZSkge1xuXHRcdFx0dmFyIGZvcm1EYXRhO1xuXG5cdFx0XHR4aHIgPSBuZXcgby54aHIuWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdFx0Ly8gRG8gd2UgaGF2ZSB1cGxvYWQgcHJvZ3Jlc3Mgc3VwcG9ydFxuXHRcdFx0aWYgKHhoci51cGxvYWQpIHtcblx0XHRcdFx0eGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGZpbGUubG9hZGVkID0gTWF0aC5taW4oZmlsZS5zaXplLCBvZmZzZXQgKyBlLmxvYWRlZCk7XG5cdFx0XHRcdFx0dXAudHJpZ2dlcignVXBsb2FkUHJvZ3Jlc3MnLCBmaWxlKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBjaGVjayBpZiB1cGxvYWQgbWFkZSBpdHNlbGYgdGhyb3VnaFxuXHRcdFx0XHRpZiAoeGhyLnN0YXR1cyA+PSA0MDApIHtcblx0XHRcdFx0XHRoYW5kbGVFcnJvcigpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHJpZXMgPSB1cC5zZXR0aW5ncy5tYXhfcmV0cmllczsgLy8gcmVzZXQgdGhlIGNvdW50ZXJcblxuXHRcdFx0XHQvLyBIYW5kbGUgY2h1bmsgcmVzcG9uc2Vcblx0XHRcdFx0aWYgKGN1ckNodW5rU2l6ZSA8IGJsb2Iuc2l6ZSkge1xuXHRcdFx0XHRcdGNodW5rQmxvYi5kZXN0cm95KCk7XG5cblx0XHRcdFx0XHRvZmZzZXQgKz0gY3VyQ2h1bmtTaXplO1xuXHRcdFx0XHRcdGZpbGUubG9hZGVkID0gTWF0aC5taW4ob2Zmc2V0LCBibG9iLnNpemUpO1xuXG5cdFx0XHRcdFx0dXAudHJpZ2dlcignQ2h1bmtVcGxvYWRlZCcsIGZpbGUsIHtcblx0XHRcdFx0XHRcdG9mZnNldCA6IGZpbGUubG9hZGVkLFxuXHRcdFx0XHRcdFx0dG90YWwgOiBibG9iLnNpemUsXG5cdFx0XHRcdFx0XHRyZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQsXG5cdFx0XHRcdFx0XHRzdGF0dXMgOiB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzOiB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIHN0b2NrIEFuZHJvaWQgYnJvd3NlciBkb2Vzbid0IGZpcmUgdXBsb2FkIHByb2dyZXNzIGV2ZW50cywgYnV0IGluIGNodW5raW5nIG1vZGUgd2UgY2FuIGZha2UgdGhlbVxuXHRcdFx0XHRcdGlmIChwbHVwbG9hZC51YS5icm93c2VyID09PSAnQW5kcm9pZCBCcm93c2VyJykge1xuXHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBoYXJtIGluIGdlbmVyYWwsIGJ1dCBpcyBub3QgcmVxdWlyZWQgYW55d2hlcmUgZWxzZVxuXHRcdFx0XHRcdFx0dXAudHJpZ2dlcignVXBsb2FkUHJvZ3Jlc3MnLCBmaWxlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmlsZS5sb2FkZWQgPSBmaWxlLnNpemU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjaHVua0Jsb2IgPSBmb3JtRGF0YSA9IG51bGw7IC8vIEZyZWUgbWVtb3J5XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZmlsZSBpcyB1cGxvYWRlZFxuXHRcdFx0XHRpZiAoIW9mZnNldCB8fCBvZmZzZXQgPj0gYmxvYi5zaXplKSB7XG5cdFx0XHRcdFx0Ly8gSWYgZmlsZSB3YXMgbW9kaWZpZWQsIGRlc3RvcnkgdGhlIGNvcHlcblx0XHRcdFx0XHRpZiAoZmlsZS5zaXplICE9IGZpbGUub3JpZ1NpemUpIHtcblx0XHRcdFx0XHRcdGJsb2IuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0YmxvYiA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dXAudHJpZ2dlcignVXBsb2FkUHJvZ3Jlc3MnLCBmaWxlKTtcblxuXHRcdFx0XHRcdGZpbGUuc3RhdHVzID0gcGx1cGxvYWQuRE9ORTtcblx0XHRcdFx0XHRmaWxlLmNvbXBsZXRlVGltZXN0YW1wID0gK25ldyBEYXRlKCk7XG5cblx0XHRcdFx0XHR1cC50cmlnZ2VyKCdGaWxlVXBsb2FkZWQnLCBmaWxlLCB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQsXG5cdFx0XHRcdFx0XHRzdGF0dXMgOiB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzOiB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBTdGlsbCBjaHVua3MgbGVmdFxuXHRcdFx0XHRcdGRlbGF5KHVwbG9hZE5leHRDaHVuaywgMSk7IC8vIHJ1biBkZXRhY2hlZCwgb3RoZXJ3aXNlIGV2ZW50IGhhbmRsZXJzIGludGVyZmVyZVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRoYW5kbGVFcnJvcigpO1xuXHRcdFx0fTtcblxuXHRcdFx0eGhyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0eGhyID0gbnVsbDtcblx0XHRcdH07XG5cblx0XHRcdC8vIEJ1aWxkIG11bHRpcGFydCByZXF1ZXN0XG5cdFx0XHRpZiAodXAuc2V0dGluZ3MubXVsdGlwYXJ0ICYmIGZlYXR1cmVzLm11bHRpcGFydCkge1xuXHRcdFx0XHR4aHIub3Blbih1cC5zZXR0aW5ncy5odHRwX21ldGhvZCwgdXJsLCB0cnVlKTtcblxuXHRcdFx0XHQvLyBTZXQgY3VzdG9tIGhlYWRlcnNcblx0XHRcdFx0cGx1cGxvYWQuZWFjaCh1cC5zZXR0aW5ncy5oZWFkZXJzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Zm9ybURhdGEgPSBuZXcgby54aHIuRm9ybURhdGEoKTtcblxuXHRcdFx0XHQvLyBBZGQgbXVsdGlwYXJ0IHBhcmFtc1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKHBsdXBsb2FkLmV4dGVuZChhcmdzLCB1cC5zZXR0aW5ncy5tdWx0aXBhcnRfcGFyYW1zKSwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBBZGQgZmlsZSBhbmQgc2VuZCBpdFxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQodXAuc2V0dGluZ3MuZmlsZV9kYXRhX25hbWUsIGNodW5rQmxvYik7XG5cdFx0XHRcdHhoci5zZW5kKGZvcm1EYXRhLCB7XG5cdFx0XHRcdFx0cnVudGltZV9vcmRlcjogdXAuc2V0dGluZ3MucnVudGltZXMsXG5cdFx0XHRcdFx0cmVxdWlyZWRfY2FwczogdXAuc2V0dGluZ3MucmVxdWlyZWRfZmVhdHVyZXMsXG5cdFx0XHRcdFx0cHJlZmVycmVkX2NhcHM6IHByZWZlcnJlZF9jYXBzLFxuXHRcdFx0XHRcdHN3Zl91cmw6IHVwLnNldHRpbmdzLmZsYXNoX3N3Zl91cmwsXG5cdFx0XHRcdFx0eGFwX3VybDogdXAuc2V0dGluZ3Muc2lsdmVybGlnaHRfeGFwX3VybFxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGlmIG5vIG11bHRpcGFydCwgc2VuZCBhcyBiaW5hcnkgc3RyZWFtXG5cdFx0XHRcdHVybCA9IHBsdXBsb2FkLmJ1aWxkVXJsKHVwLnNldHRpbmdzLnVybCwgcGx1cGxvYWQuZXh0ZW5kKGFyZ3MsIHVwLnNldHRpbmdzLm11bHRpcGFydF9wYXJhbXMpKTtcblxuXHRcdFx0XHR4aHIub3Blbih1cC5zZXR0aW5ncy5odHRwX21ldGhvZCwgdXJsLCB0cnVlKTtcblxuXHRcdFx0XHQvLyBTZXQgY3VzdG9tIGhlYWRlcnNcblx0XHRcdFx0cGx1cGxvYWQuZWFjaCh1cC5zZXR0aW5ncy5oZWFkZXJzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gZG8gbm90IHNldCBDb250ZW50LVR5cGUsIGlmIGl0IHdhcyBkZWZpbmVkIHByZXZpb3VzbHkgKHNlZSAjMTIwMylcblx0XHRcdFx0aWYgKCF4aHIuaGFzUmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJykpIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpOyAvLyBCaW5hcnkgc3RyZWFtIGhlYWRlclxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eGhyLnNlbmQoY2h1bmtCbG9iLCB7XG5cdFx0XHRcdFx0cnVudGltZV9vcmRlcjogdXAuc2V0dGluZ3MucnVudGltZXMsXG5cdFx0XHRcdFx0cmVxdWlyZWRfY2FwczogdXAuc2V0dGluZ3MucmVxdWlyZWRfZmVhdHVyZXMsXG5cdFx0XHRcdFx0cHJlZmVycmVkX2NhcHM6IHByZWZlcnJlZF9jYXBzLFxuXHRcdFx0XHRcdHN3Zl91cmw6IHVwLnNldHRpbmdzLmZsYXNoX3N3Zl91cmwsXG5cdFx0XHRcdFx0eGFwX3VybDogdXAuc2V0dGluZ3Muc2lsdmVybGlnaHRfeGFwX3VybFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGJsb2IgPSBmaWxlLmdldFNvdXJjZSgpO1xuXG5cdFx0Ly8gU3RhcnQgdXBsb2FkaW5nIGNodW5rc1xuXHRcdGlmICghcGx1cGxvYWQuaXNFbXB0eU9iaih1cC5zZXR0aW5ncy5yZXNpemUpICYmIHJ1bnRpbWVDYW4oYmxvYiwgJ3NlbmRfYmluYXJ5X3N0cmluZycpICYmIHBsdXBsb2FkLmluQXJyYXkoYmxvYi50eXBlLCBbJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvcG5nJ10pICE9PSAtMSkge1xuXHRcdFx0Ly8gUmVzaXplIGlmIHJlcXVpcmVkXG5cdFx0XHRyZXNpemVJbWFnZS5jYWxsKHRoaXMsIGJsb2IsIHVwLnNldHRpbmdzLnJlc2l6ZSwgZnVuY3Rpb24ocmVzaXplZEJsb2IpIHtcblx0XHRcdFx0YmxvYiA9IHJlc2l6ZWRCbG9iO1xuXHRcdFx0XHRmaWxlLnNpemUgPSByZXNpemVkQmxvYi5zaXplO1xuXHRcdFx0XHR1cGxvYWROZXh0Q2h1bmsoKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cGxvYWROZXh0Q2h1bmsoKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIG9uVXBsb2FkUHJvZ3Jlc3ModXAsIGZpbGUpIHtcblx0XHRjYWxjRmlsZShmaWxlKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gb25TdGF0ZUNoYW5nZWQodXApIHtcblx0XHRpZiAodXAuc3RhdGUgPT0gcGx1cGxvYWQuU1RBUlRFRCkge1xuXHRcdFx0Ly8gR2V0IHN0YXJ0IHRpbWUgdG8gY2FsY3VsYXRlIGJwc1xuXHRcdFx0c3RhcnRUaW1lID0gKCtuZXcgRGF0ZSgpKTtcblx0XHR9IGVsc2UgaWYgKHVwLnN0YXRlID09IHBsdXBsb2FkLlNUT1BQRUQpIHtcblx0XHRcdC8vIFJlc2V0IGN1cnJlbnRseSB1cGxvYWRpbmcgZmlsZXNcblx0XHRcdGZvciAodmFyIGkgPSB1cC5maWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAodXAuZmlsZXNbaV0uc3RhdHVzID09IHBsdXBsb2FkLlVQTE9BRElORykge1xuXHRcdFx0XHRcdHVwLmZpbGVzW2ldLnN0YXR1cyA9IHBsdXBsb2FkLlFVRVVFRDtcblx0XHRcdFx0XHRjYWxjKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIG9uQ2FuY2VsVXBsb2FkKCkge1xuXHRcdGlmICh4aHIpIHtcblx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gb25GaWxlVXBsb2FkZWQodXApIHtcblx0XHRjYWxjKCk7XG5cblx0XHQvLyBVcGxvYWQgbmV4dCBmaWxlIGJ1dCBkZXRhY2ggaXQgZnJvbSB0aGUgZXJyb3IgZXZlbnRcblx0XHQvLyBzaW5jZSBvdGhlciBjdXN0b20gbGlzdGVuZXJzIG1pZ2h0IHdhbnQgdG8gc3RvcCB0aGUgcXVldWVcblx0XHRkZWxheShmdW5jdGlvbigpIHtcblx0XHRcdHVwbG9hZE5leHQuY2FsbCh1cCk7XG5cdFx0fSwgMSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIG9uRXJyb3IodXAsIGVycikge1xuXHRcdGlmIChlcnIuY29kZSA9PT0gcGx1cGxvYWQuSU5JVF9FUlJPUikge1xuXHRcdFx0dXAuZGVzdHJveSgpO1xuXHRcdH1cblx0XHQvLyBTZXQgZmFpbGVkIHN0YXR1cyBpZiBhbiBlcnJvciBvY2N1cmVkIG9uIGEgZmlsZVxuXHRcdGVsc2UgaWYgKGVyci5jb2RlID09PSBwbHVwbG9hZC5IVFRQX0VSUk9SKSB7XG5cdFx0XHRlcnIuZmlsZS5zdGF0dXMgPSBwbHVwbG9hZC5GQUlMRUQ7XG5cdFx0XHRlcnIuZmlsZS5jb21wbGV0ZVRpbWVzdGFtcCA9ICtuZXcgRGF0ZSgpO1xuXHRcdFx0Y2FsY0ZpbGUoZXJyLmZpbGUpO1xuXG5cdFx0XHQvLyBVcGxvYWQgbmV4dCBmaWxlIGJ1dCBkZXRhY2ggaXQgZnJvbSB0aGUgZXJyb3IgZXZlbnRcblx0XHRcdC8vIHNpbmNlIG90aGVyIGN1c3RvbSBsaXN0ZW5lcnMgbWlnaHQgd2FudCB0byBzdG9wIHRoZSBxdWV1ZVxuXHRcdFx0aWYgKHVwLnN0YXRlID09IHBsdXBsb2FkLlNUQVJURUQpIHsgLy8gdXBsb2FkIGluIHByb2dyZXNzXG5cdFx0XHRcdHVwLnRyaWdnZXIoJ0NhbmNlbFVwbG9hZCcpO1xuXHRcdFx0XHRkZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR1cGxvYWROZXh0LmNhbGwodXApO1xuXHRcdFx0XHR9LCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIG9uRGVzdHJveSh1cCkge1xuXHRcdHVwLnN0b3AoKTtcblxuXHRcdC8vIFB1cmdlIHRoZSBxdWV1ZVxuXHRcdHBsdXBsb2FkLmVhY2goZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdGZpbGUuZGVzdHJveSgpO1xuXHRcdH0pO1xuXHRcdGZpbGVzID0gW107XG5cblx0XHRpZiAoZmlsZUlucHV0cy5sZW5ndGgpIHtcblx0XHRcdHBsdXBsb2FkLmVhY2goZmlsZUlucHV0cywgZnVuY3Rpb24oZmlsZUlucHV0KSB7XG5cdFx0XHRcdGZpbGVJbnB1dC5kZXN0cm95KCk7XG5cdFx0XHR9KTtcblx0XHRcdGZpbGVJbnB1dHMgPSBbXTtcblx0XHR9XG5cblx0XHRpZiAoZmlsZURyb3BzLmxlbmd0aCkge1xuXHRcdFx0cGx1cGxvYWQuZWFjaChmaWxlRHJvcHMsIGZ1bmN0aW9uKGZpbGVEcm9wKSB7XG5cdFx0XHRcdGZpbGVEcm9wLmRlc3Ryb3koKTtcblx0XHRcdH0pO1xuXHRcdFx0ZmlsZURyb3BzID0gW107XG5cdFx0fVxuXG5cdFx0cHJlZmVycmVkX2NhcHMgPSB7fTtcblx0XHRkaXNhYmxlZCA9IGZhbHNlO1xuXHRcdHN0YXJ0VGltZSA9IHhociA9IG51bGw7XG5cdFx0dG90YWwucmVzZXQoKTtcblx0fVxuXG5cblx0Ly8gRGVmYXVsdCBzZXR0aW5nc1xuXHRzZXR0aW5ncyA9IHtcblx0XHRjaHVua19zaXplOiAwLFxuXHRcdGZpbGVfZGF0YV9uYW1lOiAnZmlsZScsXG5cdFx0ZmlsdGVyczoge1xuXHRcdFx0bWltZV90eXBlczogW10sXG5cdFx0XHRwcmV2ZW50X2R1cGxpY2F0ZXM6IGZhbHNlLFxuXHRcdFx0bWF4X2ZpbGVfc2l6ZTogMFxuXHRcdH0sXG5cdFx0Zmxhc2hfc3dmX3VybDogJ2pzL01veGllLnN3ZicsXG5cdFx0aHR0cF9tZXRob2Q6ICdQT1NUJyxcblx0XHRtYXhfcmV0cmllczogMCxcblx0XHRtdWx0aXBhcnQ6IHRydWUsXG5cdFx0bXVsdGlfc2VsZWN0aW9uOiB0cnVlLFxuXHRcdHJlc2l6ZTogZmFsc2UsXG5cdFx0cnVudGltZXM6IFJ1bnRpbWUub3JkZXIsXG5cdFx0c2VuZF9maWxlX25hbWU6IHRydWUsXG5cdFx0c2VuZF9jaHVua19udW1iZXI6IHRydWUsXG5cdFx0c2lsdmVybGlnaHRfeGFwX3VybDogJ2pzL01veGllLnhhcCdcblx0fTtcblxuXG5cdHNldE9wdGlvbi5jYWxsKHRoaXMsIG9wdGlvbnMsIG51bGwsIHRydWUpO1xuXG5cdC8vIEluaXRhbCB0b3RhbCBzdGF0ZVxuXHR0b3RhbCA9IG5ldyBwbHVwbG9hZC5RdWV1ZVByb2dyZXNzKCk7XG5cblx0Ly8gQWRkIHB1YmxpYyBtZXRob2RzXG5cdHBsdXBsb2FkLmV4dGVuZCh0aGlzLCB7XG5cblx0XHQvKipcblx0XHQgKiBVbmlxdWUgaWQgZm9yIHRoZSBVcGxvYWRlciBpbnN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBpZFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdGlkIDogdWlkLFxuXHRcdHVpZCA6IHVpZCwgLy8gbU94aWUgdXNlcyB0aGlzIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBldmVudCB0YXJnZXRzXG5cblx0XHQvKipcblx0XHQgKiBDdXJyZW50IHN0YXRlIG9mIHRoZSB0b3RhbCB1cGxvYWRpbmcgcHJvZ3Jlc3MuIFRoaXMgb25lIGNhbiBlaXRoZXIgYmUgcGx1cGxvYWQuU1RBUlRFRCBvciBwbHVwbG9hZC5TVE9QUEVELlxuXHRcdCAqIFRoZXNlIHN0YXRlcyBhcmUgY29udHJvbGxlZCBieSB0aGUgc3RvcC9zdGFydCBtZXRob2RzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBTVE9QUEVELlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHN0YXRlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICovXG5cdFx0c3RhdGUgOiBwbHVwbG9hZC5TVE9QUEVELFxuXG5cdFx0LyoqXG5cdFx0ICogTWFwIG9mIGZlYXR1cmVzIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhlIHVwbG9hZGVyIHJ1bnRpbWUuIEZlYXR1cmVzIHdpbGwgYmUgZmlsbGVkXG5cdFx0ICogYmVmb3JlIHRoZSBpbml0IGV2ZW50IGlzIGNhbGxlZCwgdGhlc2UgZmVhdHVyZXMgY2FuIHRoZW4gYmUgdXNlZCB0byBhbHRlciB0aGUgVUkgZm9yIHRoZSBlbmQgdXNlci5cblx0XHQgKiBTb21lIG9mIHRoZSBjdXJyZW50IGZlYXR1cmVzIHRoYXQgbWlnaHQgYmUgaW4gdGhpcyBtYXAgaXM6IGRyYWdkcm9wLCBjaHVua3MsIGpwZ3Jlc2l6ZSwgcG5ncmVzaXplLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGZlYXR1cmVzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0ZmVhdHVyZXMgOiB7fSxcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgcnVudGltZSBuYW1lLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHJ1bnRpbWVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHRydW50aW1lIDogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgdXBsb2FkIHF1ZXVlLCBhbiBhcnJheSBvZiBGaWxlIGluc3RhbmNlcy5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBmaWxlc1xuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICogQHNlZSBwbHVwbG9hZC5GaWxlXG5cdFx0ICovXG5cdFx0ZmlsZXMgOiBmaWxlcyxcblxuXHRcdC8qKlxuXHRcdCAqIE9iamVjdCB3aXRoIG5hbWUvdmFsdWUgc2V0dGluZ3MuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgc2V0dGluZ3Ncblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHRzZXR0aW5ncyA6IHNldHRpbmdzLFxuXG5cdFx0LyoqXG5cdFx0ICogVG90YWwgcHJvZ2VzcyBpbmZvcm1hdGlvbi4gSG93IG1hbnkgZmlsZXMgaGFzIGJlZW4gdXBsb2FkZWQsIHRvdGFsIHBlcmNlbnQgZXRjLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHRvdGFsXG5cdFx0ICogQHR5cGUgcGx1cGxvYWQuUXVldWVQcm9ncmVzc1xuXHRcdCAqL1xuXHRcdHRvdGFsIDogdG90YWwsXG5cblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVzIHRoZSBVcGxvYWRlciBpbnN0YW5jZSBhbmQgYWRkcyBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnMuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKi9cblx0XHRpbml0IDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIG9wdCwgcHJlaW5pdE9wdCwgZXJyO1xuXG5cdFx0XHRwcmVpbml0T3B0ID0gc2VsZi5nZXRPcHRpb24oJ3ByZWluaXQnKTtcblx0XHRcdGlmICh0eXBlb2YocHJlaW5pdE9wdCkgPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHByZWluaXRPcHQoc2VsZik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKHByZWluaXRPcHQsIGZ1bmN0aW9uKGZ1bmMsIG5hbWUpIHtcblx0XHRcdFx0XHRzZWxmLmJpbmQobmFtZSwgZnVuYyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRiaW5kRXZlbnRMaXN0ZW5lcnMuY2FsbChzZWxmKTtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHJlcXVpcmVkIG9wdGlvbnNcblx0XHRcdHBsdXBsb2FkLmVhY2goWydjb250YWluZXInLCAnYnJvd3NlX2J1dHRvbicsICdkcm9wX2VsZW1lbnQnXSwgZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0aWYgKHNlbGYuZ2V0T3B0aW9uKGVsKSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGVyciA9IHtcblx0XHRcdFx0XHRcdGNvZGUgOiBwbHVwbG9hZC5JTklUX0VSUk9SLFxuXHRcdFx0XHRcdFx0bWVzc2FnZSA6IHBsdXBsb2FkLnNwcmludGYocGx1cGxvYWQudHJhbnNsYXRlKFwiJXMgc3BlY2lmaWVkLCBidXQgY2Fubm90IGJlIGZvdW5kLlwiKSwgZWwpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYudHJpZ2dlcignRXJyb3InLCBlcnIpO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmICghc2V0dGluZ3MuYnJvd3NlX2J1dHRvbiAmJiAhc2V0dGluZ3MuZHJvcF9lbGVtZW50KSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLnRyaWdnZXIoJ0Vycm9yJywge1xuXHRcdFx0XHRcdGNvZGUgOiBwbHVwbG9hZC5JTklUX0VSUk9SLFxuXHRcdFx0XHRcdG1lc3NhZ2UgOiBwbHVwbG9hZC50cmFuc2xhdGUoXCJZb3UgbXVzdCBzcGVjaWZ5IGVpdGhlciBicm93c2VfYnV0dG9uIG9yIGRyb3BfZWxlbWVudC5cIilcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblxuXHRcdFx0aW5pdENvbnRyb2xzLmNhbGwoc2VsZiwgc2V0dGluZ3MsIGZ1bmN0aW9uKGluaXRlZCkge1xuXHRcdFx0XHR2YXIgaW5pdE9wdCA9IHNlbGYuZ2V0T3B0aW9uKCdpbml0Jyk7XG5cdFx0XHRcdGlmICh0eXBlb2YoaW5pdE9wdCkgPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0aW5pdE9wdChzZWxmKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbHVwbG9hZC5lYWNoKGluaXRPcHQsIGZ1bmN0aW9uKGZ1bmMsIG5hbWUpIHtcblx0XHRcdFx0XHRcdHNlbGYuYmluZChuYW1lLCBmdW5jKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpbml0ZWQpIHtcblx0XHRcdFx0XHRzZWxmLnJ1bnRpbWUgPSBSdW50aW1lLmdldEluZm8oZ2V0UlVJRCgpKS50eXBlO1xuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcignSW5pdCcsIHsgcnVudGltZTogc2VsZi5ydW50aW1lIH0pO1xuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcignUG9zdEluaXQnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ0Vycm9yJywge1xuXHRcdFx0XHRcdFx0Y29kZSA6IHBsdXBsb2FkLklOSVRfRVJST1IsXG5cdFx0XHRcdFx0XHRtZXNzYWdlIDogcGx1cGxvYWQudHJhbnNsYXRlKCdJbml0IGVycm9yLicpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIG9wdGlvbihzKS5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2Qgc2V0T3B0aW9uXG5cdFx0ICogQHNpbmNlIDIuMVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uIE5hbWUgb2YgdGhlIG9wdGlvbiB0byBjaGFuZ2Ugb3IgdGhlIHNldCBvZiBrZXkvdmFsdWUgcGFpcnNcblx0XHQgKiBAcGFyYW0ge01peGVkfSBbdmFsdWVdIFZhbHVlIGZvciB0aGUgb3B0aW9uIChpcyBpZ25vcmVkLCBpZiBmaXJzdCBhcmd1bWVudCBpcyBvYmplY3QpXG5cdFx0ICovXG5cdFx0c2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XG5cdFx0XHRzZXRPcHRpb24uY2FsbCh0aGlzLCBvcHRpb24sIHZhbHVlLCAhdGhpcy5ydW50aW1lKTsgLy8gdW50aWwgcnVudGltZSBub3Qgc2V0IHdlIGRvIG5vdCBuZWVkIHRvIHJlaW5pdGlhbGl6ZVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIG9wdGlvbiBvciB0aGUgd2hvbGUgY29uZmlndXJhdGlvbiwgaWYgbm90IHNwZWNpZmllZC5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgZ2V0T3B0aW9uXG5cdFx0ICogQHNpbmNlIDIuMVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9uXSBOYW1lIG9mIHRoZSBvcHRpb24gdG8gZ2V0XG5cdFx0ICogQHJldHVybiB7TWl4ZWR9IFZhbHVlIGZvciB0aGUgb3B0aW9uIG9yIHRoZSB3aG9sZSBzZXRcblx0XHQgKi9cblx0XHRnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge1xuXHRcdFx0aWYgKCFvcHRpb24pIHtcblx0XHRcdFx0cmV0dXJuIHNldHRpbmdzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNldHRpbmdzW29wdGlvbl07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZnJlc2hlcyB0aGUgdXBsb2FkIGluc3RhbmNlIGJ5IGRpc3BhdGNoaW5nIG91dCBhIHJlZnJlc2ggZXZlbnQgdG8gYWxsIHJ1bnRpbWVzLlxuXHRcdCAqIFRoaXMgd291bGQgZm9yIGV4YW1wbGUgcmVwb3NpdGlvbiBmbGFzaC9zaWx2ZXJsaWdodCBzaGltcyBvbiB0aGUgcGFnZS5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgcmVmcmVzaFxuXHRcdCAqL1xuXHRcdHJlZnJlc2ggOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChmaWxlSW5wdXRzLmxlbmd0aCkge1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKGZpbGVJbnB1dHMsIGZ1bmN0aW9uKGZpbGVJbnB1dCkge1xuXHRcdFx0XHRcdGZpbGVJbnB1dC50cmlnZ2VyKCdSZWZyZXNoJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50cmlnZ2VyKCdSZWZyZXNoJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFN0YXJ0cyB1cGxvYWRpbmcgdGhlIHF1ZXVlZCBmaWxlcy5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2Qgc3RhcnRcblx0XHQgKi9cblx0XHRzdGFydCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUgIT0gcGx1cGxvYWQuU1RBUlRFRCkge1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gcGx1cGxvYWQuU1RBUlRFRDtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdTdGF0ZUNoYW5nZWQnKTtcblxuXHRcdFx0XHR1cGxvYWROZXh0LmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFN0b3BzIHRoZSB1cGxvYWQgb2YgdGhlIHF1ZXVlZCBmaWxlcy5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2Qgc3RvcFxuXHRcdCAqL1xuXHRcdHN0b3AgOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnN0YXRlICE9IHBsdXBsb2FkLlNUT1BQRUQpIHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IHBsdXBsb2FkLlNUT1BQRUQ7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignU3RhdGVDaGFuZ2VkJyk7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignQ2FuY2VsVXBsb2FkJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogRGlzYWJsZXMvZW5hYmxlcyBicm93c2UgYnV0dG9uIG9uIHJlcXVlc3QuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGRpc2FibGVCcm93c2Vcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGUgV2hldGhlciB0byBkaXNhYmxlIG9yIGVuYWJsZSAoZGVmYXVsdDogdHJ1ZSlcblx0XHQgKi9cblx0XHRkaXNhYmxlQnJvd3NlIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkaXNhYmxlZCA9IGFyZ3VtZW50c1swXSAhPT0gdW5kZWYgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG5cdFx0XHRpZiAoZmlsZUlucHV0cy5sZW5ndGgpIHtcblx0XHRcdFx0cGx1cGxvYWQuZWFjaChmaWxlSW5wdXRzLCBmdW5jdGlvbihmaWxlSW5wdXQpIHtcblx0XHRcdFx0XHRmaWxlSW5wdXQuZGlzYWJsZShkaXNhYmxlZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ0Rpc2FibGVCcm93c2UnLCBkaXNhYmxlZCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBmaWxlIG9iamVjdCBieSBpZC5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgZ2V0RmlsZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBGaWxlIGlkIHRvIGxvb2sgZm9yLlxuXHRcdCAqIEByZXR1cm4ge3BsdXBsb2FkLkZpbGV9IEZpbGUgb2JqZWN0IG9yIHVuZGVmaW5lZCBpZiBpdCB3YXNuJ3QgZm91bmQ7XG5cdFx0ICovXG5cdFx0Z2V0RmlsZSA6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdGZvciAoaSA9IGZpbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChmaWxlc1tpXS5pZCA9PT0gaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmlsZXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkcyBmaWxlIHRvIHRoZSBxdWV1ZSBwcm9ncmFtbWF0aWNhbGx5LiBDYW4gYmUgbmF0aXZlIGZpbGUsIGluc3RhbmNlIG9mIFBsdXBsb2FkLkZpbGUsXG5cdFx0ICogaW5zdGFuY2Ugb2YgbU94aWUuRmlsZSwgaW5wdXRbdHlwZT1cImZpbGVcIl0gZWxlbWVudCwgb3IgYXJyYXkgb2YgdGhlc2UuIEZpcmVzIEZpbGVzQWRkZWQsXG5cdFx0ICogaWYgYW55IGZpbGVzIHdlcmUgYWRkZWQgdG8gdGhlIHF1ZXVlLiBPdGhlcndpc2Ugbm90aGluZyBoYXBwZW5zLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBhZGRGaWxlXG5cdFx0ICogQHNpbmNlIDIuMFxuXHRcdCAqIEBwYXJhbSB7cGx1cGxvYWQuRmlsZXxtT3hpZS5GaWxlfEZpbGV8Tm9kZXxBcnJheX0gZmlsZSBGaWxlIG9yIGZpbGVzIHRvIGFkZCB0byB0aGUgcXVldWUuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IFtmaWxlTmFtZV0gSWYgc3BlY2lmaWVkLCB3aWxsIGJlIHVzZWQgYXMgYSBuYW1lIGZvciB0aGUgZmlsZVxuXHRcdCAqL1xuXHRcdGFkZEZpbGUgOiBmdW5jdGlvbihmaWxlLCBmaWxlTmFtZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0XHQsIHF1ZXVlID0gW11cblx0XHRcdCwgZmlsZXNBZGRlZCA9IFtdXG5cdFx0XHQsIHJ1aWRcblx0XHRcdDtcblxuXHRcdFx0ZnVuY3Rpb24gZmlsdGVyRmlsZShmaWxlLCBjYikge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHRcdFx0cGx1cGxvYWQuZWFjaChzZWxmLnNldHRpbmdzLmZpbHRlcnMsIGZ1bmN0aW9uKHJ1bGUsIG5hbWUpIHtcblx0XHRcdFx0XHRpZiAoZmlsZUZpbHRlcnNbbmFtZV0pIHtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRcdFx0ZmlsZUZpbHRlcnNbbmFtZV0uY2FsbChzZWxmLCBydWxlLCBmaWxlLCBmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHRcdFx0XHRjYighcmVzKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRwbHVwbG9hZC5pblNlcmllcyhxdWV1ZSwgY2IpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBtZXRob2QgcmVzb2x2ZUZpbGVcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKiBAcGFyYW0ge21veGllLmZpbGUuRmlsZXxtb3hpZS5maWxlLkJsb2J8cGx1cGxvYWQuRmlsZXxGaWxlfEJsb2J8aW5wdXRbdHlwZT1cImZpbGVcIl19IGZpbGVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZUZpbGUoZmlsZSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHBsdXBsb2FkLnR5cGVPZihmaWxlKTtcblxuXHRcdFx0XHQvLyBtb3hpZS5maWxlLkZpbGVcblx0XHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBvLmZpbGUuRmlsZSkge1xuXHRcdFx0XHRcdGlmICghZmlsZS5ydWlkICYmICFmaWxlLmlzRGV0YWNoZWQoKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFydWlkKSB7IC8vIHdlaXJkIGNhc2Vcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZmlsZS5ydWlkID0gcnVpZDtcblx0XHRcdFx0XHRcdGZpbGUuY29ubmVjdFJ1bnRpbWUocnVpZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc29sdmVGaWxlKG5ldyBwbHVwbG9hZC5GaWxlKGZpbGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBtb3hpZS5maWxlLkJsb2Jcblx0XHRcdFx0ZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIG8uZmlsZS5CbG9iKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUZpbGUoZmlsZS5nZXRTb3VyY2UoKSk7XG5cdFx0XHRcdFx0ZmlsZS5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcGx1cGxvYWQuRmlsZSAtIGZpbmFsIHN0ZXAgZm9yIG90aGVyIGJyYW5jaGVzXG5cdFx0XHRcdGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBwbHVwbG9hZC5GaWxlKSB7XG5cdFx0XHRcdFx0aWYgKGZpbGVOYW1lKSB7XG5cdFx0XHRcdFx0XHRmaWxlLm5hbWUgPSBmaWxlTmFtZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdFx0XHQvLyBydW4gdGhyb3VnaCB0aGUgaW50ZXJuYWwgYW5kIHVzZXItZGVmaW5lZCBmaWx0ZXJzLCBpZiBhbnlcblx0XHRcdFx0XHRcdGZpbHRlckZpbGUoZmlsZSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gbWFrZSBmaWxlcyBhdmFpbGFibGUgZm9yIHRoZSBmaWx0ZXJzIGJ5IHVwZGF0aW5nIHRoZSBtYWluIHF1ZXVlIGRpcmVjdGx5XG5cdFx0XHRcdFx0XHRcdFx0ZmlsZXMucHVzaChmaWxlKTtcblx0XHRcdFx0XHRcdFx0XHQvLyBjb2xsZWN0IHRoZSBmaWxlcyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIEZpbGVzQWRkZWQgZXZlbnRcblx0XHRcdFx0XHRcdFx0XHRmaWxlc0FkZGVkLnB1c2goZmlsZSk7XG5cblx0XHRcdFx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoXCJGaWxlRmlsdGVyZWRcIiwgZmlsZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsYXkoY2IsIDEpOyAvLyBkbyBub3QgYnVpbGQgdXAgcmVjdXJzaW9ucyBvciBldmVudHVhbGx5IHdlIG1pZ2h0IGhpdCB0aGUgbGltaXRzXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBuYXRpdmUgRmlsZSBvciBibG9iXG5cdFx0XHRcdGVsc2UgaWYgKHBsdXBsb2FkLmluQXJyYXkodHlwZSwgWydmaWxlJywgJ2Jsb2InXSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUZpbGUobmV3IG8uZmlsZS5GaWxlKG51bGwsIGZpbGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpbnB1dFt0eXBlPVwiZmlsZVwiXVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlID09PSAnbm9kZScgJiYgcGx1cGxvYWQudHlwZU9mKGZpbGUuZmlsZXMpID09PSAnZmlsZWxpc3QnKSB7XG5cdFx0XHRcdFx0Ly8gaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBpbnB1dFt0eXBlPVwiZmlsZVwiXVxuXHRcdFx0XHRcdHBsdXBsb2FkLmVhY2goZmlsZS5maWxlcywgcmVzb2x2ZUZpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG1peGVkIGFycmF5IG9mIGFueSBzdXBwb3J0ZWQgdHlwZXMgKHNlZSBhYm92ZSlcblx0XHRcdFx0ZWxzZSBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xuXHRcdFx0XHRcdGZpbGVOYW1lID0gbnVsbDsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IHVuc2V0IGFueXdheSB0byBhdm9pZCBmdW5ueSBzaXR1YXRpb25zXG5cdFx0XHRcdFx0cGx1cGxvYWQuZWFjaChmaWxlLCByZXNvbHZlRmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cnVpZCA9IGdldFJVSUQoKTtcblxuXHRcdFx0cmVzb2x2ZUZpbGUoZmlsZSk7XG5cblx0XHRcdGlmIChxdWV1ZS5sZW5ndGgpIHtcblx0XHRcdFx0cGx1cGxvYWQuaW5TZXJpZXMocXVldWUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIGlmIGFueSBmaWxlcyBsZWZ0IGFmdGVyIGZpbHRyYXRpb24sIHRyaWdnZXIgRmlsZXNBZGRlZFxuXHRcdFx0XHRcdGlmIChmaWxlc0FkZGVkLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0c2VsZi50cmlnZ2VyKFwiRmlsZXNBZGRlZFwiLCBmaWxlc0FkZGVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIGEgc3BlY2lmaWMgZmlsZS5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgcmVtb3ZlRmlsZVxuXHRcdCAqIEBwYXJhbSB7cGx1cGxvYWQuRmlsZXxTdHJpbmd9IGZpbGUgRmlsZSB0byByZW1vdmUgZnJvbSBxdWV1ZS5cblx0XHQgKi9cblx0XHRyZW1vdmVGaWxlIDogZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0dmFyIGlkID0gdHlwZW9mKGZpbGUpID09PSAnc3RyaW5nJyA/IGZpbGUgOiBmaWxlLmlkO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gZmlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGZpbGVzW2ldLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnNwbGljZShpLCAxKVswXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHBhcnQgb2YgdGhlIHF1ZXVlIGFuZCByZXR1cm5zIHRoZSBmaWxlcyByZW1vdmVkLiBUaGlzIHdpbGwgYWxzbyB0cmlnZ2VyIHRoZSBGaWxlc1JlbW92ZWQgYW5kIFF1ZXVlQ2hhbmdlZCBldmVudHMuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIHNwbGljZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAoT3B0aW9uYWwpIFN0YXJ0IGluZGV4IHRvIHJlbW92ZSBmcm9tLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggKE9wdGlvbmFsKSBMZW5naCBvZiBpdGVtcyB0byByZW1vdmUuXG5cdFx0ICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGZpbGVzIHRoYXQgd2FzIHJlbW92ZWQuXG5cdFx0ICovXG5cdFx0c3BsaWNlIDogZnVuY3Rpb24oc3RhcnQsIGxlbmd0aCkge1xuXHRcdFx0Ly8gU3BsaWNlIGFuZCB0cmlnZ2VyIGV2ZW50c1xuXHRcdFx0dmFyIHJlbW92ZWQgPSBmaWxlcy5zcGxpY2Uoc3RhcnQgPT09IHVuZGVmID8gMCA6IHN0YXJ0LCBsZW5ndGggPT09IHVuZGVmID8gZmlsZXMubGVuZ3RoIDogbGVuZ3RoKTtcblxuXHRcdFx0Ly8gaWYgdXBsb2FkIGlzIGluIHByb2dyZXNzIHdlIG5lZWQgdG8gc3RvcCBpdCBhbmQgcmVzdGFydCBhZnRlciBmaWxlcyBhcmUgcmVtb3ZlZFxuXHRcdFx0dmFyIHJlc3RhcnRSZXF1aXJlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUgPT0gcGx1cGxvYWQuU1RBUlRFRCkgeyAvLyB1cGxvYWQgaW4gcHJvZ3Jlc3Ncblx0XHRcdFx0cGx1cGxvYWQuZWFjaChyZW1vdmVkLCBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHRcdFx0aWYgKGZpbGUuc3RhdHVzID09PSBwbHVwbG9hZC5VUExPQURJTkcpIHtcblx0XHRcdFx0XHRcdHJlc3RhcnRSZXF1aXJlZCA9IHRydWU7IC8vIGRvIG5vdCByZXN0YXJ0LCB1bmxlc3MgZmlsZSB0aGF0IGlzIGJlaW5nIHJlbW92ZWQgaXMgdXBsb2FkaW5nXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAocmVzdGFydFJlcXVpcmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5zdG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy50cmlnZ2VyKFwiRmlsZXNSZW1vdmVkXCIsIHJlbW92ZWQpO1xuXG5cdFx0XHQvLyBEaXNwb3NlIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRob3NlIGZpbGVzXG5cdFx0XHRwbHVwbG9hZC5lYWNoKHJlbW92ZWQsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0ZmlsZS5kZXN0cm95KCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHJlc3RhcnRSZXF1aXJlZCkge1xuXHRcdFx0XHR0aGlzLnN0YXJ0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbmFtZSBhbmQgaXRzIGFyZ3VtZW50cyB0byBhbGwgbGlzdGVuZXJzLlxuXG5cdFx0QG1ldGhvZCB0cmlnZ2VyXG5cdFx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgRXZlbnQgbmFtZSB0byBmaXJlLlxuXHRcdEBwYXJhbSB7T2JqZWN0Li59IE11bHRpcGxlIGFyZ3VtZW50cyB0byBwYXNzIGFsb25nIHRvIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXG5cdFx0Ki9cblxuXHRcdC8vIG92ZXJyaWRlIHRoZSBwYXJlbnQgbWV0aG9kIHRvIG1hdGNoIFBsdXBsb2FkLWxpa2UgZXZlbnQgbG9naWNcblx0XHRkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgbGlzdCwgYXJncywgcmVzdWx0O1xuXG5cdFx0XHR0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRsaXN0ID0gdGhpcy5oYXNFdmVudExpc3RlbmVyKHR5cGUpO1xuXG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHQvLyBzb3J0IGV2ZW50IGxpc3QgYnkgcHJpb3JpdHlcblx0XHRcdFx0bGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5OyB9KTtcblxuXHRcdFx0XHQvLyBmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgY3VycmVudCBwbHVwbG9hZC5VcGxvYWRlciBpbnN0YW5jZVxuXHRcdFx0XHRhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHRhcmdzLnNoaWZ0KCk7XG5cdFx0XHRcdGFyZ3MudW5zaGlmdCh0aGlzKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHQvLyBGaXJlIGV2ZW50LCBicmVhayBjaGFpbiBpZiBmYWxzZSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdGlmIChsaXN0W2ldLmZuLmFwcGx5KGxpc3RbaV0uc2NvcGUsIGFyZ3MpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdENoZWNrIHdoZXRoZXIgdXBsb2FkZXIgaGFzIGFueSBsaXN0ZW5lcnMgdG8gdGhlIHNwZWNpZmllZCBldmVudC5cblxuXHRcdEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxuXHRcdEBwYXJhbSB7U3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUgdG8gY2hlY2sgZm9yLlxuXHRcdCovXG5cblxuXHRcdC8qKlxuXHRcdEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgYnkgbmFtZS5cblxuXHRcdEBtZXRob2QgYmluZFxuXHRcdEBwYXJhbSB7U3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUgdG8gbGlzdGVuIGZvci5cblx0XHRAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIG9uZXMgdGhlIGV2ZW50IGdldHMgZmlyZWQuXG5cdFx0QHBhcmFtIHtPYmplY3R9IFtzY29wZV0gT3B0aW9uYWwgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGluLlxuXHRcdEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHk9MF0gUHJpb3JpdHkgb2YgdGhlIGV2ZW50IGhhbmRsZXIgLSBoYW5kbGVycyB3aXRoIGhpZ2hlciBwcmlvcml0aWVzIHdpbGwgYmUgY2FsbGVkIGZpcnN0XG5cdFx0Ki9cblx0XHRiaW5kOiBmdW5jdGlvbihuYW1lLCBmbiwgc2NvcGUsIHByaW9yaXR5KSB7XG5cdFx0XHQvLyBhZGFwdCBtb3hpZSBFdmVudFRhcmdldCBzdHlsZSB0byBQbHVwbG9hZC1saWtlXG5cdFx0XHRwbHVwbG9hZC5VcGxvYWRlci5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMsIG5hbWUsIGZuLCBwcmlvcml0eSwgc2NvcGUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHRSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXG5cblx0XHRAbWV0aG9kIHVuYmluZFxuXHRcdEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgZXZlbnQgdG8gcmVtb3ZlLlxuXHRcdEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIGxpc3RlbmVyLlxuXHRcdCovXG5cblx0XHQvKipcblx0XHRSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG5cblx0XHRAbWV0aG9kIHVuYmluZEFsbFxuXHRcdCovXG5cblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3lzIFBsdXBsb2FkIGluc3RhbmNlIGFuZCBjbGVhbnMgYWZ0ZXIgaXRzZWxmLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBkZXN0cm95XG5cdFx0ICovXG5cdFx0ZGVzdHJveSA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdEZXN0cm95Jyk7XG5cdFx0XHRzZXR0aW5ncyA9IHRvdGFsID0gbnVsbDsgLy8gcHVyZ2UgdGhlc2UgZXhjbHVzaXZlbHlcblx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbnBsdXBsb2FkLlVwbG9hZGVyLnByb3RvdHlwZSA9IG8uY29yZS5FdmVudFRhcmdldC5pbnN0YW5jZTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGZpbGUgaW5zdGFuY2UuXG4gKlxuICogQGNsYXNzIEZpbGVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIE9iamVjdCBjb250YWluaW5nIGZpbGUgcHJvcGVydGllc1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbGUubmFtZSBOYW1lIG9mIHRoZSBmaWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGZpbGUuc2l6ZSBGaWxlIHNpemUuXG4gKi9cbnBsdXBsb2FkLkZpbGUgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBmaWxlcG9vbCA9IHt9O1xuXG5cdGZ1bmN0aW9uIFBsdXBsb2FkRmlsZShmaWxlKSB7XG5cblx0XHRwbHVwbG9hZC5leHRlbmQodGhpcywge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEZpbGUgaWQgdGhpcyBpcyBhIGdsb2JhbGx5IHVuaXF1ZSBpZCBmb3IgdGhlIHNwZWNpZmljIGZpbGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHByb3BlcnR5IGlkXG5cdFx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0aWQ6IHBsdXBsb2FkLmd1aWQoKSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaWxlIG5hbWUgZm9yIGV4YW1wbGUgXCJteWZpbGUuZ2lmXCIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHByb3BlcnR5IG5hbWVcblx0XHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRuYW1lOiBmaWxlLm5hbWUgfHwgZmlsZS5maWxlTmFtZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaWxlIHR5cGUsIGBlLmcgaW1hZ2UvanBlZ2Bcblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdHR5cGU6IGZpbGUudHlwZSB8fCAnJyxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaWxlIHNpemUgaW4gYnl0ZXMgKG1heSBjaGFuZ2UgYWZ0ZXIgY2xpZW50LXNpZGUgbWFudXBpbGF0aW9uKS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgc2l6ZVxuXHRcdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0XHQgKi9cblx0XHRcdHNpemU6IGZpbGUuc2l6ZSB8fCBmaWxlLmZpbGVTaXplLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIE9yaWdpbmFsIGZpbGUgc2l6ZSBpbiBieXRlcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgb3JpZ1NpemVcblx0XHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdFx0ICovXG5cdFx0XHRvcmlnU2l6ZTogZmlsZS5zaXplIHx8IGZpbGUuZmlsZVNpemUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIG9mIHRoZSBmaWxlcyB0b3RhbCBzaXplLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdFx0ICovXG5cdFx0XHRsb2FkZWQ6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTnVtYmVyIG9mIHBlcmNlbnRhZ2UgdXBsb2FkZWQgb2YgdGhlIGZpbGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHByb3BlcnR5IHBlcmNlbnRcblx0XHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdFx0ICovXG5cdFx0XHRwZXJjZW50OiAwLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0YXR1cyBjb25zdGFudCBtYXRjaGluZyB0aGUgcGx1cGxvYWQgc3RhdGVzIFFVRVVFRCwgVVBMT0FESU5HLCBGQUlMRUQsIERPTkUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHByb3BlcnR5IHN0YXR1c1xuXHRcdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0XHQgKiBAc2VlIHBsdXBsb2FkXG5cdFx0XHQgKi9cblx0XHRcdHN0YXR1czogcGx1cGxvYWQuUVVFVUVELFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIERhdGUgb2YgbGFzdCBtb2RpZmljYXRpb24uXG5cdFx0XHQgKlxuXHRcdFx0ICogQHByb3BlcnR5IGxhc3RNb2RpZmllZERhdGVcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdGxhc3RNb2RpZmllZERhdGU6IGZpbGUubGFzdE1vZGlmaWVkRGF0ZSB8fCAobmV3IERhdGUoKSkudG9Mb2NhbGVTdHJpbmcoKSwgLy8gVGh1IEF1ZyAyMyAyMDEyIDE5OjQwOjAwIEdNVCswNDAwIChHRVQpXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgd2hlbiBmaWxlIGJlY29tZXMgcGx1cGxvYWQuRE9ORSBvciBwbHVwbG9hZC5GQUlMRUQuIElzIHVzZWQgdG8gY2FsY3VsYXRlIHByb3BlciBwbHVwbG9hZC5RdWV1ZVByb2dyZXNzLmJ5dGVzUGVyU2VjLlxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEBwcm9wZXJ0eSBjb21wbGV0ZVRpbWVzdGFtcFxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHRcdFx0Y29tcGxldGVUaW1lc3RhbXA6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBuYXRpdmUgd2luZG93LkZpbGUgb2JqZWN0LCB3aGVuIGl0J3MgYXZhaWxhYmxlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZXRob2QgZ2V0TmF0aXZlXG5cdFx0XHQgKiBAcmV0dXJuIHt3aW5kb3cuRmlsZX0gb3IgbnVsbCwgaWYgcGx1cGxvYWQuRmlsZSBpcyBvZiBkaWZmZXJlbnQgb3JpZ2luXG5cdFx0XHQgKi9cblx0XHRcdGdldE5hdGl2ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBmaWxlID0gdGhpcy5nZXRTb3VyY2UoKS5nZXRTb3VyY2UoKTtcblx0XHRcdFx0cmV0dXJuIHBsdXBsb2FkLmluQXJyYXkocGx1cGxvYWQudHlwZU9mKGZpbGUpLCBbJ2Jsb2InLCAnZmlsZSddKSAhPT0gLTEgPyBmaWxlIDogbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBtT3hpZS5GaWxlIC0gdW5pZmllZCB3cmFwcGVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFjcm9zcyBydW50aW1lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGdldFNvdXJjZVxuXHRcdFx0ICogQHJldHVybiB7bU94aWUuRmlsZX0gb3IgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIWZpbGVwb29sW3RoaXMuaWRdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZpbGVwb29sW3RoaXMuaWRdO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXN0cm95cyBwbHVwbG9hZC5GaWxlIG9iamVjdC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0XHRcdCAqL1xuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLmdldFNvdXJjZSgpO1xuXHRcdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdFx0c3JjLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRkZWxldGUgZmlsZXBvb2xbdGhpcy5pZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGZpbGVwb29sW3RoaXMuaWRdID0gZmlsZTtcblx0fVxuXG5cdHJldHVybiBQbHVwbG9hZEZpbGU7XG59KCkpO1xuXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHF1ZXVlIHByb2dyZXNzLlxuICpcbiAqIEBjbGFzcyBRdWV1ZVByb2dyZXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuIHBsdXBsb2FkLlF1ZXVlUHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNlbGYgPSB0aGlzOyAvLyBTZXR1cCBhbGlhcyBmb3Igc2VsZiB0byByZWR1Y2UgY29kZSBzaXplIHdoZW4gaXQncyBjb21wcmVzc2VkXG5cblx0LyoqXG5cdCAqIFRvdGFsIHF1ZXVlIGZpbGUgc2l6ZS5cblx0ICpcblx0ICogQHByb3BlcnR5IHNpemVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHRzZWxmLnNpemUgPSAwO1xuXG5cdC8qKlxuXHQgKiBUb3RhbCBieXRlcyB1cGxvYWRlZC5cblx0ICpcblx0ICogQHByb3BlcnR5IGxvYWRlZFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdHNlbGYubG9hZGVkID0gMDtcblxuXHQvKipcblx0ICogTnVtYmVyIG9mIGZpbGVzIHVwbG9hZGVkLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgdXBsb2FkZWRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHRzZWxmLnVwbG9hZGVkID0gMDtcblxuXHQvKipcblx0ICogTnVtYmVyIG9mIGZpbGVzIGZhaWxlZCB0byB1cGxvYWQuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBmYWlsZWRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHRzZWxmLmZhaWxlZCA9IDA7XG5cblx0LyoqXG5cdCAqIE51bWJlciBvZiBmaWxlcyB5ZXQgdG8gYmUgdXBsb2FkZWQuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBxdWV1ZWRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHRzZWxmLnF1ZXVlZCA9IDA7XG5cblx0LyoqXG5cdCAqIFRvdGFsIHBlcmNlbnQgb2YgdGhlIHVwbG9hZGVkIGJ5dGVzLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgcGVyY2VudFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdHNlbGYucGVyY2VudCA9IDA7XG5cblx0LyoqXG5cdCAqIEJ5dGVzIHVwbG9hZGVkIHBlciBzZWNvbmQuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBieXRlc1BlclNlY1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdHNlbGYuYnl0ZXNQZXJTZWMgPSAwO1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIHByb2dyZXNzIHRvIGl0cyBpbml0aWFsIHZhbHVlcy5cblx0ICpcblx0ICogQG1ldGhvZCByZXNldFxuXHQgKi9cblx0c2VsZi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuc2l6ZSA9IHNlbGYubG9hZGVkID0gc2VsZi51cGxvYWRlZCA9IHNlbGYuZmFpbGVkID0gc2VsZi5xdWV1ZWQgPSBzZWxmLnBlcmNlbnQgPSBzZWxmLmJ5dGVzUGVyU2VjID0gMDtcblx0fTtcbn07XG5cbmV4cG9ydHMucGx1cGxvYWQgPSBwbHVwbG9hZDtcblxufSh0aGlzLCBtb3hpZSkpO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGx1cGxvYWQvcGx1cGxvYWQuZGV2LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogcWluaXUtanMtc2RrIHZAVkVSU0lPTlxuICpcbiAqIENvcHlyaWdodCAyMDE1IGJ5IFFpbml1XG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgVjIgTGljZW5zZS5cbiAqXG4gKiBHaXRIdWI6IGh0dHA6Ly9naXRodWIuY29tL3Fpbml1L2pzLXNka1xuICpcbiAqIERhdGU6IEBEQVRFXG4gKi9cbi8vdmVyc2lvbiAxLjEuMFxuLypnbG9iYWwgcGx1cGxvYWQgLG1veGllKi9cbi8qZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cbi8qZXhwb3J0ZWQgUWluaXUgKi9cbi8qZXhwb3J0ZWQgUWluaXVKc1NESyAqL1xuXG47KGZ1bmN0aW9uIChnbG9iYWwpIHtcblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgY29va2llIG9yIHJlbW92ZXMgY29va2llIHdpdGggbmVnYXRpdmUgZXhwaXJhdGlvblxuICAgICAqIEBwYXJhbSAga2V5ICAgICAgIFRoZSBrZXkgb3IgaWRlbnRpZmllciBmb3IgdGhlIHN0b3JlXG4gICAgICogQHBhcmFtICB2YWx1ZSAgICAgQ29udGVudHMgb2YgdGhlIHN0b3JlXG4gICAgICogQHBhcmFtICBleHAgICAgICAgRXhwaXJhdGlvbiAtIGNyZWF0aW9uIGRlZmF1bHRzIHRvIDMwIGRheXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb29raWUoa2V5LCB2YWx1ZSwgZXhwKSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKGV4cCAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgdmFyIGV4cGlyZXMgPSBcIjsgZXhwaXJlcz1cIiArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0ga2V5ICsgXCI9XCIgKyB2YWx1ZSArIGV4cGlyZXMgKyBcIjsgcGF0aD0vXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZW50cyBvZiBjb29raWVcbiAgICAgKiBAcGFyYW0gIGtleSAgICAgICBUaGUga2V5IG9yIGlkZW50aWZpZXIgZm9yIHRoZSBzdG9yZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWRDb29raWUoa2V5KSB7XG4gICAgICAgIHZhciBuYW1lRVEgPSBrZXkgKyBcIj1cIjtcbiAgICAgICAgdmFyIGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBjYS5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgY3VycmVudCBicm93c2VyIGlzIG5vdCBzdXBwb3J0IGxvY2FsU3RvcmFnZVxuICAgIC8vIHVzZSBjb29raWUgdG8gbWFrZSBhIHBvbHlmaWxsXG4gICAgaWYgKCF3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPSB7XG4gICAgICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUNvb2tpZShrZXksIHZhbHVlLCAzMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ29va2llKGtleSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUNvb2tpZShrZXksICcnLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUWluaXVKc1NESygpIHtcbiAgICAgICAgdmFyIG1veGllID0gcmVxdWlyZSgnLi9wbHVwbG9hZC9tb3hpZScpO1xuICAgICAgICB3aW5kb3cubW94aWUgPSBtb3hpZTtcbiAgICAgICAgdmFyIHBsdXBsb2FkID0gcmVxdWlyZSgnLi9wbHVwbG9hZC9wbHVwbG9hZC5kZXYnKTtcbiAgICAgICAgd2luZG93LnBsdXBsb2FkID0gcGx1cGxvYWQ7XG5cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVjdCBJRSB2ZXJzaW9uXG4gICAgICAgICAqIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBub3QgSUVcbiAgICAgICAgICogICAgIGl0IHdpbGwgcmV0dXJuIGZhbHNlXG4gICAgICAgICAqIGVsc2VcbiAgICAgICAgICogICAgIGl0IHdpbGwgcmV0dXJuIHZlcnNpb24gb2YgY3VycmVudCBJRSBicm93c2VyXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcnxCb29sZWFufSBJRSB2ZXJzaW9uIG9yIGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRldGVjdElFVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2ID0gNCxcbiAgICAgICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2knKTtcbiAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArIHYgKyAnXT48aT48L2k+PCFbZW5kaWZdLS0+JyxcbiAgICAgICAgICAgICAgICAgICAgYWxsWzBdXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYgPiA0ID8gdiA6IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb2dnZXIgPSB7XG4gICAgICAgICAgICBNVVRFOiAwLFxuICAgICAgICAgICAgRkFUQTogMSxcbiAgICAgICAgICAgIEVSUk9SOiAyLFxuICAgICAgICAgICAgV0FSTjogMyxcbiAgICAgICAgICAgIElORk86IDQsXG4gICAgICAgICAgICBERUJVRzogNSxcbiAgICAgICAgICAgIFRSQUNFOiA2LFxuICAgICAgICAgICAgbGV2ZWw6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBsb2codHlwZSwgYXJncykge1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IFwiW3Fpbml1LWpzLXNka11bXCIgKyB0eXBlICsgXCJdXCI7XG4gICAgICAgICAgICB2YXIgbXNnID0gaGVhZGVyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIiBcIiArIGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiIFwiICsgdGhhdC5zdHJpbmdpZnlKU09OKGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGF0LmRldGVjdElFVmVyc2lvbigpKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTM4OTcyL2NvbnNvbGUtbG9nLWFwcGx5LW5vdC13b3JraW5nLWluLWllOVxuICAgICAgICAgICAgICAgIC8vdmFyIGxvZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICAgICAgICAgICAgICAgIC8vbG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChoZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxaW5pdS1qcy1zZGstbG9nJykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncWluaXUtanMtc2RrLWxvZycpLmlubmVySFRNTCArPSAnPHA+JyArIG1zZyArICc8L3A+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VMb2dGdW5jKGNvZGUpIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gY29kZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgbG9nZ2VyW2Z1bmNdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGxvZ2dlcltmdW5jXS5oaXN0b3J5ID0gbG9nZ2VyW2Z1bmNdLmhpc3RvcnkgfHwgW107XG4gICAgICAgICAgICAgICAgLy8gbG9nZ2VyW2Z1bmNdLmhpc3RvcnkucHVzaChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cgJiYgbG9nZ2VyLmxldmVsID49IGxvZ2dlcltjb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhmdW5jLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gbG9nZ2VyKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiAodHlwZW9mIGxvZ2dlcltwcm9wZXJ0eV0pID09PSBcIm51bWJlclwiICYmICFsb2dnZXIuaGFzT3duUHJvcGVydHkocHJvcGVydHkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBtYWtlTG9nRnVuYyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBxaW5pdVVwbG9hZFVybDtcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIHFpbml1VXBsb2FkVXJsID0gJ2h0dHBzOi8vdXBsb2FkLnFpbml1cC5jb20nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcWluaXVVcGxvYWRVcmwgPSAnaHR0cDovL3VwbG9hZC5xaW5pdXAuY29tJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBxaW5pdSB1cGxvYWQgdXJsc1xuICAgICAgICAgKiAncWluaXVVcGxvYWRVcmxzJyBpcyB1c2VkIHRvIGNoYW5nZSB0YXJnZXQgd2hlbiBjdXJyZW50IHVybCBpcyBub3QgYXZhbGlhYmxlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBxaW5pdVVwbG9hZFVybHMgPSBbXG4gICAgICAgICAgICBcImh0dHA6Ly91cGxvYWQucWluaXVwLmNvbVwiLFxuICAgICAgICAgICAgXCJodHRwOi8vdXAucWluaXVwLmNvbVwiXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIHFpbml1VXBIb3N0cyA9IHtcbiAgICAgICAgICAgIFwiaHR0cFwiOiBbXG4gICAgICAgICAgICAgICAgXCJodHRwOi8vdXBsb2FkLnFpbml1cC5jb21cIixcbiAgICAgICAgICAgICAgICBcImh0dHA6Ly91cC5xaW5pdXAuY29tXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImh0dHBzXCI6IFtcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vdXBsb2FkLnFpbml1cC5jb21cIlxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjaGFuZ2VVcmxUaW1lcyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlc2V0IHVwbG9hZCB1cmxcbiAgICAgICAgICogaWYgY3VycmVudCBwYWdlIHByb3RvY2FsIGlzIGh0dHBzXG4gICAgICAgICAqICAgICBpdCB3aWxsIGFsd2F5cyByZXR1cm4gJ2h0dHBzOi8vdXAucWJveC5tZSdcbiAgICAgICAgICogZWxzZVxuICAgICAgICAgKiAgICAgaXQgd2lsbCBzZXQgJ3Fpbml1VXBsb2FkVXJsJyB2YWx1ZSB3aXRoICdxaW5pdVVwbG9hZFVybHMnIGxvb3BseVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZFVybCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbnVtOiAnICsgbnVtKTtcbiAgICAgICAgICAgIGlmKCBudW0gPT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcInVzZSBtYWluIHVwaG9zdFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgaG9zdHMgPSBxaW5pdVVwSG9zdHMubWFpbjtcbiAgICAgICAgICAgICAgICBxaW5pdVVwbG9hZFVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBcImh0dHBzOi8vXCIgKyBob3N0c1swXSA6IFwiaHR0cDovL1wiICsgaG9zdHNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcInVzZSBiYWNrdXAgdXBob3N0XCIpO1xuICAgICAgICAgICAgICAgIHZhciBob3N0cyA9IHFpbml1VXBIb3N0cy5iYWNrdXA7XG4gICAgICAgICAgICAgICAgaWYoIG51bSAlIDIgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxaW5pdVVwbG9hZFVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBcImh0dHBzOi8vXCIgKyBob3N0c1sxXSA6IFwiaHR0cDovL1wiICsgaG9zdHNbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcWluaXVVcGxvYWRVcmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gXCJodHRwczovL1wiICsgaG9zdHNbMF0gOiBcImh0dHA6Ly9cIiArIGhvc3RzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcWluaXVVcGxvYWRVcmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gXCJodHRwczovL1wiICsgaG9zdHNbMF0gOiBcImh0dHA6Ly9cIiArIGhvc3RzWzBdO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXNldFVwbG9hZFVybDogJyArIHFpbml1VXBsb2FkVXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdGhpcy5yZXNldFVwbG9hZFVybCgpO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlzIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHVybCBvZiBhIGZpbGVcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmlsZSBpcyBhIGltYWdlIG9yIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0ltYWdlID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnNwbGl0KC9bPyNdLylbMF07XG4gICAgICAgICAgICByZXR1cm4gKC9cXC4ocG5nfGpwZ3xqcGVnfGdpZnxibXApJC9pKS50ZXN0KHVybCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gZmlsZSBleHRlbnNpb25cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAgIGlucHV0OiB0ZXN0LnR4dFxuICAgICAgICAgKiAgICAgb3V0cHV0OiB0eHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgdmFyIHRlbXBBcnIgPSBmaWxlbmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICB2YXIgZXh0O1xuICAgICAgICAgICAgaWYgKHRlbXBBcnIubGVuZ3RoID09PSAxIHx8ICh0ZW1wQXJyWzBdID09PSBcIlwiICYmIHRlbXBBcnIubGVuZ3RoID09PSAyKSkge1xuICAgICAgICAgICAgICAgIGV4dCA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dCA9IHRlbXBBcnIucG9wKCkudG9Mb3dlckNhc2UoKTsgLy9nZXQgdGhlIGV4dGVuc2lvbiBhbmQgbWFrZSBpdCBsb3dlci1jYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbmNvZGUgc3RyaW5nIGJ5IHV0ZjhcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXRmOF9lbmNvZGUgPSBmdW5jdGlvbiAoYXJnU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgICAgICAgICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgICAgICAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IHNvd2JlcnJ5XG4gICAgICAgICAgICAvLyArICAgIHR3ZWFrZWQgYnk6IEphY2tcbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFl2ZXMgU3VjYWV0XG4gICAgICAgICAgICAvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuICAgICAgICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBVbHJpY2hcbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieTogUmFmYWwgS3VrYXdza2lcbiAgICAgICAgICAgIC8vICsgICBpbXByb3ZlZCBieToga2lyaWxsb2lkXG4gICAgICAgICAgICAvLyArICAgYnVnZml4ZWQgYnk6IGtpcmlsbG9pZFxuICAgICAgICAgICAgLy8gKiAgICAgZXhhbXBsZSAxOiB0aGlzLnV0ZjhfZW5jb2RlKCdLZXZpbiB2YW4gWm9ubmV2ZWxkJyk7XG4gICAgICAgICAgICAvLyAqICAgICByZXR1cm5zIDE6ICdLZXZpbiB2YW4gWm9ubmV2ZWxkJ1xuXG4gICAgICAgICAgICBpZiAoYXJnU3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBhcmdTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gKGFyZ1N0cmluZyArICcnKTsgLy8gLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICAgICAgICAgIHZhciB1dGZ0ZXh0ID0gJycsXG4gICAgICAgICAgICAgICAgc3RhcnQsIGVuZCwgc3RyaW5nbCA9IDA7XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gMDtcbiAgICAgICAgICAgIHN0cmluZ2wgPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBzdHJpbmdsOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5jID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMxID4gMTI3ICYmIGMxIDwgMjA0OCkge1xuICAgICAgICAgICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGMxID4+IDYpIHwgMTkyLCAoYzEgJiA2MykgfCAxMjhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMxICYgMHhGODAwIF4gMHhEODAwID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGMxID4+IDEyKSB8IDIyNCwgKChjMSA+PiA2KSAmIDYzKSB8IDEyOCwgKGMxICYgNjMpIHwgMTI4XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gc3Vycm9nYXRlIHBhaXJzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjMSAmIDB4RkMwMCBeIDB4RDgwMCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdVbm1hdGNoZWQgdHJhaWwgc3Vycm9nYXRlIGF0ICcgKyBuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSBzdHJpbmcuY2hhckNvZGVBdCgrK24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYzIgJiAweEZDMDAgXiAweERDMDAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVW5tYXRjaGVkIGxlYWQgc3Vycm9nYXRlIGF0ICcgKyAobiAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjMSA9ICgoYzEgJiAweDNGRikgPDwgMTApICsgKGMyICYgMHgzRkYpICsgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIChjMSA+PiAxOCkgfCAyNDAsICgoYzEgPj4gMTIpICYgNjMpIHwgMTI4LCAoKGMxID4+IDYpICYgNjMpIHwgMTI4LCAoYzEgJiA2MykgfCAxMjhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gZW5jO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIHN0cmluZ2wpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmdGV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmJhc2U2NF9kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAgICAgICAgIC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuICAgICAgICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cbiAgICAgICAgICAgIC8vICsgICAgICBpbnB1dCBieTogQW1hbiBHdXB0YVxuICAgICAgICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gICAgICAgICAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAgICAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAgICAgICAvLyArICAgICAgaW5wdXQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG4gICAgICAgICAgICAvLyArICAgYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgICAgICAgLy8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZGVjb2RlKCdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09Jyk7XG4gICAgICAgICAgICAvLyAqICAgICByZXR1cm5zIDE6ICdLZXZpbiB2YW4gWm9ubmV2ZWxkJ1xuICAgICAgICAgICAgLy8gbW96aWxsYSBoYXMgdGhpcyBuYXRpdmVcbiAgICAgICAgICAgIC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZiB0aGlzLndpbmRvd1snYXRvYiddID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vICAgIHJldHVybiBhdG9iKGRhdGEpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICB2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgICAgICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgICAgICAgICBhYyA9IDAsXG4gICAgICAgICAgICAgICAgZGVjID0gXCJcIixcbiAgICAgICAgICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhICs9ICcnO1xuXG4gICAgICAgICAgICBkbyB7IC8vIHVucGFjayBmb3VyIGhleGV0cyBpbnRvIHRocmVlIG9jdGV0cyB1c2luZyBpbmRleCBwb2ludHMgaW4gYjY0XG4gICAgICAgICAgICAgICAgaDEgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgICAgICBoMiA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgICAgIGgzID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgICAgICAgICAgaDQgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcblxuICAgICAgICAgICAgICAgIGJpdHMgPSBoMSA8PCAxOCB8IGgyIDw8IDEyIHwgaDMgPDwgNiB8IGg0O1xuXG4gICAgICAgICAgICAgICAgbzEgPSBiaXRzID4+IDE2ICYgMHhmZjtcbiAgICAgICAgICAgICAgICBvMiA9IGJpdHMgPj4gOCAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgbzMgPSBiaXRzICYgMHhmZjtcblxuICAgICAgICAgICAgICAgIGlmIChoMyA9PT0gNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaDQgPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yLCBvMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgICAgICAgICAgZGVjID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlYztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZW5jb2RlIGRhdGEgYnkgYmFzZTY0XG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gZGF0YSB0byBlbmNvZGVcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmFzZTY0X2VuY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgICAgICAgICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEJheXJvbiBHdWV2YXJhXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuICAgICAgICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgICAgICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgICAgICAgIC8vIC0gICAgZGVwZW5kcyBvbjogdGhpcy51dGY4X2VuY29kZVxuICAgICAgICAgICAgLy8gKiAgICAgZXhhbXBsZSAxOiB0aGlzLmJhc2U2NF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgICAgICAgICAgIC8vICogICAgIHJldHVybnMgMTogJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nXG4gICAgICAgICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydhdG9iJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHZhciBiNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgICAgICAgICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgICAgICAgICBhYyA9IDAsXG4gICAgICAgICAgICAgICAgZW5jID0gJycsXG4gICAgICAgICAgICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YSA9IHRoaXMudXRmOF9lbmNvZGUoZGF0YSArICcnKTtcblxuICAgICAgICAgICAgZG8geyAvLyBwYWNrIHRocmVlIG9jdGV0cyBpbnRvIGZvdXIgaGV4ZXRzXG4gICAgICAgICAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgIG8zID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgICAgICAgICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgICAgICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICAgICAgICAgIGgyID0gYml0cyA+PiAxMiAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgICAgICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgICAgICAgICAvLyB1c2UgaGV4ZXRzIHRvIGluZGV4IGludG8gYjY0LCBhbmQgYXBwZW5kIHJlc3VsdCB0byBlbmNvZGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5sZW5ndGggJSAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTIpICsgJz09JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTEpICsgJz0nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZW5jb2RlIHN0cmluZyBpbiB1cmwgYnkgYmFzZTY0XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gdXJsXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuVVJMU2FmZUJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5iYXNlNjRfZW5jb2RlKHYpO1xuICAgICAgICAgICAgcmV0dXJuIHYucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvXFwrL2csICctJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5VUkxTYWZlQmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHYgPSB2LnJlcGxhY2UoL18vZywgJy8nKS5yZXBsYWNlKC8tL2csICcrJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlNjRfZGVjb2RlKHYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRPRE86IHVzZSBtT3hpZVxuICAgICAgICAvKipcbiAgICAgICAgICogY3JhZXRlIG9iamVjdCB1c2VkIHRvIEFKQVhcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVBamF4ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgeG1saHR0cCA9IHt9O1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeG1saHR0cCA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geG1saHR0cDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUT0RPOiBlbmhhbmNlIElFIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBhcnNlIGpzb24gc3RyaW5nIHRvIGphdmFzY3JpcHQgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30ganNvbiBzdHJpbmdcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyc2VKU09OID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5KU09OICYmIHdpbmRvdy5KU09OLnBhcnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5KU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3ZhciByeF9vbmUgPSAvXltcXF0sOnt9XFxzXSokLyxcbiAgICAgICAgICAgIC8vICAgIHJ4X3R3byA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2csXG4gICAgICAgICAgICAvLyAgICByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZyxcbiAgICAgICAgICAgIC8vICAgIHJ4X2ZvdXIgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csXG4gICAgICAgICAgICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgICAgICAgICAgIC8vdmFyIGpzb247XG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gU3RyaW5nKGRhdGEpO1xuICAgICAgICAgICAgcnhfZGFuZ2Vyb3VzLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAocnhfZGFuZ2Vyb3VzLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ4X2Rhbmdlcm91cywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0b2RvIOS9v+eUqOS4gOS4i+WIpOaWrSzlop7liqDlronlhajmgKdcbiAgICAgICAgICAgIC8vaWYgKFxuICAgICAgICAgICAgLy8gICAgcnhfb25lLnRlc3QoXG4gICAgICAgICAgICAvLyAgICAgICAgdGV4dFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAucmVwbGFjZShyeF90d28sICdAJylcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgLnJlcGxhY2UocnhfdGhyZWUsICddJylcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgLnJlcGxhY2UocnhfZm91ciwgJycpXG4gICAgICAgICAgICAvLyAgICApXG4gICAgICAgICAgICAvLykge1xuICAgICAgICAgICAgLy8gICAgcmV0dXJuIGV2YWwoJygnICsgdGV4dCArICcpJyk7XG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgcmV0dXJuIGV2YWwoJygnICsgdGV4dCArICcpJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBhcnNlIGphdmFzY3JpcHQgb2JqZWN0IHRvIGpzb24gc3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30ganNvbiBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RyaW5naWZ5SlNPTiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5KU09OICYmIHdpbmRvdy5KU09OLnN0cmluZ2lmeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIChvYmopKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcIicgKyBvYmoucmVwbGFjZSgvKFtcIlxcXFxdKS9nLCAnXFxcXCQxJykgKyAnXCInO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAodGhhdC5zdHJpbmdpZnlKU09OKS5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQXJyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJBcnIucHVzaCh0aGF0LnN0cmluZ2lmeUpTT04ob2JqW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1snICsgc3RyQXJyLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCh0aGF0LnN0cmluZ2lmeUpTT04ocHJvcGVydHkpICsgJzonICsgdGhhdC5zdHJpbmdpZnlKU09OKG9ialtwcm9wZXJ0eV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3snICsgc3RyaW5nLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRyaW0gc3BhY2UgYmVzaWRlIHRleHRcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB1bnRyaW1lZCBzdHJpbmdcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSB0cmltZWQgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaW0gPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQgPT09IG51bGwgPyBcIlwiIDogdGV4dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNyZWF0ZSBhIHVwbG9hZGVyIGJ5IFFpbml1SnNTREtcbiAgICAgICAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWRlclxuICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IHVwbG9hZGVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwbG9hZGVyID0gZnVuY3Rpb24gKG9wKSB7XG5cbiAgICAgICAgICAgIC8qKioqKioqKioqIGlubmVyIGZ1bmN0aW9uIGRlZmluZSBzdGFydCAqKioqKioqKioqL1xuXG4gICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRoZSBkaWZmZXJlbnQgY29uZGl0aW9uIHRvIHJlc2V0IGNodW5rIHNpemVcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIHVwbG9hZCBzdHJhdGVneSBhY2NvcmRpbmcgd2l0aCB0aGUgY2h1bmsgc2l6ZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2h1bmsgc2l6ZSBpcyB6ZXJvIHdpbGwgY2F1c2UgdG8gZGlyZWN0IHVwbG9hZFxuICAgICAgICAgICAgICAgIC8vIHNlZSB0aGUgc3RhdGVtZW50IGJpbmRlZCBvbiAnQmVmb3JlVXBsb2FkJyBldmVudFxuICAgICAgICAgICAgdmFyIHJlc2V0X2NodW5rX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZSA9IHRoYXQuZGV0ZWN0SUVWZXJzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBCTE9DS19CSVRTLCBNQVhfQ0hVTktfU0laRSwgY2h1bmtfc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSBTYWZhcmkgNeOAgVdpbmRvd3MgN+OAgWlPUyA3IHNldCBpc1NwZWNpYWxTYWZhcmkgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNTcGVjaWFsU2FmYXJpID0gKG1veGllLmNvcmUudXRpbHMuRW52LmJyb3dzZXIgPT09IFwiU2FmYXJpXCIgJiYgbW94aWUuY29yZS51dGlscy5FbnYudmVyc2lvbiA8PSA1ICYmIG1veGllLmNvcmUudXRpbHMuRW52Lm9zID09PSBcIldpbmRvd3NcIiAmJiBtb3hpZS5jb3JlLnV0aWxzLkVudi5vc1ZlcnNpb24gPT09IFwiN1wiKSB8fCAobW94aWUuY29yZS51dGlscy5FbnYuYnJvd3NlciA9PT0gXCJTYWZhcmlcIiAmJiBtb3hpZS5jb3JlLnV0aWxzLkVudi5vcyA9PT0gXCJpT1NcIiAmJiBtb3hpZS5jb3JlLnV0aWxzLkVudi5vc1ZlcnNpb24gPT09IFwiN1wiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSBJRSA5Le+8jGNodW5rX3NpemUgaXMgbm90IGVtcHR5IGFuZCBmbGFzaCBpcyBpbmNsdWRlZCBpbiBydW50aW1lc1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgb3AuY2h1bmtfc2l6ZSB0byB6ZXJvXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGllICYmIGllIDwgOSAmJiBvcC5jaHVua19zaXplICYmIG9wLnJ1bnRpbWVzLmluZGV4T2YoJ2ZsYXNoJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWUgJiYgaWUgPCA5ICYmIG9wLmNodW5rX3NpemUgJiYgb3AucnVudGltZXMuaW5kZXhPZignZmxhc2gnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgbGluazogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vZG9jcy9GcmVxdWVudGx5LUFza2VkLVF1ZXN0aW9ucyN3aGVuLXRvLXVzZS1jaHVua2luZy1hbmQtd2hlbi1ub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICB3aGVuIHBsdXBsb2FkIGNodW5rX3NpemUgc2V0dGluZyBpcyd0IG51bGwgLGl0IGNhdXNlIGJ1ZyBpbiBpZTgvOSAgd2hpY2ggcnVucyAgZmxhc2ggcnVudGltZXMgKG5vdCBzdXBwb3J0IGh0bWw1KSAuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5jaHVua19zaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1NwZWNpYWxTYWZhcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbjcgc2FmYXJpIC8gaU9TNyBzYWZhcmkgaGF2ZSBidWcgd2hlbiBpbiBjaHVuayB1cGxvYWQgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgY2h1bmtfc2l6ZSB0byAwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIGNodW5rIGluIHNwZWNpYWwgdmVyc2lvbiBzYWZhcmlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLmNodW5rX3NpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQkxPQ0tfQklUUyA9IDIwO1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFYX0NIVU5LX1NJWkUgPSA0IDw8IEJMT0NLX0JJVFM7IC8vNE1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtfc2l6ZSA9IHBsdXBsb2FkLnBhcnNlU2l6ZShvcC5jaHVua19zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua19zaXplID4gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcC5jaHVua19zaXplID0gTUFYX0NIVU5LX1NJWkU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBxaW5pdSBzZXJ2aWNlICBtYXhfY2h1bmtfc2l6ZSBpcyA0bVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgY2h1bmtfc2l6ZSB0byBtYXhfY2h1bmtfc2l6ZSg0bSkgd2hlbiBjaHVua19zaXplID4gNG1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBvcC5jaHVua19zaXplIHNldCAwIHdpbGwgYmUgY2F1c2UgdG8gZGlyZWN0IHVwbG9hZFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRIb3N0cyA9IGZ1bmN0aW9uIChob3N0cykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdXBsb2FkSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0ID0gaG9zdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChob3N0LmluZGV4T2YoXCJ1cGxvYWRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3QuaW5kZXhPZignLUgnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaG9zdC5zcGxpdCgnICcpWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGhvc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHVwbG9hZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvL21ha2UgdXBsb2FkIGRvbWFpbnMgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwbG9hZERvbWFpbiA9IHJlc3VsdFt1cGxvYWRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFt1cGxvYWRJbmRleF0gPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IHVwbG9hZERvbWFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRQdXRQb2xpY3kgPSBmdW5jdGlvbiAodXB0b2tlbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IHVwdG9rZW4uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgIHZhciBhayA9IHNlZ21lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBwdXRQb2xpY3kgPSB0aGF0LnBhcnNlSlNPTih0aGF0LlVSTFNhZmVCYXNlNjREZWNvZGUoc2VnbWVudHNbMl0pKTtcbiAgICAgICAgICAgICAgICBwdXRQb2xpY3kuYWsgPSBhaztcbiAgICAgICAgICAgICAgICBpZiAocHV0UG9saWN5LnNjb3BlLmluZGV4T2YoXCI6XCIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHV0UG9saWN5LmJ1Y2tldCA9IHB1dFBvbGljeS5zY29wZS5zcGxpdChcIjpcIilbMF07XG4gICAgICAgICAgICAgICAgICAgIHB1dFBvbGljeS5rZXkgPSBwdXRQb2xpY3kuc2NvcGUuc3BsaXQoXCI6XCIpWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1dFBvbGljeS5idWNrZXQgPSBwdXRQb2xpY3kuc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwdXRQb2xpY3k7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0VXBIb3N0cyA9IGZ1bmN0aW9uICh1cHRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHB1dFBvbGljeSA9IGdldFB1dFBvbGljeSh1cHRva2VuKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBob3N0c191cmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gXCJodHRwczovL1wiICsgXCJhcGkucWluaXUuY29tL3YyL3F1ZXJ5P2FrPVwiICsgcHV0UG9saWN5LmFrICsgXCImYnVja2V0PVwiICsgcHV0UG9saWN5LmJ1Y2tldCA6IFwiaHR0cDovL1wiICsgXCJhcGkucWluaXUuY29tL3YyL3F1ZXJ5P2FrPVwiICsgcHV0UG9saWN5LmFrICsgXCImYnVja2V0PVwiICsgcHV0UG9saWN5LmJ1Y2tldDtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJwdXRQb2xpY3k6IFwiLCBwdXRQb2xpY3kpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdldCB1cGhvc3RzIGZyb206IFwiLCB1cGhvc3RzX3VybCk7XG4gICAgICAgICAgICAgICAgdmFyIGllID0gdGhhdC5kZXRlY3RJRVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgYWpheDtcbiAgICAgICAgICAgICAgICBpZiAoaWUgJiYgaWUgPD0gOSkge1xuICAgICAgICAgICAgICAgICAgICBhamF4ID0gbmV3IG1veGllLnhoci5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICBtb3hpZS5jb3JlLnV0aWxzLkVudi5zd2ZfdXJsID0gb3AuZmxhc2hfc3dmX3VybDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhamF4ID0gdGhhdC5jcmVhdGVBamF4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFqYXgub3BlbignR0VUJywgdXBob3N0c191cmwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgb25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJhamF4LnJlYWR5U3RhdGU6IFwiLCBhamF4LnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWpheC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJhamF4LnN0YXR1czogXCIsIGFqYXguc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhamF4LnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcWluaXVVcEhvc3RzLm1haW4gPSByZXMudXAuYWNjLm1haW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcWluaXVVcEhvc3RzLmJhY2t1cCA9IHJlcy51cC5hY2MuYmFja3VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdldCBuZXcgdXBob3N0czogXCIsIHFpbml1VXBIb3N0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yZXNldFVwbG9hZFVybCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiZ2V0IHVwaG9zdHMgZXJyb3I6IFwiLCBhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFqYXguYmluZCgncmVhZHlzdGF0ZWNoYW5nZScsIG9ucmVhZHlzdGF0ZWNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWpheC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvbnJlYWR5c3RhdGVjaGFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFqYXguc2VuZCgpO1xuICAgICAgICAgICAgICAgIC8vIGFqYXguc2VuZCgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIChhamF4LnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgcmVzID0gdGhhdC5wYXJzZUpTT04oYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIC8vICAgICBxaW5pdVVwSG9zdHMuaHR0cCA9IGdldEhvc3RzKHJlcy5odHRwLnVwKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgcWluaXVVcEhvc3RzLmh0dHBzID0gZ2V0SG9zdHMocmVzLmh0dHBzLnVwKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IG5ldyB1cGhvc3RzOiBcIiwgcWluaXVVcEhvc3RzKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhhdC5yZXNldFVwbG9hZFVybCgpO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGxvZ2dlci5lcnJvcihcImdldCB1cGhvc3RzIGVycm9yOiBcIiwgYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0VXB0b2tlbiA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGF0LnRva2VuIHx8IChvcC51cHRva2VuX3VybCAmJiB0aGF0LnRva2VuSW5mby5pc0V4cGlyZWQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5ld1VwVG9rZW4oZmlsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ2V0TmV3VXB0b2tlbiBtYXliZSBjYWxsZWQgYXQgSW5pdCBFdmVudCBvciBCZWZvcmVVcGxvYWQgRXZlbnRcbiAgICAgICAgICAgIC8vIGNhc2UgSW5pdCBFdmVudCwgdGhlIGZpbGUgcGFyYW0gb2YgZ2V0VXB0a2VuIHdpbGwgYmUgc2V0IGEgbnVsbCB2YWx1ZVxuICAgICAgICAgICAgLy8gaWYgb3AudXB0b2tlbiBoYXMgdmFsdWUsIHNldCB1cHRva2VuIHdpdGggb3AudXB0b2tlblxuICAgICAgICAgICAgLy8gZWxzZSBpZiBvcC51cHRva2VuX3VybCBoYXMgdmFsdWUsIHNldCB1cHRva2VuIGZyb20gb3AudXB0b2tlbl91cmxcbiAgICAgICAgICAgIC8vIGVsc2UgaWYgb3AudXB0b2tlbl9mdW5jIGhhcyB2YWx1ZSwgc2V0IHVwdG9rZW4gYnkgcmVzdWx0IG9mIG9wLnVwdG9rZW5fZnVuY1xuICAgICAgICAgICAgdmFyIGdldE5ld1VwVG9rZW4gPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcC51cHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudG9rZW4gPSBvcC51cHRva2VuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AudXB0b2tlbl91cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IHVwdG9rZW4gZnJvbTogXCIsIHRoYXQudXB0b2tlbl91cmwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB1c2UgbU94aWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFqYXggPSB0aGF0LmNyZWF0ZUFqYXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYWpheC5vcGVuKCdHRVQnLCB0aGF0LnVwdG9rZW5fdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFqYXguc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWpheC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmIChhamF4LnJlYWR5U3RhdGUgPT09IDQgJiYgYWpheC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGhhdC50b2tlbiA9IHJlcy51cHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB9O1xuICAgICAgICAgICAgICAgICAgICBhamF4LnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXguc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRva2VuID0gcmVzLnVwdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGF0LnRva2VuLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRQb2xpY3kgPSB0aGF0LnBhcnNlSlNPTih0aGF0LlVSTFNhZmVCYXNlNjREZWNvZGUoc2VnbWVudHNbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC50b2tlbk1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudG9rZW5NYXAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwodGltZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyVGltZSA9IGdldFRpbWVzdGFtcChuZXcgRGF0ZShhamF4LmdldFJlc3BvbnNlSGVhZGVyKFwiZGF0ZVwiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudFRpbWUgPSBnZXRUaW1lc3RhbXAobmV3IERhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRva2VuSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEZWxheTogY2xpZW50VGltZSAtIHNlcnZlclRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmU6IHB1dFBvbGljeS5kZWFkbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0V4cGlyZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRUaW1lID0gdGhpcy5kZWFkbGluZSAtIGdldFRpbWVzdGFtcChuZXcgRGF0ZSgpKSArIHRoaXMuc2VydmVyRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VGltZSA8IDYwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IG5ldyB1cHRva2VuOiBcIiwgdGhhdC50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJnZXQgdG9rZW4gaW5mbzogXCIsIHRoYXQudG9rZW5JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcImdldCB1cHRva2VuIGVycm9yOiBcIiwgYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC51cHRva2VuX2Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IHVwdG9rZW4gZnJvbSB1cHRva2VuX2Z1bmNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudG9rZW4gPSBvcC51cHRva2VuX2Z1bmMoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdldCBuZXcgdXB0b2tlbjogXCIsIHRoYXQudG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIm9uZSBvZiBbdXB0b2tlbiwgdXB0b2tlbl91cmwsIHVwdG9rZW5fZnVuY10gc2V0dGluZ3MgaW4gb3B0aW9ucyBpcyByZXF1aXJlZCFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGF0LnRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFVwSG9zdHModGhhdC50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnRva2VuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ2V0IGZpbGUga2V5IGFjY29yZGluZyB3aXRoIHRoZSB1c2VyIHBhc3NlZCBvcHRpb25zXG4gICAgICAgICAgICB2YXIgZ2V0RmlsZUtleSA9IGZ1bmN0aW9uICh1cCwgZmlsZSwgZnVuYykge1xuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkdcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHlvdSBzZXQgdGhlIGtleSBpbiBwdXRQb2xpY3kgYnkgXCJzY29wZVwiOiBcImJ1Y2tldDprZXlcIlxuICAgICAgICAgICAgICAgIC8vIFlvdSBzaG91bGQgdW5kZXJzdGFuZCB0aGUgcmlzayBvZiBvdmVycmlkZSBhIGZpbGUgaW4gdGhlIGJ1Y2tldFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZSBjb2RlIGJlbG93IHRoYXQgYXV0b21hdGljYWxseSBnZXQga2V5IGZyb20gdXB0b2tlbiBoYXMgYmVlbiBjb21tZW50ZWRcbiAgICAgICAgICAgICAgICAvLyB2YXIgcHV0UG9saWN5ID0gZ2V0UHV0UG9saWN5KHRoYXQudG9rZW4pXG4gICAgICAgICAgICAgICAgLy8gaWYgKHB1dFBvbGljeS5rZXkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgbG9nZ2VyLmRlYnVnKFwia2V5IGlzIGRlZmluZWQgaW4gcHV0UG9saWN5LnNjb3BlOiBcIiwgcHV0UG9saWN5LmtleSlcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHB1dFBvbGljeS5rZXlcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnLFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVfbmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wLnNhdmVfa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZV9uYW1lcyA9IHVwLmdldE9wdGlvbiAmJiB1cC5nZXRPcHRpb24oJ3VuaXF1ZV9uYW1lcycpO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVfbmFtZXMgPSB1bmlxdWVfbmFtZXMgfHwgKHVwLnNldHRpbmdzICYmIHVwLnNldHRpbmdzLnVuaXF1ZV9uYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmlxdWVfbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSB0aGF0LmdldEZpbGVFeHRlbnNpb24oZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGV4dCA/IGZpbGUuaWQgKyAnLicgKyBleHQgOiBmaWxlLmlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBmdW5jKHVwLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldERvbWFpbkZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiB1cmwubWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW146Xi9dKikvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwcyA/IGdyb3Vwc1sxXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldFBvcnRGcm9tVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgICAgIGlmICh1cmwgJiYgdXJsLm1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSB1cmwubWF0Y2goLyheaHR0cHM/KS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBncm91cHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwcyA9IHVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW146Xi9dKik6KFxcZCopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cHNbMl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJodHRwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjgwXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI0NDNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKioqKioqKioqIGlubmVyIGZ1bmN0aW9uIGRlZmluZSBlbmQgKioqKioqKioqKi9cblxuICAgICAgICAgICAgaWYgKG9wLmxvZ19sZXZlbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sZXZlbCA9IG9wLmxvZ19sZXZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcC5kb21haW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnZG9tYWluIHNldHRpbmcgaW4gb3B0aW9ucyBpcyByZXF1aXJlZCEnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wLmJyb3dzZV9idXR0b24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYnJvd3NlX2J1dHRvbiBzZXR0aW5nIGluIG9wdGlvbnMgaXMgcmVxdWlyZWQhJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcC51cHRva2VuICYmICFvcC51cHRva2VuX3VybCAmJiAhb3AudXB0b2tlbl9mdW5jKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ29uZSBvZiBbdXB0b2tlbiwgdXB0b2tlbl91cmwsIHVwdG9rZW5fZnVuY10gc2V0dGluZ3MgaW4gb3B0aW9ucyBpcyByZXF1aXJlZCEnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJpbml0IHVwbG9hZGVyIHN0YXJ0XCIpO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJlbnZpcm9ubWVudDogXCIsIG1veGllLmNvcmUudXRpbHMuRW52KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwidXNlckFnZW50OiBcIiwgbmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB7fTtcblxuICAgICAgICAgICAgLy8gaG9sZCB0aGUgaGFuZGxlciBmcm9tIHVzZXIgcGFzc2VkIG9wdGlvbnNcbiAgICAgICAgICAgIHZhciBfRXJyb3JfSGFuZGxlciA9IG9wLmluaXQgJiYgb3AuaW5pdC5FcnJvcjtcbiAgICAgICAgICAgIHZhciBfRmlsZVVwbG9hZGVkX0hhbmRsZXIgPSBvcC5pbml0ICYmIG9wLmluaXQuRmlsZVVwbG9hZGVkO1xuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBoYW5kbGVyIGZvciBpbnRlcmNlcHRcbiAgICAgICAgICAgIG9wLmluaXQuRXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIG9wLmluaXQuRmlsZVVwbG9hZGVkID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICAgIHRoYXQudXB0b2tlbl91cmwgPSBvcC51cHRva2VuX3VybDtcbiAgICAgICAgICAgIHRoYXQudG9rZW4gPSAnJztcbiAgICAgICAgICAgIHRoYXQua2V5X2hhbmRsZXIgPSB0eXBlb2Ygb3AuaW5pdC5LZXkgPT09ICdmdW5jdGlvbicgPyBvcC5pbml0LktleSA6ICcnO1xuICAgICAgICAgICAgdGhpcy5kb21haW4gPSBvcC5kb21haW47XG4gICAgICAgICAgICAvLyBUT0RPOiBjdHggaXMgZ2xvYmFsIGluIHNjb3BlIG9mIGEgdXBsb2FkZXIgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIHRoaXMgbWF5YmUgY2F1c2UgZXJyb3JcbiAgICAgICAgICAgIHZhciBjdHggPSAnJztcbiAgICAgICAgICAgIHZhciBzcGVlZENhbEluZm8gPSB7XG4gICAgICAgICAgICAgICAgaXNSZXN1bWVVcGxvYWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc3VtZUZpbGVzaXplOiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogJycsXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXNldF9jaHVua19zaXplKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJpbnZva2UgcmVzZXRfY2h1bmtfc2l6ZSgpXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwib3AuY2h1bmtfc2l6ZTogXCIsIG9wLmNodW5rX3NpemUpO1xuXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFNldHRpbmcgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBxaW5pdVVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaWUgPSB0aGF0LmRldGVjdElFVmVyc2lvbigpO1xuICAgICAgICAgICAgLy8gY2FzZSBJRSA5LVxuICAgICAgICAgICAgLy8gYWRkIGFjY2VwdCBpbiBtdWx0aXBhcnQgcGFyYW1zXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWUgPD0gOSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTZXR0aW5nLm11bHRpcGFydF9wYXJhbXMuYWNjZXB0ID0gJ3RleHQvcGxhaW47IGNoYXJzZXQ9dXRmLTgnO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFkZCBhY2NlcHQgdGV4dC9wbGFpbiBpbiBtdWx0aXBhcnQgcGFyYW1zXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb21wb3NlIG9wdGlvbnMgd2l0aCB1c2VyIHBhc3NlZCBvcHRpb25zIGFuZCBkZWZhdWx0IHNldHRpbmdcbiAgICAgICAgICAgIHBsdXBsb2FkLmV4dGVuZChvcHRpb24sIG9wLCBkZWZhdWx0U2V0dGluZyk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm9wdGlvbjogXCIsIG9wdGlvbik7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyB1cGxvYWRlciB3aXRoIGNvbXBvc2VkIG9wdGlvbnNcbiAgICAgICAgICAgIHZhciB1cGxvYWRlciA9IG5ldyBwbHVwbG9hZC5VcGxvYWRlcihvcHRpb24pO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJuZXcgcGx1cGxvYWQuVXBsb2FkZXIob3B0aW9uKVwiKTtcblxuICAgICAgICAgICAgLy8gYmluZCBnZXROZXdVcFRva2VuIHRvICdJbml0JyBldmVudFxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnSW5pdCcsIGZ1bmN0aW9uICh1cCwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiSW5pdCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgLy8gaWYgb3AuZ2V0X25ld191cHRva2VuIGlzIG5vdCB0cnVlXG4gICAgICAgICAgICAgICAgLy8gICAgICBpbnZva2UgZ2V0TmV3VXB0b2tlbiB3aGVuIHVwbG9hZGVyIGluaXRcbiAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgLy8gICAgICBnZXROZXdVcHRva2VuIGV2ZXJ5dGltZSBiZWZvcmUgYSBuZXcgZmlsZSB1cGxvYWRcbiAgICAgICAgICAgICAgICBpZiAoIW9wLmdldF9uZXdfdXB0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBnZXROZXdVcFRva2VuKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2dldE5ld1VwVG9rZW4obnVsbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBJbml0IGV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBiaW5kICdGaWxlc0FkZGVkJyBldmVudFxuICAgICAgICAgICAgLy8gd2hlbiBmaWxlIGJlIGFkZGVkIGFuZCBhdXRvX3N0YXJ0IGhhcyBzZXQgdmFsdWVcbiAgICAgICAgICAgIC8vIHVwbG9hZGVyIHdpbGwgYXV0byBzdGFydCB1cGxvYWQgdGhlIGZpbGVcbiAgICAgICAgICAgIHVwbG9hZGVyLmJpbmQoJ0ZpbGVzQWRkZWQnLCBmdW5jdGlvbiAodXAsIGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmlsZXNBZGRlZCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgdmFyIGF1dG9fc3RhcnQgPSB1cC5nZXRPcHRpb24gJiYgdXAuZ2V0T3B0aW9uKCdhdXRvX3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgYXV0b19zdGFydCA9IGF1dG9fc3RhcnQgfHwgKHVwLnNldHRpbmdzICYmIHVwLnNldHRpbmdzLmF1dG9fc3RhcnQpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImF1dG9fc3RhcnQ6IFwiLCBhdXRvX3N0YXJ0KTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJmaWxlczogXCIsIGZpbGVzKTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpcyBpT1NcbiAgICAgICAgICAgICAgICB2YXIgaXNfaW9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW94aWUuY29yZS51dGlscy5FbnYuT1MudG9Mb3dlckNhc2UoKSA9PT0gXCJpb3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudCBlbnYgb3MgaXMgaU9TIGNoYW5nZSBmaWxlIG5hbWUgdG8gW3RpbWVdLltleHRdXG4gICAgICAgICAgICAgICAgaWYgKGlzX2lvcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gdGhhdC5nZXRGaWxlRXh0ZW5zaW9uKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlLmlkICsgXCIuXCIgKyBleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXV0b19zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJpbnZva2UgdXAuc3RhcnQoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBsdXBsb2FkLmVhY2goZmlsZXMsIGZ1bmN0aW9uKGksIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHVwLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsb2dnZXIuZGVidWcoXCJpbnZva2UgdXAuc3RhcnQoKVwiKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbG9nZ2VyLmRlYnVnKFwiZmlsZTogXCIsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXAucmVmcmVzaCgpOyAvLyBSZXBvc2l0aW9uIEZsYXNoL1NpbHZlcmxpZ2h0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBGaWxlc0FkZGVkIGV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBiaW5kICdCZWZvcmVVcGxvYWQnIGV2ZW50XG4gICAgICAgICAgICAvLyBpbnRlcmNlcHQgdGhlIHByb2Nlc3Mgb2YgdXBsb2FkXG4gICAgICAgICAgICAvLyAtIHByZXBhcmUgdXB0b2tlblxuICAgICAgICAgICAgLy8gLSBhY2NvcmRpbmcgdGhlIGNodW5rIHNpemUgdG8gbWFrZSBkaWZmZXJudCB1cGxvYWQgc3RyYXRlZ3lcbiAgICAgICAgICAgIC8vIC0gcmVzdW1lIHVwbG9hZCB3aXRoIHRoZSBsYXN0IGJyZWFrcG9pbnQgb2YgZmlsZVxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnQmVmb3JlVXBsb2FkJywgZnVuY3Rpb24gKHVwLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQmVmb3JlVXBsb2FkIGV2ZW50IGFjdGl2YXRlZFwiKTtcbiAgICAgICAgICAgICAgICBmaWxlLl9zdGFydF9hdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGEga2V5IG5hbWVkIHNwZWVkIGZvciBmaWxlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZpbGUuc3BlZWQgPSBmaWxlLnNwZWVkIHx8IDA7XG4gICAgICAgICAgICAgICAgY3R4ID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAob3AuZ2V0X25ld191cHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE5ld1VwVG9rZW4oZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdFVwbG9hZCA9IGZ1bmN0aW9uICh1cCwgZmlsZSwgZnVuYykge1xuICAgICAgICAgICAgICAgICAgICBzcGVlZENhbEluZm8uc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBhcnRfcGFyYW1zX29iajtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnNhdmVfa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9rZW4nOiB0aGF0LnRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwYXJ0X3BhcmFtc19vYmogPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2tleSc6IGdldEZpbGVLZXkodXAsIGZpbGUsIGZ1bmMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbic6IHRoYXQudG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGllID0gdGhhdC5kZXRlY3RJRVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSBJRSA5LVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWNjZXB0IGluIG11bHRpcGFydCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGllICYmIGllIDw9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGFydF9wYXJhbXNfb2JqLmFjY2VwdCA9ICd0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFkZCBhY2NlcHQgdGV4dC9wbGFpbiBpbiBtdWx0aXBhcnQgcGFyYW1zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZGlyZWN0VXBsb2FkIG11bHRpcGFydF9wYXJhbXNfb2JqOiBcIiwgbXVsdGlwYXJ0X3BhcmFtc19vYmopO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4X3ZhcnMgPSBvcC54X3ZhcnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4X3ZhcnMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgeF92YXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeF9rZXkgaW4geF92YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhfdmFycy5oYXNPd25Qcm9wZXJ0eSh4X2tleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4X3ZhcnNbeF9rZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29ialsneDonICsgeF9rZXldID0geF92YXJzW3hfa2V5XSh1cCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHhfdmFyc1t4X2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29ialsneDonICsgeF9rZXldID0geF92YXJzW3hfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHVwLnNldE9wdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAndXJsJzogcWluaXVVcGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXVsdGlwYXJ0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaHVua19zaXplJzogaXNfYW5kcm9pZF93ZWl4aW5fb3JfcXEoKSA/IG9wLm1heF9maWxlX3NpemUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXVsdGlwYXJ0X3BhcmFtcyc6IG11bHRpcGFydF9wYXJhbXNfb2JqXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgaXMgd2VpeGluIG9yIHFxIGlubmVyIGJyb3dzZXJcbiAgICAgICAgICAgICAgICB2YXIgaXNfYW5kcm9pZF93ZWl4aW5fb3JfcXEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh1YS5tYXRjaCgvTWljcm9NZXNzZW5nZXIvaSkgfHwgbW94aWUuY29yZS51dGlscy5FbnYuYnJvd3NlciA9PT0gXCJRUUJyb3dzZXJcIiB8fCB1YS5tYXRjaCgvVjFfQU5EX1NRL2kpKSAmJiBtb3hpZS5jb3JlLnV0aWxzLkVudi5PUy50b0xvd2VyQ2FzZSgpID09PSBcImFuZHJvaWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGNodW5rX3NpemUgPSB1cC5nZXRPcHRpb24gJiYgdXAuZ2V0T3B0aW9uKCdjaHVua19zaXplJyk7XG4gICAgICAgICAgICAgICAgY2h1bmtfc2l6ZSA9IGNodW5rX3NpemUgfHwgKHVwLnNldHRpbmdzICYmIHVwLnNldHRpbmdzLmNodW5rX3NpemUpO1xuXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwidXBsb2FkZXIucnVudGltZTogXCIsIHVwbG9hZGVyLnJ1bnRpbWUpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImNodW5rX3NpemU6IFwiLCBjaHVua19zaXplKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZsYXNoIHN1cHBvcnQgY2h1bmsgdXBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKCh1cGxvYWRlci5ydW50aW1lID09PSAnaHRtbDUnIHx8IHVwbG9hZGVyLnJ1bnRpbWUgPT09ICdmbGFzaCcpICYmIGNodW5rX3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuc2l6ZSA8IGNodW5rX3NpemUgfHwgaXNfYW5kcm9pZF93ZWl4aW5fb3JfcXEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZGlyZWN0VXBsb2FkIGJlY2F1c2UgZmlsZS5zaXplIDwgY2h1bmtfc2l6ZSB8fCBpc19hbmRyb2lkX3dlaXhpbl9vcl9xcSgpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0IHVwbG9hZCBpZiBmaWxlIHNpemUgaXMgbGVzcyB0aGVuIHRoZSBjaHVuayBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RVcGxvYWQodXAsIGZpbGUsIHRoYXQua2V5X2hhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZCBhIHBvbGlmaWxsIHRvIG1ha2UgaXQgd29yayBpbiBJRSA5LVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVNTVUU6IGlmIGZpbGUubmFtZSBpcyBleGlzdGVkIGluIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IG5vdCB0aGUgc2FtZSBmaWxlIG1heWJlIGNhdXNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxGaWxlSW5mbyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2h1bmtfc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEZpbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYWx0aG91Z2ggb25seSB0aGUgaHRtbDUgcnVudGltZSB3aWxsIGVudGVyIHRoaXMgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IG5lZWQgdW5pZm9ybSB3YXkgdG8gbWFrZSBjb252ZXJ0aW9uIGJldHdlZW4gc3RyaW5nIGFuZCBqc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWxlSW5mbyA9IHRoYXQucGFyc2VKU09OKGxvY2FsRmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBsb2NhbEZpbGVJbmZvLnRpbWUgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYURheSA9IDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vICBtaWxsaXNlY29uZHMgb2Ygb25lIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYXN0IHVwbG9hZCB0aW1lIGlzIHdpdGhpbiBvbmUgZGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICB3aWxsIHVwbG9hZCBjb250aW51b3VzbHkgZm9sbG93IHRoZSBsYXN0IGJyZWFrcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICB3aWxsIHJldXBsb2FkIGVudGlyZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyAtIGJlZm9yZSA8IGFEYXkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxGaWxlSW5mby5wZXJjZW50ICE9PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnNpemUgPT09IGxvY2FsRmlsZUluZm8udG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiBmaWxlLm5hbWUgYW5kIGZpbGUuc2l6ZSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBub3QgdGhlIHNhbWUgZmlsZSB3aWxsIGNhdXNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5wZXJjZW50ID0gbG9jYWxGaWxlSW5mby5wZXJjZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUubG9hZGVkID0gbG9jYWxGaWxlSW5mby5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4ID0gbG9jYWxGaWxlSW5mby5jdHg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgc3BlZWQgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkQ2FsSW5mby5pc1Jlc3VtZVVwbG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWRDYWxJbmZvLnJlc3VtZUZpbGVzaXplID0gbG9jYWxGaWxlSW5mby5vZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgYmxvY2sgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEZpbGVJbmZvLm9mZnNldCArIGJsb2NrU2l6ZSA+IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NpemUgPSBmaWxlLnNpemUgLSBsb2NhbEZpbGVJbmZvLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmaWxlIGluZm8gd2hlbiBmaWxlLnNpemUgaXMgY29uZmxpY3Qgd2l0aCBmaWxlIGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShmaWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZmlsZSBpbmZvIHdoZW4gdXBsb2FkIHBlcmNlbnQgaXMgMTAwJVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgNDk5IGJ1Z1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmaWxlIGluZm8gd2hlbiBsYXN0IHVwbG9hZCB0aW1lIGlzIG92ZXIgb25lIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShmaWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkQ2FsSW5mby5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBhcnRfcGFyYW1zX29iaiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGllID0gdGhhdC5kZXRlY3RJRVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgSUUgOS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhY2NlcHQgaW4gbXVsdGlwYXJ0IHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGllICYmIGllIDw9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29iai5hY2NlcHQgPSAndGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWRkIGFjY2VwdCB0ZXh0L3BsYWluIGluIG11bHRpcGFydCBwYXJhbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0byBzdXBwb3J0IGJwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIucWluaXUuY29tL2RvY3MvdjYvYXBpL3JlZmVyZW5jZS91cC9icHV0Lmh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLnNldE9wdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VybCc6IHFpbml1VXBsb2FkVXJsICsgJy9ta2Jsay8nICsgYmxvY2tTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtdWx0aXBhcnQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2h1bmtfc2l6ZSc6IGNodW5rX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcXVpcmVkX2ZlYXR1cmVzJzogXCJjaHVua3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnVXBUb2tlbiAnICsgZ2V0VXB0b2tlbihmaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ211bHRpcGFydF9wYXJhbXMnOiBtdWx0aXBhcnRfcGFyYW1zX29ialxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJkaXJlY3RVcGxvYWQgYmVjYXVzZSB1cGxvYWRlci5ydW50aW1lICE9PSAnaHRtbDUnIHx8IHVwbG9hZGVyLnJ1bnRpbWUgIT09ICdmbGFzaCcgfHwgIWNodW5rX3NpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpcmVjdCB1cGxvYWQgaWYgcnVudGltZSBpcyBub3QgaHRtbDVcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0VXBsb2FkKHVwLCBmaWxlLCB0aGF0LmtleV9oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBCZWZvcmVVcGxvYWQgZXZlbnRcIik7XG5cbiAgICAgICAgICAgIC8vIGJpbmQgJ1VwbG9hZFByb2dyZXNzJyBldmVudFxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHVwbG9hZCBzcGVlZFxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnVXBsb2FkUHJvZ3Jlc3MnLCBmdW5jdGlvbiAodXAsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJVcGxvYWRQcm9ncmVzcyBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgc3BlZWRDYWxJbmZvLmN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVVc2VkID0gc3BlZWRDYWxJbmZvLmN1cnJlbnRUaW1lIC0gc3BlZWRDYWxJbmZvLnN0YXJ0VGltZTsgLy8gbXNcbiAgICAgICAgICAgICAgICB2YXIgZmlsZVVwbG9hZGVkID0gZmlsZS5sb2FkZWQgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWRDYWxJbmZvLmlzUmVzdW1lVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVVcGxvYWRlZCA9IGZpbGUubG9hZGVkIC0gc3BlZWRDYWxJbmZvLnJlc3VtZUZpbGVzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlLnNwZWVkID0gKGZpbGVVcGxvYWRlZCAvIHRpbWVVc2VkICogMTAwMCkudG9GaXhlZCgwKSB8fCAwOyAvLyB1bml0OiBieXRlL3NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJiaW5kIFVwbG9hZFByb2dyZXNzIGV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBiaW5kICdDaHVua1VwbG9hZGVkJyBldmVudFxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGNodW5rIHVwbG9hZCBpbmZvIGFuZCBzZXQgbmV4dCBjaHVuayB1cGxvYWQgdXJsXG4gICAgICAgICAgICB1cGxvYWRlci5iaW5kKCdDaHVua1VwbG9hZGVkJywgZnVuY3Rpb24gKHVwLCBmaWxlLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2h1bmtVcGxvYWRlZCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2h1bmtVcGxvYWRlZCBmaWxlOiBcIiwgZmlsZSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2h1bmtVcGxvYWRlZCBpbmZvOiBcIiwgaW5mbyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoYXQucGFyc2VKU09OKGluZm8ucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNodW5rVXBsb2FkZWQgcmVzOiBcIiwgcmVzKTtcbiAgICAgICAgICAgICAgICAvLyBjdHggc2hvdWxkIGxvb2sgbGlrZSAnW2NodW5rMDFfY3R4XSxbY2h1bmswMl9jdHhdLFtjaHVuazAzX2N0eF0sLi4uJ1xuICAgICAgICAgICAgICAgIGN0eCA9IGN0eCA/IGN0eCArICcsJyArIHJlcy5jdHggOiByZXMuY3R4O1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0U2l6ZSA9IGluZm8udG90YWwgLSBpbmZvLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtfc2l6ZSA9IHVwLmdldE9wdGlvbiAmJiB1cC5nZXRPcHRpb24oJ2NodW5rX3NpemUnKTtcbiAgICAgICAgICAgICAgICBjaHVua19zaXplID0gY2h1bmtfc2l6ZSB8fCAodXAuc2V0dGluZ3MgJiYgdXAuc2V0dGluZ3MuY2h1bmtfc2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRTaXplIDwgY2h1bmtfc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cC5zZXRPcHRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VybCc6IHFpbml1VXBsb2FkVXJsICsgJy9ta2Jsay8nICsgbGVmdFNpemVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcInVwLnNldE9wdGlvbiB1cmw6IFwiLCBxaW5pdVVwbG9hZFVybCArICcvbWtibGsvJyArIGxlZnRTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXAuc2V0T3B0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdVcFRva2VuICcgKyBnZXRVcHRva2VuKGZpbGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShmaWxlLm5hbWUsIHRoYXQuc3RyaW5naWZ5SlNPTih7XG4gICAgICAgICAgICAgICAgICAgIGN0eDogY3R4LFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiBmaWxlLnBlcmNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiBpbmZvLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGluZm8ub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImJpbmQgQ2h1bmtVcGxvYWRlZCBldmVudFwiKTtcblxuICAgICAgICAgICAgdmFyIHJldHJpZXMgPSBvcC5tYXhfcmV0cmllcztcblxuICAgICAgICAgICAgLy8gaWYgZXJyb3IgaXMgdW5rb3duIHN3aXRjaCB1cGxvYWQgdXJsIGFuZCByZXRyeVxuICAgICAgICAgICAgdmFyIHVua25vd19lcnJvcl9yZXRyeSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHJpZXMtLSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJlc2V0VXBsb2FkVXJsKHJldHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zdGF0dXMgPSBwbHVwbG9hZC5RVUVVRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cmllcyA9IHFpbml1VXBsb2FkVXJscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBiaW5kICdFcnJvcicgZXZlbnRcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBlcnIuY29kZSBhbmQgcmV0dXJuIHRoZSBlcnJUaXBcbiAgICAgICAgICAgIHVwbG9hZGVyLmJpbmQoJ0Vycm9yJywgKGZ1bmN0aW9uIChfRXJyb3JfSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodXAsIGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcImVycjogXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3dUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyclRpcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGVyci5maWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcGx1cGxvYWQuRkFJTEVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn5LiK5Lyg5aSx6LSl44CC6K+356iN5ZCO5YaN6K+V44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBwbHVwbG9hZC5GSUxFX1NJWkVfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhfZmlsZV9zaXplID0gdXAuZ2V0T3B0aW9uICYmIHVwLmdldE9wdGlvbignbWF4X2ZpbGVfc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfZmlsZV9zaXplID0gbWF4X2ZpbGVfc2l6ZSB8fCAodXAuc2V0dGluZ3MgJiYgdXAuc2V0dGluZ3MubWF4X2ZpbGVfc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9ICfmtY/op4jlmajmnIDlpKflj6/kuIrkvKAnICsgbWF4X2ZpbGVfc2l6ZSArICfjgILmm7TlpKfmlofku7bor7fkvb/nlKjlkb3ku6TooYzlt6XlhbfjgIInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHBsdXBsb2FkLkZJTEVfRVhURU5TSU9OX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn5paH5Lu26aqM6K+B5aSx6LSl44CC6K+356iN5ZCO6YeN6K+V44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBwbHVwbG9hZC5IVFRQX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLnJlc3BvbnNlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IHBhcnNlSlNPTiBlcnJvciAsd2hlbiBodHRwIGVycm9yIGlzIGxpa2UgbmV0OjpFUlJfQUREUkVTU19VTlJFQUNIQUJMRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gZXJyLm1lc3NhZ2UgfHwgJ+acquefpee9kee7nOmUmeivr+OAgic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVua25vd19lcnJvcl9yZXRyeShmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck9iaiA9IHRoYXQucGFyc2VKU09OKGVyci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclRleHQgPSBlcnJvck9iai5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBcIuivt+axguaKpeaWh+agvOW8j+mUmeivr+OAglwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLlrqLmiLfnq6/orqTor4HmjojmnYPlpLHotKXjgILor7fph43or5XmiJbmj5DkuqTlj43ppojjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9IFwi5a6i5oi356uv6K+35rGC6ZSZ6K+v44CC6K+36YeN6K+V5oiW5o+Q5Lqk5Y+N6aaI44CCXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU3OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBcIui1hOa6kOS4iuS8oOaIkOWKn++8jOS9huWbnuiwg+Wksei0peOAglwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLnvZHnu5zov57mjqXlvILluLjjgILor7fph43or5XmiJbmj5DkuqTlj43ppojjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVua25vd19lcnJvcl9yZXRyeShmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2MTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLmlofku7blt7LlrZjlnKjjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iaiA9IHRoYXQucGFyc2VKU09OKGVycm9yT2JqLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gZXJyb3JPYmouZXJyb3IgfHwgJ2ZpbGUgZXhpc3RzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IGVycm9yT2JqLmVycm9yIHx8ICdmaWxlIGV4aXN0cyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2MzE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLmjIflrprnqbrpl7TkuI3lrZjlnKjjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9IFwi5LiK5Lyg5pWw5o2u5Z2X5qCh6aqM5Ye66ZSZ44CC6K+36YeN6K+V5oiW5o+Q5Lqk5Y+N6aaI44CCXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9IFwi5pyq55+l6ZSZ6K+v44CCXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1bmtub3dfZXJyb3JfcmV0cnkoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBlcnJUaXAgKyAnKCcgKyBlcnIuc3RhdHVzICsgJ++8micgKyBlcnJvclRleHQgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcGx1cGxvYWQuU0VDVVJJVFlfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9ICflronlhajphY3nva7plJnor6/jgILor7fogZTns7vnvZHnq5nnrqHnkIblkZjjgIInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHBsdXBsb2FkLkdFTkVSSUNfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9ICfkuIrkvKDlpLHotKXjgILor7fnqI3lkI7lho3or5XjgIInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHBsdXBsb2FkLklPX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn5LiK5Lyg5aSx6LSl44CC6K+356iN5ZCO5YaN6K+V44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBwbHVwbG9hZC5JTklUX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn572R56uZ6YWN572u6ZSZ6K+v44CC6K+36IGU57O7572R56uZ566h55CG5ZGY44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBlcnIubWVzc2FnZSArIGVyci5kZXRhaWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVua25vd19lcnJvcl9yZXRyeShmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9FcnJvcl9IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX0Vycm9yX0hhbmRsZXIodXAsIGVyciwgZXJyVGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cC5yZWZyZXNoKCk7IC8vIFJlcG9zaXRpb24gRmxhc2gvU2lsdmVybGlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoX0Vycm9yX0hhbmRsZXIpKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBFcnJvciBldmVudFwiKTtcblxuICAgICAgICAgICAgLy8gYmluZCAnRmlsZVVwbG9hZGVkJyBldmVudFxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0IHRoZSBjb21wbGV0ZSBvZiB1cGxvYWRcbiAgICAgICAgICAgIC8vIC0gZ2V0IGRvd250b2tlbiBmcm9tIGRvd250b2tlbl91cmwgaWYgYnVja2V0IGlzIHByaXZhdGVcbiAgICAgICAgICAgIC8vIC0gaW52b2tlIG1rZmlsZSBhcGkgdG8gY29tcG9zZSBjaHVua3MgaWYgdXBsb2FkIHN0cmF0ZWd5IGlzIGNodW5rIHVwbG9hZFxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnRmlsZVVwbG9hZGVkJywgKGZ1bmN0aW9uIChfRmlsZVVwbG9hZGVkX0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHVwLCBmaWxlLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVVcGxvYWRlZCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVVcGxvYWRlZCBmaWxlOiBcIiwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVVcGxvYWRlZCBpbmZvOiBcIiwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3dUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3Rfc3RlcCA9IGZ1bmN0aW9uICh1cCwgZmlsZSwgaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmlsZVVwbG9hZGVkIGxhc3Qgc3RlcDpcIiwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AuZG93bnRva2VuX3VybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wLmRvd29udG9rZW5fdXJsIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgZ2V0IGRvd250b2tlbiBiZWZvcmUgaW52b2tlIHRoZSBfRmlsZVVwbG9hZGVkX0hhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWpheF9kb3dudG9rZW4gPSB0aGF0LmNyZWF0ZUFqYXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4X2Rvd250b2tlbi5vcGVuKCdQT1NUJywgb3AuZG93bnRva2VuX3VybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheF9kb3dudG9rZW4uc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhfZG93bnRva2VuLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXhfZG93bnRva2VuLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhamF4X2Rvd250b2tlbi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNfZG93bnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc19kb3dudG9rZW4gPSB0aGF0LnBhcnNlSlNPTihhamF4X2Rvd250b2tlbi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKCdpbnZhbGlkIGpzb24gZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvX2V4dGVuZGVkID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1cGxvYWQuZXh0ZW5kKGluZm9fZXh0ZW5kZWQsIHRoYXQucGFyc2VKU09OKGluZm8ucmVzcG9uc2UpLCByZXNfZG93bnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnJlc3BvbnNlID0gdGhhdC5zdHJpbmdpZnlKU09OKGluZm9fZXh0ZW5kZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfRmlsZVVwbG9hZGVkX0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX0ZpbGVVcGxvYWRlZF9IYW5kbGVyKHVwLCBmaWxlLCBpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVyLnRyaWdnZXIoJ0Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGFqYXhfZG93bnRva2VuLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGFqYXhfZG93bnRva2VuLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogcGx1cGxvYWQuSFRUUF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4X2Rvd250b2tlbi5zZW5kKCdrZXk9JyArIHRoYXQucGFyc2VKU09OKGluZm8ucmVzcG9uc2UpLmtleSArICcmZG9tYWluPScgKyBvcC5kb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfRmlsZVVwbG9hZGVkX0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfRmlsZVVwbG9hZGVkX0hhbmRsZXIodXAsIGZpbGUsIGluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihpbmZvLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gY3R4ID8gY3R4IDogcmVzLmN0eDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3R4IGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIHRoYXQgbWVhbnMgdGhlIHVwbG9hZCBzdHJhdGVneSBpcyBjaHVuayB1cGxvYWRcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICBiZWZvcmUgdGhlIGludm9rZSB0aGUgbGFzdF9zdGVwXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgd2UgbmVlZCByZXF1ZXN0IHRoZSBta2ZpbGUgdG8gY29tcG9zZSBhbGwgdXBsb2FkZWQgY2h1bmtzXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICBpbnZva2UgdGhlIGxhc3Rfc3RlcFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJjdHg6IFwiLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJzYXZlX2tleTogXCIsIG9wLnNhdmVfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3Auc2F2ZV9rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZXRGaWxlS2V5KHVwLCBmaWxlLCB0aGF0LmtleV9oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkgPyAnL2tleS8nICsgdGhhdC5VUkxTYWZlQmFzZTY0RW5jb2RlKGtleSkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gJy9mbmFtZS8nICsgdGhhdC5VUkxTYWZlQmFzZTY0RW5jb2RlKGZpbGUubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm9wLnhfdmFyczogXCIsIG9wLnhfdmFycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeF92YXJzID0gb3AueF92YXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhfdmFsID0gJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeF92YXJzX3VybCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhfdmFycyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB4X3ZhcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeF9rZXkgaW4geF92YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4X3ZhcnMuaGFzT3duUHJvcGVydHkoeF9rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhfdmFyc1t4X2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4X3ZhbCA9IHRoYXQuVVJMU2FmZUJhc2U2NEVuY29kZSh4X3ZhcnNbeF9rZXldKHVwLCBmaWxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB4X3ZhcnNbeF9rZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhfdmFsID0gdGhhdC5VUkxTYWZlQmFzZTY0RW5jb2RlKHhfdmFyc1t4X2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeF92YXJzX3VybCArPSAnL3g6JyArIHhfa2V5ICsgJy8nICsgeF92YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBxaW5pdVVwbG9hZFVybCArICcvbWtmaWxlLycgKyBmaWxlLnNpemUgKyBrZXkgKyBmbmFtZSArIHhfdmFyc191cmw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZSA9IHRoYXQuZGV0ZWN0SUVWZXJzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWpheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheCA9IG5ldyBtb3hpZS54aHIuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3hpZS5jb3JlLnV0aWxzLkVudi5zd2ZfdXJsID0gb3AuZmxhc2hfc3dmX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheCA9IHRoYXQuY3JlYXRlQWpheCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheC5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFqYXguc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3VwdG9rZW46Jyt0aGF0LnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFqYXguc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsICdVcFRva2VuICcgKyB0aGF0LnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWpheC5yZWFkeVN0YXRlOiBcIiwgYWpheC5yZWFkeVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWpheC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhamF4SW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXguc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogYWpheC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGFqYXgucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczogYWpheC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJta2ZpbGUgaXMgc3VjY2VzczogXCIsIGFqYXhJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Rfc3RlcCh1cCwgZmlsZSwgYWpheEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheEluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBhamF4LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogYWpheC5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAtMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczogYWpheC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm1rZmlsZSBpcyBlcnJvcjogXCIsIGFqYXhJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVyLnRyaWdnZXIoJ0Vycm9yJywgYWpheEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheC5iaW5kKCdyZWFkeXN0YXRlY2hhbmdlJywgb25yZWFkeXN0YXRlY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvbnJlYWR5c3RhdGVjaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4LnNlbmQoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm1rZmlsZTogXCIsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3N0ZXAodXAsIGZpbGUsIGluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKF9GaWxlVXBsb2FkZWRfSGFuZGxlcikpO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJiaW5kIEZpbGVVcGxvYWRlZCBldmVudFwiKTtcblxuICAgICAgICAgICAgLy8gaW5pdCB1cGxvYWRlclxuICAgICAgICAgICAgdXBsb2FkZXIuaW5pdCgpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiaW52b2tlIHVwbG9hZGVyLmluaXQoKVwiKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiaW5pdCB1cGxvYWRlciBlbmRcIik7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHVybCBieSBrZXlcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkgb2YgZmlsZVxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHVybCBvZiBmaWxlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFVybCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gZW5jb2RlVVJJKGtleSk7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gdGhpcy5kb21haW47XG4gICAgICAgICAgICBpZiAoZG9tYWluLnNsaWNlKGRvbWFpbi5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gZG9tYWluICsgJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbiArIGtleTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgUWluaXUgPSBuZXcgUWluaXVKc1NESygpO1xuXG4gICAgZ2xvYmFsLlFpbml1ID0gUWluaXU7XG4gICAgZ2xvYmFsLlFpbml1SnNTREsgPSBRaW5pdUpzU0RLO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFFpbml1SnNTREs7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIHJlZ2lzdGVyIGFzICdxaW5pdS1qcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG4gICAgICAgIGRlZmluZSgncWluaXUtanMnLCBbJy4vcGx1cGxvYWQvbW94aWUuanMnLCcuL3BsdXBsb2FkL3BsdXBsb2FkLmRldi5qcyddLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUWluaXVKc1NESztcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLlFpbml1SnNTREsgPSBRaW5pdUpzU0RLO1xuICAgIH1cbn0pKHdpbmRvdyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9xaW5pdS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9
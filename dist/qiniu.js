/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;var MXI_DEBUG = true;
/**
 * mOxie - multi-runtime File API & XMLHttpRequest L2 Polyfill
 * v1.5.3
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 *
 * Date: 2017-02-02
 */
;(function (global, factory) {
	var extract = function() {
		var ctx = {};
		factory.apply(ctx, arguments);
		return ctx.moxie;
	};
	
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (extract),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === "object" && module.exports) {
		module.exports = extract();
	} else {
		global.moxie = extract();
	}
}(this || window, function() {
/**
 * Compiled inline version. (Library mode)
 */

/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
/*globals $code */

(function(exports, undefined) {
	"use strict";

	var modules = {};

	function require(ids, callback) {
		var module, defs = [];

		for (var i = 0; i < ids.length; ++i) {
			module = modules[ids[i]] || resolve(ids[i]);
			if (!module) {
				throw 'module definition dependecy not found: ' + ids[i];
			}

			defs.push(module);
		}

		callback.apply(null, defs);
	}

	function define(id, dependencies, definition) {
		if (typeof id !== 'string') {
			throw 'invalid module definition, module id must be defined and be a string';
		}

		if (dependencies === undefined) {
			throw 'invalid module definition, dependencies must be specified';
		}

		if (definition === undefined) {
			throw 'invalid module definition, definition function must be specified';
		}

		require(dependencies, function() {
			modules[id] = definition.apply(null, arguments);
		});
	}

	function defined(id) {
		return !!modules[id];
	}

	function resolve(id) {
		var target = exports;
		var fragments = id.split(/[.\/]/);

		for (var fi = 0; fi < fragments.length; ++fi) {
			if (!target[fragments[fi]]) {
				return;
			}

			target = target[fragments[fi]];
		}

		return target;
	}

	function expose(ids) {
		for (var i = 0; i < ids.length; i++) {
			var target = exports;
			var id = ids[i];
			var fragments = id.split(/[.\/]/);

			for (var fi = 0; fi < fragments.length - 1; ++fi) {
				if (target[fragments[fi]] === undefined) {
					target[fragments[fi]] = {};
				}

				target = target[fragments[fi]];
			}

			target[fragments[fragments.length - 1]] = modules[id];
		}
	}

// Included from: src/javascript/core/utils/Basic.js

/**
 * Basic.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/core/utils/Basic
@public
@static
*/
define('moxie/core/utils/Basic', [], function() {
	/**
	Gets the true type of the built-in object (better version of typeof).
	@author Angus Croll (http://javascriptweblog.wordpress.com/)

	@method typeOf
	@for Utils
	@static
	@param {Object} o Object to check.
	@return {String} Object [[Class]]
	*/
	function typeOf(o) {
		var undef;

		if (o === undef) {
			return 'undefined';
		} else if (o === null) {
			return 'null';
		} else if (o.nodeType) {
			return 'node';
		}

		// the snippet below is awesome, however it fails to detect null, undefined and arguments types in IE lte 8
		return ({}).toString.call(o).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
	}

	/**
	Extends the specified object with another object(s).

	@method extend
	@static
	@param {Object} target Object to extend.
	@param {Object} [obj]* Multiple objects to extend with.
	@return {Object} Same as target, the extended object.
	*/
	function extend() {
		return merge(false, false, arguments);
	}


	/**
	Extends the specified object with another object(s), but only if the property exists in the target.

	@method extendIf
	@static
	@param {Object} target Object to extend.
	@param {Object} [obj]* Multiple objects to extend with.
	@return {Object} Same as target, the extended object.
	*/
	function extendIf() {
		return merge(true, false, arguments);
	}


	function extendImmutable() {
		return merge(false, true, arguments);
	}


	function extendImmutableIf() {
		return merge(true, true, arguments);
	}


	function shallowCopy(obj) {
		switch (typeOf(obj)) {
			case 'array':
				return Array.prototype.slice.call(obj);

			case 'object':
				return extend({}, obj);
		}
		return obj;
	}


	function merge(strict, immutable, args) {
		var undef;
		var target = args[0];

		each(args, function(arg, i) {
			if (i > 0) {
				each(arg, function(value, key) {
					var isComplex = inArray(typeOf(value), ['array', 'object']) !== -1;

					if (value === undef || strict && target[key] === undef) {
						return true;
					}

					if (isComplex && immutable) {
						value = shallowCopy(value);
					}

					if (typeOf(target[key]) === typeOf(value) && isComplex) {
						merge(strict, immutable, [target[key], value]);
					} else {
						target[key] = value;
					}
				});
			}
		});

		return target;
	}


	/**
	A way to inherit one `class` from another in a consisstent way (more or less)

	@method inherit
	@static
	@since >1.4.1
	@param {Function} child
	@param {Function} parent
	@return {Function} Prepared constructor
	*/
	function inherit(child, parent) {
		// copy over all parent properties
		for (var key in parent) {
			if ({}.hasOwnProperty.call(parent, key)) {
				child[key] = parent[key];
			}
		}

		// give child `class` a place to define its own methods
		function ctor() {
			this.constructor = child;
		}
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();

		// keep a way to reference parent methods
		child.__parent__ = parent.prototype;
		return child;
	}


	/**
	Executes the callback function for each item in array/object. If you return false in the
	callback it will break the loop.

	@method each
	@static
	@param {Object} obj Object to iterate.
	@param {function} callback Callback function to execute for each item.
	*/
	function each(obj, callback) {
		var length, key, i, undef;

		if (obj) {
			try {
				length = obj.length;
			} catch(ex) {
				length = undef;
			}

			if (length === undef || typeof(length) !== 'number') {
				// Loop object items
				for (key in obj) {
					if (obj.hasOwnProperty(key)) {
						if (callback(obj[key], key) === false) {
							return;
						}
					}
				}
			} else {
				// Loop array items
				for (i = 0; i < length; i++) {
					if (callback(obj[i], i) === false) {
						return;
					}
				}
			}
		}
	}

	/**
	Checks if object is empty.

	@method isEmptyObj
	@static
	@param {Object} o Object to check.
	@return {Boolean}
	*/
	function isEmptyObj(obj) {
		var prop;

		if (!obj || typeOf(obj) !== 'object') {
			return true;
		}

		for (prop in obj) {
			return false;
		}

		return true;
	}

	/**
	Recieve an array of functions (usually async) to call in sequence, each  function
	receives a callback as first argument that it should call, when it completes. Finally,
	after everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the sequence and invoke main callback
	immediately.

	@method inSeries
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of error
	*/
	function inSeries(queue, cb) {
		var i = 0, length = queue.length;

		if (typeOf(cb) !== 'function') {
			cb = function() {};
		}

		if (!queue || !queue.length) {
			cb();
		}

		function callNext(i) {
			if (typeOf(queue[i]) === 'function') {
				queue[i](function(error) {
					/*jshint expr:true */
					++i < length && !error ? callNext(i) : cb(error);
				});
			}
		}
		callNext(i);
	}


	/**
	Recieve an array of functions (usually async) to call in parallel, each  function
	receives a callback as first argument that it should call, when it completes. After
	everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the process and invoke main callback
	immediately.

	@method inParallel
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of erro
	*/
	function inParallel(queue, cb) {
		var count = 0, num = queue.length, cbArgs = new Array(num);

		each(queue, function(fn, i) {
			fn(function(error) {
				if (error) {
					return cb(error);
				}

				var args = [].slice.call(arguments);
				args.shift(); // strip error - undefined or not

				cbArgs[i] = args;
				count++;

				if (count === num) {
					cbArgs.unshift(null);
					cb.apply(this, cbArgs);
				}
			});
		});
	}


	/**
	Find an element in array and return it's index if present, otherwise return -1.

	@method inArray
	@static
	@param {Mixed} needle Element to find
	@param {Array} array
	@return {Int} Index of the element, or -1 if not found
	*/
	function inArray(needle, array) {
		if (array) {
			if (Array.prototype.indexOf) {
				return Array.prototype.indexOf.call(array, needle);
			}

			for (var i = 0, length = array.length; i < length; i++) {
				if (array[i] === needle) {
					return i;
				}
			}
		}
		return -1;
	}


	/**
	Returns elements of first array if they are not present in second. And false - otherwise.

	@private
	@method arrayDiff
	@param {Array} needles
	@param {Array} array
	@return {Array|Boolean}
	*/
	function arrayDiff(needles, array) {
		var diff = [];

		if (typeOf(needles) !== 'array') {
			needles = [needles];
		}

		if (typeOf(array) !== 'array') {
			array = [array];
		}

		for (var i in needles) {
			if (inArray(needles[i], array) === -1) {
				diff.push(needles[i]);
			}
		}
		return diff.length ? diff : false;
	}


	/**
	Find intersection of two arrays.

	@private
	@method arrayIntersect
	@param {Array} array1
	@param {Array} array2
	@return {Array} Intersection of two arrays or null if there is none
	*/
	function arrayIntersect(array1, array2) {
		var result = [];
		each(array1, function(item) {
			if (inArray(item, array2) !== -1) {
				result.push(item);
			}
		});
		return result.length ? result : null;
	}


	/**
	Forces anything into an array.

	@method toArray
	@static
	@param {Object} obj Object with length field.
	@return {Array} Array object containing all items.
	*/
	function toArray(obj) {
		var i, arr = [];

		for (i = 0; i < obj.length; i++) {
			arr[i] = obj[i];
		}

		return arr;
	}


	/**
	Generates an unique ID. The only way a user would be able to get the same ID is if the two persons
	at the same exact millisecond manage to get the same 5 random numbers between 0-65535; it also uses
	a counter so each ID is guaranteed to be unique for the given page. It is more probable for the earth
	to be hit with an asteroid.

	@method guid
	@static
	@param {String} prefix to prepend (by default 'o' will be prepended).
	@method guid
	@return {String} Virtually unique id.
	*/
	var guid = (function() {
		var counter = 0;

		return function(prefix) {
			var guid = new Date().getTime().toString(32), i;

			for (i = 0; i < 5; i++) {
				guid += Math.floor(Math.random() * 65535).toString(32);
			}

			return (prefix || 'o_') + guid + (counter++).toString(32);
		};
	}());


	/**
	Trims white spaces around the string

	@method trim
	@static
	@param {String} str
	@return {String}
	*/
	function trim(str) {
		if (!str) {
			return str;
		}
		return String.prototype.trim ? String.prototype.trim.call(str) : str.toString().replace(/^\s*/, '').replace(/\s*$/, '');
	}


	/**
	Parses the specified size string into a byte value. For example 10kb becomes 10240.

	@method parseSizeStr
	@static
	@param {String/Number} size String to parse or number to just pass through.
	@return {Number} Size in bytes.
	*/
	function parseSizeStr(size) {
		if (typeof(size) !== 'string') {
			return size;
		}

		var muls = {
				t: 1099511627776,
				g: 1073741824,
				m: 1048576,
				k: 1024
			},
			mul;

		size = /^([0-9\.]+)([tmgk]?)$/.exec(size.toLowerCase().replace(/[^0-9\.tmkg]/g, ''));
		mul = size[2];
		size = +size[1];

		if (muls.hasOwnProperty(mul)) {
			size *= muls[mul];
		}
		return Math.floor(size);
	}


	/**
	 * Pseudo sprintf implementation - simple way to replace tokens with specified values.
	 *
	 * @param {String} str String with tokens
	 * @return {String} String with replaced tokens
	 */
	function sprintf(str) {
		var args = [].slice.call(arguments, 1);

		return str.replace(/%[a-z]/g, function() {
			var value = args.shift();
			return typeOf(value) !== 'undefined' ? value : '';
		});
	}



	function delay(cb, timeout) {
		var self = this;
		setTimeout(function() {
			cb.call(self);
		}, timeout || 1);
	}


	return {
		guid: guid,
		typeOf: typeOf,
		extend: extend,
		extendIf: extendIf,
		extendImmutable: extendImmutable,
		extendImmutableIf: extendImmutableIf,
		inherit: inherit,
		each: each,
		isEmptyObj: isEmptyObj,
		inSeries: inSeries,
		inParallel: inParallel,
		inArray: inArray,
		arrayDiff: arrayDiff,
		arrayIntersect: arrayIntersect,
		toArray: toArray,
		trim: trim,
		sprintf: sprintf,
		parseSizeStr: parseSizeStr,
		delay: delay
	};
});

// Included from: src/javascript/core/utils/Encode.js

/**
 * Encode.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Encode', [], function() {

	/**
	@class moxie/core/utils/Encode
	*/

	/**
	Encode string with UTF-8

	@method utf8_encode
	@for Utils
	@static
	@param {String} str String to encode
	@return {String} UTF-8 encoded string
	*/
	var utf8_encode = function(str) {
		return unescape(encodeURIComponent(str));
	};
	
	/**
	Decode UTF-8 encoded string

	@method utf8_decode
	@static
	@param {String} str String to decode
	@return {String} Decoded string
	*/
	var utf8_decode = function(str_data) {
		return decodeURIComponent(escape(str_data));
	};
	
	/**
	Decode Base64 encoded string (uses browser's default method if available),
	from: https://raw.github.com/kvz/phpjs/master/functions/url/base64_decode.js

	@method atob
	@static
	@param {String} data String to decode
	@return {String} Decoded string
	*/
	var atob = function(data, utf8) {
		if (typeof(window.atob) === 'function') {
			return utf8 ? utf8_decode(window.atob(data)) : window.atob(data);
		}

		// http://kevin.vanzonneveld.net
		// +   original by: Tyler Akins (http://rumkin.com)
		// +   improved by: Thunder.m
		// +      input by: Aman Gupta
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   bugfixed by: Onno Marsman
		// +   bugfixed by: Pellentesque Malesuada
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +      input by: Brett Zamir (http://brett-zamir.me)
		// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
		// *     returns 1: 'Kevin van Zonneveld'
		// mozilla has this native
		// - but breaks in 2.0.0.12!
		//if (typeof this.window.atob == 'function') {
		//    return atob(data);
		//}
		var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			dec = "",
			tmp_arr = [];

		if (!data) {
			return data;
		}

		data += '';

		do { // unpack four hexets into three octets using index points in b64
			h1 = b64.indexOf(data.charAt(i++));
			h2 = b64.indexOf(data.charAt(i++));
			h3 = b64.indexOf(data.charAt(i++));
			h4 = b64.indexOf(data.charAt(i++));

			bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

			o1 = bits >> 16 & 0xff;
			o2 = bits >> 8 & 0xff;
			o3 = bits & 0xff;

			if (h3 == 64) {
				tmp_arr[ac++] = String.fromCharCode(o1);
			} else if (h4 == 64) {
				tmp_arr[ac++] = String.fromCharCode(o1, o2);
			} else {
				tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
			}
		} while (i < data.length);

		dec = tmp_arr.join('');

		return utf8 ? utf8_decode(dec) : dec;
	};
	
	/**
	Base64 encode string (uses browser's default method if available),
	from: https://raw.github.com/kvz/phpjs/master/functions/url/base64_encode.js

	@method btoa
	@static
	@param {String} data String to encode
	@return {String} Base64 encoded string
	*/
	var btoa = function(data, utf8) {
		if (utf8) {
			data = utf8_encode(data);
		}

		if (typeof(window.btoa) === 'function') {
			return window.btoa(data);
		}

		// http://kevin.vanzonneveld.net
		// +   original by: Tyler Akins (http://rumkin.com)
		// +   improved by: Bayron Guevara
		// +   improved by: Thunder.m
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   bugfixed by: Pellentesque Malesuada
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   improved by: Rafał Kukawski (http://kukawski.pl)
		// *     example 1: base64_encode('Kevin van Zonneveld');
		// *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
		// mozilla has this native
		// - but breaks in 2.0.0.12!
		var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			enc = "",
			tmp_arr = [];

		if (!data) {
			return data;
		}

		do { // pack three octets into four hexets
			o1 = data.charCodeAt(i++);
			o2 = data.charCodeAt(i++);
			o3 = data.charCodeAt(i++);

			bits = o1 << 16 | o2 << 8 | o3;

			h1 = bits >> 18 & 0x3f;
			h2 = bits >> 12 & 0x3f;
			h3 = bits >> 6 & 0x3f;
			h4 = bits & 0x3f;

			// use hexets to index into b64, and append result to encoded string
			tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
		} while (i < data.length);

		enc = tmp_arr.join('');

		var r = data.length % 3;

		return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
	};


	return {
		utf8_encode: utf8_encode,
		utf8_decode: utf8_decode,
		atob: atob,
		btoa: btoa
	};
});

// Included from: src/javascript/core/utils/Env.js

/**
 * Env.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/utils/Env", [
	"moxie/core/utils/Basic"
], function(Basic) {
	
	/**
	 * UAParser.js v0.7.7
	 * Lightweight JavaScript-based User-Agent string parser
	 * https://github.com/faisalman/ua-parser-js
	 *
	 * Copyright © 2012-2015 Faisal Salman <fyzlman@gmail.com>
	 * Dual licensed under GPLv2 & MIT
	 */
	var UAParser = (function (undefined) {

	    //////////////
	    // Constants
	    /////////////


	    var EMPTY       = '',
	        UNKNOWN     = '?',
	        FUNC_TYPE   = 'function',
	        UNDEF_TYPE  = 'undefined',
	        OBJ_TYPE    = 'object',
	        MAJOR       = 'major',
	        MODEL       = 'model',
	        NAME        = 'name',
	        TYPE        = 'type',
	        VENDOR      = 'vendor',
	        VERSION     = 'version',
	        ARCHITECTURE= 'architecture',
	        CONSOLE     = 'console',
	        MOBILE      = 'mobile',
	        TABLET      = 'tablet';


	    ///////////
	    // Helper
	    //////////


	    var util = {
	        has : function (str1, str2) {
	            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
	        },
	        lowerize : function (str) {
	            return str.toLowerCase();
	        }
	    };


	    ///////////////
	    // Map helper
	    //////////////


	    var mapper = {

	        rgx : function () {

	            // loop through all regexes maps
	            for (var result, i = 0, j, k, p, q, matches, match, args = arguments; i < args.length; i += 2) {

	                var regex = args[i],       // even sequence (0,2,4,..)
	                    props = args[i + 1];   // odd sequence (1,3,5,..)

	                // construct object barebones
	                if (typeof(result) === UNDEF_TYPE) {
	                    result = {};
	                    for (p in props) {
	                        q = props[p];
	                        if (typeof(q) === OBJ_TYPE) {
	                            result[q[0]] = undefined;
	                        } else {
	                            result[q] = undefined;
	                        }
	                    }
	                }

	                // try matching uastring with regexes
	                for (j = k = 0; j < regex.length; j++) {
	                    matches = regex[j].exec(this.getUA());
	                    if (!!matches) {
	                        for (p = 0; p < props.length; p++) {
	                            match = matches[++k];
	                            q = props[p];
	                            // check if given property is actually array
	                            if (typeof(q) === OBJ_TYPE && q.length > 0) {
	                                if (q.length == 2) {
	                                    if (typeof(q[1]) == FUNC_TYPE) {
	                                        // assign modified match
	                                        result[q[0]] = q[1].call(this, match);
	                                    } else {
	                                        // assign given value, ignore regex match
	                                        result[q[0]] = q[1];
	                                    }
	                                } else if (q.length == 3) {
	                                    // check whether function or regex
	                                    if (typeof(q[1]) === FUNC_TYPE && !(q[1].exec && q[1].test)) {
	                                        // call function (usually string mapper)
	                                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
	                                    } else {
	                                        // sanitize match using given regex
	                                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
	                                    }
	                                } else if (q.length == 4) {
	                                        result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
	                                }
	                            } else {
	                                result[q] = match ? match : undefined;
	                            }
	                        }
	                        break;
	                    }
	                }

	                if(!!matches) break; // break the loop immediately if match found
	            }
	            return result;
	        },

	        str : function (str, map) {

	            for (var i in map) {
	                // check if array
	                if (typeof(map[i]) === OBJ_TYPE && map[i].length > 0) {
	                    for (var j = 0; j < map[i].length; j++) {
	                        if (util.has(map[i][j], str)) {
	                            return (i === UNKNOWN) ? undefined : i;
	                        }
	                    }
	                } else if (util.has(map[i], str)) {
	                    return (i === UNKNOWN) ? undefined : i;
	                }
	            }
	            return str;
	        }
	    };


	    ///////////////
	    // String map
	    //////////////


	    var maps = {

	        browser : {
	            oldsafari : {
	                major : {
	                    '1' : ['/8', '/1', '/3'],
	                    '2' : '/4',
	                    '?' : '/'
	                },
	                version : {
	                    '1.0'   : '/8',
	                    '1.2'   : '/1',
	                    '1.3'   : '/3',
	                    '2.0'   : '/412',
	                    '2.0.2' : '/416',
	                    '2.0.3' : '/417',
	                    '2.0.4' : '/419',
	                    '?'     : '/'
	                }
	            }
	        },

	        device : {
	            sprint : {
	                model : {
	                    'Evo Shift 4G' : '7373KT'
	                },
	                vendor : {
	                    'HTC'       : 'APA',
	                    'Sprint'    : 'Sprint'
	                }
	            }
	        },

	        os : {
	            windows : {
	                version : {
	                    'ME'        : '4.90',
	                    'NT 3.11'   : 'NT3.51',
	                    'NT 4.0'    : 'NT4.0',
	                    '2000'      : 'NT 5.0',
	                    'XP'        : ['NT 5.1', 'NT 5.2'],
	                    'Vista'     : 'NT 6.0',
	                    '7'         : 'NT 6.1',
	                    '8'         : 'NT 6.2',
	                    '8.1'       : 'NT 6.3',
	                    'RT'        : 'ARM'
	                }
	            }
	        }
	    };


	    //////////////
	    // Regex map
	    /////////////


	    var regexes = {

	        browser : [[
	        
	            // Presto based
	            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
	            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
	            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
	            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80

	            ], [NAME, VERSION], [

	            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
	            ], [[NAME, 'Opera'], VERSION], [

	            // Mixed
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,
	                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

	            // Trident based
	            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
	                                                                                // Avant/IEMobile/SlimBrowser/Baidu
	            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

	            // Webkit/KHTML based
	            /(rekonq)\/([\w\.]+)*/i,                                            // Rekonq
	            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi)\/([\w\.-]+)/i
	                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron
	            ], [NAME, VERSION], [

	            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
	            ], [[NAME, 'IE'], VERSION], [

	            /(edge)\/((\d+)?[\w\.]+)/i                                          // Microsoft Edge
	            ], [NAME, VERSION], [

	            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
	            ], [[NAME, 'Yandex'], VERSION], [

	            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
	            ], [[NAME, /_/g, ' '], VERSION], [

	            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i,
	                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
	            /(uc\s?browser|qqbrowser)[\/\s]?([\w\.]+)/i
	                                                                                // UCBrowser/QQBrowser
	            ], [NAME, VERSION], [

	            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
	            ], [[NAME, 'Dolphin'], VERSION], [

	            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
	            ], [[NAME, 'Chrome'], VERSION], [

	            /XiaoMi\/MiuiBrowser\/([\w\.]+)/i                                   // MIUI Browser
	            ], [VERSION, [NAME, 'MIUI Browser']], [

	            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)/i         // Android Browser
	            ], [VERSION, [NAME, 'Android Browser']], [

	            /FBAV\/([\w\.]+);/i                                                 // Facebook App for iOS
	            ], [VERSION, [NAME, 'Facebook']], [

	            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
	            ], [VERSION, [NAME, 'Mobile Safari']], [

	            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
	            ], [VERSION, NAME], [

	            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
	            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

	            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
	            /(webkit|khtml)\/([\w\.]+)/i
	            ], [NAME, VERSION], [

	            // Gecko based
	            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
	            ], [[NAME, 'Netscape'], VERSION], [
	            /(swiftfox)/i,                                                      // Swiftfox
	            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
	                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
	            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,
	                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
	            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

	            // Other
	            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf)[\/\s]?([\w\.]+)/i,
	                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf
	            /(links)\s\(([\w\.]+)/i,                                            // Links
	            /(gobrowser)\/?([\w\.]+)*/i,                                        // GoBrowser
	            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
	            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
	            ], [NAME, VERSION]
	        ],

	        engine : [[

	            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
	            ], [VERSION, [NAME, 'EdgeHTML']], [

	            /(presto)\/([\w\.]+)/i,                                             // Presto
	            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
	            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
	            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
	            ], [NAME, VERSION], [

	            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
	            ], [VERSION, NAME]
	        ],

	        os : [[

	            // Windows based
	            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
	            ], [NAME, VERSION], [
	            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
	            /(windows\sphone(?:\sos)*|windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
	            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
	            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
	            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

	            // Mobile/Embedded OS
	            /\((bb)(10);/i                                                      // BlackBerry 10
	            ], [[NAME, 'BlackBerry'], VERSION], [
	            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
	            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
	            /(android|webos|palm\os|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,
	                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
	            /linux;.+(sailfish);/i                                              // Sailfish OS
	            ], [NAME, VERSION], [
	            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
	            ], [[NAME, 'Symbian'], VERSION], [
	            /\((series40);/i                                                    // Series 40
	            ], [NAME], [
	            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
	            ], [[NAME, 'Firefox OS'], VERSION], [

	            // Console
	            /(nintendo|playstation)\s([wids3portablevu]+)/i,                    // Nintendo/Playstation

	            // GNU/Linux based
	            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
	            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
	            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?([\w\.-]+)*/i,
	                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
	                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
	            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
	            /(gnu)\s?([\w\.]+)*/i                                               // GNU
	            ], [NAME, VERSION], [

	            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
	            ], [[NAME, 'Chromium OS'], VERSION],[

	            // Solaris
	            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
	            ], [[NAME, 'Solaris'], VERSION], [

	            // BSD based
	            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
	            ], [NAME, VERSION],[

	            /(ip[honead]+)(?:.*os\s*([\w]+)*\slike\smac|;\sopera)/i             // iOS
	            ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [

	            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i,
	            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
	            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

	            // Other
	            /((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,                            // Solaris
	            /(haiku)\s(\w+)/i,                                                  // Haiku
	            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
	            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
	                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
	            /(unix)\s?([\w\.]+)*/i                                              // UNIX
	            ], [NAME, VERSION]
	        ]
	    };


	    /////////////////
	    // Constructor
	    ////////////////


	    var UAParser = function (uastring) {

	        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);

	        this.getBrowser = function () {
	            return mapper.rgx.apply(this, regexes.browser);
	        };
	        this.getEngine = function () {
	            return mapper.rgx.apply(this, regexes.engine);
	        };
	        this.getOS = function () {
	            return mapper.rgx.apply(this, regexes.os);
	        };
	        this.getResult = function() {
	            return {
	                ua      : this.getUA(),
	                browser : this.getBrowser(),
	                engine  : this.getEngine(),
	                os      : this.getOS()
	            };
	        };
	        this.getUA = function () {
	            return ua;
	        };
	        this.setUA = function (uastring) {
	            ua = uastring;
	            return this;
	        };
	        this.setUA(ua);
	    };

	    return UAParser;
	})();


	function version_compare(v1, v2, operator) {
	  // From: http://phpjs.org/functions
	  // +      original by: Philippe Jausions (http://pear.php.net/user/jausions)
	  // +      original by: Aidan Lister (http://aidanlister.com/)
	  // + reimplemented by: Kankrelune (http://www.webfaktory.info/)
	  // +      improved by: Brett Zamir (http://brett-zamir.me)
	  // +      improved by: Scott Baker
	  // +      improved by: Theriault
	  // *        example 1: version_compare('8.2.5rc', '8.2.5a');
	  // *        returns 1: 1
	  // *        example 2: version_compare('8.2.50', '8.2.52', '<');
	  // *        returns 2: true
	  // *        example 3: version_compare('5.3.0-dev', '5.3.0');
	  // *        returns 3: -1
	  // *        example 4: version_compare('4.1.0.52','4.01.0.51');
	  // *        returns 4: 1

	  // Important: compare must be initialized at 0.
	  var i = 0,
	    x = 0,
	    compare = 0,
	    // vm maps textual PHP versions to negatives so they're less than 0.
	    // PHP currently defines these as CASE-SENSITIVE. It is important to
	    // leave these as negatives so that they can come before numerical versions
	    // and as if no letters were there to begin with.
	    // (1alpha is < 1 and < 1.1 but > 1dev1)
	    // If a non-numerical value can't be mapped to this table, it receives
	    // -7 as its value.
	    vm = {
	      'dev': -6,
	      'alpha': -5,
	      'a': -5,
	      'beta': -4,
	      'b': -4,
	      'RC': -3,
	      'rc': -3,
	      '#': -2,
	      'p': 1,
	      'pl': 1
	    },
	    // This function will be called to prepare each version argument.
	    // It replaces every _, -, and + with a dot.
	    // It surrounds any nonsequence of numbers/dots with dots.
	    // It replaces sequences of dots with a single dot.
	    //    version_compare('4..0', '4.0') == 0
	    // Important: A string of 0 length needs to be converted into a value
	    // even less than an unexisting value in vm (-7), hence [-8].
	    // It's also important to not strip spaces because of this.
	    //   version_compare('', ' ') == 1
	    prepVersion = function (v) {
	      v = ('' + v).replace(/[_\-+]/g, '.');
	      v = v.replace(/([^.\d]+)/g, '.$1.').replace(/\.{2,}/g, '.');
	      return (!v.length ? [-8] : v.split('.'));
	    },
	    // This converts a version component to a number.
	    // Empty component becomes 0.
	    // Non-numerical component becomes a negative number.
	    // Numerical component becomes itself as an integer.
	    numVersion = function (v) {
	      return !v ? 0 : (isNaN(v) ? vm[v] || -7 : parseInt(v, 10));
	    };

	  v1 = prepVersion(v1);
	  v2 = prepVersion(v2);
	  x = Math.max(v1.length, v2.length);
	  for (i = 0; i < x; i++) {
	    if (v1[i] == v2[i]) {
	      continue;
	    }
	    v1[i] = numVersion(v1[i]);
	    v2[i] = numVersion(v2[i]);
	    if (v1[i] < v2[i]) {
	      compare = -1;
	      break;
	    } else if (v1[i] > v2[i]) {
	      compare = 1;
	      break;
	    }
	  }
	  if (!operator) {
	    return compare;
	  }

	  // Important: operator is CASE-SENSITIVE.
	  // "No operator" seems to be treated as "<."
	  // Any other values seem to make the function return null.
	  switch (operator) {
	  case '>':
	  case 'gt':
	    return (compare > 0);
	  case '>=':
	  case 'ge':
	    return (compare >= 0);
	  case '<=':
	  case 'le':
	    return (compare <= 0);
	  case '==':
	  case '=':
	  case 'eq':
	    return (compare === 0);
	  case '<>':
	  case '!=':
	  case 'ne':
	    return (compare !== 0);
	  case '':
	  case '<':
	  case 'lt':
	    return (compare < 0);
	  default:
	    return null;
	  }
	}


	var can = (function() {
		var caps = {
				define_property: (function() {
					/* // currently too much extra code required, not exactly worth it
					try { // as of IE8, getters/setters are supported only on DOM elements
						var obj = {};
						if (Object.defineProperty) {
							Object.defineProperty(obj, 'prop', {
								enumerable: true,
								configurable: true
							});
							return true;
						}
					} catch(ex) {}

					if (Object.prototype.__defineGetter__ && Object.prototype.__defineSetter__) {
						return true;
					}*/
					return false;
				}()),

				create_canvas: (function() {
					// On the S60 and BB Storm, getContext exists, but always returns undefined
					// so we actually have to call getContext() to verify
					// github.com/Modernizr/Modernizr/issues/issue/97/
					var el = document.createElement('canvas');
					return !!(el.getContext && el.getContext('2d'));
				}()),

				return_response_type: function(responseType) {
					try {
						if (Basic.inArray(responseType, ['', 'text', 'document']) !== -1) {
							return true;
						} else if (window.XMLHttpRequest) {
							var xhr = new XMLHttpRequest();
							xhr.open('get', '/'); // otherwise Gecko throws an exception
							if ('responseType' in xhr) {
								xhr.responseType = responseType;
								// as of 23.0.1271.64, Chrome switched from throwing exception to merely logging it to the console (why? o why?)
								if (xhr.responseType !== responseType) {
									return false;
								}
								return true;
							}
						}
					} catch (ex) {}
					return false;
				},

				// ideas for this heavily come from Modernizr (http://modernizr.com/)
				use_data_uri: (function() {
					var du = new Image();

					du.onload = function() {
						caps.use_data_uri = (du.width === 1 && du.height === 1);
					};
					
					setTimeout(function() {
						du.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP8AAAAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==";
					}, 1);
					return false;
				}()),

				use_data_uri_over32kb: function() { // IE8
					return caps.use_data_uri && (Env.browser !== 'IE' || Env.version >= 9);
				},

				use_data_uri_of: function(bytes) {
					return (caps.use_data_uri && bytes < 33000 || caps.use_data_uri_over32kb());
				},

				use_fileinput: function() {
					if (navigator.userAgent.match(/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\/(1.0|2.0|2.5|3.0))/)) {
						return false;
					}

					var el = document.createElement('input');
					el.setAttribute('type', 'file');
					return !el.disabled;
				}
			};

		return function(cap) {
			var args = [].slice.call(arguments);
			args.shift(); // shift of cap
			return Basic.typeOf(caps[cap]) === 'function' ? caps[cap].apply(this, args) : !!caps[cap];
		};
	}());


	var uaResult = new UAParser().getResult();


	var Env = {
		can: can,

		uaParser: UAParser,
		
		browser: uaResult.browser.name,
		version: uaResult.browser.version,
		os: uaResult.os.name, // everybody intuitively types it in a lowercase for some reason
		osVersion: uaResult.os.version,

		verComp: version_compare,
		
		swf_url: "../flash/Moxie.swf",
		xap_url: "../silverlight/Moxie.xap",
		global_event_dispatcher: "moxie.core.EventTarget.instance.dispatchEvent"
	};

	// for backward compatibility
	// @deprecated Use `Env.os` instead
	Env.OS = Env.os;

	if (MXI_DEBUG) {
		Env.debug = {
			runtime: true,
			events: false
		};

		Env.log = function() {
			
			function logObj(data) {
				// TODO: this should recursively print out the object in a pretty way
				console.appendChild(document.createTextNode(data + "\n"));
			}

			var data = arguments[0];

			if (Basic.typeOf(data) === 'string') {
				data = Basic.sprintf.apply(this, arguments);
			}

			if (window && window.console && window.console.log) {
				window.console.log(data);
			} else if (document) {
				var console = document.getElementById('moxie-console');
				if (!console) {
					console = document.createElement('pre');
					console.id = 'moxie-console';
					//console.style.display = 'none';
					document.body.appendChild(console);
				}

				if (Basic.inArray(Basic.typeOf(data), ['object', 'array']) !== -1) {
					logObj(data);
				} else {
					console.appendChild(document.createTextNode(data + "\n"));
				}
			}
		};
	}

	return Env;
});

// Included from: src/javascript/core/Exceptions.js

/**
 * Exceptions.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/Exceptions', [
	'moxie/core/utils/Basic'
], function(Basic) {
	
	function _findKey(obj, value) {
		var key;
		for (key in obj) {
			if (obj[key] === value) {
				return key;
			}
		}
		return null;
	}

	/**
	@class moxie/core/Exception
	*/
	return {
		RuntimeError: (function() {
			var namecodes = {
				NOT_INIT_ERR: 1,
				EXCEPTION_ERR: 3,
				NOT_SUPPORTED_ERR: 9,
				JS_ERR: 4
			};

			function RuntimeError(code, message) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + (message || ": RuntimeError " + this.code);
			}
			
			Basic.extend(RuntimeError, namecodes);
			RuntimeError.prototype = Error.prototype;
			return RuntimeError;
		}()),
		
		OperationNotAllowedException: (function() {
			
			function OperationNotAllowedException(code) {
				this.code = code;
				this.name = 'OperationNotAllowedException';
			}
			
			Basic.extend(OperationNotAllowedException, {
				NOT_ALLOWED_ERR: 1
			});
			
			OperationNotAllowedException.prototype = Error.prototype;
			
			return OperationNotAllowedException;
		}()),

		ImageError: (function() {
			var namecodes = {
				WRONG_FORMAT: 1,
				MAX_RESOLUTION_ERR: 2,
				INVALID_META_ERR: 3
			};

			function ImageError(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": ImageError " + this.code;
			}
			
			Basic.extend(ImageError, namecodes);
			ImageError.prototype = Error.prototype;

			return ImageError;
		}()),

		FileException: (function() {
			var namecodes = {
				NOT_FOUND_ERR: 1,
				SECURITY_ERR: 2,
				ABORT_ERR: 3,
				NOT_READABLE_ERR: 4,
				ENCODING_ERR: 5,
				NO_MODIFICATION_ALLOWED_ERR: 6,
				INVALID_STATE_ERR: 7,
				SYNTAX_ERR: 8
			};

			function FileException(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": FileException " + this.code;
			}
			
			Basic.extend(FileException, namecodes);
			FileException.prototype = Error.prototype;
			return FileException;
		}()),
		
		DOMException: (function() {
			var namecodes = {
				INDEX_SIZE_ERR: 1,
				DOMSTRING_SIZE_ERR: 2,
				HIERARCHY_REQUEST_ERR: 3,
				WRONG_DOCUMENT_ERR: 4,
				INVALID_CHARACTER_ERR: 5,
				NO_DATA_ALLOWED_ERR: 6,
				NO_MODIFICATION_ALLOWED_ERR: 7,
				NOT_FOUND_ERR: 8,
				NOT_SUPPORTED_ERR: 9,
				INUSE_ATTRIBUTE_ERR: 10,
				INVALID_STATE_ERR: 11,
				SYNTAX_ERR: 12,
				INVALID_MODIFICATION_ERR: 13,
				NAMESPACE_ERR: 14,
				INVALID_ACCESS_ERR: 15,
				VALIDATION_ERR: 16,
				TYPE_MISMATCH_ERR: 17,
				SECURITY_ERR: 18,
				NETWORK_ERR: 19,
				ABORT_ERR: 20,
				URL_MISMATCH_ERR: 21,
				QUOTA_EXCEEDED_ERR: 22,
				TIMEOUT_ERR: 23,
				INVALID_NODE_TYPE_ERR: 24,
				DATA_CLONE_ERR: 25
			};

			function DOMException(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": DOMException " + this.code;
			}
			
			Basic.extend(DOMException, namecodes);
			DOMException.prototype = Error.prototype;
			return DOMException;
		}()),
		
		EventException: (function() {
			function EventException(code) {
				this.code = code;
				this.name = 'EventException';
			}
			
			Basic.extend(EventException, {
				UNSPECIFIED_EVENT_TYPE_ERR: 0
			});
			
			EventException.prototype = Error.prototype;
			
			return EventException;
		}())
	};
});

// Included from: src/javascript/core/utils/Dom.js

/**
 * Dom.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Dom', ['moxie/core/utils/Env'], function(Env) {

	/**
	Get DOM Element by it's id.

	@method get
	@for Utils
	@param {String} id Identifier of the DOM Element
	@return {DOMElement}
	*/
	var get = function(id) {
		if (typeof id !== 'string') {
			return id;
		}
		return document.getElementById(id);
	};

	/**
	Checks if specified DOM element has specified class.

	@method hasClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var hasClass = function(obj, name) {
		if (!obj.className) {
			return false;
		}

		var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");
		return regExp.test(obj.className);
	};

	/**
	Adds specified className to specified DOM element.

	@method addClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var addClass = function(obj, name) {
		if (!hasClass(obj, name)) {
			obj.className = !obj.className ? name : obj.className.replace(/\s+$/, '') + ' ' + name;
		}
	};

	/**
	Removes specified className from specified DOM element.

	@method removeClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var removeClass = function(obj, name) {
		if (obj.className) {
			var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");
			obj.className = obj.className.replace(regExp, function($0, $1, $2) {
				return $1 === ' ' && $2 === ' ' ? ' ' : '';
			});
		}
	};

	/**
	Returns a given computed style of a DOM element.

	@method getStyle
	@static
	@param {Object} obj DOM element like object.
	@param {String} name Style you want to get from the DOM element
	*/
	var getStyle = function(obj, name) {
		if (obj.currentStyle) {
			return obj.currentStyle[name];
		} else if (window.getComputedStyle) {
			return window.getComputedStyle(obj, null)[name];
		}
	};


	/**
	Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.

	@method getPos
	@static
	@param {Element} node HTML element or element id to get x, y position from.
	@param {Element} root Optional root element to stop calculations at.
	@return {object} Absolute position of the specified element object with x, y fields.
	*/
	var getPos = function(node, root) {
		var x = 0, y = 0, parent, doc = document, nodeRect, rootRect;

		node = node;
		root = root || doc.body;

		// Returns the x, y cordinate for an element on IE 6 and IE 7
		function getIEPos(node) {
			var bodyElm, rect, x = 0, y = 0;

			if (node) {
				rect = node.getBoundingClientRect();
				bodyElm = doc.compatMode === "CSS1Compat" ? doc.documentElement : doc.body;
				x = rect.left + bodyElm.scrollLeft;
				y = rect.top + bodyElm.scrollTop;
			}

			return {
				x : x,
				y : y
			};
		}

		// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode
		if (node && node.getBoundingClientRect && Env.browser === 'IE' && (!doc.documentMode || doc.documentMode < 8)) {
			nodeRect = getIEPos(node);
			rootRect = getIEPos(root);

			return {
				x : nodeRect.x - rootRect.x,
				y : nodeRect.y - rootRect.y
			};
		}

		parent = node;
		while (parent && parent != root && parent.nodeType) {
			x += parent.offsetLeft || 0;
			y += parent.offsetTop || 0;
			parent = parent.offsetParent;
		}

		parent = node.parentNode;
		while (parent && parent != root && parent.nodeType) {
			x -= parent.scrollLeft || 0;
			y -= parent.scrollTop || 0;
			parent = parent.parentNode;
		}

		return {
			x : x,
			y : y
		};
	};

	/**
	Returns the size of the specified node in pixels.

	@method getSize
	@static
	@param {Node} node Node to get the size of.
	@return {Object} Object with a w and h property.
	*/
	var getSize = function(node) {
		return {
			w : node.offsetWidth || node.clientWidth,
			h : node.offsetHeight || node.clientHeight
		};
	};

	return {
		get: get,
		hasClass: hasClass,
		addClass: addClass,
		removeClass: removeClass,
		getStyle: getStyle,
		getPos: getPos,
		getSize: getSize
	};
});

// Included from: src/javascript/core/EventTarget.js

/**
 * EventTarget.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/EventTarget', [
	'moxie/core/utils/Env',
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic'
], function(Env, x, Basic) {

	// hash of event listeners by object uid
	var eventpool = {};

	/**
	Parent object for all event dispatching components and objects

	@class moxie/core/EventTarget
	@constructor EventTarget
	*/
	function EventTarget() {
		/**
		Unique id of the event dispatcher, usually overriden by children

		@property uid
		@type String
		*/
		this.uid = Basic.guid();
	}


	Basic.extend(EventTarget.prototype, {

		/**
		Can be called from within a child  in order to acquire uniqie id in automated manner

		@method init
		*/
		init: function() {
			if (!this.uid) {
				this.uid = Basic.guid('uid_');
			}
		},

		/**
		Register a handler to a specific event dispatched by the object

		@method addEventListener
		@param {String} type Type or basically a name of the event to subscribe to
		@param {Function} fn Callback function that will be called when event happens
		@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first
		@param {Object} [scope=this] A scope to invoke event handler in
		*/
		addEventListener: function(type, fn, priority, scope) {
			var self = this, list;

			// without uid no event handlers can be added, so make sure we got one
			if (!this.hasOwnProperty('uid')) {
				this.uid = Basic.guid('uid_');
			}

			type = Basic.trim(type);

			if (/\s/.test(type)) {
				// multiple event types were passed for one handler
				Basic.each(type.split(/\s+/), function(type) {
					self.addEventListener(type, fn, priority, scope);
				});
				return;
			}

			type = type.toLowerCase();
			priority = parseInt(priority, 10) || 0;

			list = eventpool[this.uid] && eventpool[this.uid][type] || [];
			list.push({fn : fn, priority : priority, scope : scope || this});

			if (!eventpool[this.uid]) {
				eventpool[this.uid] = {};
			}
			eventpool[this.uid][type] = list;
		},

		/**
		Check if any handlers were registered to the specified event

		@method hasEventListener
		@param {String} [type] Type or basically a name of the event to check
		@return {Mixed} Returns a handler if it was found and false, if - not
		*/
		hasEventListener: function(type) {
			var list;
			if (type) {
				type = type.toLowerCase();
				list = eventpool[this.uid] && eventpool[this.uid][type];
			} else {
				list = eventpool[this.uid];
			}
			return list ? list : false;
		},

		/**
		Unregister the handler from the event, or if former was not specified - unregister all handlers

		@method removeEventListener
		@param {String} type Type or basically a name of the event
		@param {Function} [fn] Handler to unregister
		*/
		removeEventListener: function(type, fn) {
			var self = this, list, i;

			type = type.toLowerCase();

			if (/\s/.test(type)) {
				// multiple event types were passed for one handler
				Basic.each(type.split(/\s+/), function(type) {
					self.removeEventListener(type, fn);
				});
				return;
			}

			list = eventpool[this.uid] && eventpool[this.uid][type];

			if (list) {
				if (fn) {
					for (i = list.length - 1; i >= 0; i--) {
						if (list[i].fn === fn) {
							list.splice(i, 1);
							break;
						}
					}
				} else {
					list = [];
				}

				// delete event list if it has become empty
				if (!list.length) {
					delete eventpool[this.uid][type];

					// and object specific entry in a hash if it has no more listeners attached
					if (Basic.isEmptyObj(eventpool[this.uid])) {
						delete eventpool[this.uid];
					}
				}
			}
		},

		/**
		Remove all event handlers from the object

		@method removeAllEventListeners
		*/
		removeAllEventListeners: function() {
			if (eventpool[this.uid]) {
				delete eventpool[this.uid];
			}
		},

		/**
		Dispatch the event

		@method dispatchEvent
		@param {String/Object} Type of event or event object to dispatch
		@param {Mixed} [...] Variable number of arguments to be passed to a handlers
		@return {Boolean} true by default and false if any handler returned false
		*/
		dispatchEvent: function(type) {
			var uid, list, args, tmpEvt, evt = {}, result = true, undef;

			if (Basic.typeOf(type) !== 'string') {
				// we can't use original object directly (because of Silverlight)
				tmpEvt = type;

				if (Basic.typeOf(tmpEvt.type) === 'string') {
					type = tmpEvt.type;

					if (tmpEvt.total !== undef && tmpEvt.loaded !== undef) { // progress event
						evt.total = tmpEvt.total;
						evt.loaded = tmpEvt.loaded;
					}
					evt.async = tmpEvt.async || false;
				} else {
					throw new x.EventException(x.EventException.UNSPECIFIED_EVENT_TYPE_ERR);
				}
			}

			// check if event is meant to be dispatched on an object having specific uid
			if (type.indexOf('::') !== -1) {
				(function(arr) {
					uid = arr[0];
					type = arr[1];
				}(type.split('::')));
			} else {
				uid = this.uid;
			}

			type = type.toLowerCase();

			list = eventpool[uid] && eventpool[uid][type];

			if (list) {
				// sort event list by prority
				list.sort(function(a, b) { return b.priority - a.priority; });

				args = [].slice.call(arguments);

				// first argument will be pseudo-event object
				args.shift();
				evt.type = type;
				args.unshift(evt);

				if (MXI_DEBUG && Env.debug.events) {
					Env.log("Event '%s' fired on %u", evt.type, uid);
				}

				// Dispatch event to all listeners
				var queue = [];
				Basic.each(list, function(handler) {
					// explicitly set the target, otherwise events fired from shims do not get it
					args[0].target = handler.scope;
					// if event is marked as async, detach the handler
					if (evt.async) {
						queue.push(function(cb) {
							setTimeout(function() {
								cb(handler.fn.apply(handler.scope, args) === false);
							}, 1);
						});
					} else {
						queue.push(function(cb) {
							cb(handler.fn.apply(handler.scope, args) === false); // if handler returns false stop propagation
						});
					}
				});
				if (queue.length) {
					Basic.inSeries(queue, function(err) {
						result = !err;
					});
				}
			}
			return result;
		},

		/**
		Register a handler to the event type that will run only once

		@method bindOnce
		@since >1.4.1
		@param {String} type Type or basically a name of the event to subscribe to
		@param {Function} fn Callback function that will be called when event happens
		@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first
		@param {Object} [scope=this] A scope to invoke event handler in
		*/
		bindOnce: function(type, fn, priority, scope) {
			var self = this;
			self.bind.call(this, type, function cb() {
				self.unbind(type, cb);
				return fn.apply(this, arguments);
			}, priority, scope);
		},

		/**
		Alias for addEventListener

		@method bind
		@protected
		*/
		bind: function() {
			this.addEventListener.apply(this, arguments);
		},

		/**
		Alias for removeEventListener

		@method unbind
		@protected
		*/
		unbind: function() {
			this.removeEventListener.apply(this, arguments);
		},

		/**
		Alias for removeAllEventListeners

		@method unbindAll
		@protected
		*/
		unbindAll: function() {
			this.removeAllEventListeners.apply(this, arguments);
		},

		/**
		Alias for dispatchEvent

		@method trigger
		@protected
		*/
		trigger: function() {
			return this.dispatchEvent.apply(this, arguments);
		},


		/**
		Handle properties of on[event] type.

		@method handleEventProps
		@private
		*/
		handleEventProps: function(dispatches) {
			var self = this;

			this.bind(dispatches.join(' '), function(e) {
				var prop = 'on' + e.type.toLowerCase();
				if (Basic.typeOf(this[prop]) === 'function') {
					this[prop].apply(this, arguments);
				}
			});

			// object must have defined event properties, even if it doesn't make use of them
			Basic.each(dispatches, function(prop) {
				prop = 'on' + prop.toLowerCase(prop);
				if (Basic.typeOf(self[prop]) === 'undefined') {
					self[prop] = null;
				}
			});
		}

	});


	EventTarget.instance = new EventTarget();

	return EventTarget;
});

// Included from: src/javascript/runtime/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/Runtime', [
	"moxie/core/utils/Env",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/EventTarget"
], function(Env, Basic, Dom, EventTarget) {
	var runtimeConstructors = {}, runtimes = {};

	/**
	Common set of methods and properties for every runtime instance

	@class moxie/runtime/Runtime

	@param {Object} options
	@param {String} type Sanitized name of the runtime
	@param {Object} [caps] Set of capabilities that differentiate specified runtime
	@param {Object} [modeCaps] Set of capabilities that do require specific operational mode
	@param {String} [preferredMode='browser'] Preferred operational mode to choose if no required capabilities were requested
	*/
	function Runtime(options, type, caps, modeCaps, preferredMode) {
		/**
		Dispatched when runtime is initialized and ready.
		Results in RuntimeInit on a connected component.

		@event Init
		*/

		/**
		Dispatched when runtime fails to initialize.
		Results in RuntimeError on a connected component.

		@event Error
		*/

		var self = this
		, _shim
		, _uid = Basic.guid(type + '_')
		, defaultMode = preferredMode || 'browser'
		;

		options = options || {};

		// register runtime in private hash
		runtimes[_uid] = this;

		/**
		Default set of capabilities, which can be redifined later by specific runtime

		@private
		@property caps
		@type Object
		*/
		caps = Basic.extend({
			// Runtime can: 
			// provide access to raw binary data of the file
			access_binary: false,
			// provide access to raw binary data of the image (image extension is optional) 
			access_image_binary: false,
			// display binary data as thumbs for example
			display_media: false,
			// make cross-domain requests
			do_cors: false,
			// accept files dragged and dropped from the desktop
			drag_and_drop: false,
			// filter files in selection dialog by their extensions
			filter_by_extension: true,
			// resize image (and manipulate it raw data of any file in general)
			resize_image: false,
			// periodically report how many bytes of total in the file were uploaded (loaded)
			report_upload_progress: false,
			// provide access to the headers of http response 
			return_response_headers: false,
			// support response of specific type, which should be passed as an argument
			// e.g. runtime.can('return_response_type', 'blob')
			return_response_type: false,
			// return http status code of the response
			return_status_code: true,
			// send custom http header with the request
			send_custom_headers: false,
			// pick up the files from a dialog
			select_file: false,
			// select whole folder in file browse dialog
			select_folder: false,
			// select multiple files at once in file browse dialog
			select_multiple: true,
			// send raw binary data, that is generated after image resizing or manipulation of other kind
			send_binary_string: false,
			// send cookies with http request and therefore retain session
			send_browser_cookies: true,
			// send data formatted as multipart/form-data
			send_multipart: true,
			// slice the file or blob to smaller parts
			slice_blob: false,
			// upload file without preloading it to memory, stream it out directly from disk
			stream_upload: false,
			// programmatically trigger file browse dialog
			summon_file_dialog: false,
			// upload file of specific size, size should be passed as argument
			// e.g. runtime.can('upload_filesize', '500mb')
			upload_filesize: true,
			// initiate http request with specific http method, method should be passed as argument
			// e.g. runtime.can('use_http_method', 'put')
			use_http_method: true
		}, caps);
			
	
		// default to the mode that is compatible with preferred caps
		if (options.preferred_caps) {
			defaultMode = Runtime.getMode(modeCaps, options.preferred_caps, defaultMode);
		}

		if (MXI_DEBUG && Env.debug.runtime) {
			Env.log("\tdefault mode: %s", defaultMode);	
		}
		
		// small extension factory here (is meant to be extended with actual extensions constructors)
		_shim = (function() {
			var objpool = {};
			return {
				exec: function(uid, comp, fn, args) {
					if (_shim[comp]) {
						if (!objpool[uid]) {
							objpool[uid] = {
								context: this,
								instance: new _shim[comp]()
							};
						}
						if (objpool[uid].instance[fn]) {
							return objpool[uid].instance[fn].apply(this, args);
						}
					}
				},

				removeInstance: function(uid) {
					delete objpool[uid];
				},

				removeAllInstances: function() {
					var self = this;
					Basic.each(objpool, function(obj, uid) {
						if (Basic.typeOf(obj.instance.destroy) === 'function') {
							obj.instance.destroy.call(obj.context);
						}
						self.removeInstance(uid);
					});
				}
			};
		}());


		// public methods
		Basic.extend(this, {
			/**
			Specifies whether runtime instance was initialized or not

			@property initialized
			@type {Boolean}
			@default false
			*/
			initialized: false, // shims require this flag to stop initialization retries

			/**
			Unique ID of the runtime

			@property uid
			@type {String}
			*/
			uid: _uid,

			/**
			Runtime type (e.g. flash, html5, etc)

			@property type
			@type {String}
			*/
			type: type,

			/**
			Runtime (not native one) may operate in browser or client mode.

			@property mode
			@private
			@type {String|Boolean} current mode or false, if none possible
			*/
			mode: Runtime.getMode(modeCaps, (options.required_caps), defaultMode),

			/**
			id of the DOM container for the runtime (if available)

			@property shimid
			@type {String}
			*/
			shimid: _uid + '_container',

			/**
			Number of connected clients. If equal to zero, runtime can be destroyed

			@property clients
			@type {Number}
			*/
			clients: 0,

			/**
			Runtime initialization options

			@property options
			@type {Object}
			*/
			options: options,

			/**
			Checks if the runtime has specific capability

			@method can
			@param {String} cap Name of capability to check
			@param {Mixed} [value] If passed, capability should somehow correlate to the value
			@param {Object} [refCaps] Set of capabilities to check the specified cap against (defaults to internal set)
			@return {Boolean} true if runtime has such capability and false, if - not
			*/
			can: function(cap, value) {
				var refCaps = arguments[2] || caps;

				// if cap var is a comma-separated list of caps, convert it to object (key/value)
				if (Basic.typeOf(cap) === 'string' && Basic.typeOf(value) === 'undefined') {
					cap = Runtime.parseCaps(cap);
				}

				if (Basic.typeOf(cap) === 'object') {
					for (var key in cap) {
						if (!this.can(key, cap[key], refCaps)) {
							return false;
						}
					}
					return true;
				}

				// check the individual cap
				if (Basic.typeOf(refCaps[cap]) === 'function') {
					return refCaps[cap].call(this, value);
				} else {
					return (value === refCaps[cap]);
				}
			},

			/**
			Returns container for the runtime as DOM element

			@method getShimContainer
			@return {DOMElement}
			*/
			getShimContainer: function() {
				var container, shimContainer = Dom.get(this.shimid);

				// if no container for shim, create one
				if (!shimContainer) {
					container = Dom.get(this.options.container) || document.body;

					// create shim container and insert it at an absolute position into the outer container
					shimContainer = document.createElement('div');
					shimContainer.id = this.shimid;
					shimContainer.className = 'moxie-shim moxie-shim-' + this.type;

					Basic.extend(shimContainer.style, {
						position: 'absolute',
						top: '0px',
						left: '0px',
						width: '1px',
						height: '1px',
						overflow: 'hidden'
					});

					container.appendChild(shimContainer);
					container = null;
				}

				return shimContainer;
			},

			/**
			Returns runtime as DOM element (if appropriate)

			@method getShim
			@return {DOMElement}
			*/
			getShim: function() {
				return _shim;
			},

			/**
			Invokes a method within the runtime itself (might differ across the runtimes)

			@method shimExec
			@param {Mixed} []
			@protected
			@return {Mixed} Depends on the action and component
			*/
			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return self.getShim().exec.call(this, this.uid, component, action, args);
			},

			/**
			Operaional interface that is used by components to invoke specific actions on the runtime
			(is invoked in the scope of component)

			@method exec
			@param {Mixed} []*
			@protected
			@return {Mixed} Depends on the action and component
			*/
			exec: function(component, action) { // this is called in the context of component, not runtime
				var args = [].slice.call(arguments, 2);

				if (self[component] && self[component][action]) {
					return self[component][action].apply(this, args);
				}
				return self.shimExec.apply(this, arguments);
			},

			/**
			Destroys the runtime (removes all events and deletes DOM structures)

			@method destroy
			*/
			destroy: function() {
				if (!self) {
					return; // obviously already destroyed
				}

				var shimContainer = Dom.get(this.shimid);
				if (shimContainer) {
					shimContainer.parentNode.removeChild(shimContainer);
				}

				if (_shim) {
					_shim.removeAllInstances();
				}

				this.unbindAll();
				delete runtimes[this.uid];
				this.uid = null; // mark this runtime as destroyed
				_uid = self = _shim = shimContainer = null;
			}
		});

		// once we got the mode, test against all caps
		if (this.mode && options.required_caps && !this.can(options.required_caps)) {
			this.mode = false;
		}	
	}


	/**
	Default order to try different runtime types

	@property order
	@type String
	@static
	*/
	Runtime.order = 'html5,flash,silverlight,html4';


	/**
	Retrieves runtime from private hash by it's uid

	@method getRuntime
	@private
	@static
	@param {String} uid Unique identifier of the runtime
	@return {Runtime|Boolean} Returns runtime, if it exists and false, if - not
	*/
	Runtime.getRuntime = function(uid) {
		return runtimes[uid] ? runtimes[uid] : false;
	};


	/**
	Register constructor for the Runtime of new (or perhaps modified) type

	@method addConstructor
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@param {Function} construct Constructor for the Runtime type
	*/
	Runtime.addConstructor = function(type, constructor) {
		constructor.prototype = EventTarget.instance;
		runtimeConstructors[type] = constructor;
	};


	/**
	Get the constructor for the specified type.

	method getConstructor
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@return {Function} Constructor for the Runtime type
	*/
	Runtime.getConstructor = function(type) {
		return runtimeConstructors[type] || null;
	};


	/**
	Get info about the runtime (uid, type, capabilities)

	@method getInfo
	@static
	@param {String} uid Unique identifier of the runtime
	@return {Mixed} Info object or null if runtime doesn't exist
	*/
	Runtime.getInfo = function(uid) {
		var runtime = Runtime.getRuntime(uid);

		if (runtime) {
			return {
				uid: runtime.uid,
				type: runtime.type,
				mode: runtime.mode,
				can: function() {
					return runtime.can.apply(runtime, arguments);
				}
			};
		}
		return null;
	};


	/**
	Convert caps represented by a comma-separated string to the object representation.

	@method parseCaps
	@static
	@param {String} capStr Comma-separated list of capabilities
	@return {Object}
	*/
	Runtime.parseCaps = function(capStr) {
		var capObj = {};

		if (Basic.typeOf(capStr) !== 'string') {
			return capStr || {};
		}

		Basic.each(capStr.split(','), function(key) {
			capObj[key] = true; // we assume it to be - true
		});

		return capObj;
	};

	/**
	Test the specified runtime for specific capabilities.

	@method can
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@param {String|Object} caps Set of capabilities to check
	@return {Boolean} Result of the test
	*/
	Runtime.can = function(type, caps) {
		var runtime
		, constructor = Runtime.getConstructor(type)
		, mode
		;
		if (constructor) {
			runtime = new constructor({
				required_caps: caps
			});
			mode = runtime.mode;
			runtime.destroy();
			return !!mode;
		}
		return false;
	};


	/**
	Figure out a runtime that supports specified capabilities.

	@method thatCan
	@static
	@param {String|Object} caps Set of capabilities to check
	@param {String} [runtimeOrder] Comma-separated list of runtimes to check against
	@return {String} Usable runtime identifier or null
	*/
	Runtime.thatCan = function(caps, runtimeOrder) {
		var types = (runtimeOrder || Runtime.order).split(/\s*,\s*/);
		for (var i in types) {
			if (Runtime.can(types[i], caps)) {
				return types[i];
			}
		}
		return null;
	};


	/**
	Figure out an operational mode for the specified set of capabilities.

	@method getMode
	@static
	@param {Object} modeCaps Set of capabilities that depend on particular runtime mode
	@param {Object} [requiredCaps] Supplied set of capabilities to find operational mode for
	@param {String|Boolean} [defaultMode='browser'] Default mode to use 
	@return {String|Boolean} Compatible operational mode
	*/
	Runtime.getMode = function(modeCaps, requiredCaps, defaultMode) {
		var mode = null;

		if (Basic.typeOf(defaultMode) === 'undefined') { // only if not specified
			defaultMode = 'browser';
		}

		if (requiredCaps && !Basic.isEmptyObj(modeCaps)) {
			// loop over required caps and check if they do require the same mode
			Basic.each(requiredCaps, function(value, cap) {
				if (modeCaps.hasOwnProperty(cap)) {
					var capMode = modeCaps[cap](value);

					// make sure we always have an array
					if (typeof(capMode) === 'string') {
						capMode = [capMode];
					}
					
					if (!mode) {
						mode = capMode;						
					} else if (!(mode = Basic.arrayIntersect(mode, capMode))) {
						// if cap requires conflicting mode - runtime cannot fulfill required caps

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("\t\t%c: %v (conflicting mode requested: %s)", cap, value, capMode);	
						}

						return (mode = false);
					}					
				}

				if (MXI_DEBUG && Env.debug.runtime) {
					Env.log("\t\t%c: %v (compatible modes: %s)", cap, value, mode);	
				}
			});

			if (mode) {
				return Basic.inArray(defaultMode, mode) !== -1 ? defaultMode : mode[0];
			} else if (mode === false) {
				return false;
			}
		}
		return defaultMode; 
	};


	/**
	Capability check that always returns true

	@private
	@static
	@return {True}
	*/
	Runtime.capTrue = function() {
		return true;
	};

	/**
	Capability check that always returns false

	@private
	@static
	@return {False}
	*/
	Runtime.capFalse = function() {
		return false;
	};

	/**
	Evaluate the expression to boolean value and create a function that always returns it.

	@private
	@static
	@param {Mixed} expr Expression to evaluate
	@return {Function} Function returning the result of evaluation
	*/
	Runtime.capTest = function(expr) {
		return function() {
			return !!expr;
		};
	};

	return Runtime;
});

// Included from: src/javascript/runtime/RuntimeClient.js

/**
 * RuntimeClient.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/RuntimeClient', [
	'moxie/core/utils/Env',
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic',
	'moxie/runtime/Runtime'
], function(Env, x, Basic, Runtime) {
	/**
	Set of methods and properties, required by a component to acquire ability to connect to a runtime

	@class moxie/runtime/RuntimeClient
	*/
	return function RuntimeClient() {
		var runtime;

		Basic.extend(this, {
			/**
			Connects to the runtime specified by the options. Will either connect to existing runtime or create a new one.
			Increments number of clients connected to the specified runtime.

			@private
			@method connectRuntime
			@param {Mixed} options Can be a runtme uid or a set of key-value pairs defining requirements and pre-requisites
			*/
			connectRuntime: function(options) {
				var comp = this, ruid;

				function initialize(items) {
					var type, constructor;

					// if we ran out of runtimes
					if (!items.length) {
						comp.trigger('RuntimeError', new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));
						runtime = null;
						return;
					}

					type = items.shift().toLowerCase();
					constructor = Runtime.getConstructor(type);
					if (!constructor) {
						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Constructor for '%s' runtime is not available.", type);
						}
						initialize(items);
						return;
					}

					if (MXI_DEBUG && Env.debug.runtime) {
						Env.log("Trying runtime: %s", type);
						Env.log(options);
					}

					// try initializing the runtime
					runtime = new constructor(options);

					runtime.bind('Init', function() {
						// mark runtime as initialized
						runtime.initialized = true;

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Runtime '%s' initialized", runtime.type);
						}

						// jailbreak ...
						setTimeout(function() {
							runtime.clients++;
							comp.ruid = runtime.uid;
							// this will be triggered on component
							comp.trigger('RuntimeInit', runtime);
						}, 1);
					});

					runtime.bind('Error', function() {
						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Runtime '%s' failed to initialize", runtime.type);
						}

						runtime.destroy(); // runtime cannot destroy itself from inside at a right moment, thus we do it here
						initialize(items);
					});

					runtime.bind('Exception', function(e, err) {
						var message = err.name + "(#" + err.code + ")" + (err.message ? ", from: " + err.message : '');
						
						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("Runtime '%s' has thrown an exception: %s", this.type, message);
						}
						comp.trigger('RuntimeError', new x.RuntimeError(x.RuntimeError.EXCEPTION_ERR, message));
					});

					if (MXI_DEBUG && Env.debug.runtime) {
						Env.log("\tselected mode: %s", runtime.mode);	
					}

					// check if runtime managed to pick-up operational mode
					if (!runtime.mode) {
						runtime.trigger('Error');
						return;
					}

					runtime.init();
				}

				// check if a particular runtime was requested
				if (Basic.typeOf(options) === 'string') {
					ruid = options;
				} else if (Basic.typeOf(options.ruid) === 'string') {
					ruid = options.ruid;
				}

				if (ruid) {
					runtime = Runtime.getRuntime(ruid);
					if (runtime) {
						comp.ruid = ruid;
						runtime.clients++;
						return runtime;
					} else {
						// there should be a runtime and there's none - weird case
						throw new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR);
					}
				}

				// initialize a fresh one, that fits runtime list and required features best
				initialize((options.runtime_order || Runtime.order).split(/\s*,\s*/));
			},


			/**
			Disconnects from the runtime. Decrements number of clients connected to the specified runtime.

			@private
			@method disconnectRuntime
			*/
			disconnectRuntime: function() {
				if (runtime && --runtime.clients <= 0) {
					runtime.destroy();
				}

				// once the component is disconnected, it shouldn't have access to the runtime
				runtime = null;
			},


			/**
			Returns the runtime to which the client is currently connected.

			@method getRuntime
			@return {Runtime} Runtime or null if client is not connected
			*/
			getRuntime: function() {
				if (runtime && runtime.uid) {
					return runtime;
				}
				return runtime = null; // make sure we do not leave zombies rambling around
			},


			/**
			Handy shortcut to safely invoke runtime extension methods.
			
			@private
			@method exec
			@return {Mixed} Whatever runtime extension method returns
			*/
			exec: function() {
				return runtime ? runtime.exec.apply(this, arguments) : null;
			},


			/**
			Test runtime client for specific capability
			
			@method can
			@param {String} cap
			@return {Bool}
			*/
			can: function(cap) {
				return runtime ? runtime.can(cap) : false;
			}

		});
	};


});

// Included from: src/javascript/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/Blob', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Encode',
	'moxie/runtime/RuntimeClient'
], function(Basic, Encode, RuntimeClient) {
	
	var blobpool = {};

	/**
	@class moxie/file/Blob
	@constructor
	@param {String} ruid Unique id of the runtime, to which this blob belongs to
	@param {Object} blob Object "Native" blob object, as it is represented in the runtime
	*/
	function Blob(ruid, blob) {

		function _sliceDetached(start, end, type) {
			var blob, data = blobpool[this.uid];

			if (Basic.typeOf(data) !== 'string' || !data.length) {
				return null; // or throw exception
			}

			blob = new Blob(null, {
				type: type,
				size: end - start
			});
			blob.detach(data.substr(start, blob.size));

			return blob;
		}

		RuntimeClient.call(this);

		if (ruid) {	
			this.connectRuntime(ruid);
		}

		if (!blob) {
			blob = {};
		} else if (Basic.typeOf(blob) === 'string') { // dataUrl or binary string
			blob = { data: blob };
		}

		Basic.extend(this, {
			
			/**
			Unique id of the component

			@property uid
			@type {String}
			*/
			uid: blob.uid || Basic.guid('uid_'),
			
			/**
			Unique id of the connected runtime, if falsy, then runtime will have to be initialized 
			before this Blob can be used, modified or sent

			@property ruid
			@type {String}
			*/
			ruid: ruid,
	
			/**
			Size of blob

			@property size
			@type {Number}
			@default 0
			*/
			size: blob.size || 0,
			
			/**
			Mime type of blob

			@property type
			@type {String}
			@default ''
			*/
			type: blob.type || '',
			
			/**
			@method slice
			@param {Number} [start=0]
			*/
			slice: function(start, end, type) {		
				if (this.isDetached()) {
					return _sliceDetached.apply(this, arguments);
				}
				return this.getRuntime().exec.call(this, 'Blob', 'slice', this.getSource(), start, end, type);
			},

			/**
			Returns "native" blob object (as it is represented in connected runtime) or null if not found

			@method getSource
			@return {Blob} Returns "native" blob object or null if not found
			*/
			getSource: function() {
				if (!blobpool[this.uid]) {
					return null;	
				}
				return blobpool[this.uid];
			},

			/** 
			Detaches blob from any runtime that it depends on and initialize with standalone value

			@method detach
			@protected
			@param {DOMString} [data=''] Standalone value
			*/
			detach: function(data) {
				if (this.ruid) {
					this.getRuntime().exec.call(this, 'Blob', 'destroy');
					this.disconnectRuntime();
					this.ruid = null;
				}

				data = data || '';

				// if dataUrl, convert to binary string
				if (data.substr(0, 5) == 'data:') {
					var base64Offset = data.indexOf(';base64,');
					this.type = data.substring(5, base64Offset);
					data = Encode.atob(data.substring(base64Offset + 8));
				}

				this.size = data.length;

				blobpool[this.uid] = data;
			},

			/**
			Checks if blob is standalone (detached of any runtime)
			
			@method isDetached
			@protected
			@return {Boolean}
			*/
			isDetached: function() {
				return !this.ruid && Basic.typeOf(blobpool[this.uid]) === 'string';
			},
			
			/** 
			Destroy Blob and free any resources it was using

			@method destroy
			*/
			destroy: function() {
				this.detach();
				delete blobpool[this.uid];
			}
		});

		
		if (blob.data) {
			this.detach(blob.data); // auto-detach if payload has been passed
		} else {
			blobpool[this.uid] = blob;	
		}
	}
	
	return Blob;
});

// Included from: src/javascript/core/I18n.js

/**
 * I18n.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/I18n", [
	"moxie/core/utils/Basic"
], function(Basic) {
	var i18n = {};

	/**
	@class moxie/core/I18n
	*/
	return {
		/**
		 * Extends the language pack object with new items.
		 *
		 * @param {Object} pack Language pack items to add.
		 * @return {Object} Extended language pack object.
		 */
		addI18n: function(pack) {
			return Basic.extend(i18n, pack);
		},

		/**
		 * Translates the specified string by checking for the english string in the language pack lookup.
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		translate: function(str) {
			return i18n[str] || str;
		},

		/**
		 * Shortcut for translate function
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		_: function(str) {
			return this.translate(str);
		},

		/**
		 * Pseudo sprintf implementation - simple way to replace tokens with specified values.
		 *
		 * @param {String} str String with tokens
		 * @return {String} String with replaced tokens
		 */
		sprintf: function(str) {
			var args = [].slice.call(arguments, 1);

			return str.replace(/%[a-z]/g, function() {
				var value = args.shift();
				return Basic.typeOf(value) !== 'undefined' ? value : '';
			});
		}
	};
});

// Included from: src/javascript/core/utils/Mime.js

/**
 * Mime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/utils/Mime", [
	"moxie/core/utils/Basic",
	"moxie/core/I18n"
], function(Basic, I18n) {
	
	var mimeData = "" +
		"application/msword,doc dot," +
		"application/pdf,pdf," +
		"application/pgp-signature,pgp," +
		"application/postscript,ps ai eps," +
		"application/rtf,rtf," +
		"application/vnd.ms-excel,xls xlb," +
		"application/vnd.ms-powerpoint,ppt pps pot," +
		"application/zip,zip," +
		"application/x-shockwave-flash,swf swfl," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document,docx," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template,dotx," +
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,xlsx," +
		"application/vnd.openxmlformats-officedocument.presentationml.presentation,pptx," +
		"application/vnd.openxmlformats-officedocument.presentationml.template,potx," +
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow,ppsx," +
		"application/x-javascript,js," +
		"application/json,json," +
		"audio/mpeg,mp3 mpga mpega mp2," +
		"audio/x-wav,wav," +
		"audio/x-m4a,m4a," +
		"audio/ogg,oga ogg," +
		"audio/aiff,aiff aif," +
		"audio/flac,flac," +
		"audio/aac,aac," +
		"audio/ac3,ac3," +
		"audio/x-ms-wma,wma," +
		"image/bmp,bmp," +
		"image/gif,gif," +
		"image/jpeg,jpg jpeg jpe," +
		"image/photoshop,psd," +
		"image/png,png," +
		"image/svg+xml,svg svgz," +
		"image/tiff,tiff tif," +
		"text/plain,asc txt text diff log," +
		"text/html,htm html xhtml," +
		"text/css,css," +
		"text/csv,csv," +
		"text/rtf,rtf," +
		"video/mpeg,mpeg mpg mpe m2v," +
		"video/quicktime,qt mov," +
		"video/mp4,mp4," +
		"video/x-m4v,m4v," +
		"video/x-flv,flv," +
		"video/x-ms-wmv,wmv," +
		"video/avi,avi," +
		"video/webm,webm," +
		"video/3gpp,3gpp 3gp," +
		"video/3gpp2,3g2," +
		"video/vnd.rn-realvideo,rv," +
		"video/ogg,ogv," + 
		"video/x-matroska,mkv," +
		"application/vnd.oasis.opendocument.formula-template,otf," +
		"application/octet-stream,exe";
	
	
	var Mime = {

		mimes: {},

		extensions: {},

		// Parses the default mime types string into a mimes and extensions lookup maps
		addMimeType: function (mimeData) {
			var items = mimeData.split(/,/), i, ii, ext;
			
			for (i = 0; i < items.length; i += 2) {
				ext = items[i + 1].split(/ /);

				// extension to mime lookup
				for (ii = 0; ii < ext.length; ii++) {
					this.mimes[ext[ii]] = items[i];
				}
				// mime to extension lookup
				this.extensions[items[i]] = ext;
			}
		},


		extList2mimes: function (filters, addMissingExtensions) {
			var self = this, ext, i, ii, type, mimes = [];
			
			// convert extensions to mime types list
			for (i = 0; i < filters.length; i++) {
				ext = filters[i].extensions.toLowerCase().split(/\s*,\s*/);

				for (ii = 0; ii < ext.length; ii++) {
					
					// if there's an asterisk in the list, then accept attribute is not required
					if (ext[ii] === '*') {
						return [];
					}

					type = self.mimes[ext[ii]];

					// future browsers should filter by extension, finally
					if (addMissingExtensions && /^\w+$/.test(ext[ii])) {
						mimes.push('.' + ext[ii]);
					} else if (type && Basic.inArray(type, mimes) === -1) {
						mimes.push(type);
					} else if (!type) {
						// if we have no type in our map, then accept all
						return [];
					}
				}
			}
			return mimes;
		},


		mimes2exts: function(mimes) {
			var self = this, exts = [];
			
			Basic.each(mimes, function(mime) {
				mime = mime.toLowerCase();

				if (mime === '*') {
					exts = [];
					return false;
				}

				// check if this thing looks like mime type
				var m = mime.match(/^(\w+)\/(\*|\w+)$/);
				if (m) {
					if (m[2] === '*') { 
						// wildcard mime type detected
						Basic.each(self.extensions, function(arr, mime) {
							if ((new RegExp('^' + m[1] + '/')).test(mime)) {
								[].push.apply(exts, self.extensions[mime]);
							}
						});
					} else if (self.extensions[mime]) {
						[].push.apply(exts, self.extensions[mime]);
					}
				}
			});
			return exts;
		},


		mimes2extList: function(mimes) {
			var accept = [], exts = [];

			if (Basic.typeOf(mimes) === 'string') {
				mimes = Basic.trim(mimes).split(/\s*,\s*/);
			}

			exts = this.mimes2exts(mimes);
			
			accept.push({
				title: I18n.translate('Files'),
				extensions: exts.length ? exts.join(',') : '*'
			});
			
			// save original mimes string
			accept.mimes = mimes;

			return accept;
		},


		getFileExtension: function(fileName) {
			var matches = fileName && fileName.match(/\.([^.]+)$/);
			if (matches) {
				return matches[1].toLowerCase();
			}
			return '';
		},

		getFileMime: function(fileName) {
			return this.mimes[this.getFileExtension(fileName)] || '';
		}
	};

	Mime.addMimeType(mimeData);

	return Mime;
});

// Included from: src/javascript/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileInput', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Env',
	'moxie/core/utils/Mime',
	'moxie/core/utils/Dom',
	'moxie/core/Exceptions',
	'moxie/core/EventTarget',
	'moxie/core/I18n',
	'moxie/runtime/Runtime',
	'moxie/runtime/RuntimeClient'
], function(Basic, Env, Mime, Dom, x, EventTarget, I18n, Runtime, RuntimeClient) {
	/**
	Provides a convenient way to create cross-browser file-picker. Generates file selection dialog on click,
	converts selected files to _File_ objects, to be used in conjunction with _Image_, preloaded in memory
	with _FileReader_ or uploaded to a server through _XMLHttpRequest_.

	@class moxie/file/FileInput
	@constructor
	@extends EventTarget
	@uses RuntimeClient
	@param {Object|String|DOMElement} options If options is string or node, argument is considered as _browse\_button_.
		@param {String|DOMElement} options.browse_button DOM Element to turn into file picker.
		@param {Array} [options.accept] Array of mime types to accept. By default accepts all.
		@param {Boolean} [options.multiple=false] Enable selection of multiple files.
		@param {Boolean} [options.directory=false] Turn file input into the folder input (cannot be both at the same time).
		@param {String|DOMElement} [options.container] DOM Element to use as a container for file-picker. Defaults to parentNode 
		for _browse\_button_.
		@param {Object|String} [options.required_caps] Set of required capabilities, that chosen runtime must support.

	@example
		<div id="container">
			<a id="file-picker" href="javascript:;">Browse...</a>
		</div>

		<script>
			var fileInput = new mOxie.FileInput({
				browse_button: 'file-picker', // or document.getElementById('file-picker')
				container: 'container',
				accept: [
					{title: "Image files", extensions: "jpg,gif,png"} // accept only images
				],
				multiple: true // allow multiple file selection
			});

			fileInput.onchange = function(e) {
				// do something to files array
				console.info(e.target.files); // or this.files or fileInput.files
			};

			fileInput.init(); // initialize
		</script>
	*/
	var dispatches = [
		/**
		Dispatched when runtime is connected and file-picker is ready to be used.

		@event ready
		@param {Object} event
		*/
		'ready',

		/**
		Dispatched right after [ready](#event_ready) event, and whenever [refresh()](#method_refresh) is invoked. 
		Check [corresponding documentation entry](#method_refresh) for more info.

		@event refresh
		@param {Object} event
		*/

		/**
		Dispatched when selection of files in the dialog is complete.

		@event change
		@param {Object} event
		*/
		'change',

		'cancel', // TODO: might be useful

		/**
		Dispatched when mouse cursor enters file-picker area. Can be used to style element
		accordingly.

		@event mouseenter
		@param {Object} event
		*/
		'mouseenter',

		/**
		Dispatched when mouse cursor leaves file-picker area. Can be used to style element
		accordingly.

		@event mouseleave
		@param {Object} event
		*/
		'mouseleave',

		/**
		Dispatched when functional mouse button is pressed on top of file-picker area.

		@event mousedown
		@param {Object} event
		*/
		'mousedown',

		/**
		Dispatched when functional mouse button is released on top of file-picker area.

		@event mouseup
		@param {Object} event
		*/
		'mouseup'
	];

	function FileInput(options) {
		if (MXI_DEBUG) {
			Env.log("Instantiating FileInput...");	
		}

		var container, browseButton, defaults;

		// if flat argument passed it should be browse_button id
		if (Basic.inArray(Basic.typeOf(options), ['string', 'node']) !== -1) {
			options = { browse_button : options };
		}

		// this will help us to find proper default container
		browseButton = Dom.get(options.browse_button);
		if (!browseButton) {
			// browse button is required
			throw new x.DOMException(x.DOMException.NOT_FOUND_ERR);
		}

		// figure out the options
		defaults = {
			accept: [{
				title: I18n.translate('All Files'),
				extensions: '*'
			}],
			multiple: false,
			required_caps: false,
			container: browseButton.parentNode || document.body
		};
		
		options = Basic.extend({}, defaults, options);

		// convert to object representation
		if (typeof(options.required_caps) === 'string') {
			options.required_caps = Runtime.parseCaps(options.required_caps);
		}
					
		// normalize accept option (could be list of mime types or array of title/extensions pairs)
		if (typeof(options.accept) === 'string') {
			options.accept = Mime.mimes2extList(options.accept);
		}

		container = Dom.get(options.container);
		// make sure we have container
		if (!container) {
			container = document.body;
		}

		// make container relative, if it's not
		if (Dom.getStyle(container, 'position') === 'static') {
			container.style.position = 'relative';
		}

		container = browseButton = null; // IE
						
		RuntimeClient.call(this);
		
		Basic.extend(this, {
			/**
			Unique id of the component

			@property uid
			@protected
			@readOnly
			@type {String}
			@default UID
			*/
			uid: Basic.guid('uid_'),
			
			/**
			Unique id of the connected runtime, if any.

			@property ruid
			@protected
			@type {String}
			*/
			ruid: null,

			/**
			Unique id of the runtime container. Useful to get hold of it for various manipulations.

			@property shimid
			@protected
			@type {String}
			*/
			shimid: null,
			
			/**
			Array of selected mOxie.File objects

			@property files
			@type {Array}
			@default null
			*/
			files: null,

			/**
			Initializes the file-picker, connects it to runtime and dispatches event ready when done.

			@method init
			*/
			init: function() {
				var self = this;

				self.bind('RuntimeInit', function(e, runtime) {
					self.ruid = runtime.uid;
					self.shimid = runtime.shimid;

					self.bind("Ready", function() {
						self.trigger("Refresh");
					}, 999);

					// re-position and resize shim container
					self.bind('Refresh', function() {
						var pos, size, browseButton, shimContainer, zIndex;
						
						browseButton = Dom.get(options.browse_button);
						shimContainer = Dom.get(runtime.shimid); // do not use runtime.getShimContainer(), since it will create container if it doesn't exist

						if (browseButton) {
							pos = Dom.getPos(browseButton, Dom.get(options.container));
							size = Dom.getSize(browseButton);
							zIndex = parseInt(Dom.getStyle(browseButton, 'z-index'), 10) || 0;

							if (shimContainer) {
								Basic.extend(shimContainer.style, {
									top: pos.y + 'px',
									left: pos.x + 'px',
									width: size.w + 'px',
									height: size.h + 'px',
									zIndex: zIndex + 1
								});
							}
						}
						shimContainer = browseButton = null;
					});
					
					runtime.exec.call(self, 'FileInput', 'init', options);
				});

				// runtime needs: options.required_features, options.runtime_order and options.container
				self.connectRuntime(Basic.extend({}, options, {
					required_caps: {
						select_file: true
					}
				}));
			},


			/**
			 * Get current option value by its name
			 *
			 * @method getOption
			 * @param name
			 * @return {Mixed}
			 */
			getOption: function(name) {
				return options[name];
			},


			/**
			 * Sets a new value for the option specified by name
			 *
			 * @method setOption
			 * @param name
			 * @param value
			 */
			setOption: function(name, value) {
				if (!options.hasOwnProperty(name)) {
					return;
				}

				var oldValue = options[name];

				switch (name) {
					case 'accept':
						if (typeof(value) === 'string') {
							value = Mime.mimes2extList(value);
						}
						break;

					case 'container':
					case 'required_caps':
						throw new x.FileException(x.FileException.NO_MODIFICATION_ALLOWED_ERR);
				}

				options[name] = value;
				this.exec('FileInput', 'setOption', name, value);

				this.trigger('OptionChanged', name, value, oldValue);
			},

			/**
			Disables file-picker element, so that it doesn't react to mouse clicks.

			@method disable
			@param {Boolean} [state=true] Disable component if - true, enable if - false
			*/
			disable: function(state) {
				var runtime = this.getRuntime();
				if (runtime) {
					this.exec('FileInput', 'disable', Basic.typeOf(state) === 'undefined' ? true : state);
				}
			},


			/**
			Reposition and resize dialog trigger to match the position and size of browse_button element.

			@method refresh
			*/
			refresh: function() {
				this.trigger("Refresh");
			},


			/**
			Destroy component.

			@method destroy
			*/
			destroy: function() {
				var runtime = this.getRuntime();
				if (runtime) {
					runtime.exec.call(this, 'FileInput', 'destroy');
					this.disconnectRuntime();
				}

				if (Basic.typeOf(this.files) === 'array') {
					// no sense in leaving associated files behind
					Basic.each(this.files, function(file) {
						file.destroy();
					});
				} 
				this.files = null;

				this.unbindAll();
			}
		});

		this.handleEventProps(dispatches);
	}

	FileInput.prototype = EventTarget.instance;

	return FileInput;
});

// Included from: src/javascript/file/File.js

/**
 * File.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/File', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Mime',
	'moxie/file/Blob'
], function(Basic, Mime, Blob) {
	/**
	@class moxie/file/File
	@extends Blob
	@constructor
	@param {String} ruid Unique id of the runtime, to which this blob belongs to
	@param {Object} file Object "Native" file object, as it is represented in the runtime
	*/
	function File(ruid, file) {
		if (!file) { // avoid extra errors in case we overlooked something
			file = {};
		}

		Blob.apply(this, arguments);

		if (!this.type) {
			this.type = Mime.getFileMime(file.name);
		}

		// sanitize file name or generate new one
		var name;
		if (file.name) {
			name = file.name.replace(/\\/g, '/');
			name = name.substr(name.lastIndexOf('/') + 1);
		} else if (this.type) {
			var prefix = this.type.split('/')[0];
			name = Basic.guid((prefix !== '' ? prefix : 'file') + '_');
			
			if (Mime.extensions[this.type]) {
				name += '.' + Mime.extensions[this.type][0]; // append proper extension if possible
			}
		}
		
		
		Basic.extend(this, {
			/**
			File name

			@property name
			@type {String}
			@default UID
			*/
			name: name || Basic.guid('file_'),

			/**
			Relative path to the file inside a directory

			@property relativePath
			@type {String}
			@default ''
			*/
			relativePath: '',
			
			/**
			Date of last modification

			@property lastModifiedDate
			@type {String}
			@default now
			*/
			lastModifiedDate: file.lastModifiedDate || (new Date()).toLocaleString() // Thu Aug 23 2012 19:40:00 GMT+0400 (GET)
		});
	}

	File.prototype = Blob.prototype;

	return File;
});

// Included from: src/javascript/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileDrop', [
	'moxie/core/I18n',
	'moxie/core/utils/Dom',
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic',
	'moxie/core/utils/Env',
	'moxie/file/File',
	'moxie/runtime/RuntimeClient',
	'moxie/core/EventTarget',
	'moxie/core/utils/Mime'
], function(I18n, Dom, x, Basic, Env, File, RuntimeClient, EventTarget, Mime) {
	/**
	Turn arbitrary DOM element to a drop zone accepting files. Converts selected files to _File_ objects, to be used 
	in conjunction with _Image_, preloaded in memory with _FileReader_ or uploaded to a server through 
	_XMLHttpRequest_.

	@example
		<div id="drop_zone">
			Drop files here
		</div>
		<br />
		<div id="filelist"></div>

		<script type="text/javascript">
			var fileDrop = new mOxie.FileDrop('drop_zone'), fileList = mOxie.get('filelist');

			fileDrop.ondrop = function() {
				mOxie.each(this.files, function(file) {
					fileList.innerHTML += '<div>' + file.name + '</div>';
				});
			};

			fileDrop.init();
		</script>

	@class moxie/file/FileDrop
	@constructor
	@extends EventTarget
	@uses RuntimeClient
	@param {Object|String} options If options has typeof string, argument is considered as options.drop_zone
		@param {String|DOMElement} options.drop_zone DOM Element to turn into a drop zone
		@param {Array} [options.accept] Array of mime types to accept. By default accepts all
		@param {Object|String} [options.required_caps] Set of required capabilities, that chosen runtime must support
	*/
	var dispatches = [
		/**
		Dispatched when runtime is connected and drop zone is ready to accept files.

		@event ready
		@param {Object} event
		*/
		'ready', 

		/**
		Dispatched when dragging cursor enters the drop zone.

		@event dragenter
		@param {Object} event
		*/
		'dragenter',

		/**
		Dispatched when dragging cursor leaves the drop zone.

		@event dragleave
		@param {Object} event
		*/
		'dragleave', 

		/**
		Dispatched when file is dropped onto the drop zone.

		@event drop
		@param {Object} event
		*/
		'drop', 

		/**
		Dispatched if error occurs.

		@event error
		@param {Object} event
		*/
		'error'
	];

	function FileDrop(options) {
		if (MXI_DEBUG) {
			Env.log("Instantiating FileDrop...");	
		}

		var self = this, defaults;

		// if flat argument passed it should be drop_zone id
		if (typeof(options) === 'string') {
			options = { drop_zone : options };
		}

		// figure out the options
		defaults = {
			accept: [{
				title: I18n.translate('All Files'),
				extensions: '*'
			}],
			required_caps: {
				drag_and_drop: true
			}
		};
		
		options = typeof(options) === 'object' ? Basic.extend({}, defaults, options) : defaults;

		// this will help us to find proper default container
		options.container = Dom.get(options.drop_zone) || document.body;

		// make container relative, if it is not
		if (Dom.getStyle(options.container, 'position') === 'static') {
			options.container.style.position = 'relative';
		}
					
		// normalize accept option (could be list of mime types or array of title/extensions pairs)
		if (typeof(options.accept) === 'string') {
			options.accept = Mime.mimes2extList(options.accept);
		}

		RuntimeClient.call(self);

		Basic.extend(self, {
			uid: Basic.guid('uid_'),

			ruid: null,

			files: null,

			init: function() {		
				self.bind('RuntimeInit', function(e, runtime) {
					self.ruid = runtime.uid;
					runtime.exec.call(self, 'FileDrop', 'init', options);
					self.dispatchEvent('ready');
				});
							
				// runtime needs: options.required_features, options.runtime_order and options.container
				self.connectRuntime(options); // throws RuntimeError
			},

			destroy: function() {
				var runtime = this.getRuntime();
				if (runtime) {
					runtime.exec.call(this, 'FileDrop', 'destroy');
					this.disconnectRuntime();
				}
				this.files = null;
				
				this.unbindAll();
			}
		});

		this.handleEventProps(dispatches);
	}

	FileDrop.prototype = EventTarget.instance;

	return FileDrop;
});

// Included from: src/javascript/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileReader', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Encode',
	'moxie/core/Exceptions',
	'moxie/core/EventTarget',
	'moxie/file/Blob',
	'moxie/runtime/RuntimeClient'
], function(Basic, Encode, x, EventTarget, Blob, RuntimeClient) {
	/**
	Utility for preloading o.Blob/o.File objects in memory. By design closely follows [W3C FileReader](http://www.w3.org/TR/FileAPI/#dfn-filereader)
	interface. Where possible uses native FileReader, where - not falls back to shims.

	@class moxie/file/FileReader
	@constructor FileReader
	@extends EventTarget
	@uses RuntimeClient
	*/
	var dispatches = [

		/** 
		Dispatched when the read starts.

		@event loadstart
		@param {Object} event
		*/
		'loadstart', 

		/** 
		Dispatched while reading (and decoding) blob, and reporting partial Blob data (progess.loaded/progress.total).

		@event progress
		@param {Object} event
		*/
		'progress', 

		/** 
		Dispatched when the read has successfully completed.

		@event load
		@param {Object} event
		*/
		'load', 

		/** 
		Dispatched when the read has been aborted. For instance, by invoking the abort() method.

		@event abort
		@param {Object} event
		*/
		'abort', 

		/** 
		Dispatched when the read has failed.

		@event error
		@param {Object} event
		*/
		'error', 

		/** 
		Dispatched when the request has completed (either in success or failure).

		@event loadend
		@param {Object} event
		*/
		'loadend'
	];
	
	function FileReader() {

		RuntimeClient.call(this);

		Basic.extend(this, {
			/**
			UID of the component instance.

			@property uid
			@type {String}
			*/
			uid: Basic.guid('uid_'),

			/**
			Contains current state of FileReader object. Can take values of FileReader.EMPTY, FileReader.LOADING
			and FileReader.DONE.

			@property readyState
			@type {Number}
			@default FileReader.EMPTY
			*/
			readyState: FileReader.EMPTY,
			
			/**
			Result of the successful read operation.

			@property result
			@type {String}
			*/
			result: null,
			
			/**
			Stores the error of failed asynchronous read operation.

			@property error
			@type {DOMError}
			*/
			error: null,
			
			/**
			Initiates reading of File/Blob object contents to binary string.

			@method readAsBinaryString
			@param {Blob|File} blob Object to preload
			*/
			readAsBinaryString: function(blob) {
				_read.call(this, 'readAsBinaryString', blob);
			},
			
			/**
			Initiates reading of File/Blob object contents to dataURL string.

			@method readAsDataURL
			@param {Blob|File} blob Object to preload
			*/
			readAsDataURL: function(blob) {
				_read.call(this, 'readAsDataURL', blob);
			},
			
			/**
			Initiates reading of File/Blob object contents to string.

			@method readAsText
			@param {Blob|File} blob Object to preload
			*/
			readAsText: function(blob) {
				_read.call(this, 'readAsText', blob);
			},
			
			/**
			Aborts preloading process.

			@method abort
			*/
			abort: function() {
				this.result = null;
				
				if (Basic.inArray(this.readyState, [FileReader.EMPTY, FileReader.DONE]) !== -1) {
					return;
				} else if (this.readyState === FileReader.LOADING) {
					this.readyState = FileReader.DONE;
				}

				this.exec('FileReader', 'abort');
				
				this.trigger('abort');
				this.trigger('loadend');
			},

			/**
			Destroy component and release resources.

			@method destroy
			*/
			destroy: function() {
				this.abort();
				this.exec('FileReader', 'destroy');
				this.disconnectRuntime();
				this.unbindAll();
			}
		});

		// uid must already be assigned
		this.handleEventProps(dispatches);

		this.bind('Error', function(e, err) {
			this.readyState = FileReader.DONE;
			this.error = err;
		}, 999);
		
		this.bind('Load', function(e) {
			this.readyState = FileReader.DONE;
		}, 999);

		
		function _read(op, blob) {
			var self = this;			

			this.trigger('loadstart');

			if (this.readyState === FileReader.LOADING) {
				this.trigger('error', new x.DOMException(x.DOMException.INVALID_STATE_ERR));
				this.trigger('loadend');
				return;
			}

			// if source is not o.Blob/o.File
			if (!(blob instanceof Blob)) {
				this.trigger('error', new x.DOMException(x.DOMException.NOT_FOUND_ERR));
				this.trigger('loadend');
				return;
			}

			this.result = null;
			this.readyState = FileReader.LOADING;
			
			if (blob.isDetached()) {
				var src = blob.getSource();
				switch (op) {
					case 'readAsText':
					case 'readAsBinaryString':
						this.result = src;
						break;
					case 'readAsDataURL':
						this.result = 'data:' + blob.type + ';base64,' + Encode.btoa(src);
						break;
				}
				this.readyState = FileReader.DONE;
				this.trigger('load');
				this.trigger('loadend');
			} else {
				this.connectRuntime(blob.ruid);
				this.exec('FileReader', 'read', op, blob);
			}
		}
	}
	
	/**
	Initial FileReader state

	@property EMPTY
	@type {Number}
	@final
	@static
	@default 0
	*/
	FileReader.EMPTY = 0;

	/**
	FileReader switches to this state when it is preloading the source

	@property LOADING
	@type {Number}
	@final
	@static
	@default 1
	*/
	FileReader.LOADING = 1;

	/**
	Preloading is complete, this is a final state

	@property DONE
	@type {Number}
	@final
	@static
	@default 2
	*/
	FileReader.DONE = 2;

	FileReader.prototype = EventTarget.instance;

	return FileReader;
});

// Included from: src/javascript/core/utils/Url.js

/**
 * Url.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Url', [
	'moxie/core/utils/Basic'
], function(Basic) {
	/**
	Parse url into separate components and fill in absent parts with parts from current url,
	based on https://raw.github.com/kvz/phpjs/master/functions/url/parse_url.js

	@method parseUrl
	@for Utils
	@static
	@param {String} url Url to parse (defaults to empty string if undefined)
	@return {Object} Hash containing extracted uri components
	*/
	var parseUrl = function(url, currentUrl) {
		var key = ['source', 'scheme', 'authority', 'userInfo', 'user', 'pass', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'fragment']
		, i = key.length
		, ports = {
			http: 80,
			https: 443
		}
		, uri = {}
		, regex = /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@\/]*):?([^:@\/]*))?@)?(\[[\da-fA-F:]+\]|[^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/
		, m = regex.exec(url || '')
		, isRelative
		, isSchemeLess = /^\/\/\w/.test(url)
		;

		switch (Basic.typeOf(currentUrl)) {
			case 'undefined':
				currentUrl = parseUrl(document.location.href, false);
				break;

			case 'string':
				currentUrl = parseUrl(currentUrl, false);
				break;
		}

		while (i--) {
			if (m[i]) {
				uri[key[i]] = m[i];
			}
		}

		isRelative = !isSchemeLess && !uri.scheme;

		if (isSchemeLess || isRelative) {
			uri.scheme = currentUrl.scheme;
		}

		// when url is relative, we set the origin and the path ourselves
		if (isRelative) {
			uri.host = currentUrl.host;
			uri.port = currentUrl.port;

			var path = '';
			// for urls without trailing slash we need to figure out the path
			if (/^[^\/]/.test(uri.path)) {
				path = currentUrl.path;
				// if path ends with a filename, strip it
				if (/\/[^\/]*\.[^\/]*$/.test(path)) {
					path = path.replace(/\/[^\/]+$/, '/');
				} else {
					// avoid double slash at the end (see #127)
					path = path.replace(/\/?$/, '/');
				}
			}
			uri.path = path + (uri.path || ''); // site may reside at domain.com or domain.com/subdir
		}

		if (!uri.port) {
			uri.port = ports[uri.scheme] || 80;
		}

		uri.port = parseInt(uri.port, 10);

		if (!uri.path) {
			uri.path = "/";
		}

		delete uri.source;

		return uri;
	};

	/**
	Resolve url - among other things will turn relative url to absolute

	@method resolveUrl
	@static
	@param {String|Object} url Either absolute or relative, or a result of parseUrl call
	@return {String} Resolved, absolute url
	*/
	var resolveUrl = function(url) {
		var ports = { // we ignore default ports
			http: 80,
			https: 443
		}
		, urlp = typeof(url) === 'object' ? url : parseUrl(url);
		;

		return urlp.scheme + '://' + urlp.host + (urlp.port !== ports[urlp.scheme] ? ':' + urlp.port : '') + urlp.path + (urlp.query ? urlp.query : '');
	};

	/**
	Check if specified url has the same origin as the current document

	@method hasSameOrigin
	@param {String|Object} url
	@return {Boolean}
	*/
	var hasSameOrigin = function(url) {
		function origin(url) {
			return [url.scheme, url.host, url.port].join('/');
		}

		if (typeof url === 'string') {
			url = parseUrl(url);
		}

		return origin(parseUrl()) === origin(url);
	};

	return {
		parseUrl: parseUrl,
		resolveUrl: resolveUrl,
		hasSameOrigin: hasSameOrigin
	};
});

// Included from: src/javascript/runtime/RuntimeTarget.js

/**
 * RuntimeTarget.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/RuntimeTarget', [
	'moxie/core/utils/Basic',
	'moxie/runtime/RuntimeClient',
	"moxie/core/EventTarget"
], function(Basic, RuntimeClient, EventTarget) {
	/**
	Instance of this class can be used as a target for the events dispatched by shims,
	when allowing them onto components is for either reason inappropriate

	@class moxie/runtime/RuntimeTarget
	@constructor
	@protected
	@extends EventTarget
	*/
	function RuntimeTarget() {
		this.uid = Basic.guid('uid_');
		
		RuntimeClient.call(this);

		this.destroy = function() {
			this.disconnectRuntime();
			this.unbindAll();
		};
	}

	RuntimeTarget.prototype = EventTarget.instance;

	return RuntimeTarget;
});

// Included from: src/javascript/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileReaderSync', [
	'moxie/core/utils/Basic',
	'moxie/runtime/RuntimeClient',
	'moxie/core/utils/Encode'
], function(Basic, RuntimeClient, Encode) {
	/**
	Synchronous FileReader implementation. Something like this is available in WebWorkers environment, here
	it can be used to read only preloaded blobs/files and only below certain size (not yet sure what that'd be,
	but probably < 1mb). Not meant to be used directly by user.

	@class moxie/file/FileReaderSync
	@private
	@constructor
	*/
	return function() {
		RuntimeClient.call(this);

		Basic.extend(this, {
			uid: Basic.guid('uid_'),

			readAsBinaryString: function(blob) {
				return _read.call(this, 'readAsBinaryString', blob);
			},
			
			readAsDataURL: function(blob) {
				return _read.call(this, 'readAsDataURL', blob);
			},
			
			/*readAsArrayBuffer: function(blob) {
				return _read.call(this, 'readAsArrayBuffer', blob);
			},*/
			
			readAsText: function(blob) {
				return _read.call(this, 'readAsText', blob);
			}
		});

		function _read(op, blob) {
			if (blob.isDetached()) {
				var src = blob.getSource();
				switch (op) {
					case 'readAsBinaryString':
						return src;
					case 'readAsDataURL':
						return 'data:' + blob.type + ';base64,' + Encode.btoa(src);
					case 'readAsText':
						var txt = '';
						for (var i = 0, length = src.length; i < length; i++) {
							txt += String.fromCharCode(src[i]);
						}
						return txt;
				}
			} else {
				var result = this.connectRuntime(blob.ruid).exec.call(this, 'FileReaderSync', 'read', op, blob);
				this.disconnectRuntime();
				return result;
			}
		}
	};
});

// Included from: src/javascript/xhr/FormData.js

/**
 * FormData.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/xhr/FormData", [
	"moxie/core/Exceptions",
	"moxie/core/utils/Basic",
	"moxie/file/Blob"
], function(x, Basic, Blob) {
	/**
	FormData

	@class moxie/xhr/FormData
	@constructor
	*/
	function FormData() {
		var _blob, _fields = [];

		Basic.extend(this, {
			/**
			Append another key-value pair to the FormData object

			@method append
			@param {String} name Name for the new field
			@param {String|Blob|Array|Object} value Value for the field
			*/
			append: function(name, value) {
				var self = this, valueType = Basic.typeOf(value);

				// according to specs value might be either Blob or String
				if (value instanceof Blob) {
					_blob = {
						name: name,
						value: value // unfortunately we can only send single Blob in one FormData
					};
				} else if ('array' === valueType) {
					name += '[]';

					Basic.each(value, function(value) {
						self.append(name, value);
					});
				} else if ('object' === valueType) {
					Basic.each(value, function(value, key) {
						self.append(name + '[' + key + ']', value);
					});
				} else if ('null' === valueType || 'undefined' === valueType || 'number' === valueType && isNaN(value)) {
					self.append(name, "false");
				} else {
					_fields.push({
						name: name,
						value: value.toString()
					});
				}
			},

			/**
			Checks if FormData contains Blob.

			@method hasBlob
			@return {Boolean}
			*/
			hasBlob: function() {
				return !!this.getBlob();
			},

			/**
			Retrieves blob.

			@method getBlob
			@return {Object} Either Blob if found or null
			*/
			getBlob: function() {
				return _blob && _blob.value || null;
			},

			/**
			Retrieves blob field name.

			@method getBlobName
			@return {String} Either Blob field name or null
			*/
			getBlobName: function() {
				return _blob && _blob.name || null;
			},

			/**
			Loop over the fields in FormData and invoke the callback for each of them.

			@method each
			@param {Function} cb Callback to call for each field
			*/
			each: function(cb) {
				Basic.each(_fields, function(field) {
					cb(field.value, field.name);
				});

				if (_blob) {
					cb(_blob.value, _blob.name);
				}
			},

			destroy: function() {
				_blob = null;
				_fields = [];
			}
		});
	}

	return FormData;
});

// Included from: src/javascript/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/xhr/XMLHttpRequest", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/core/EventTarget",
	"moxie/core/utils/Encode",
	"moxie/core/utils/Url",
	"moxie/runtime/Runtime",
	"moxie/runtime/RuntimeTarget",
	"moxie/file/Blob",
	"moxie/file/FileReaderSync",
	"moxie/xhr/FormData",
	"moxie/core/utils/Env",
	"moxie/core/utils/Mime"
], function(Basic, x, EventTarget, Encode, Url, Runtime, RuntimeTarget, Blob, FileReaderSync, FormData, Env, Mime) {

	var httpCode = {
		100: 'Continue',
		101: 'Switching Protocols',
		102: 'Processing',

		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		207: 'Multi-Status',
		226: 'IM Used',

		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		306: 'Reserved',
		307: 'Temporary Redirect',

		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Timeout',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Long',
		415: 'Unsupported Media Type',
		416: 'Requested Range Not Satisfiable',
		417: 'Expectation Failed',
		422: 'Unprocessable Entity',
		423: 'Locked',
		424: 'Failed Dependency',
		426: 'Upgrade Required',

		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Timeout',
		505: 'HTTP Version Not Supported',
		506: 'Variant Also Negotiates',
		507: 'Insufficient Storage',
		510: 'Not Extended'
	};

	function XMLHttpRequestUpload() {
		this.uid = Basic.guid('uid_');
	}

	XMLHttpRequestUpload.prototype = EventTarget.instance;

	/**
	Implementation of XMLHttpRequest

	@class moxie/xhr/XMLHttpRequest
	@constructor
	@uses RuntimeClient
	@extends EventTarget
	*/
	var dispatches = [
		'loadstart',

		'progress',

		'abort',

		'error',

		'load',

		'timeout',

		'loadend'

		// readystatechange (for historical reasons)
	];

	var NATIVE = 1, RUNTIME = 2;

	function XMLHttpRequest() {
		var self = this,
			// this (together with _p() @see below) is here to gracefully upgrade to setter/getter syntax where possible
			props = {
				/**
				The amount of milliseconds a request can take before being terminated. Initially zero. Zero means there is no timeout.

				@property timeout
				@type Number
				@default 0
				*/
				timeout: 0,

				/**
				Current state, can take following values:
				UNSENT (numeric value 0)
				The object has been constructed.

				OPENED (numeric value 1)
				The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the request can be made using the send() method.

				HEADERS_RECEIVED (numeric value 2)
				All redirects (if any) have been followed and all HTTP headers of the final response have been received. Several response members of the object are now available.

				LOADING (numeric value 3)
				The response entity body is being received.

				DONE (numeric value 4)

				@property readyState
				@type Number
				@default 0 (UNSENT)
				*/
				readyState: XMLHttpRequest.UNSENT,

				/**
				True when user credentials are to be included in a cross-origin request. False when they are to be excluded
				in a cross-origin request and when cookies are to be ignored in its response. Initially false.

				@property withCredentials
				@type Boolean
				@default false
				*/
				withCredentials: false,

				/**
				Returns the HTTP status code.

				@property status
				@type Number
				@default 0
				*/
				status: 0,

				/**
				Returns the HTTP status text.

				@property statusText
				@type String
				*/
				statusText: "",

				/**
				Returns the response type. Can be set to change the response type. Values are:
				the empty string (default), "arraybuffer", "blob", "document", "json", and "text".

				@property responseType
				@type String
				*/
				responseType: "",

				/**
				Returns the document response entity body.

				Throws an "InvalidStateError" exception if responseType is not the empty string or "document".

				@property responseXML
				@type Document
				*/
				responseXML: null,

				/**
				Returns the text response entity body.

				Throws an "InvalidStateError" exception if responseType is not the empty string or "text".

				@property responseText
				@type String
				*/
				responseText: null,

				/**
				Returns the response entity body (http://www.w3.org/TR/XMLHttpRequest/#response-entity-body).
				Can become: ArrayBuffer, Blob, Document, JSON, Text

				@property response
				@type Mixed
				*/
				response: null
			},

			_async = true,
			_url,
			_method,
			_headers = {},
			_user,
			_password,
			_encoding = null,
			_mimeType = null,

			// flags
			_sync_flag = false,
			_send_flag = false,
			_upload_events_flag = false,
			_upload_complete_flag = false,
			_error_flag = false,
			_same_origin_flag = false,

			// times
			_start_time,
			_timeoutset_time,

			_finalMime = null,
			_finalCharset = null,

			_options = {},
			_xhr,
			_responseHeaders = '',
			_responseHeadersBag
			;


		Basic.extend(this, props, {
			/**
			Unique id of the component

			@property uid
			@type String
			*/
			uid: Basic.guid('uid_'),

			/**
			Target for Upload events

			@property upload
			@type XMLHttpRequestUpload
			*/
			upload: new XMLHttpRequestUpload(),


			/**
			Sets the request method, request URL, synchronous flag, request username, and request password.

			Throws a "SyntaxError" exception if one of the following is true:

			method is not a valid HTTP method.
			url cannot be resolved.
			url contains the "user:password" format in the userinfo production.
			Throws a "SecurityError" exception if method is a case-insensitive match for CONNECT, TRACE or TRACK.

			Throws an "InvalidAccessError" exception if one of the following is true:

			Either user or password is passed as argument and the origin of url does not match the XMLHttpRequest origin.
			There is an associated XMLHttpRequest document and either the timeout attribute is not zero,
			the withCredentials attribute is true, or the responseType attribute is not the empty string.


			@method open
			@param {String} method HTTP method to use on request
			@param {String} url URL to request
			@param {Boolean} [async=true] If false request will be done in synchronous manner. Asynchronous by default.
			@param {String} [user] Username to use in HTTP authentication process on server-side
			@param {String} [password] Password to use in HTTP authentication process on server-side
			*/
			open: function(method, url, async, user, password) {
				var urlp;

				// first two arguments are required
				if (!method || !url) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 2 - check if any code point in method is higher than U+00FF or after deflating method it does not match the method
				if (/[\u0100-\uffff]/.test(method) || Encode.utf8_encode(method) !== method) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 3
				if (!!~Basic.inArray(method.toUpperCase(), ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'])) {
					_method = method.toUpperCase();
				}


				// 4 - allowing these methods poses a security risk
				if (!!~Basic.inArray(_method, ['CONNECT', 'TRACE', 'TRACK'])) {
					throw new x.DOMException(x.DOMException.SECURITY_ERR);
				}

				// 5
				url = Encode.utf8_encode(url);

				// 6 - Resolve url relative to the XMLHttpRequest base URL. If the algorithm returns an error, throw a "SyntaxError".
				urlp = Url.parseUrl(url);

				_same_origin_flag = Url.hasSameOrigin(urlp);

				// 7 - manually build up absolute url
				_url = Url.resolveUrl(url);

				// 9-10, 12-13
				if ((user || password) && !_same_origin_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				_user = user || urlp.user;
				_password = password || urlp.pass;

				// 11
				_async = async || true;

				if (_async === false && (_p('timeout') || _p('withCredentials') || _p('responseType') !== "")) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 14 - terminate abort()

				// 15 - terminate send()

				// 18
				_sync_flag = !_async;
				_send_flag = false;
				_headers = {};
				_reset.call(this);

				// 19
				_p('readyState', XMLHttpRequest.OPENED);

				// 20
				this.dispatchEvent('readystatechange');
			},

			/**
			Appends an header to the list of author request headers, or if header is already
			in the list of author request headers, combines its value with value.

			Throws an "InvalidStateError" exception if the state is not OPENED or if the send() flag is set.
			Throws a "SyntaxError" exception if header is not a valid HTTP header field name or if value
			is not a valid HTTP header field value.

			@method setRequestHeader
			@param {String} header
			@param {String|Number} value
			*/
			setRequestHeader: function(header, value) {
				var uaHeaders = [ // these headers are controlled by the user agent
						"accept-charset",
						"accept-encoding",
						"access-control-request-headers",
						"access-control-request-method",
						"connection",
						"content-length",
						"cookie",
						"cookie2",
						"content-transfer-encoding",
						"date",
						"expect",
						"host",
						"keep-alive",
						"origin",
						"referer",
						"te",
						"trailer",
						"transfer-encoding",
						"upgrade",
						"user-agent",
						"via"
					];

				// 1-2
				if (_p('readyState') !== XMLHttpRequest.OPENED || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3
				if (/[\u0100-\uffff]/.test(header) || Encode.utf8_encode(header) !== header) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 4
				/* this step is seemingly bypassed in browsers, probably to allow various unicode characters in header values
				if (/[\u0100-\uffff]/.test(value) || Encode.utf8_encode(value) !== value) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}*/

				header = Basic.trim(header).toLowerCase();

				// setting of proxy-* and sec-* headers is prohibited by spec
				if (!!~Basic.inArray(header, uaHeaders) || /^(proxy\-|sec\-)/.test(header)) {
					return false;
				}

				// camelize
				// browsers lowercase header names (at least for custom ones)
				// header = header.replace(/\b\w/g, function($1) { return $1.toUpperCase(); });

				if (!_headers[header]) {
					_headers[header] = value;
				} else {
					// http://tools.ietf.org/html/rfc2616#section-4.2 (last paragraph)
					_headers[header] += ', ' + value;
				}
				return true;
			},

			/**
			 * Test if the specified header is already set on this request.
			 * Returns a header value or boolean false if it's not yet set.
			 *
			 * @method hasRequestHeader
			 * @param {String} header Name of the header to test
			 * @return {Boolean|String}
			 */
			hasRequestHeader: function(header) {
				return header && _headers[header.toLowerCase()] || false;
			},

			/**
			Returns all headers from the response, with the exception of those whose field name is Set-Cookie or Set-Cookie2.

			@method getAllResponseHeaders
			@return {String} reponse headers or empty string
			*/
			getAllResponseHeaders: function() {
				return _responseHeaders || '';
			},

			/**
			Returns the header field value from the response of which the field name matches header,
			unless the field name is Set-Cookie or Set-Cookie2.

			@method getResponseHeader
			@param {String} header
			@return {String} value(s) for the specified header or null
			*/
			getResponseHeader: function(header) {
				header = header.toLowerCase();

				if (_error_flag || !!~Basic.inArray(header, ['set-cookie', 'set-cookie2'])) {
					return null;
				}

				if (_responseHeaders && _responseHeaders !== '') {
					// if we didn't parse response headers until now, do it and keep for later
					if (!_responseHeadersBag) {
						_responseHeadersBag = {};
						Basic.each(_responseHeaders.split(/\r\n/), function(line) {
							var pair = line.split(/:\s+/);
							if (pair.length === 2) { // last line might be empty, omit
								pair[0] = Basic.trim(pair[0]); // just in case
								_responseHeadersBag[pair[0].toLowerCase()] = { // simply to retain header name in original form
									header: pair[0],
									value: Basic.trim(pair[1])
								};
							}
						});
					}
					if (_responseHeadersBag.hasOwnProperty(header)) {
						return _responseHeadersBag[header].header + ': ' + _responseHeadersBag[header].value;
					}
				}
				return null;
			},

			/**
			Sets the Content-Type header for the response to mime.
			Throws an "InvalidStateError" exception if the state is LOADING or DONE.
			Throws a "SyntaxError" exception if mime is not a valid media type.

			@method overrideMimeType
			@param String mime Mime type to set
			*/
			overrideMimeType: function(mime) {
				var matches, charset;

				// 1
				if (!!~Basic.inArray(_p('readyState'), [XMLHttpRequest.LOADING, XMLHttpRequest.DONE])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2
				mime = Basic.trim(mime.toLowerCase());

				if (/;/.test(mime) && (matches = mime.match(/^([^;]+)(?:;\scharset\=)?(.*)$/))) {
					mime = matches[1];
					if (matches[2]) {
						charset = matches[2];
					}
				}

				if (!Mime.mimes[mime]) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 3-4
				_finalMime = mime;
				_finalCharset = charset;
			},

			/**
			Initiates the request. The optional argument provides the request entity body.
			The argument is ignored if request method is GET or HEAD.

			Throws an "InvalidStateError" exception if the state is not OPENED or if the send() flag is set.

			@method send
			@param {Blob|Document|String|FormData} [data] Request entity body
			@param {Object} [options] Set of requirements and pre-requisities for runtime initialization
			*/
			send: function(data, options) {
				if (Basic.typeOf(options) === 'string') {
					_options = { ruid: options };
				} else if (!options) {
					_options = {};
				} else {
					_options = options;
				}

				// 1-2
				if (this.readyState !== XMLHttpRequest.OPENED || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3
				// sending Blob
				if (data instanceof Blob) {
					_options.ruid = data.ruid;
					_mimeType = data.type || 'application/octet-stream';
				}

				// FormData
				else if (data instanceof FormData) {
					if (data.hasBlob()) {
						var blob = data.getBlob();
						_options.ruid = blob.ruid;
						_mimeType = blob.type || 'application/octet-stream';
					}
				}

				// DOMString
				else if (typeof data === 'string') {
					_encoding = 'UTF-8';
					_mimeType = 'text/plain;charset=UTF-8';

					// data should be converted to Unicode and encoded as UTF-8
					data = Encode.utf8_encode(data);
				}

				// if withCredentials not set, but requested, set it automatically
				if (!this.withCredentials) {
					this.withCredentials = (_options.required_caps && _options.required_caps.send_browser_cookies) && !_same_origin_flag;
				}

				// 4 - storage mutex
				// 5
				_upload_events_flag = (!_sync_flag && this.upload.hasEventListener()); // DSAP
				// 6
				_error_flag = false;
				// 7
				_upload_complete_flag = !data;
				// 8 - Asynchronous steps
				if (!_sync_flag) {
					// 8.1
					_send_flag = true;
					// 8.2
					// this.dispatchEvent('loadstart'); // will be dispatched either by native or runtime xhr
					// 8.3
					//if (!_upload_complete_flag) {
						// this.upload.dispatchEvent('loadstart');	// will be dispatched either by native or runtime xhr
					//}
				}
				// 8.5 - Return the send() method call, but continue running the steps in this algorithm.
				_doXHR.call(this, data);
			},

			/**
			Cancels any network activity.

			@method abort
			*/
			abort: function() {
				_error_flag = true;
				_sync_flag = false;

				if (!~Basic.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED, XMLHttpRequest.DONE])) {
					_p('readyState', XMLHttpRequest.DONE);
					_send_flag = false;

					if (_xhr) {
						_xhr.getRuntime().exec.call(_xhr, 'XMLHttpRequest', 'abort', _upload_complete_flag);
					} else {
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}

					_upload_complete_flag = true;
				} else {
					_p('readyState', XMLHttpRequest.UNSENT);
				}
			},

			destroy: function() {
				if (_xhr) {
					if (Basic.typeOf(_xhr.destroy) === 'function') {
						_xhr.destroy();
					}
					_xhr = null;
				}

				this.unbindAll();

				if (this.upload) {
					this.upload.unbindAll();
					this.upload = null;
				}
			}
		});

		this.handleEventProps(dispatches.concat(['readystatechange'])); // for historical reasons
		this.upload.handleEventProps(dispatches);

		/* this is nice, but maybe too lengthy

		// if supported by JS version, set getters/setters for specific properties
		o.defineProperty(this, 'readyState', {
			configurable: false,

			get: function() {
				return _p('readyState');
			}
		});

		o.defineProperty(this, 'timeout', {
			configurable: false,

			get: function() {
				return _p('timeout');
			},

			set: function(value) {

				if (_sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// timeout still should be measured relative to the start time of request
				_timeoutset_time = (new Date).getTime();

				_p('timeout', value);
			}
		});

		// the withCredentials attribute has no effect when fetching same-origin resources
		o.defineProperty(this, 'withCredentials', {
			configurable: false,

			get: function() {
				return _p('withCredentials');
			},

			set: function(value) {
				// 1-2
				if (!~o.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED]) || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3-4
				if (_anonymous_flag || _sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 5
				_p('withCredentials', value);
			}
		});

		o.defineProperty(this, 'status', {
			configurable: false,

			get: function() {
				return _p('status');
			}
		});

		o.defineProperty(this, 'statusText', {
			configurable: false,

			get: function() {
				return _p('statusText');
			}
		});

		o.defineProperty(this, 'responseType', {
			configurable: false,

			get: function() {
				return _p('responseType');
			},

			set: function(value) {
				// 1
				if (!!~o.inArray(_p('readyState'), [XMLHttpRequest.LOADING, XMLHttpRequest.DONE])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2
				if (_sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 3
				_p('responseType', value.toLowerCase());
			}
		});

		o.defineProperty(this, 'responseText', {
			configurable: false,

			get: function() {
				// 1
				if (!~o.inArray(_p('responseType'), ['', 'text'])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2-3
				if (_p('readyState') !== XMLHttpRequest.DONE && _p('readyState') !== XMLHttpRequest.LOADING || _error_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				return _p('responseText');
			}
		});

		o.defineProperty(this, 'responseXML', {
			configurable: false,

			get: function() {
				// 1
				if (!~o.inArray(_p('responseType'), ['', 'document'])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2-3
				if (_p('readyState') !== XMLHttpRequest.DONE || _error_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				return _p('responseXML');
			}
		});

		o.defineProperty(this, 'response', {
			configurable: false,

			get: function() {
				if (!!~o.inArray(_p('responseType'), ['', 'text'])) {
					if (_p('readyState') !== XMLHttpRequest.DONE && _p('readyState') !== XMLHttpRequest.LOADING || _error_flag) {
						return '';
					}
				}

				if (_p('readyState') !== XMLHttpRequest.DONE || _error_flag) {
					return null;
				}

				return _p('response');
			}
		});

		*/

		function _p(prop, value) {
			if (!props.hasOwnProperty(prop)) {
				return;
			}
			if (arguments.length === 1) { // get
				return Env.can('define_property') ? props[prop] : self[prop];
			} else { // set
				if (Env.can('define_property')) {
					props[prop] = value;
				} else {
					self[prop] = value;
				}
			}
		}

		/*
		function _toASCII(str, AllowUnassigned, UseSTD3ASCIIRules) {
			// TODO: http://tools.ietf.org/html/rfc3490#section-4.1
			return str.toLowerCase();
		}
		*/


		function _doXHR(data) {
			var self = this;

			_start_time = new Date().getTime();

			_xhr = new RuntimeTarget();

			function loadEnd() {
				if (_xhr) { // it could have been destroyed by now
					_xhr.destroy();
					_xhr = null;
				}
				self.dispatchEvent('loadend');
				self = null;
			}

			function exec(runtime) {
				_xhr.bind('LoadStart', function(e) {
					_p('readyState', XMLHttpRequest.LOADING);
					self.dispatchEvent('readystatechange');

					self.dispatchEvent(e);

					if (_upload_events_flag) {
						self.upload.dispatchEvent(e);
					}
				});

				_xhr.bind('Progress', function(e) {
					if (_p('readyState') !== XMLHttpRequest.LOADING) {
						_p('readyState', XMLHttpRequest.LOADING); // LoadStart unreliable (in Flash for example)
						self.dispatchEvent('readystatechange');
					}
					self.dispatchEvent(e);
				});

				_xhr.bind('UploadProgress', function(e) {
					if (_upload_events_flag) {
						self.upload.dispatchEvent({
							type: 'progress',
							lengthComputable: false,
							total: e.total,
							loaded: e.loaded
						});
					}
				});

				_xhr.bind('Load', function(e) {
					_p('readyState', XMLHttpRequest.DONE);
					_p('status', Number(runtime.exec.call(_xhr, 'XMLHttpRequest', 'getStatus') || 0));
					_p('statusText', httpCode[_p('status')] || "");

					_p('response', runtime.exec.call(_xhr, 'XMLHttpRequest', 'getResponse', _p('responseType')));

					if (!!~Basic.inArray(_p('responseType'), ['text', ''])) {
						_p('responseText', _p('response'));
					} else if (_p('responseType') === 'document') {
						_p('responseXML', _p('response'));
					}

					_responseHeaders = runtime.exec.call(_xhr, 'XMLHttpRequest', 'getAllResponseHeaders');

					self.dispatchEvent('readystatechange');

					if (_p('status') > 0) { // status 0 usually means that server is unreachable
						if (_upload_events_flag) {
							self.upload.dispatchEvent(e);
						}
						self.dispatchEvent(e);
					} else {
						_error_flag = true;
						self.dispatchEvent('error');
					}
					loadEnd();
				});

				_xhr.bind('Abort', function(e) {
					self.dispatchEvent(e);
					loadEnd();
				});

				_xhr.bind('Error', function(e) {
					_error_flag = true;
					_p('readyState', XMLHttpRequest.DONE);
					self.dispatchEvent('readystatechange');
					_upload_complete_flag = true;
					self.dispatchEvent(e);
					loadEnd();
				});

				runtime.exec.call(_xhr, 'XMLHttpRequest', 'send', {
					url: _url,
					method: _method,
					async: _async,
					user: _user,
					password: _password,
					headers: _headers,
					mimeType: _mimeType,
					encoding: _encoding,
					responseType: self.responseType,
					withCredentials: self.withCredentials,
					options: _options
				}, data);
			}

			// clarify our requirements
			if (typeof(_options.required_caps) === 'string') {
				_options.required_caps = Runtime.parseCaps(_options.required_caps);
			}

			_options.required_caps = Basic.extend({}, _options.required_caps, {
				return_response_type: self.responseType
			});

			if (data instanceof FormData) {
				_options.required_caps.send_multipart = true;
			}

			if (!Basic.isEmptyObj(_headers)) {
				_options.required_caps.send_custom_headers = true;
			}

			if (!_same_origin_flag) {
				_options.required_caps.do_cors = true;
			}


			if (_options.ruid) { // we do not need to wait if we can connect directly
				exec(_xhr.connectRuntime(_options));
			} else {
				_xhr.bind('RuntimeInit', function(e, runtime) {
					exec(runtime);
				});
				_xhr.bind('RuntimeError', function(e, err) {
					self.dispatchEvent('RuntimeError', err);
				});
				_xhr.connectRuntime(_options);
			}
		}


		function _reset() {
			_p('responseText', "");
			_p('responseXML', null);
			_p('response', null);
			_p('status', 0);
			_p('statusText', "");
			_start_time = _timeoutset_time = null;
		}
	}

	XMLHttpRequest.UNSENT = 0;
	XMLHttpRequest.OPENED = 1;
	XMLHttpRequest.HEADERS_RECEIVED = 2;
	XMLHttpRequest.LOADING = 3;
	XMLHttpRequest.DONE = 4;

	XMLHttpRequest.prototype = EventTarget.instance;

	return XMLHttpRequest;
});

// Included from: src/javascript/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/runtime/Transporter", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Encode",
	"moxie/runtime/RuntimeClient",
	"moxie/core/EventTarget"
], function(Basic, Encode, RuntimeClient, EventTarget) {

	/**
	@class moxie/runtime/Transporter
	@constructor
	*/
	function Transporter() {
		var mod, _runtime, _data, _size, _pos, _chunk_size;

		RuntimeClient.call(this);

		Basic.extend(this, {
			uid: Basic.guid('uid_'),

			state: Transporter.IDLE,

			result: null,

			transport: function(data, type, options) {
				var self = this;

				options = Basic.extend({
					chunk_size: 204798
				}, options);

				// should divide by three, base64 requires this
				if ((mod = options.chunk_size % 3)) {
					options.chunk_size += 3 - mod;
				}

				_chunk_size = options.chunk_size;

				_reset.call(this);
				_data = data;
				_size = data.length;

				if (Basic.typeOf(options) === 'string' || options.ruid) {
					_run.call(self, type, this.connectRuntime(options));
				} else {
					// we require this to run only once
					var cb = function(e, runtime) {
						self.unbind("RuntimeInit", cb);
						_run.call(self, type, runtime);
					};
					this.bind("RuntimeInit", cb);
					this.connectRuntime(options);
				}
			},

			abort: function() {
				var self = this;

				self.state = Transporter.IDLE;
				if (_runtime) {
					_runtime.exec.call(self, 'Transporter', 'clear');
					self.trigger("TransportingAborted");
				}

				_reset.call(self);
			},


			destroy: function() {
				this.unbindAll();
				_runtime = null;
				this.disconnectRuntime();
				_reset.call(this);
			}
		});

		function _reset() {
			_size = _pos = 0;
			_data = this.result = null;
		}

		function _run(type, runtime) {
			var self = this;

			_runtime = runtime;

			//self.unbind("RuntimeInit");

			self.bind("TransportingProgress", function(e) {
				_pos = e.loaded;

				if (_pos < _size && Basic.inArray(self.state, [Transporter.IDLE, Transporter.DONE]) === -1) {
					_transport.call(self);
				}
			}, 999);

			self.bind("TransportingComplete", function() {
				_pos = _size;
				self.state = Transporter.DONE;
				_data = null; // clean a bit
				self.result = _runtime.exec.call(self, 'Transporter', 'getAsBlob', type || '');
			}, 999);

			self.state = Transporter.BUSY;
			self.trigger("TransportingStarted");
			_transport.call(self);
		}

		function _transport() {
			var self = this,
				chunk,
				bytesLeft = _size - _pos;

			if (_chunk_size > bytesLeft) {
				_chunk_size = bytesLeft;
			}

			chunk = Encode.btoa(_data.substr(_pos, _chunk_size));
			_runtime.exec.call(self, 'Transporter', 'receive', chunk, _size);
		}
	}

	Transporter.IDLE = 0;
	Transporter.BUSY = 1;
	Transporter.DONE = 2;

	Transporter.prototype = EventTarget.instance;

	return Transporter;
});

// Included from: src/javascript/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/image/Image", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/file/FileReaderSync",
	"moxie/xhr/XMLHttpRequest",
	"moxie/runtime/Runtime",
	"moxie/runtime/RuntimeClient",
	"moxie/runtime/Transporter",
	"moxie/core/utils/Env",
	"moxie/core/EventTarget",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/core/utils/Encode"
], function(Basic, Dom, x, FileReaderSync, XMLHttpRequest, Runtime, RuntimeClient, Transporter, Env, EventTarget, Blob, File, Encode) {
	/**
	Image preloading and manipulation utility. Additionally it provides access to image meta info (Exif, GPS) and raw binary data.

	@class moxie/image/Image
	@constructor
	@extends EventTarget
	*/
	var dispatches = [
		'progress',

		/**
		Dispatched when loading is complete.

		@event load
		@param {Object} event
		*/
		'load',

		'error',

		/**
		Dispatched when resize operation is complete.
		
		@event resize
		@param {Object} event
		*/
		'resize',

		/**
		Dispatched when visual representation of the image is successfully embedded
		into the corresponsing container.

		@event embedded
		@param {Object} event
		*/
		'embedded'
	];

	function Image() {

		RuntimeClient.call(this);

		Basic.extend(this, {
			/**
			Unique id of the component

			@property uid
			@type {String}
			*/
			uid: Basic.guid('uid_'),

			/**
			Unique id of the connected runtime, if any.

			@property ruid
			@type {String}
			*/
			ruid: null,

			/**
			Name of the file, that was used to create an image, if available. If not equals to empty string.

			@property name
			@type {String}
			@default ""
			*/
			name: "",

			/**
			Size of the image in bytes. Actual value is set only after image is preloaded.

			@property size
			@type {Number}
			@default 0
			*/
			size: 0,

			/**
			Width of the image. Actual value is set only after image is preloaded.

			@property width
			@type {Number}
			@default 0
			*/
			width: 0,

			/**
			Height of the image. Actual value is set only after image is preloaded.

			@property height
			@type {Number}
			@default 0
			*/
			height: 0,

			/**
			Mime type of the image. Currently only image/jpeg and image/png are supported. Actual value is set only after image is preloaded.

			@property type
			@type {String}
			@default ""
			*/
			type: "",

			/**
			Holds meta info (Exif, GPS). Is populated only for image/jpeg. Actual value is set only after image is preloaded.

			@property meta
			@type {Object}
			@default {}
			*/
			meta: {},

			/**
			Alias for load method, that takes another mOxie.Image object as a source (see load).

			@method clone
			@param {Image} src Source for the image
			@param {Boolean} [exact=false] Whether to activate in-depth clone mode
			*/
			clone: function() {
				this.load.apply(this, arguments);
			},

			/**
			Loads image from various sources. Currently the source for new image can be: mOxie.Image, mOxie.Blob/mOxie.File, 
			native Blob/File, dataUrl or URL. Depending on the type of the source, arguments - differ. When source is URL, 
			Image will be downloaded from remote destination and loaded in memory.

			@example
				var img = new mOxie.Image();
				img.onload = function() {
					var blob = img.getAsBlob();
					
					var formData = new mOxie.FormData();
					formData.append('file', blob);

					var xhr = new mOxie.XMLHttpRequest();
					xhr.onload = function() {
						// upload complete
					};
					xhr.open('post', 'upload.php');
					xhr.send(formData);
				};
				img.load("http://www.moxiecode.com/images/mox-logo.jpg"); // notice file extension (.jpg)
			

			@method load
			@param {Image|Blob|File|String} src Source for the image
			@param {Boolean|Object} [mixed]
			*/
			load: function() {
				_load.apply(this, arguments);
			},


			/**
			Resizes the image to fit the specified width/height. If crop is specified, image will also be 
			cropped to the exact dimensions.

			@method resize
			@since 3.0
			@param {Object} options
				@param {Number} options.width Resulting width
				@param {Number} [options.height=width] Resulting height (optional, if not supplied will default to width)
				@param {String} [options.type='image/jpeg'] MIME type of the resulting image
				@param {Number} [options.quality=90] In the case of JPEG, controls the quality of resulting image
				@param {Boolean} [options.crop='cc'] If not falsy, image will be cropped, by default from center
				@param {Boolean} [options.fit=true] In case of crop whether to upscale the image to fit the exact dimensions
				@param {Boolean} [options.preserveHeaders=true] Whether to preserve meta headers (on JPEGs after resize)
				@param {String} [options.resample='default'] Resampling algorithm to use during resize
				@param {Boolean} [options.multipass=true] Whether to scale the image in steps (results in better quality)
			*/
			resize: function(options) {
				var self = this;
				var orientation;
				var scale;

				var srcRect = {
					x: 0,
					y: 0,
					width: self.width,
					height: self.height
				};

				var opts = Basic.extendIf({
					width: self.width,
					height: self.height,
					type: self.type || 'image/jpeg',
					quality: 90,
					crop: false,
					fit: true,
					preserveHeaders: true,
					resample: 'default',
					multipass: true
				}, options);

				try {
					if (!self.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}

					// no way to reliably intercept the crash due to high resolution, so we simply avoid it
					if (self.width > Image.MAX_RESIZE_WIDTH || self.height > Image.MAX_RESIZE_HEIGHT) {
						throw new x.ImageError(x.ImageError.MAX_RESOLUTION_ERR);
					}

					// take into account orientation tag
					orientation = (self.meta && self.meta.tiff && self.meta.tiff.Orientation) || 1;

					if (Basic.inArray(orientation, [5,6,7,8]) !== -1) { // values that require 90 degree rotation
						var tmp = opts.width;
						opts.width = opts.height;
						opts.height = tmp;
					}

					if (opts.crop) {
						scale = Math.max(opts.width/self.width, opts.height/self.height);

						if (options.fit) {
							// first scale it up or down to fit the original image
							srcRect.width = Math.min(Math.ceil(opts.width/scale), self.width);
							srcRect.height = Math.min(Math.ceil(opts.height/scale), self.height);
							
							// recalculate the scale for adapted dimensions
							scale = opts.width/srcRect.width;
						} else {
							srcRect.width = Math.min(opts.width, self.width);
							srcRect.height = Math.min(opts.height, self.height);

							// now we do not need to scale it any further
							scale = 1; 
						}

						if (typeof(opts.crop) === 'boolean') {
							opts.crop = 'cc';
						}

						switch (opts.crop.toLowerCase().replace(/_/, '-')) {
							case 'rb':
							case 'right-bottom':
								srcRect.x = self.width - srcRect.width;
								srcRect.y = self.height - srcRect.height;
								break;

							case 'cb':
							case 'center-bottom':
								srcRect.x = Math.floor((self.width - srcRect.width) / 2);
								srcRect.y = self.height - srcRect.height;
								break;

							case 'lb':
							case 'left-bottom':
								srcRect.x = 0;
								srcRect.y = self.height - srcRect.height;
								break;

							case 'lt':
							case 'left-top':
								srcRect.x = 0;
								srcRect.y = 0;
								break;

							case 'ct':
							case 'center-top':
								srcRect.x = Math.floor((self.width - srcRect.width) / 2);
								srcRect.y = 0;
								break;

							case 'rt':
							case 'right-top':
								srcRect.x = self.width - srcRect.width;
								srcRect.y = 0;
								break;

							case 'rc':
							case 'right-center':
							case 'right-middle':
								srcRect.x = self.width - srcRect.width;
								srcRect.y = Math.floor((self.height - srcRect.height) / 2);
								break;


							case 'lc':
							case 'left-center':
							case 'left-middle':
								srcRect.x = 0;
								srcRect.y = Math.floor((self.height - srcRect.height) / 2);
								break;

							case 'cc':
							case 'center-center':
							case 'center-middle':
							default:
								srcRect.x = Math.floor((self.width - srcRect.width) / 2);
								srcRect.y = Math.floor((self.height - srcRect.height) / 2);
						}

						// original image might be smaller than requested crop, so - avoid negative values
						srcRect.x = Math.max(srcRect.x, 0);
						srcRect.y = Math.max(srcRect.y, 0);
					} else {
						scale = Math.min(opts.width/self.width, opts.height/self.height);
					}

					this.exec('Image', 'resize', srcRect, scale, opts);
				} catch(ex) {
					// for now simply trigger error event
					self.trigger('error', ex.code);
				}
			},

			/**
			Downsizes the image to fit the specified width/height. If crop is supplied, image will be cropped to exact dimensions.

			@method downsize
			@deprecated use resize()
			*/
			downsize: function(options) {
				var defaults = {
					width: this.width,
					height: this.height,
					type: this.type || 'image/jpeg',
					quality: 90,
					crop: false,
					preserveHeaders: true,
					resample: 'default'
				}, opts;

				if (typeof(options) === 'object') {
					opts = Basic.extend(defaults, options);
				} else {
					// for backward compatibility
					opts = Basic.extend(defaults, {
						width: arguments[0],
						height: arguments[1],
						crop: arguments[2],
						preserveHeaders: arguments[3]
					});
				}

				this.resize(opts);
			},

			/**
			Alias for downsize(width, height, true). (see downsize)
			
			@method crop
			@param {Number} width Resulting width
			@param {Number} [height=width] Resulting height (optional, if not supplied will default to width)
			@param {Boolean} [preserveHeaders=true] Whether to preserve meta headers (on JPEGs after resize)
			*/
			crop: function(width, height, preserveHeaders) {
				this.downsize(width, height, true, preserveHeaders);
			},

			getAsCanvas: function() {
				if (!Env.can('create_canvas')) {
					throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
				}
				return this.exec('Image', 'getAsCanvas');
			},

			/**
			Retrieves image in it's current state as mOxie.Blob object. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsBlob
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {Blob} Image as Blob
			*/
			getAsBlob: function(type, quality) {
				if (!this.size) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}
				return this.exec('Image', 'getAsBlob', type || 'image/jpeg', quality || 90);
			},

			/**
			Retrieves image in it's current state as dataURL string. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsDataURL
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {String} Image as dataURL string
			*/
			getAsDataURL: function(type, quality) {
				if (!this.size) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}
				return this.exec('Image', 'getAsDataURL', type || 'image/jpeg', quality || 90);
			},

			/**
			Retrieves image in it's current state as binary string. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsBinaryString
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {String} Image as binary string
			*/
			getAsBinaryString: function(type, quality) {
				var dataUrl = this.getAsDataURL(type, quality);
				return Encode.atob(dataUrl.substring(dataUrl.indexOf('base64,') + 7));
			},

			/**
			Embeds a visual representation of the image into the specified node. Depending on the runtime, 
			it might be a canvas, an img node or a thrid party shim object (Flash or SilverLight - very rare, 
			can be used in legacy browsers that do not have canvas or proper dataURI support).

			@method embed
			@param {DOMElement} el DOM element to insert the image object into
			@param {Object} [options]
				@param {Number} [options.width] The width of an embed (defaults to the image width)
				@param {Number} [options.height] The height of an embed (defaults to the image height)
				@param {String} [options.type="image/jpeg"] Mime type
				@param {Number} [options.quality=90] Quality of an embed, if mime type is image/jpeg
				@param {Boolean} [options.crop=false] Whether to crop an embed to the specified dimensions
			*/
			embed: function(el, options) {
				var self = this
				, runtime // this has to be outside of all the closures to contain proper runtime
				;

				var opts = Basic.extend({
					width: this.width,
					height: this.height,
					type: this.type || 'image/jpeg',
					quality: 90
				}, options);
				

				function render(type, quality) {
					var img = this;

					// if possible, embed a canvas element directly
					if (Env.can('create_canvas')) {
						var canvas = img.getAsCanvas();
						if (canvas) {
							el.appendChild(canvas);
							canvas = null;
							img.destroy();
							self.trigger('embedded');
							return;
						}
					}

					var dataUrl = img.getAsDataURL(type, quality);
					if (!dataUrl) {
						throw new x.ImageError(x.ImageError.WRONG_FORMAT);
					}

					if (Env.can('use_data_uri_of', dataUrl.length)) {
						el.innerHTML = '<img src="' + dataUrl + '" width="' + img.width + '" height="' + img.height + '" />';
						img.destroy();
						self.trigger('embedded');
					} else {
						var tr = new Transporter();

						tr.bind("TransportingComplete", function() {
							runtime = self.connectRuntime(this.result.ruid);

							self.bind("Embedded", function() {
								// position and size properly
								Basic.extend(runtime.getShimContainer().style, {
									//position: 'relative',
									top: '0px',
									left: '0px',
									width: img.width + 'px',
									height: img.height + 'px'
								});

								// some shims (Flash/SilverLight) reinitialize, if parent element is hidden, reordered or it's
								// position type changes (in Gecko), but since we basically need this only in IEs 6/7 and
								// sometimes 8 and they do not have this problem, we can comment this for now
								/*tr.bind("RuntimeInit", function(e, runtime) {
									tr.destroy();
									runtime.destroy();
									onResize.call(self); // re-feed our image data
								});*/

								runtime = null; // release
							}, 999);

							runtime.exec.call(self, "ImageView", "display", this.result.uid, width, height);
							img.destroy();
						});

						tr.transport(Encode.atob(dataUrl.substring(dataUrl.indexOf('base64,') + 7)), type, {
							required_caps: {
								display_media: true
							},
							runtime_order: 'flash,silverlight',
							container: el
						});
					}
				}

				try {
					if (!(el = Dom.get(el))) {
						throw new x.DOMException(x.DOMException.INVALID_NODE_TYPE_ERR);
					}

					if (!this.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}
					
					// high-resolution images cannot be consistently handled across the runtimes
					if (this.width > Image.MAX_RESIZE_WIDTH || this.height > Image.MAX_RESIZE_HEIGHT) {
						//throw new x.ImageError(x.ImageError.MAX_RESOLUTION_ERR);
					}

					var imgCopy = new Image();

					imgCopy.bind("Resize", function() {
						render.call(this, opts.type, opts.quality);
					});

					imgCopy.bind("Load", function() {
						this.downsize(opts);
					});

					// if embedded thumb data is available and dimensions are big enough, use it
					if (this.meta.thumb && this.meta.thumb.width >= opts.width && this.meta.thumb.height >= opts.height) {
						imgCopy.load(this.meta.thumb.data);
					} else {
						imgCopy.clone(this, false);
					}

					return imgCopy;
				} catch(ex) {
					// for now simply trigger error event
					this.trigger('error', ex.code);
				}
			},

			/**
			Properly destroys the image and frees resources in use. If any. Recommended way to dispose mOxie.Image object.

			@method destroy
			*/
			destroy: function() {
				if (this.ruid) {
					this.getRuntime().exec.call(this, 'Image', 'destroy');
					this.disconnectRuntime();
				}
				if (this.meta && this.meta.thumb) {
					// thumb is blob, make sure we destroy it first
					this.meta.thumb.data.destroy();
				}
				this.unbindAll();
			}
		});


		// this is here, because in order to bind properly, we need uid, which is created above
		this.handleEventProps(dispatches);

		this.bind('Load Resize', function() {
			return _updateInfo.call(this); // if operation fails (e.g. image is neither PNG nor JPEG) cancel all pending events
		}, 999);


		function _updateInfo(info) {
			try {
				if (!info) {
					info = this.exec('Image', 'getInfo');
				}

				this.size = info.size;
				this.width = info.width;
				this.height = info.height;
				this.type = info.type;
				this.meta = info.meta;

				// update file name, only if empty
				if (this.name === '') {
					this.name = info.name;
				}

				return true;
			} catch(ex) {
				this.trigger('error', ex.code);
				return false;
			}
		}


		function _load(src) {
			var srcType = Basic.typeOf(src);

			try {
				// if source is Image
				if (src instanceof Image) {
					if (!src.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}
					_loadFromImage.apply(this, arguments);
				}
				// if source is o.Blob/o.File
				else if (src instanceof Blob) {
					if (!~Basic.inArray(src.type, ['image/jpeg', 'image/png'])) {
						throw new x.ImageError(x.ImageError.WRONG_FORMAT);
					}
					_loadFromBlob.apply(this, arguments);
				}
				// if native blob/file
				else if (Basic.inArray(srcType, ['blob', 'file']) !== -1) {
					_load.call(this, new File(null, src), arguments[1]);
				}
				// if String
				else if (srcType === 'string') {
					// if dataUrl String
					if (src.substr(0, 5) === 'data:') {
						_load.call(this, new Blob(null, { data: src }), arguments[1]);
					}
					// else assume Url, either relative or absolute
					else {
						_loadFromUrl.apply(this, arguments);
					}
				}
				// if source seems to be an img node
				else if (srcType === 'node' && src.nodeName.toLowerCase() === 'img') {
					_load.call(this, src.src, arguments[1]);
				}
				else {
					throw new x.DOMException(x.DOMException.TYPE_MISMATCH_ERR);
				}
			} catch(ex) {
				// for now simply trigger error event
				this.trigger('error', ex.code);
			}
		}


		function _loadFromImage(img, exact) {
			var runtime = this.connectRuntime(img.ruid);
			this.ruid = runtime.uid;
			runtime.exec.call(this, 'Image', 'loadFromImage', img, (Basic.typeOf(exact) === 'undefined' ? true : exact));
		}


		function _loadFromBlob(blob, options) {
			var self = this;

			self.name = blob.name || '';

			function exec(runtime) {
				self.ruid = runtime.uid;
				runtime.exec.call(self, 'Image', 'loadFromBlob', blob);
			}

			if (blob.isDetached()) {
				this.bind('RuntimeInit', function(e, runtime) {
					exec(runtime);
				});

				// convert to object representation
				if (options && typeof(options.required_caps) === 'string') {
					options.required_caps = Runtime.parseCaps(options.required_caps);
				}

				this.connectRuntime(Basic.extend({
					required_caps: {
						access_image_binary: true,
						resize_image: true
					}
				}, options));
			} else {
				exec(this.connectRuntime(blob.ruid));
			}
		}


		function _loadFromUrl(url, options) {
			var self = this, xhr;

			xhr = new XMLHttpRequest();

			xhr.open('get', url);
			xhr.responseType = 'blob';

			xhr.onprogress = function(e) {
				self.trigger(e);
			};

			xhr.onload = function() {
				_loadFromBlob.call(self, xhr.response, true);
			};

			xhr.onerror = function(e) {
				self.trigger(e);
			};

			xhr.onloadend = function() {
				xhr.destroy();
			};

			xhr.bind('RuntimeError', function(e, err) {
				self.trigger('RuntimeError', err);
			});

			xhr.send(null, options);
		}
	}

	// virtual world will crash on you if image has a resolution higher than this:
	Image.MAX_RESIZE_WIDTH = 8192;
	Image.MAX_RESIZE_HEIGHT = 8192; 

	Image.prototype = EventTarget.instance;

	return Image;
});

// Included from: src/javascript/runtime/html5/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global File:true */

/**
Defines constructor for HTML5 runtime.

@class moxie/runtime/html5/Runtime
@private
*/
define("moxie/runtime/html5/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime",
	"moxie/core/utils/Env"
], function(Basic, x, Runtime, Env) {
	
	var type = "html5", extensions = {};
	
	function Html5Runtime(options) {
		var I = this
		, Test = Runtime.capTest
		, True = Runtime.capTrue
		;

		var caps = Basic.extend({
				access_binary: Test(window.FileReader || window.File && window.File.getAsDataURL),
				access_image_binary: function() {
					return I.can('access_binary') && !!extensions.Image;
				},
				display_media: Test(
					(Env.can('create_canvas') || Env.can('use_data_uri_over32kb')) && 
					defined('moxie/image/Image')
				),
				do_cors: Test(window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()),
				drag_and_drop: Test(function() {
					// this comes directly from Modernizr: http://www.modernizr.com/
					var div = document.createElement('div');
					// IE has support for drag and drop since version 5, but doesn't support dropping files from desktop
					return (('draggable' in div) || ('ondragstart' in div && 'ondrop' in div)) && 
						(Env.browser !== 'IE' || Env.verComp(Env.version, 9, '>'));
				}()),
				filter_by_extension: Test(function() { // if you know how to feature-detect this, please suggest
					return !(
						(Env.browser === 'Chrome' && Env.verComp(Env.version, 28, '<')) || 
						(Env.browser === 'IE' && Env.verComp(Env.version, 10, '<')) || 
						(Env.browser === 'Safari' && Env.verComp(Env.version, 7, '<')) ||
						(Env.browser === 'Firefox' && Env.verComp(Env.version, 37, '<'))
					);
				}()),
				return_response_headers: True,
				return_response_type: function(responseType) {
					if (responseType === 'json' && !!window.JSON) { // we can fake this one even if it's not supported
						return true;
					} 
					return Env.can('return_response_type', responseType);
				},
				return_status_code: True,
				report_upload_progress: Test(window.XMLHttpRequest && new XMLHttpRequest().upload),
				resize_image: function() {
					return I.can('access_binary') && Env.can('create_canvas');
				},
				select_file: function() {
					return Env.can('use_fileinput') && window.File;
				},
				select_folder: function() {
					return I.can('select_file') && (
						Env.browser === 'Chrome' && Env.verComp(Env.version, 21, '>=') ||
						Env.browser === 'Firefox' && Env.verComp(Env.version, 42, '>=') // https://developer.mozilla.org/en-US/Firefox/Releases/42
					);
				},
				select_multiple: function() {
					// it is buggy on Safari Windows and iOS
					return I.can('select_file') &&
						!(Env.browser === 'Safari' && Env.os === 'Windows') &&
						!(Env.os === 'iOS' && Env.verComp(Env.osVersion, "7.0.0", '>') && Env.verComp(Env.osVersion, "8.0.0", '<'));
				},
				send_binary_string: Test(window.XMLHttpRequest && (new XMLHttpRequest().sendAsBinary || (window.Uint8Array && window.ArrayBuffer))),
				send_custom_headers: Test(window.XMLHttpRequest),
				send_multipart: function() {
					return !!(window.XMLHttpRequest && new XMLHttpRequest().upload && window.FormData) || I.can('send_binary_string');
				},
				slice_blob: Test(window.File && (File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice)),
				stream_upload: function(){
					return I.can('slice_blob') && I.can('send_multipart');
				},
				summon_file_dialog: function() { // yeah... some dirty sniffing here...
					return I.can('select_file') && (
						(Env.browser === 'Firefox' && Env.verComp(Env.version, 4, '>=')) ||
						(Env.browser === 'Opera' && Env.verComp(Env.version, 12, '>=')) ||
						(Env.browser === 'IE' && Env.verComp(Env.version, 10, '>=')) ||
						!!~Basic.inArray(Env.browser, ['Chrome', 'Safari', 'Edge'])
					);
				},
				upload_filesize: True,
				use_http_method: True
			}, 
			arguments[2]
		);

		Runtime.call(this, options, (arguments[1] || type), caps);


		Basic.extend(this, {

			init : function() {
				this.trigger("Init");
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					destroy = I = null;
				};
			}(this.destroy))
		});

		Basic.extend(this.getShim(), extensions);
	}

	Runtime.addConstructor(type, Html5Runtime);

	return extensions;
});

// Included from: src/javascript/runtime/html5/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/Blob
@private
*/
define("moxie/runtime/html5/file/Blob", [
	"moxie/runtime/html5/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	function HTML5Blob() {
		function w3cBlobSlice(blob, start, end) {
			var blobSlice;

			if (window.File.prototype.slice) {
				try {
					blob.slice();	// depricated version will throw WRONG_ARGUMENTS_ERR exception
					return blob.slice(start, end);
				} catch (e) {
					// depricated slice method
					return blob.slice(start, end - start);
				}
			// slice method got prefixed: https://bugzilla.mozilla.org/show_bug.cgi?id=649672
			} else if ((blobSlice = window.File.prototype.webkitSlice || window.File.prototype.mozSlice)) {
				return blobSlice.call(blob, start, end);
			} else {
				return null; // or throw some exception
			}
		}

		this.slice = function() {
			return new Blob(this.getRuntime().uid, w3cBlobSlice.apply(this, arguments));
		};
	}

	return (extensions.Blob = HTML5Blob);
});

// Included from: src/javascript/core/utils/Events.js

/**
 * Events.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Events', [
	'moxie/core/utils/Basic'
], function(Basic) {
	var eventhash = {}, uid = 'moxie_' + Basic.guid();
	
	// IE W3C like event funcs
	function preventDefault() {
		this.returnValue = false;
	}

	function stopPropagation() {
		this.cancelBubble = true;
	}

	/**
	Adds an event handler to the specified object and store reference to the handler
	in objects internal Plupload registry (@see removeEvent).
	
	@method addEvent
	@for Utils
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Name to add event listener to.
	@param {Function} callback Function to call when event occurs.
	@param {String} [key] that might be used to add specifity to the event record.
	*/
	var addEvent = function(obj, name, callback, key) {
		var func, events;
					
		name = name.toLowerCase();

		// Add event listener
		if (obj.addEventListener) {
			func = callback;
			
			obj.addEventListener(name, func, false);
		} else if (obj.attachEvent) {
			func = function() {
				var evt = window.event;

				if (!evt.target) {
					evt.target = evt.srcElement;
				}

				evt.preventDefault = preventDefault;
				evt.stopPropagation = stopPropagation;

				callback(evt);
			};

			obj.attachEvent('on' + name, func);
		}
		
		// Log event handler to objects internal mOxie registry
		if (!obj[uid]) {
			obj[uid] = Basic.guid();
		}
		
		if (!eventhash.hasOwnProperty(obj[uid])) {
			eventhash[obj[uid]] = {};
		}
		
		events = eventhash[obj[uid]];
		
		if (!events.hasOwnProperty(name)) {
			events[name] = [];
		}
				
		events[name].push({
			func: func,
			orig: callback, // store original callback for IE
			key: key
		});
	};
	
	
	/**
	Remove event handler from the specified object. If third argument (callback)
	is not specified remove all events with the specified name.
	
	@method removeEvent
	@static
	@param {Object} obj DOM element to remove event listener(s) from.
	@param {String} name Name of event listener to remove.
	@param {Function|String} [callback] might be a callback or unique key to match.
	*/
	var removeEvent = function(obj, name, callback) {
		var type, undef;
		
		name = name.toLowerCase();
		
		if (obj[uid] && eventhash[obj[uid]] && eventhash[obj[uid]][name]) {
			type = eventhash[obj[uid]][name];
		} else {
			return;
		}
			
		for (var i = type.length - 1; i >= 0; i--) {
			// undefined or not, key should match
			if (type[i].orig === callback || type[i].key === callback) {
				if (obj.removeEventListener) {
					obj.removeEventListener(name, type[i].func, false);
				} else if (obj.detachEvent) {
					obj.detachEvent('on'+name, type[i].func);
				}
				
				type[i].orig = null;
				type[i].func = null;
				type.splice(i, 1);
				
				// If callback was passed we are done here, otherwise proceed
				if (callback !== undef) {
					break;
				}
			}
		}
		
		// If event array got empty, remove it
		if (!type.length) {
			delete eventhash[obj[uid]][name];
		}
		
		// If mOxie registry has become empty, remove it
		if (Basic.isEmptyObj(eventhash[obj[uid]])) {
			delete eventhash[obj[uid]];
			
			// IE doesn't let you remove DOM object property with - delete
			try {
				delete obj[uid];
			} catch(e) {
				obj[uid] = undef;
			}
		}
	};
	
	
	/**
	Remove all kind of events from the specified object
	
	@method removeAllEvents
	@static
	@param {Object} obj DOM element to remove event listeners from.
	@param {String} [key] unique key to match, when removing events.
	*/
	var removeAllEvents = function(obj, key) {		
		if (!obj || !obj[uid]) {
			return;
		}
		
		Basic.each(eventhash[obj[uid]], function(events, name) {
			removeEvent(obj, name, key);
		});
	};

	return {
		addEvent: addEvent,
		removeEvent: removeEvent,
		removeAllEvents: removeAllEvents
	};
});

// Included from: src/javascript/runtime/html5/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileInput
@private
*/
define("moxie/runtime/html5/file/FileInput", [
	"moxie/runtime/html5/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, File, Basic, Dom, Events, Mime, Env) {
	
	function FileInput() {
		var _options, _browseBtnZIndex; // save original z-index

		Basic.extend(this, {
			init: function(options) {
				var comp = this, I = comp.getRuntime(), input, shimContainer, mimes, browseButton, zIndex, top;

				_options = options;

				// figure out accept string
				mimes = _options.accept.mimes || Mime.extList2mimes(_options.accept, I.can('filter_by_extension'));

				shimContainer = I.getShimContainer();

				shimContainer.innerHTML = '<input id="' + I.uid +'" type="file" style="font-size:999px;opacity:0;"' +
					(_options.multiple && I.can('select_multiple') ? 'multiple' : '') + 
					(_options.directory && I.can('select_folder') ? 'webkitdirectory directory' : '') + // Chrome 11+
					(mimes ? ' accept="' + mimes.join(',') + '"' : '') + ' />';

				input = Dom.get(I.uid);

				// prepare file input to be placed underneath the browse_button element
				Basic.extend(input.style, {
					position: 'absolute',
					top: 0,
					left: 0,
					width: '100%',
					height: '100%'
				});


				browseButton = Dom.get(_options.browse_button);
				_browseBtnZIndex = Dom.getStyle(browseButton, 'z-index') || 'auto';

				// Route click event to the input[type=file] element for browsers that support such behavior
				if (I.can('summon_file_dialog')) {
					if (Dom.getStyle(browseButton, 'position') === 'static') {
						browseButton.style.position = 'relative';
					}

					Events.addEvent(browseButton, 'click', function(e) {
						var input = Dom.get(I.uid);
						if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
							input.click();
						}
						e.preventDefault();
					}, comp.uid);

					comp.bind('Refresh', function() {
						zIndex = parseInt(_browseBtnZIndex, 10) || 1;

						Dom.get(_options.browse_button).style.zIndex = zIndex;
						this.getRuntime().getShimContainer().style.zIndex = zIndex - 1;
					});
				}

				/* Since we have to place input[type=file] on top of the browse_button for some browsers,
				browse_button loses interactivity, so we restore it here */
				top = I.can('summon_file_dialog') ? browseButton : shimContainer;

				Events.addEvent(top, 'mouseover', function() {
					comp.trigger('mouseenter');
				}, comp.uid);

				Events.addEvent(top, 'mouseout', function() {
					comp.trigger('mouseleave');
				}, comp.uid);

				Events.addEvent(top, 'mousedown', function() {
					comp.trigger('mousedown');
				}, comp.uid);

				Events.addEvent(Dom.get(_options.container), 'mouseup', function() {
					comp.trigger('mouseup');
				}, comp.uid);


				input.onchange = function onChange(e) { // there should be only one handler for this
					comp.files = [];

					Basic.each(this.files, function(file) {
						var relativePath = '';

						if (_options.directory) {
							// folders are represented by dots, filter them out (Chrome 11+)
							if (file.name == ".") {
								// if it looks like a folder...
								return true;
							}
						}

						if (file.webkitRelativePath) {
							relativePath = '/' + file.webkitRelativePath.replace(/^\//, '');
						}
						
						file = new File(I.uid, file);
						file.relativePath = relativePath;

						comp.files.push(file);
					});

					// clearing the value enables the user to select the same file again if they want to
					if (Env.browser !== 'IE' && Env.browser !== 'IEMobile') {
						this.value = '';
					} else {
						// in IE input[type="file"] is read-only so the only way to reset it is to re-insert it
						var clone = this.cloneNode(true);
						this.parentNode.replaceChild(clone, this);
						clone.onchange = onChange;
					}

					if (comp.files.length) {
						comp.trigger('change');
					}
				};

				// ready event is perfectly asynchronous
				comp.trigger({
					type: 'ready',
					async: true
				});

				shimContainer = null;
			},


			setOption: function(name, value) {
				var I = this.getRuntime();
				var input = Dom.get(I.uid);

				switch (name) {
					case 'accept':
						if (value) {
							var mimes = value.mimes || Mime.extList2mimes(value, I.can('filter_by_extension'));
							input.setAttribute('accept', mimes.join(','));
						} else {
							input.removeAttribute('accept');
						}
						break;

					case 'directory':
						if (value && I.can('select_folder')) {
							input.setAttribute('directory', '');
							input.setAttribute('webkitdirectory', '');
						} else {
							input.removeAttribute('directory');
							input.removeAttribute('webkitdirectory');
						}
						break;

					case 'multiple':
						if (value && I.can('select_multiple')) {
							input.setAttribute('multiple', '');
						} else {
							input.removeAttribute('multiple');
						}

				}
			},


			disable: function(state) {
				var I = this.getRuntime(), input;

				if ((input = Dom.get(I.uid))) {
					input.disabled = !!state;
				}
			},

			destroy: function() {
				var I = this.getRuntime()
				, shim = I.getShim()
				, shimContainer = I.getShimContainer()
				, container = _options && Dom.get(_options.container)
				, browseButton = _options && Dom.get(_options.browse_button)
				;
				
				if (container) {
					Events.removeAllEvents(container, this.uid);
				}
				
				if (browseButton) {
					Events.removeAllEvents(browseButton, this.uid);
					browseButton.style.zIndex = _browseBtnZIndex; // reset to original value
				}
				
				if (shimContainer) {
					Events.removeAllEvents(shimContainer, this.uid);
					shimContainer.innerHTML = '';
				}

				shim.removeInstance(this.uid);

				_options = shimContainer = container = browseButton = shim = null;
			}
		});
	}

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/html5/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileDrop
@private
*/
define("moxie/runtime/html5/file/FileDrop", [
	"moxie/runtime/html5/Runtime",
	'moxie/file/File',
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime"
], function(extensions, File, Basic, Dom, Events, Mime) {
	
	function FileDrop() {
		var _files = [], _allowedExts = [], _options, _ruid;

		Basic.extend(this, {
			init: function(options) {
				var comp = this, dropZone;

				_options = options;
				_ruid = comp.ruid; // every dropped-in file should have a reference to the runtime
				_allowedExts = _extractExts(_options.accept);
				dropZone = _options.container;

				Events.addEvent(dropZone, 'dragover', function(e) {
					if (!_hasFiles(e)) {
						return;
					}
					e.preventDefault();
					e.dataTransfer.dropEffect = 'copy';
				}, comp.uid);

				Events.addEvent(dropZone, 'drop', function(e) {
					if (!_hasFiles(e)) {
						return;
					}
					e.preventDefault();

					_files = [];

					// Chrome 21+ accepts folders via Drag'n'Drop
					if (e.dataTransfer.items && e.dataTransfer.items[0].webkitGetAsEntry) {
						_readItems(e.dataTransfer.items, function() {
							comp.files = _files;
							comp.trigger("drop");
						});
					} else {
						Basic.each(e.dataTransfer.files, function(file) {
							_addFile(file);
						});
						comp.files = _files;
						comp.trigger("drop");
					}
				}, comp.uid);

				Events.addEvent(dropZone, 'dragenter', function(e) {
					comp.trigger("dragenter");
				}, comp.uid);

				Events.addEvent(dropZone, 'dragleave', function(e) {
					comp.trigger("dragleave");
				}, comp.uid);
			},

			destroy: function() {
				Events.removeAllEvents(_options && Dom.get(_options.container), this.uid);
				_ruid = _files = _allowedExts = _options = null;
			}
		});


		function _hasFiles(e) {
			if (!e.dataTransfer || !e.dataTransfer.types) { // e.dataTransfer.files is not available in Gecko during dragover
				return false;
			}

			var types = Basic.toArray(e.dataTransfer.types || []);

			return Basic.inArray("Files", types) !== -1 ||
				Basic.inArray("public.file-url", types) !== -1 || // Safari < 5
				Basic.inArray("application/x-moz-file", types) !== -1 // Gecko < 1.9.2 (< Firefox 3.6)
				;
		}


		function _addFile(file, relativePath) {
			if (_isAcceptable(file)) {
				var fileObj = new File(_ruid, file);
				fileObj.relativePath = relativePath || '';
				_files.push(fileObj);
			}
		}

		
		function _extractExts(accept) {
			var exts = [];
			for (var i = 0; i < accept.length; i++) {
				[].push.apply(exts, accept[i].extensions.split(/\s*,\s*/));
			}
			return Basic.inArray('*', exts) === -1 ? exts : [];
		}


		function _isAcceptable(file) {
			if (!_allowedExts.length) {
				return true;
			}
			var ext = Mime.getFileExtension(file.name);
			return !ext || Basic.inArray(ext, _allowedExts) !== -1;
		}


		function _readItems(items, cb) {
			var entries = [];
			Basic.each(items, function(item) {
				var entry = item.webkitGetAsEntry();
				// Address #998 (https://code.google.com/p/chromium/issues/detail?id=332579)
				if (entry) {
					// file() fails on OSX when the filename contains a special character (e.g. umlaut): see #61
					if (entry.isFile) {
						_addFile(item.getAsFile(), entry.fullPath);
					} else {
						entries.push(entry);
					}
				}
			});

			if (entries.length) {
				_readEntries(entries, cb);
			} else {
				cb();
			}
		}


		function _readEntries(entries, cb) {
			var queue = [];
			Basic.each(entries, function(entry) {
				queue.push(function(cbcb) {
					_readEntry(entry, cbcb);
				});
			});
			Basic.inSeries(queue, function() {
				cb();
			});
		}


		function _readEntry(entry, cb) {
			if (entry.isFile) {
				entry.file(function(file) {
					_addFile(file, entry.fullPath);
					cb();
				}, function() {
					// fire an error event maybe
					cb();
				});
			} else if (entry.isDirectory) {
				_readDirEntry(entry, cb);
			} else {
				cb(); // not file, not directory? what then?..
			}
		}


		function _readDirEntry(dirEntry, cb) {
			var entries = [], dirReader = dirEntry.createReader();

			// keep quering recursively till no more entries
			function getEntries(cbcb) {
				dirReader.readEntries(function(moreEntries) {
					if (moreEntries.length) {
						[].push.apply(entries, moreEntries);
						getEntries(cbcb);
					} else {
						cbcb();
					}
				}, cbcb);
			}

			// ...and you thought FileReader was crazy...
			getEntries(function() {
				_readEntries(entries, cb);
			}); 
		}
	}

	return (extensions.FileDrop = FileDrop);
});

// Included from: src/javascript/runtime/html5/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileReader
@private
*/
define("moxie/runtime/html5/file/FileReader", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Encode",
	"moxie/core/utils/Basic"
], function(extensions, Encode, Basic) {
	
	function FileReader() {
		var _fr, _convertToBinary = false;

		Basic.extend(this, {

			read: function(op, blob) {
				var comp = this;

				comp.result = '';

				_fr = new window.FileReader();

				_fr.addEventListener('progress', function(e) {
					comp.trigger(e);
				});

				_fr.addEventListener('load', function(e) {
					comp.result = _convertToBinary ? _toBinary(_fr.result) : _fr.result;
					comp.trigger(e);
				});

				_fr.addEventListener('error', function(e) {
					comp.trigger(e, _fr.error);
				});

				_fr.addEventListener('loadend', function(e) {
					_fr = null;
					comp.trigger(e);
				});

				if (Basic.typeOf(_fr[op]) === 'function') {
					_convertToBinary = false;
					_fr[op](blob.getSource());
				} else if (op === 'readAsBinaryString') { // readAsBinaryString is depricated in general and never existed in IE10+
					_convertToBinary = true;
					_fr.readAsDataURL(blob.getSource());
				}
			},

			abort: function() {
				if (_fr) {
					_fr.abort();
				}
			},

			destroy: function() {
				_fr = null;
			}
		});

		function _toBinary(str) {
			return Encode.atob(str.substring(str.indexOf('base64,') + 7));
		}
	}

	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/html5/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
@class moxie/runtime/html5/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/html5/xhr/XMLHttpRequest", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Url",
	"moxie/file/File",
	"moxie/file/Blob",
	"moxie/xhr/FormData",
	"moxie/core/Exceptions",
	"moxie/core/utils/Env"
], function(extensions, Basic, Mime, Url, File, Blob, FormData, x, Env) {
	
	function XMLHttpRequest() {
		var self = this
		, _xhr
		, _filename
		;

		Basic.extend(this, {
			send: function(meta, data) {
				var target = this
				, isGecko2_5_6 = (Env.browser === 'Mozilla' && Env.verComp(Env.version, 4, '>=') && Env.verComp(Env.version, 7, '<'))
				, isAndroidBrowser = Env.browser === 'Android Browser'
				, mustSendAsBinary = false
				;

				// extract file name
				_filename = meta.url.replace(/^.+?\/([\w\-\.]+)$/, '$1').toLowerCase();

				_xhr = _getNativeXHR();
				_xhr.open(meta.method, meta.url, meta.async, meta.user, meta.password);


				// prepare data to be sent
				if (data instanceof Blob) {
					if (data.isDetached()) {
						mustSendAsBinary = true;
					}
					data = data.getSource();
				} else if (data instanceof FormData) {

					if (data.hasBlob()) {
						if (data.getBlob().isDetached()) {
							data = _prepareMultipart.call(target, data); // _xhr must be instantiated and be in OPENED state
							mustSendAsBinary = true;
						} else if ((isGecko2_5_6 || isAndroidBrowser) && Basic.typeOf(data.getBlob().getSource()) === 'blob' && window.FileReader) {
							// Gecko 2/5/6 can't send blob in FormData: https://bugzilla.mozilla.org/show_bug.cgi?id=649150
							// Android browsers (default one and Dolphin) seem to have the same issue, see: #613
							_preloadAndSend.call(target, meta, data);
							return; // _preloadAndSend will reinvoke send() with transmutated FormData =%D
						}	
					}

					// transfer fields to real FormData
					if (data instanceof FormData) { // if still a FormData, e.g. not mangled by _prepareMultipart()
						var fd = new window.FormData();
						data.each(function(value, name) {
							if (value instanceof Blob) {
								fd.append(name, value.getSource());
							} else {
								fd.append(name, value);
							}
						});
						data = fd;
					}
				}


				// if XHR L2
				if (_xhr.upload) {
					if (meta.withCredentials) {
						_xhr.withCredentials = true;
					}

					_xhr.addEventListener('load', function(e) {
						target.trigger(e);
					});

					_xhr.addEventListener('error', function(e) {
						target.trigger(e);
					});

					// additionally listen to progress events
					_xhr.addEventListener('progress', function(e) {
						target.trigger(e);
					});

					_xhr.upload.addEventListener('progress', function(e) {
						target.trigger({
							type: 'UploadProgress',
							loaded: e.loaded,
							total: e.total
						});
					});
				// ... otherwise simulate XHR L2
				} else {
					_xhr.onreadystatechange = function onReadyStateChange() {
						
						// fake Level 2 events
						switch (_xhr.readyState) {
							
							case 1: // XMLHttpRequest.OPENED
								// readystatechanged is fired twice for OPENED state (in IE and Mozilla) - neu
								break;
							
							// looks like HEADERS_RECEIVED (state 2) is not reported in Opera (or it's old versions) - neu
							case 2: // XMLHttpRequest.HEADERS_RECEIVED
								break;
								
							case 3: // XMLHttpRequest.LOADING 
								// try to fire progress event for not XHR L2
								var total, loaded;
								
								try {
									if (Url.hasSameOrigin(meta.url)) { // Content-Length not accessible for cross-domain on some browsers
										total = _xhr.getResponseHeader('Content-Length') || 0; // old Safari throws an exception here
									}

									if (_xhr.responseText) { // responseText was introduced in IE7
										loaded = _xhr.responseText.length;
									}
								} catch(ex) {
									total = loaded = 0;
								}

								target.trigger({
									type: 'progress',
									lengthComputable: !!total,
									total: parseInt(total, 10),
									loaded: loaded
								});
								break;
								
							case 4: // XMLHttpRequest.DONE
								// release readystatechange handler (mostly for IE)
								_xhr.onreadystatechange = function() {};

								// usually status 0 is returned when server is unreachable, but FF also fails to status 0 for 408 timeout
								if (_xhr.status === 0) {
									target.trigger('error');
								} else {
									target.trigger('load');
								}							
								break;
						}
					};
				}
				

				// set request headers
				if (!Basic.isEmptyObj(meta.headers)) {
					Basic.each(meta.headers, function(value, header) {
						_xhr.setRequestHeader(header, value);
					});
				}

				// request response type
				if ("" !== meta.responseType && 'responseType' in _xhr) {
					if ('json' === meta.responseType && !Env.can('return_response_type', 'json')) { // we can fake this one
						_xhr.responseType = 'text';
					} else {
						_xhr.responseType = meta.responseType;
					}
				}

				// send ...
				if (!mustSendAsBinary) {
					_xhr.send(data);
				} else {
					if (_xhr.sendAsBinary) { // Gecko
						_xhr.sendAsBinary(data);
					} else { // other browsers having support for typed arrays
						(function() {
							// mimic Gecko's sendAsBinary
							var ui8a = new Uint8Array(data.length);
							for (var i = 0; i < data.length; i++) {
								ui8a[i] = (data.charCodeAt(i) & 0xff);
							}
							_xhr.send(ui8a.buffer);
						}());
					}
				}

				target.trigger('loadstart');
			},

			getStatus: function() {
				// according to W3C spec it should return 0 for readyState < 3, but instead it throws an exception
				try {
					if (_xhr) {
						return _xhr.status;
					}
				} catch(ex) {}
				return 0;
			},

			getResponse: function(responseType) {
				var I = this.getRuntime();

				try {
					switch (responseType) {
						case 'blob':
							var file = new File(I.uid, _xhr.response);
							
							// try to extract file name from content-disposition if possible (might be - not, if CORS for example)	
							var disposition = _xhr.getResponseHeader('Content-Disposition');
							if (disposition) {
								// extract filename from response header if available
								var match = disposition.match(/filename=([\'\"'])([^\1]+)\1/);
								if (match) {
									_filename = match[2];
								}
							}
							file.name = _filename;

							// pre-webkit Opera doesn't set type property on the blob response
							if (!file.type) {
								file.type = Mime.getFileMime(_filename);
							}
							return file;

						case 'json':
							if (!Env.can('return_response_type', 'json')) {
								return _xhr.status === 200 && !!window.JSON ? JSON.parse(_xhr.responseText) : null;
							}
							return _xhr.response;

						case 'document':
							return _getDocument(_xhr);

						default:
							return _xhr.responseText !== '' ? _xhr.responseText : null; // against the specs, but for consistency across the runtimes
					}
				} catch(ex) {
					return null;
				}				
			},

			getAllResponseHeaders: function() {
				try {
					return _xhr.getAllResponseHeaders();
				} catch(ex) {}
				return '';
			},

			abort: function() {
				if (_xhr) {
					_xhr.abort();
				}
			},

			destroy: function() {
				self = _filename = null;
			}
		});


		// here we go... ugly fix for ugly bug
		function _preloadAndSend(meta, data) {
			var target = this, blob, fr;
				
			// get original blob
			blob = data.getBlob().getSource();
			
			// preload blob in memory to be sent as binary string
			fr = new window.FileReader();
			fr.onload = function() {
				// overwrite original blob
				data.append(data.getBlobName(), new Blob(null, {
					type: blob.type,
					data: fr.result
				}));
				// invoke send operation again
				self.send.call(target, meta, data);
			};
			fr.readAsBinaryString(blob);
		}

		
		function _getNativeXHR() {
			if (window.XMLHttpRequest && !(Env.browser === 'IE' && Env.verComp(Env.version, 8, '<'))) { // IE7 has native XHR but it's buggy
				return new window.XMLHttpRequest();
			} else {
				return (function() {
					var progIDs = ['Msxml2.XMLHTTP.6.0', 'Microsoft.XMLHTTP']; // if 6.0 available, use it, otherwise failback to default 3.0
					for (var i = 0; i < progIDs.length; i++) {
						try {
							return new ActiveXObject(progIDs[i]);
						} catch (ex) {}
					}
				})();
			}
		}
		
		// @credits Sergey Ilinsky	(http://www.ilinsky.com/)
		function _getDocument(xhr) {
			var rXML = xhr.responseXML;
			var rText = xhr.responseText;
			
			// Try parsing responseText (@see: http://www.ilinsky.com/articles/XMLHttpRequest/#bugs-ie-responseXML-content-type)
			if (Env.browser === 'IE' && rText && rXML && !rXML.documentElement && /[^\/]+\/[^\+]+\+xml/.test(xhr.getResponseHeader("Content-Type"))) {
				rXML = new window.ActiveXObject("Microsoft.XMLDOM");
				rXML.async = false;
				rXML.validateOnParse = false;
				rXML.loadXML(rText);
			}
	
			// Check if there is no error in document
			if (rXML) {
				if ((Env.browser === 'IE' && rXML.parseError !== 0) || !rXML.documentElement || rXML.documentElement.tagName === "parsererror") {
					return null;
				}
			}
			return rXML;
		}


		function _prepareMultipart(fd) {
			var boundary = '----moxieboundary' + new Date().getTime()
			, dashdash = '--'
			, crlf = '\r\n'
			, multipart = ''
			, I = this.getRuntime()
			;

			if (!I.can('send_binary_string')) {
				throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
			}

			_xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);

			// append multipart parameters
			fd.each(function(value, name) {
				// Firefox 3.6 failed to convert multibyte characters to UTF-8 in sendAsBinary(), 
				// so we try it here ourselves with: unescape(encodeURIComponent(value))
				if (value instanceof Blob) {
					// Build RFC2388 blob
					multipart += dashdash + boundary + crlf +
						'Content-Disposition: form-data; name="' + name + '"; filename="' + unescape(encodeURIComponent(value.name || 'blob')) + '"' + crlf +
						'Content-Type: ' + (value.type || 'application/octet-stream') + crlf + crlf +
						value.getSource() + crlf;
				} else {
					multipart += dashdash + boundary + crlf +
						'Content-Disposition: form-data; name="' + name + '"' + crlf + crlf +
						unescape(encodeURIComponent(value)) + crlf;
				}
			});

			multipart += dashdash + boundary + dashdash + crlf;

			return multipart;
		}
	}

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/html5/utils/BinaryReader.js

/**
 * BinaryReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/utils/BinaryReader
@private
*/
define("moxie/runtime/html5/utils/BinaryReader", [
	"moxie/core/utils/Basic"
], function(Basic) {

	
	function BinaryReader(data) {
		if (data instanceof ArrayBuffer) {
			ArrayBufferReader.apply(this, arguments);
		} else {
			UTF16StringReader.apply(this, arguments);
		}
	}

	Basic.extend(BinaryReader.prototype, {
		
		littleEndian: false,


		read: function(idx, size) {
			var sum, mv, i;

			if (idx + size > this.length()) {
				throw new Error("You are trying to read outside the source boundaries.");
			}
			
			mv = this.littleEndian 
				? 0 
				: -8 * (size - 1)
			;

			for (i = 0, sum = 0; i < size; i++) {
				sum |= (this.readByteAt(idx + i) << Math.abs(mv + i*8));
			}
			return sum;
		},


		write: function(idx, num, size) {
			var mv, i, str = '';

			if (idx > this.length()) {
				throw new Error("You are trying to write outside the source boundaries.");
			}

			mv = this.littleEndian 
				? 0 
				: -8 * (size - 1)
			;

			for (i = 0; i < size; i++) {
				this.writeByteAt(idx + i, (num >> Math.abs(mv + i*8)) & 255);
			}
		},


		BYTE: function(idx) {
			return this.read(idx, 1);
		},


		SHORT: function(idx) {
			return this.read(idx, 2);
		},


		LONG: function(idx) {
			return this.read(idx, 4);
		},


		SLONG: function(idx) { // 2's complement notation
			var num = this.read(idx, 4);
			return (num > 2147483647 ? num - 4294967296 : num);
		},


		CHAR: function(idx) {
			return String.fromCharCode(this.read(idx, 1));
		},


		STRING: function(idx, count) {
			return this.asArray('CHAR', idx, count).join('');
		},


		asArray: function(type, idx, count) {
			var values = [];

			for (var i = 0; i < count; i++) {
				values[i] = this[type](idx + i);
			}
			return values;
		}
	});


	function ArrayBufferReader(data) {
		var _dv = new DataView(data);

		Basic.extend(this, {
			
			readByteAt: function(idx) {
				return _dv.getUint8(idx);
			},


			writeByteAt: function(idx, value) {
				_dv.setUint8(idx, value);
			},
			

			SEGMENT: function(idx, size, value) {
				switch (arguments.length) {
					case 2:
						return data.slice(idx, idx + size);

					case 1:
						return data.slice(idx);

					case 3:
						if (value === null) {
							value = new ArrayBuffer();
						}

						if (value instanceof ArrayBuffer) {					
							var arr = new Uint8Array(this.length() - size + value.byteLength);
							if (idx > 0) {
								arr.set(new Uint8Array(data.slice(0, idx)), 0);
							}
							arr.set(new Uint8Array(value), idx);
							arr.set(new Uint8Array(data.slice(idx + size)), idx + value.byteLength);

							this.clear();
							data = arr.buffer;
							_dv = new DataView(data);
							break;
						}

					default: return data;
				}
			},


			length: function() {
				return data ? data.byteLength : 0;
			},


			clear: function() {
				_dv = data = null;
			}
		});
	}


	function UTF16StringReader(data) {
		Basic.extend(this, {
			
			readByteAt: function(idx) {
				return data.charCodeAt(idx);
			},


			writeByteAt: function(idx, value) {
				putstr(String.fromCharCode(value), idx, 1);
			},


			SEGMENT: function(idx, length, segment) {
				switch (arguments.length) {
					case 1:
						return data.substr(idx);
					case 2:
						return data.substr(idx, length);
					case 3:
						putstr(segment !== null ? segment : '', idx, length);
						break;
					default: return data;
				}
			},


			length: function() {
				return data ? data.length : 0;
			}, 

			clear: function() {
				data = null;
			}
		});


		function putstr(segment, idx, length) {
			length = arguments.length === 3 ? length : data.length - idx - 1;
			data = data.substr(0, idx) + segment + data.substr(length + idx);
		}
	}


	return BinaryReader;
});

// Included from: src/javascript/runtime/html5/image/JPEGHeaders.js

/**
 * JPEGHeaders.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */
 
/**
@class moxie/runtime/html5/image/JPEGHeaders
@private
*/
define("moxie/runtime/html5/image/JPEGHeaders", [
	"moxie/runtime/html5/utils/BinaryReader",
	"moxie/core/Exceptions"
], function(BinaryReader, x) {
	
	return function JPEGHeaders(data) {
		var headers = [], _br, idx, marker, length = 0;

		_br = new BinaryReader(data);

		// Check if data is jpeg
		if (_br.SHORT(0) !== 0xFFD8) {
			_br.clear();
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}

		idx = 2;

		while (idx <= _br.length()) {
			marker = _br.SHORT(idx);

			// omit RST (restart) markers
			if (marker >= 0xFFD0 && marker <= 0xFFD7) {
				idx += 2;
				continue;
			}

			// no headers allowed after SOS marker
			if (marker === 0xFFDA || marker === 0xFFD9) {
				break;
			}

			length = _br.SHORT(idx + 2) + 2;

			// APPn marker detected
			if (marker >= 0xFFE1 && marker <= 0xFFEF) {
				headers.push({
					hex: marker,
					name: 'APP' + (marker & 0x000F),
					start: idx,
					length: length,
					segment: _br.SEGMENT(idx, length)
				});
			}

			idx += length;
		}

		_br.clear();

		return {
			headers: headers,

			restore: function(data) {
				var max, i, br;

				br = new BinaryReader(data);

				idx = br.SHORT(2) == 0xFFE0 ? 4 + br.SHORT(4) : 2;

				for (i = 0, max = headers.length; i < max; i++) {
					br.SEGMENT(idx, 0, headers[i].segment);
					idx += headers[i].length;
				}

				data = br.SEGMENT();
				br.clear();
				return data;
			},

			strip: function(data) {
				var br, headers, jpegHeaders, i;

				jpegHeaders = new JPEGHeaders(data);
				headers = jpegHeaders.headers;
				jpegHeaders.purge();

				br = new BinaryReader(data);

				i = headers.length;
				while (i--) {
					br.SEGMENT(headers[i].start, headers[i].length, '');
				}
				
				data = br.SEGMENT();
				br.clear();
				return data;
			},

			get: function(name) {
				var array = [];

				for (var i = 0, max = headers.length; i < max; i++) {
					if (headers[i].name === name.toUpperCase()) {
						array.push(headers[i].segment);
					}
				}
				return array;
			},

			set: function(name, segment) {
				var array = [], i, ii, max;

				if (typeof(segment) === 'string') {
					array.push(segment);
				} else {
					array = segment;
				}

				for (i = ii = 0, max = headers.length; i < max; i++) {
					if (headers[i].name === name.toUpperCase()) {
						headers[i].segment = array[ii];
						headers[i].length = array[ii].length;
						ii++;
					}
					if (ii >= array.length) {
						break;
					}
				}
			},

			purge: function() {
				this.headers = headers = [];
			}
		};
	};
});

// Included from: src/javascript/runtime/html5/image/ExifParser.js

/**
 * ExifParser.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/ExifParser
@private
*/
define("moxie/runtime/html5/image/ExifParser", [
	"moxie/core/utils/Basic",
	"moxie/runtime/html5/utils/BinaryReader",
	"moxie/core/Exceptions"
], function(Basic, BinaryReader, x) {
	
	function ExifParser(data) {
		var __super__, tags, tagDescs, offsets, idx, Tiff;
		
		BinaryReader.call(this, data);

		tags = {
			tiff: {
				/*
				The image orientation viewed in terms of rows and columns.

				1 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
				2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
				3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
				4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
				5 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
				6 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
				7 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
				8 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
				*/
				0x0112: 'Orientation',
				0x010E: 'ImageDescription',
				0x010F: 'Make',
				0x0110: 'Model',
				0x0131: 'Software',
				0x8769: 'ExifIFDPointer',
				0x8825:	'GPSInfoIFDPointer'
			},
			exif: {
				0x9000: 'ExifVersion',
				0xA001: 'ColorSpace',
				0xA002: 'PixelXDimension',
				0xA003: 'PixelYDimension',
				0x9003: 'DateTimeOriginal',
				0x829A: 'ExposureTime',
				0x829D: 'FNumber',
				0x8827: 'ISOSpeedRatings',
				0x9201: 'ShutterSpeedValue',
				0x9202: 'ApertureValue'	,
				0x9207: 'MeteringMode',
				0x9208: 'LightSource',
				0x9209: 'Flash',
				0x920A: 'FocalLength',
				0xA402: 'ExposureMode',
				0xA403: 'WhiteBalance',
				0xA406: 'SceneCaptureType',
				0xA404: 'DigitalZoomRatio',
				0xA408: 'Contrast',
				0xA409: 'Saturation',
				0xA40A: 'Sharpness'
			},
			gps: {
				0x0000: 'GPSVersionID',
				0x0001: 'GPSLatitudeRef',
				0x0002: 'GPSLatitude',
				0x0003: 'GPSLongitudeRef',
				0x0004: 'GPSLongitude'
			},

			thumb: {
				0x0201: 'JPEGInterchangeFormat',
				0x0202: 'JPEGInterchangeFormatLength'
			}
		};

		tagDescs = {
			'ColorSpace': {
				1: 'sRGB',
				0: 'Uncalibrated'
			},

			'MeteringMode': {
				0: 'Unknown',
				1: 'Average',
				2: 'CenterWeightedAverage',
				3: 'Spot',
				4: 'MultiSpot',
				5: 'Pattern',
				6: 'Partial',
				255: 'Other'
			},

			'LightSource': {
				1: 'Daylight',
				2: 'Fliorescent',
				3: 'Tungsten',
				4: 'Flash',
				9: 'Fine weather',
				10: 'Cloudy weather',
				11: 'Shade',
				12: 'Daylight fluorescent (D 5700 - 7100K)',
				13: 'Day white fluorescent (N 4600 -5400K)',
				14: 'Cool white fluorescent (W 3900 - 4500K)',
				15: 'White fluorescent (WW 3200 - 3700K)',
				17: 'Standard light A',
				18: 'Standard light B',
				19: 'Standard light C',
				20: 'D55',
				21: 'D65',
				22: 'D75',
				23: 'D50',
				24: 'ISO studio tungsten',
				255: 'Other'
			},

			'Flash': {
				0x0000: 'Flash did not fire',
				0x0001: 'Flash fired',
				0x0005: 'Strobe return light not detected',
				0x0007: 'Strobe return light detected',
				0x0009: 'Flash fired, compulsory flash mode',
				0x000D: 'Flash fired, compulsory flash mode, return light not detected',
				0x000F: 'Flash fired, compulsory flash mode, return light detected',
				0x0010: 'Flash did not fire, compulsory flash mode',
				0x0018: 'Flash did not fire, auto mode',
				0x0019: 'Flash fired, auto mode',
				0x001D: 'Flash fired, auto mode, return light not detected',
				0x001F: 'Flash fired, auto mode, return light detected',
				0x0020: 'No flash function',
				0x0041: 'Flash fired, red-eye reduction mode',
				0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
				0x0047: 'Flash fired, red-eye reduction mode, return light detected',
				0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
				0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
				0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
				0x0059: 'Flash fired, auto mode, red-eye reduction mode',
				0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
				0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
			},

			'ExposureMode': {
				0: 'Auto exposure',
				1: 'Manual exposure',
				2: 'Auto bracket'
			},

			'WhiteBalance': {
				0: 'Auto white balance',
				1: 'Manual white balance'
			},

			'SceneCaptureType': {
				0: 'Standard',
				1: 'Landscape',
				2: 'Portrait',
				3: 'Night scene'
			},

			'Contrast': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			'Saturation': {
				0: 'Normal',
				1: 'Low saturation',
				2: 'High saturation'
			},

			'Sharpness': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			// GPS related
			'GPSLatitudeRef': {
				N: 'North latitude',
				S: 'South latitude'
			},

			'GPSLongitudeRef': {
				E: 'East longitude',
				W: 'West longitude'
			}
		};

		offsets = {
			tiffHeader: 10
		};
		
		idx = offsets.tiffHeader;

		__super__ = {
			clear: this.clear
		};

		// Public functions
		Basic.extend(this, {
			
			read: function() {
				try {
					return ExifParser.prototype.read.apply(this, arguments);
				} catch (ex) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				}
			},


			write: function() {
				try {
					return ExifParser.prototype.write.apply(this, arguments);
				} catch (ex) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				}
			},


			UNDEFINED: function() {
				return this.BYTE.apply(this, arguments);
			},


			RATIONAL: function(idx) {
				return this.LONG(idx) / this.LONG(idx + 4)
			},


			SRATIONAL: function(idx) {
				return this.SLONG(idx) / this.SLONG(idx + 4)
			},

			ASCII: function(idx) {
				return this.CHAR(idx);
			},

			TIFF: function() {
				return Tiff || null;
			},


			EXIF: function() {
				var Exif = null;

				if (offsets.exifIFD) {
					try {
						Exif = extractTags.call(this, offsets.exifIFD, tags.exif);
					} catch(ex) {
						return null;
					}

					// Fix formatting of some tags
					if (Exif.ExifVersion && Basic.typeOf(Exif.ExifVersion) === 'array') {
						for (var i = 0, exifVersion = ''; i < Exif.ExifVersion.length; i++) {
							exifVersion += String.fromCharCode(Exif.ExifVersion[i]);
						}
						Exif.ExifVersion = exifVersion;
					}
				}

				return Exif;
			},


			GPS: function() {
				var GPS = null;

				if (offsets.gpsIFD) {
					try {
						GPS = extractTags.call(this, offsets.gpsIFD, tags.gps);
					} catch (ex) {
						return null;
					}

					// iOS devices (and probably some others) do not put in GPSVersionID tag (why?..)
					if (GPS.GPSVersionID && Basic.typeOf(GPS.GPSVersionID) === 'array') {
						GPS.GPSVersionID = GPS.GPSVersionID.join('.');
					}
				}

				return GPS;
			},


			thumb: function() {
				if (offsets.IFD1) {
					try {
						var IFD1Tags = extractTags.call(this, offsets.IFD1, tags.thumb);
						
						if ('JPEGInterchangeFormat' in IFD1Tags) {
							return this.SEGMENT(offsets.tiffHeader + IFD1Tags.JPEGInterchangeFormat, IFD1Tags.JPEGInterchangeFormatLength);
						}
					} catch (ex) {}
				}
				return null;
			},


			setExif: function(tag, value) {
				// Right now only setting of width/height is possible
				if (tag !== 'PixelXDimension' && tag !== 'PixelYDimension') { return false; }

				return setTag.call(this, 'exif', tag, value);
			},


			clear: function() {
				__super__.clear();
				data = tags = tagDescs = Tiff = offsets = __super__ = null;
			}
		});


		// Check if that's APP1 and that it has EXIF
		if (this.SHORT(0) !== 0xFFE1 || this.STRING(4, 5).toUpperCase() !== "EXIF\0") {
			throw new x.ImageError(x.ImageError.INVALID_META_ERR);
		}

		// Set read order of multi-byte data
		this.littleEndian = (this.SHORT(idx) == 0x4949);

		// Check if always present bytes are indeed present
		if (this.SHORT(idx+=2) !== 0x002A) {
			throw new x.ImageError(x.ImageError.INVALID_META_ERR);
		}

		offsets.IFD0 = offsets.tiffHeader + this.LONG(idx += 2);
		Tiff = extractTags.call(this, offsets.IFD0, tags.tiff);

		if ('ExifIFDPointer' in Tiff) {
			offsets.exifIFD = offsets.tiffHeader + Tiff.ExifIFDPointer;
			delete Tiff.ExifIFDPointer;
		}

		if ('GPSInfoIFDPointer' in Tiff) {
			offsets.gpsIFD = offsets.tiffHeader + Tiff.GPSInfoIFDPointer;
			delete Tiff.GPSInfoIFDPointer;
		}

		if (Basic.isEmptyObj(Tiff)) {
			Tiff = null;
		}

		// check if we have a thumb as well
		var IFD1Offset = this.LONG(offsets.IFD0 + this.SHORT(offsets.IFD0) * 12 + 2);
		if (IFD1Offset) {
			offsets.IFD1 = offsets.tiffHeader + IFD1Offset;
		}


		function extractTags(IFD_offset, tags2extract) {
			var data = this;
			var length, i, tag, type, count, size, offset, value, values = [], hash = {};
			
			var types = {
				1 : 'BYTE',
				7 : 'UNDEFINED',
				2 : 'ASCII',
				3 : 'SHORT',
				4 : 'LONG',
				5 : 'RATIONAL',
				9 : 'SLONG',
				10: 'SRATIONAL'
			};

			var sizes = {
				'BYTE' 		: 1,
				'UNDEFINED'	: 1,
				'ASCII'		: 1,
				'SHORT'		: 2,
				'LONG' 		: 4,
				'RATIONAL' 	: 8,
				'SLONG'		: 4,
				'SRATIONAL'	: 8
			};

			length = data.SHORT(IFD_offset);

			// The size of APP1 including all these elements shall not exceed the 64 Kbytes specified in the JPEG standard.

			for (i = 0; i < length; i++) {
				values = [];

				// Set binary reader pointer to beginning of the next tag
				offset = IFD_offset + 2 + i*12;

				tag = tags2extract[data.SHORT(offset)];

				if (tag === undefined) {
					continue; // Not the tag we requested
				}

				type = types[data.SHORT(offset+=2)];
				count = data.LONG(offset+=2);
				size = sizes[type];

				if (!size) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				}

				offset += 4;

				// tag can only fit 4 bytes of data, if data is larger we should look outside
				if (size * count > 4) {
					// instead of data tag contains an offset of the data
					offset = data.LONG(offset) + offsets.tiffHeader;
				}

				// in case we left the boundaries of data throw an early exception
				if (offset + size * count >= this.length()) {
					throw new x.ImageError(x.ImageError.INVALID_META_ERR);
				} 

				// special care for the string
				if (type === 'ASCII') {
					hash[tag] = Basic.trim(data.STRING(offset, count).replace(/\0$/, '')); // strip trailing NULL
					continue;
				} else {
					values = data.asArray(type, offset, count);
					value = (count == 1 ? values[0] : values);

					if (tagDescs.hasOwnProperty(tag) && typeof value != 'object') {
						hash[tag] = tagDescs[tag][value];
					} else {
						hash[tag] = value;
					}
				}
			}

			return hash;
		}

		// At the moment only setting of simple (LONG) values, that do not require offset recalculation, is supported
		function setTag(ifd, tag, value) {
			var offset, length, tagOffset, valueOffset = 0;

			// If tag name passed translate into hex key
			if (typeof(tag) === 'string') {
				var tmpTags = tags[ifd.toLowerCase()];
				for (var hex in tmpTags) {
					if (tmpTags[hex] === tag) {
						tag = hex;
						break;
					}
				}
			}
			offset = offsets[ifd.toLowerCase() + 'IFD'];
			length = this.SHORT(offset);

			for (var i = 0; i < length; i++) {
				tagOffset = offset + 12 * i + 2;

				if (this.SHORT(tagOffset) == tag) {
					valueOffset = tagOffset + 8;
					break;
				}
			}

			if (!valueOffset) {
				return false;
			}

			try {
				this.write(valueOffset, value, 4);
			} catch(ex) {
				return false;
			}

			return true;
		}
	}

	ExifParser.prototype = BinaryReader.prototype;

	return ExifParser;
});

// Included from: src/javascript/runtime/html5/image/JPEG.js

/**
 * JPEG.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/JPEG
@private
*/
define("moxie/runtime/html5/image/JPEG", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/html5/image/JPEGHeaders",
	"moxie/runtime/html5/utils/BinaryReader",
	"moxie/runtime/html5/image/ExifParser"
], function(Basic, x, JPEGHeaders, BinaryReader, ExifParser) {
	
	function JPEG(data) {
		var _br, _hm, _ep, _info;

		_br = new BinaryReader(data);

		// check if it is jpeg
		if (_br.SHORT(0) !== 0xFFD8) {
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}

		// backup headers
		_hm = new JPEGHeaders(data);

		// extract exif info
		try {
			_ep = new ExifParser(_hm.get('app1')[0]);
		} catch(ex) {}

		// get dimensions
		_info = _getDimensions.call(this);

		Basic.extend(this, {
			type: 'image/jpeg',

			size: _br.length(),

			width: _info && _info.width || 0,

			height: _info && _info.height || 0,

			setExif: function(tag, value) {
				if (!_ep) {
					return false; // or throw an exception
				}

				if (Basic.typeOf(tag) === 'object') {
					Basic.each(tag, function(value, tag) {
						_ep.setExif(tag, value);
					});
				} else {
					_ep.setExif(tag, value);
				}

				// update internal headers
				_hm.set('app1', _ep.SEGMENT());
			},

			writeHeaders: function() {
				if (!arguments.length) {
					// if no arguments passed, update headers internally
					return _hm.restore(data);
				}
				return _hm.restore(arguments[0]);
			},

			stripHeaders: function(data) {
				return _hm.strip(data);
			},

			purge: function() {
				_purge.call(this);
			}
		});

		if (_ep) {
			this.meta = {
				tiff: _ep.TIFF(),
				exif: _ep.EXIF(),
				gps: _ep.GPS(),
				thumb: _getThumb()
			};
		}


		function _getDimensions(br) {
			var idx = 0
			, marker
			, length
			;

			if (!br) {
				br = _br;
			}

			// examine all through the end, since some images might have very large APP segments
			while (idx <= br.length()) {
				marker = br.SHORT(idx += 2);

				if (marker >= 0xFFC0 && marker <= 0xFFC3) { // SOFn
					idx += 5; // marker (2 bytes) + length (2 bytes) + Sample precision (1 byte)
					return {
						height: br.SHORT(idx),
						width: br.SHORT(idx += 2)
					};
				}
				length = br.SHORT(idx += 2);
				idx += length - 2;
			}
			return null;
		}


		function _getThumb() {
			var data =  _ep.thumb()
			, br
			, info
			;

			if (data) {
				br = new BinaryReader(data);
				info = _getDimensions(br);
				br.clear();

				if (info) {
					info.data = data;
					return info;
				}
			}
			return null;
		}


		function _purge() {
			if (!_ep || !_hm || !_br) { 
				return; // ignore any repeating purge requests
			}
			_ep.clear();
			_hm.purge();
			_br.clear();
			_info = _hm = _ep = _br = null;
		}
	}

	return JPEG;
});

// Included from: src/javascript/runtime/html5/image/PNG.js

/**
 * PNG.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/PNG
@private
*/
define("moxie/runtime/html5/image/PNG", [
	"moxie/core/Exceptions",
	"moxie/core/utils/Basic",
	"moxie/runtime/html5/utils/BinaryReader"
], function(x, Basic, BinaryReader) {
	
	function PNG(data) {
		var _br, _hm, _ep, _info;

		_br = new BinaryReader(data);

		// check if it's png
		(function() {
			var idx = 0, i = 0
			, signature = [0x8950, 0x4E47, 0x0D0A, 0x1A0A]
			;

			for (i = 0; i < signature.length; i++, idx += 2) {
				if (signature[i] != _br.SHORT(idx)) {
					throw new x.ImageError(x.ImageError.WRONG_FORMAT);
				}
			}
		}());

		function _getDimensions() {
			var chunk, idx;

			chunk = _getChunkAt.call(this, 8);

			if (chunk.type == 'IHDR') {
				idx = chunk.start;
				return {
					width: _br.LONG(idx),
					height: _br.LONG(idx += 4)
				};
			}
			return null;
		}

		function _purge() {
			if (!_br) {
				return; // ignore any repeating purge requests
			}
			_br.clear();
			data = _info = _hm = _ep = _br = null;
		}

		_info = _getDimensions.call(this);

		Basic.extend(this, {
			type: 'image/png',

			size: _br.length(),

			width: _info.width,

			height: _info.height,

			purge: function() {
				_purge.call(this);
			}
		});

		// for PNG we can safely trigger purge automatically, as we do not keep any data for later
		_purge.call(this);

		function _getChunkAt(idx) {
			var length, type, start, CRC;

			length = _br.LONG(idx);
			type = _br.STRING(idx += 4, 4);
			start = idx += 4;
			CRC = _br.LONG(idx + length);

			return {
				length: length,
				type: type,
				start: start,
				CRC: CRC
			};
		}
	}

	return PNG;
});

// Included from: src/javascript/runtime/html5/image/ImageInfo.js

/**
 * ImageInfo.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/ImageInfo
@private
*/
define("moxie/runtime/html5/image/ImageInfo", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/html5/image/JPEG",
	"moxie/runtime/html5/image/PNG"
], function(Basic, x, JPEG, PNG) {
	/**
	Optional image investigation tool for HTML5 runtime. Provides the following features:
	- ability to distinguish image type (JPEG or PNG) by signature
	- ability to extract image width/height directly from it's internals, without preloading in memory (fast)
	- ability to extract APP headers from JPEGs (Exif, GPS, etc)
	- ability to replace width/height tags in extracted JPEG headers
	- ability to restore APP headers, that were for example stripped during image manipulation

	@class ImageInfo
	@constructor
	@param {String} data Image source as binary string
	*/
	return function(data) {
		var _cs = [JPEG, PNG], _img;

		// figure out the format, throw: ImageError.WRONG_FORMAT if not supported
		_img = (function() {
			for (var i = 0; i < _cs.length; i++) {
				try {
					return new _cs[i](data);
				} catch (ex) {
					// console.info(ex);
				}
			}
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}());

		Basic.extend(this, {
			/**
			Image Mime Type extracted from it's depths

			@property type
			@type {String}
			@default ''
			*/
			type: '',

			/**
			Image size in bytes

			@property size
			@type {Number}
			@default 0
			*/
			size: 0,

			/**
			Image width extracted from image source

			@property width
			@type {Number}
			@default 0
			*/
			width: 0,

			/**
			Image height extracted from image source

			@property height
			@type {Number}
			@default 0
			*/
			height: 0,

			/**
			Sets Exif tag. Currently applicable only for width and height tags. Obviously works only with JPEGs.

			@method setExif
			@param {String} tag Tag to set
			@param {Mixed} value Value to assign to the tag
			*/
			setExif: function() {},

			/**
			Restores headers to the source.

			@method writeHeaders
			@param {String} data Image source as binary string
			@return {String} Updated binary string
			*/
			writeHeaders: function(data) {
				return data;
			},

			/**
			Strip all headers from the source.

			@method stripHeaders
			@param {String} data Image source as binary string
			@return {String} Updated binary string
			*/
			stripHeaders: function(data) {
				return data;
			},

			/**
			Dispose resources.

			@method purge
			*/
			purge: function() {
				data = null;
			}
		});

		Basic.extend(this, _img);

		this.purge = function() {
			_img.purge();
			_img = null;
		};
	};
});

// Included from: src/javascript/runtime/html5/image/ResizerCanvas.js

/**
 * ResizerCanvas.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
 * Resizes image/canvas using canvas
 */
define("moxie/runtime/html5/image/ResizerCanvas", [], function() {

    function scale(image, ratio) {
        var sW = image.width;
        var dW = Math.floor(sW * ratio);
        var scaleCapped = false;

        if (ratio < 0.5 || ratio > 2) {
            ratio = ratio < 0.5 ? 0.5 : 2;
            scaleCapped = true;
        }

        var tCanvas = _scale(image, ratio);

        if (scaleCapped) {
            return scale(tCanvas, dW / tCanvas.width);
        } else {
            return tCanvas;
        }
    }


    function _scale(image, ratio) {
        var sW = image.width;
        var sH = image.height;
        var dW = Math.floor(sW * ratio);
        var dH = Math.floor(sH * ratio);

        var canvas = document.createElement('canvas');
        canvas.width = dW;
        canvas.height = dH;
        canvas.getContext("2d").drawImage(image, 0, 0, sW, sH, 0, 0, dW, dH);

        image = null; // just in case
        return canvas;
    }

    return {
        scale: scale
    };

});

// Included from: src/javascript/runtime/html5/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/Image
@private
*/
define("moxie/runtime/html5/image/Image", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/core/utils/Encode",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/runtime/html5/image/ImageInfo",
	"moxie/runtime/html5/image/ResizerCanvas",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, Basic, x, Encode, Blob, File, ImageInfo, ResizerCanvas, Mime, Env) {

	function HTML5Image() {
		var me = this
		, _img, _imgInfo, _canvas, _binStr, _blob
		, _modified = false // is set true whenever image is modified
		, _preserveHeaders = true
		;

		Basic.extend(this, {
			loadFromBlob: function(blob) {
				var I = this.getRuntime()
				, asBinary = arguments.length > 1 ? arguments[1] : true
				;

				if (!I.can('access_binary')) {
					throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
				}

				_blob = blob;

				if (blob.isDetached()) {
					_binStr = blob.getSource();
					_preload.call(this, _binStr);
					return;
				} else {
					_readAsDataUrl.call(this, blob.getSource(), function(dataUrl) {
						if (asBinary) {
							_binStr = _toBinary(dataUrl);
						}
						_preload.call(this, dataUrl);
					});
				}
			},

			loadFromImage: function(img, exact) {
				this.meta = img.meta;

				_blob = new File(null, {
					name: img.name,
					size: img.size,
					type: img.type
				});

				_preload.call(this, exact ? (_binStr = img.getAsBinaryString()) : img.getAsDataURL());
			},

			getInfo: function() {
				var I = this.getRuntime(), info;

				if (!_imgInfo && _binStr && I.can('access_image_binary')) {
					_imgInfo = new ImageInfo(_binStr);
				}

				// this stuff below is definitely having fun with itself
				info = {
					width: _getImg().width || 0,
					height: _getImg().height || 0,
					type: _blob.type || Mime.getFileMime(_blob.name),
					size: _binStr && _binStr.length || _blob.size || 0,
					name: _blob.name || '',
					meta: null
				};

				if (_preserveHeaders) {
					info.meta = _imgInfo && _imgInfo.meta || this.meta || {};

					// if data was taken from ImageInfo it will be a binary string, so we convert it to blob
					if (info.meta && info.meta.thumb && !(info.meta.thumb.data instanceof Blob)) {
						info.meta.thumb.data = new Blob(null, {
							type: 'image/jpeg',
							data: info.meta.thumb.data
						});
					}
				}

				return info;
			},


			resize: function(rect, ratio, options) {
				var canvas = document.createElement('canvas');
				canvas.width = rect.width;
				canvas.height = rect.height;

				canvas.getContext("2d").drawImage(_getImg(), rect.x, rect.y, rect.width, rect.height, 0, 0, canvas.width, canvas.height);

				_canvas = ResizerCanvas.scale(canvas, ratio);

				_preserveHeaders = options.preserveHeaders;

				// rotate if required, according to orientation tag
				if (!_preserveHeaders) {
					var orientation = (this.meta && this.meta.tiff && this.meta.tiff.Orientation) || 1;
					_canvas = _rotateToOrientaion(_canvas, orientation);
				}

				this.width = _canvas.width;
				this.height = _canvas.height;

				_modified = true;

				this.trigger('Resize');
			},

			getAsCanvas: function() {
				if (!_canvas) {
					_canvas = _getCanvas();
				}
				_canvas.id = this.uid + '_canvas';
				return _canvas;
			},

			getAsBlob: function(type, quality) {
				if (type !== this.type) {
					_modified = true; // reconsider the state
					return new File(null, {
						name: _blob.name || '',
						type: type,
						data: me.getAsDataURL(type, quality)
					});
				}
				return new File(null, {
					name: _blob.name || '',
					type: type,
					data: me.getAsBinaryString(type, quality)
				});
			},

			getAsDataURL: function(type) {
				var quality = arguments[1] || 90;

				// if image has not been modified, return the source right away
				if (!_modified) {
					return _img.src;
				}

				// make sure we have a canvas to work with
				_getCanvas();

				if ('image/jpeg' !== type) {
					return _canvas.toDataURL('image/png');
				} else {
					try {
						// older Geckos used to result in an exception on quality argument
						return _canvas.toDataURL('image/jpeg', quality/100);
					} catch (ex) {
						return _canvas.toDataURL('image/jpeg');
					}
				}
			},

			getAsBinaryString: function(type, quality) {
				// if image has not been modified, return the source right away
				if (!_modified) {
					// if image was not loaded from binary string
					if (!_binStr) {
						_binStr = _toBinary(me.getAsDataURL(type, quality));
					}
					return _binStr;
				}

				if ('image/jpeg' !== type) {
					_binStr = _toBinary(me.getAsDataURL(type, quality));
				} else {
					var dataUrl;

					// if jpeg
					if (!quality) {
						quality = 90;
					}

					// make sure we have a canvas to work with
					_getCanvas();

					try {
						// older Geckos used to result in an exception on quality argument
						dataUrl = _canvas.toDataURL('image/jpeg', quality/100);
					} catch (ex) {
						dataUrl = _canvas.toDataURL('image/jpeg');
					}

					_binStr = _toBinary(dataUrl);

					if (_imgInfo) {
						_binStr = _imgInfo.stripHeaders(_binStr);

						if (_preserveHeaders) {
							// update dimensions info in exif
							if (_imgInfo.meta && _imgInfo.meta.exif) {
								_imgInfo.setExif({
									PixelXDimension: this.width,
									PixelYDimension: this.height
								});
							}

							// re-inject the headers
							_binStr = _imgInfo.writeHeaders(_binStr);
						}

						// will be re-created from fresh on next getInfo call
						_imgInfo.purge();
						_imgInfo = null;
					}
				}

				_modified = false;

				return _binStr;
			},

			destroy: function() {
				me = null;
				_purge.call(this);
				this.getRuntime().getShim().removeInstance(this.uid);
			}
		});


		function _getImg() {
			if (!_canvas && !_img) {
				throw new x.ImageError(x.DOMException.INVALID_STATE_ERR);
			}
			return _canvas || _img;
		}


		function _getCanvas() {
			var canvas = _getImg();
			if (canvas.nodeName.toLowerCase() == 'canvas') {
				return canvas;
			}
			_canvas = document.createElement('canvas');
			_canvas.width = canvas.width;
			_canvas.height = canvas.height;
			_canvas.getContext("2d").drawImage(canvas, 0, 0);
			return _canvas;
		}


		function _toBinary(str) {
			return Encode.atob(str.substring(str.indexOf('base64,') + 7));
		}


		function _toDataUrl(str, type) {
			return 'data:' + (type || '') + ';base64,' + Encode.btoa(str);
		}


		function _preload(str) {
			var comp = this;

			_img = new Image();
			_img.onerror = function() {
				_purge.call(this);
				comp.trigger('error', x.ImageError.WRONG_FORMAT);
			};
			_img.onload = function() {
				comp.trigger('load');
			};

			_img.src = str.substr(0, 5) == 'data:' ? str : _toDataUrl(str, _blob.type);
		}


		function _readAsDataUrl(file, callback) {
			var comp = this, fr;

			// use FileReader if it's available
			if (window.FileReader) {
				fr = new FileReader();
				fr.onload = function() {
					callback.call(comp, this.result);
				};
				fr.onerror = function() {
					comp.trigger('error', x.ImageError.WRONG_FORMAT);
				};
				fr.readAsDataURL(file);
			} else {
				return callback.call(this, file.getAsDataURL());
			}
		}

		/**
		* Transform canvas coordination according to specified frame size and orientation
		* Orientation value is from EXIF tag
		* @author Shinichi Tomita <shinichi.tomita@gmail.com>
		*/
		function _rotateToOrientaion(img, orientation) {
			var RADIANS = Math.PI/180;
			var canvas = document.createElement('canvas');
			var ctx = canvas.getContext('2d');
			var width = img.width;
			var height = img.height;

			if (Basic.inArray(orientation, [5,6,7,8]) > -1) {
				canvas.width = height;
				canvas.height = width;
			} else {
				canvas.width = width;
				canvas.height = height;
			}

			/**
			1 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
			2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
			3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
			4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
			5 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
			6 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
			7 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
			8 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
			*/
			switch (orientation) {
				case 2:
					// horizontal flip
					ctx.translate(width, 0);
					ctx.scale(-1, 1);
					break;
				case 3:
					// 180 rotate left
					ctx.translate(width, height);
					ctx.rotate(180 * RADIANS);
					break;
				case 4:
					// vertical flip
					ctx.translate(0, height);
					ctx.scale(1, -1);
					break;
				case 5:
					// vertical flip + 90 rotate right
					ctx.rotate(90 * RADIANS);
					ctx.scale(1, -1);
					break;
				case 6:
					// 90 rotate right
					ctx.rotate(90 * RADIANS);
					ctx.translate(0, -height);
					break;
				case 7:
					// horizontal flip + 90 rotate right
					ctx.rotate(90 * RADIANS);
					ctx.translate(width, -height);
					ctx.scale(-1, 1);
					break;
				case 8:
					// 90 rotate left
					ctx.rotate(-90 * RADIANS);
					ctx.translate(-width, 0);
					break;
			}

			ctx.drawImage(img, 0, 0, width, height);
			return canvas;
		}


		function _purge() {
			if (_imgInfo) {
				_imgInfo.purge();
				_imgInfo = null;
			}

			_binStr = _img = _canvas = _blob = null;
			_modified = false;
		}
	}

	return (extensions.Image = HTML5Image);
});

// Included from: src/javascript/runtime/flash/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
Defines constructor for Flash runtime.

@class moxie/runtime/flash/Runtime
@private
*/
define("moxie/runtime/flash/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Env",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime"
], function(Basic, Env, Dom, x, Runtime) {
	
	var type = 'flash', extensions = {};

	/**
	Get the version of the Flash Player

	@method getShimVersion
	@private
	@return {Number} Flash Player version
	*/
	function getShimVersion() {
		var version;

		try {
			version = navigator.plugins['Shockwave Flash'];
			version = version.description;
		} catch (e1) {
			try {
				version = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
			} catch (e2) {
				version = '0.0';
			}
		}
		version = version.match(/\d+/g);
		return parseFloat(version[0] + '.' + version[1]);
	}


	/**
	Cross-browser SWF removal
    	- Especially needed to safely and completely remove a SWF in Internet Explorer

   	Originated from SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	*/
	function removeSWF(id) {
        var obj = Dom.get(id);
        if (obj && obj.nodeName == "OBJECT") {
            if (Env.browser === 'IE') {
                obj.style.display = "none";
                (function onInit(){
                	// http://msdn.microsoft.com/en-us/library/ie/ms534360(v=vs.85).aspx
                    if (obj.readyState == 4) {
                        removeObjectInIE(id);
                    }
                    else {
                        setTimeout(onInit, 10);
                    }
                })();
            }
            else {
                obj.parentNode.removeChild(obj);
            }
        }
    }


	function removeObjectInIE(id) {
        var obj = Dom.get(id);
        if (obj) {
            for (var i in obj) {
                if (typeof obj[i] == "function") {
                    obj[i] = null;
                }
            }
            obj.parentNode.removeChild(obj);
        }
    }

	/**
	Constructor for the Flash Runtime

	@class FlashRuntime
	@extends Runtime
	*/
	function FlashRuntime(options) {
		var I = this, initTimer;

		options = Basic.extend({ swf_url: Env.swf_url }, options);

		Runtime.call(this, options, type, {
			access_binary: function(value) {
				return value && I.mode === 'browser';
			},
			access_image_binary: function(value) {
				return value && I.mode === 'browser';
			},
			display_media: Runtime.capTest(defined('moxie/image/Image')),
			do_cors: Runtime.capTrue,
			drag_and_drop: false,
			report_upload_progress: function() {
				return I.mode === 'client';
			},
			resize_image: Runtime.capTrue,
			return_response_headers: false,
			return_response_type: function(responseType) {
				if (responseType === 'json' && !!window.JSON) {
					return true;
				} 
				return !Basic.arrayDiff(responseType, ['', 'text', 'document']) || I.mode === 'browser';
			},
			return_status_code: function(code) {
				return I.mode === 'browser' || !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: Runtime.capTrue,
			select_multiple: Runtime.capTrue,
			send_binary_string: function(value) {
				return value && I.mode === 'browser';
			},
			send_browser_cookies: function(value) {
				return value && I.mode === 'browser';
			},
			send_custom_headers: function(value) {
				return value && I.mode === 'browser';
			},
			send_multipart: Runtime.capTrue,
			slice_blob: function(value) {
				return value && I.mode === 'browser';
			},
			stream_upload: function(value) {
				return value && I.mode === 'browser';
			},
			summon_file_dialog: false,
			upload_filesize: function(size) {
				return Basic.parseSizeStr(size) <= 2097152 || I.mode === 'client';
			},
			use_http_method: function(methods) {
				return !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		}, { 
			// capabilities that require specific mode
			access_binary: function(value) {
				return value ? 'browser' : 'client';
			},
			access_image_binary: function(value) {
				return value ? 'browser' : 'client';
			},
			report_upload_progress: function(value) {
				return value ? 'browser' : 'client';
			},
			return_response_type: function(responseType) {
				return Basic.arrayDiff(responseType, ['', 'text', 'json', 'document']) ? 'browser' : ['client', 'browser'];
			},
			return_status_code: function(code) {
				return Basic.arrayDiff(code, [200, 404]) ? 'browser' : ['client', 'browser'];
			},
			send_binary_string: function(value) {
				return value ? 'browser' : 'client';
			},
			send_browser_cookies: function(value) {
				return value ? 'browser' : 'client';
			},
			send_custom_headers: function(value) {
				return value ? 'browser' : 'client';
			},
			slice_blob: function(value) {
				return value ? 'browser' : 'client';
			},
			stream_upload: function(value) {
				return value ? 'client' : 'browser';
			},
			upload_filesize: function(size) {
				return Basic.parseSizeStr(size) >= 2097152 ? 'client' : 'browser';
			}
		}, 'client');


		// minimal requirement for Flash Player version
		if (getShimVersion() < 11.3) {
			if (MXI_DEBUG && Env.debug.runtime) {
				Env.log("\tFlash didn't meet minimal version requirement (11.3).");	
			}

			this.mode = false; // with falsy mode, runtime won't operable, no matter what the mode was before
		}


		Basic.extend(this, {

			getShim: function() {
				return Dom.get(this.uid);
			},

			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return I.getShim().exec(this.uid, component, action, args);
			},

			init: function() {
				var html, el, container;

				container = this.getShimContainer();

				// if not the minimal height, shims are not initialized in older browsers (e.g FF3.6, IE6,7,8, Safari 4.0,5.0, etc)
				Basic.extend(container.style, {
					position: 'absolute',
					top: '-8px',
					left: '-8px',
					width: '9px',
					height: '9px',
					overflow: 'hidden'
				});

				// insert flash object
				html = '<object id="' + this.uid + '" type="application/x-shockwave-flash" data="' +  options.swf_url + '" ';

				if (Env.browser === 'IE') {
					html += 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" ';
				}

				html += 'width="100%" height="100%" style="outline:0">'  +
					'<param name="movie" value="' + options.swf_url + '" />' +
					'<param name="flashvars" value="uid=' + escape(this.uid) + '&target=' + Env.global_event_dispatcher + '" />' +
					'<param name="wmode" value="transparent" />' +
					'<param name="allowscriptaccess" value="always" />' +
				'</object>';

				if (Env.browser === 'IE') {
					el = document.createElement('div');
					container.appendChild(el);
					el.outerHTML = html;
					el = container = null; // just in case
				} else {
					container.innerHTML = html;
				}

				// Init is dispatched by the shim
				initTimer = setTimeout(function() {
					if (I && !I.initialized) { // runtime might be already destroyed by this moment
						I.trigger("Error", new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("\tFlash failed to initialize within a specified period of time (typically 5s).");	
						}
					}
				}, 5000);
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					removeSWF(I.uid); // SWF removal requires special care in IE

					destroy.call(I);
					clearTimeout(initTimer); // initialization check might be still onwait
					options = initTimer = destroy = I = null;
				};
			}(this.destroy))

		}, extensions);
	}

	Runtime.addConstructor(type, FlashRuntime);

	return extensions;
});

// Included from: src/javascript/runtime/flash/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/Blob
@private
*/
define("moxie/runtime/flash/file/Blob", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	var FlashBlob = {
		slice: function(blob, start, end, type) {
			var self = this.getRuntime();

			if (start < 0) {
				start = Math.max(blob.size + start, 0);
			} else if (start > 0) {
				start = Math.min(start, blob.size);
			}

			if (end < 0) {
				end = Math.max(blob.size + end, 0);
			} else if (end > 0) {
				end = Math.min(end, blob.size);
			}

			blob = self.shimExec.call(this, 'Blob', 'slice', start, end, type || '');

			if (blob) {
				blob = new Blob(self.uid, blob);
			}
			return blob;
		}
	};

	return (extensions.Blob = FlashBlob);
});

// Included from: src/javascript/runtime/flash/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileInput
@private
*/
define("moxie/runtime/flash/file/FileInput", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic"
], function(extensions, File, Basic) {
	
	var FileInput = {		
		init: function(options) {
			var comp = this, I = this.getRuntime();

			this.bind("Change", function() {
				var files = I.shimExec.call(comp, 'FileInput', 'getFiles');
				comp.files = [];
				Basic.each(files, function(file) {
					comp.files.push(new File(I.uid, file));
				});
			}, 999);

			this.getRuntime().shimExec.call(this, 'FileInput', 'init', {
				accept: options.accept,
				multiple: options.multiple
			});

			this.trigger('ready');
		}
	};

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/flash/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileReader
@private
*/
define("moxie/runtime/flash/file/FileReader", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Encode"
], function(extensions, Encode) {

	function _formatData(data, op) {
		switch (op) {
			case 'readAsText':
				return Encode.atob(data, 'utf8');
			case 'readAsBinaryString':
				return Encode.atob(data);
			case 'readAsDataURL':
				return data;
		}
		return null;
	}

	var FileReader = {
		read: function(op, blob) {
			var comp = this;

			comp.result = '';

			// special prefix for DataURL read mode
			if (op === 'readAsDataURL') {
				comp.result = 'data:' + (blob.type || '') + ';base64,';
			}

			comp.bind('Progress', function(e, data) {
				if (data) {
					comp.result += _formatData(data, op);
				}
			}, 999);

			return comp.getRuntime().shimExec.call(this, 'FileReader', 'readAsBase64', blob.uid);
		}
	};

	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/flash/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileReaderSync
@private
*/
define("moxie/runtime/flash/file/FileReaderSync", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Encode"
], function(extensions, Encode) {
	
	function _formatData(data, op) {
		switch (op) {
			case 'readAsText':
				return Encode.atob(data, 'utf8');
			case 'readAsBinaryString':
				return Encode.atob(data);
			case 'readAsDataURL':
				return data;
		}
		return null;
	}

	var FileReaderSync = {
		read: function(op, blob) {
			var result, self = this.getRuntime();

			result = self.shimExec.call(this, 'FileReaderSync', 'readAsBase64', blob.uid);
			if (!result) {
				return null; // or throw ex
			}

			// special prefix for DataURL read mode
			if (op === 'readAsDataURL') {
				result = 'data:' + (blob.type || '') + ';base64,' + result;
			}

			return _formatData(result, op, blob.type);
		}
	};

	return (extensions.FileReaderSync = FileReaderSync);
});

// Included from: src/javascript/runtime/flash/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/runtime/Transporter
@private
*/
define("moxie/runtime/flash/runtime/Transporter", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	var Transporter = {
		getAsBlob: function(type) {
			var self = this.getRuntime()
			, blob = self.shimExec.call(this, 'Transporter', 'getAsBlob', type)
			;
			if (blob) {
				return new Blob(self.uid, blob);
			}
			return null;
		}
	};

	return (extensions.Transporter = Transporter);
});

// Included from: src/javascript/runtime/flash/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/flash/xhr/XMLHttpRequest", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Basic",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/file/FileReaderSync",
	"moxie/runtime/flash/file/FileReaderSync",
	"moxie/xhr/FormData",
	"moxie/runtime/Transporter",
	"moxie/runtime/flash/runtime/Transporter"
], function(extensions, Basic, Blob, File, FileReaderSync, FileReaderSyncFlash, FormData, Transporter, TransporterFlash) {
	
	var XMLHttpRequest = {

		send: function(meta, data) {
			var target = this, self = target.getRuntime();

			function send() {
				meta.transport = self.mode;
				self.shimExec.call(target, 'XMLHttpRequest', 'send', meta, data);
			}


			function appendBlob(name, blob) {
				self.shimExec.call(target, 'XMLHttpRequest', 'appendBlob', name, blob.uid);
				data = null;
				send();
			}


			function attachBlob(blob, cb) {
				var tr = new Transporter();

				tr.bind("TransportingComplete", function() {
					cb(this.result);
				});

				tr.transport(blob.getSource(), blob.type, {
					ruid: self.uid
				});
			}

			// copy over the headers if any
			if (!Basic.isEmptyObj(meta.headers)) {
				Basic.each(meta.headers, function(value, header) {
					self.shimExec.call(target, 'XMLHttpRequest', 'setRequestHeader', header, value.toString()); // Silverlight doesn't accept integers into the arguments of type object
				});
			}

			// transfer over multipart params and blob itself
			if (data instanceof FormData) {
				var blobField;
				data.each(function(value, name) {
					if (value instanceof Blob) {
						blobField = name;
					} else {
						self.shimExec.call(target, 'XMLHttpRequest', 'append', name, value);
					}
				});

				if (!data.hasBlob()) {
					data = null;
					send();
				} else {
					var blob = data.getBlob();
					if (blob.isDetached()) {
						attachBlob(blob, function(attachedBlob) {
							blob.destroy();
							appendBlob(blobField, attachedBlob);		
						});
					} else {
						appendBlob(blobField, blob);
					}
				}
			} else if (data instanceof Blob) {
				if (data.isDetached()) {
					attachBlob(data, function(attachedBlob) {
						data.destroy();
						data = attachedBlob.uid;
						send();
					});
				} else {
					data = data.uid;
					send();
				}
			} else {
				send();
			}
		},

		getResponse: function(responseType) {
			var frs, blob, self = this.getRuntime();

			blob = self.shimExec.call(this, 'XMLHttpRequest', 'getResponseAsBlob');

			if (blob) {
				blob = new File(self.uid, blob);

				if ('blob' === responseType) {
					return blob;
				}

				try { 
					frs = new FileReaderSync();

					if (!!~Basic.inArray(responseType, ["", "text"])) {
						return frs.readAsText(blob);
					} else if ('json' === responseType && !!window.JSON) {
						return JSON.parse(frs.readAsText(blob));
					}
				} finally {
					blob.destroy();
				}
			}
			return null;
		},

		abort: function(upload_complete_flag) {
			var self = this.getRuntime();

			self.shimExec.call(this, 'XMLHttpRequest', 'abort');

			this.dispatchEvent('readystatechange');
			// this.dispatchEvent('progress');
			this.dispatchEvent('abort');

			//if (!upload_complete_flag) {
				// this.dispatchEvent('uploadprogress');
			//}
		}
	};

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/flash/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/image/Image
@private
*/
define("moxie/runtime/flash/image/Image", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/Transporter",
	"moxie/file/Blob",
	"moxie/file/FileReaderSync"
], function(extensions, Basic, Transporter, Blob, FileReaderSync) {
	
	var Image = {
		loadFromBlob: function(blob) {
			var comp = this, self = comp.getRuntime();

			function exec(srcBlob) {
				self.shimExec.call(comp, 'Image', 'loadFromBlob', srcBlob.uid);
				comp = self = null;
			}

			if (blob.isDetached()) { // binary string
				var tr = new Transporter();
				tr.bind("TransportingComplete", function() {
					exec(tr.result.getSource());
				});
				tr.transport(blob.getSource(), blob.type, { ruid: self.uid });
			} else {
				exec(blob.getSource());
			}
		},

		loadFromImage: function(img) {
			var self = this.getRuntime();
			return self.shimExec.call(this, 'Image', 'loadFromImage', img.uid);
		},

		getInfo: function() {
			var self = this.getRuntime()
			, info = self.shimExec.call(this, 'Image', 'getInfo')
			;

			if (info.meta && info.meta.thumb && info.meta.thumb.data && !(self.meta.thumb.data instanceof Blob)) {
				info.meta.thumb.data = new Blob(self.uid, info.meta.thumb.data);
			}
			return info;
		},

		getAsBlob: function(type, quality) {
			var self = this.getRuntime()
			, blob = self.shimExec.call(this, 'Image', 'getAsBlob', type, quality)
			;
			if (blob) {
				return new Blob(self.uid, blob);
			}
			return null;
		},

		getAsDataURL: function() {
			var self = this.getRuntime()
			, blob = self.Image.getAsBlob.apply(this, arguments)
			, frs
			;
			if (!blob) {
				return null;
			}
			frs = new FileReaderSync();
			return frs.readAsDataURL(blob);
		}
	};

	return (extensions.Image = Image);
});

// Included from: src/javascript/runtime/silverlight/Runtime.js

/**
 * RunTime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
Defines constructor for Silverlight runtime.

@class moxie/runtime/silverlight/Runtime
@private
*/
define("moxie/runtime/silverlight/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Env",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime"
], function(Basic, Env, Dom, x, Runtime) {
	
	var type = "silverlight", extensions = {};

	function isInstalled(version) {
		var isVersionSupported = false, control = null, actualVer,
			actualVerArray, reqVerArray, requiredVersionPart, actualVersionPart, index = 0;

		try {
			try {
				control = new ActiveXObject('AgControl.AgControl');

				if (control.IsVersionSupported(version)) {
					isVersionSupported = true;
				}

				control = null;
			} catch (e) {
				var plugin = navigator.plugins["Silverlight Plug-In"];

				if (plugin) {
					actualVer = plugin.description;

					if (actualVer === "1.0.30226.2") {
						actualVer = "2.0.30226.2";
					}

					actualVerArray = actualVer.split(".");

					while (actualVerArray.length > 3) {
						actualVerArray.pop();
					}

					while ( actualVerArray.length < 4) {
						actualVerArray.push(0);
					}

					reqVerArray = version.split(".");

					while (reqVerArray.length > 4) {
						reqVerArray.pop();
					}

					do {
						requiredVersionPart = parseInt(reqVerArray[index], 10);
						actualVersionPart = parseInt(actualVerArray[index], 10);
						index++;
					} while (index < reqVerArray.length && requiredVersionPart === actualVersionPart);

					if (requiredVersionPart <= actualVersionPart && !isNaN(requiredVersionPart)) {
						isVersionSupported = true;
					}
				}
			}
		} catch (e2) {
			isVersionSupported = false;
		}

		return isVersionSupported;
	}

	/**
	Constructor for the Silverlight Runtime

	@class SilverlightRuntime
	@extends Runtime
	*/
	function SilverlightRuntime(options) {
		var I = this, initTimer;

		options = Basic.extend({ xap_url: Env.xap_url }, options);

		Runtime.call(this, options, type, {
			access_binary: Runtime.capTrue,
			access_image_binary: Runtime.capTrue,
			display_media: Runtime.capTest(defined('moxie/image/Image')),
			do_cors: Runtime.capTrue,
			drag_and_drop: false,
			report_upload_progress: Runtime.capTrue,
			resize_image: Runtime.capTrue,
			return_response_headers: function(value) {
				return value && I.mode === 'client';
			},
			return_response_type: function(responseType) {
				if (responseType !== 'json') {
					return true;
				} else {
					return !!window.JSON;
				}
			},
			return_status_code: function(code) {
				return I.mode === 'client' || !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: Runtime.capTrue,
			select_multiple: Runtime.capTrue,
			send_binary_string: Runtime.capTrue,
			send_browser_cookies: function(value) {
				return value && I.mode === 'browser';
			},
			send_custom_headers: function(value) {
				return value && I.mode === 'client';
			},
			send_multipart: Runtime.capTrue,
			slice_blob: Runtime.capTrue,
			stream_upload: true,
			summon_file_dialog: false,
			upload_filesize: Runtime.capTrue,
			use_http_method: function(methods) {
				return I.mode === 'client' || !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		}, { 
			// capabilities that require specific mode
			return_response_headers: function(value) {
				return value ? 'client' : 'browser';
			},
			return_status_code: function(code) {
				return Basic.arrayDiff(code, [200, 404]) ? 'client' : ['client', 'browser'];
			},
			send_browser_cookies: function(value) {
				return value ? 'browser' : 'client';
			},
			send_custom_headers: function(value) {
				return value ? 'client' : 'browser';
			},
			use_http_method: function(methods) {
				return Basic.arrayDiff(methods, ['GET', 'POST']) ? 'client' : ['client', 'browser'];
			}
		});


		// minimal requirement
		if (!isInstalled('2.0.31005.0') || Env.browser === 'Opera') {
			if (MXI_DEBUG && Env.debug.runtime) {
				Env.log("\tSilverlight is not installed or minimal version (2.0.31005.0) requirement not met (not likely).");	
			}

			this.mode = false;
		}


		Basic.extend(this, {
			getShim: function() {
				return Dom.get(this.uid).content.Moxie;
			},

			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return I.getShim().exec(this.uid, component, action, args);
			},

			init : function() {
				var container;

				container = this.getShimContainer();

				container.innerHTML = '<object id="' + this.uid + '" data="data:application/x-silverlight," type="application/x-silverlight-2" width="100%" height="100%" style="outline:none;">' +
					'<param name="source" value="' + options.xap_url + '"/>' +
					'<param name="background" value="Transparent"/>' +
					'<param name="windowless" value="true"/>' +
					'<param name="enablehtmlaccess" value="true"/>' +
					'<param name="initParams" value="uid=' + this.uid + ',target=' + Env.global_event_dispatcher + '"/>' +
				'</object>';

				// Init is dispatched by the shim
				initTimer = setTimeout(function() {
					if (I && !I.initialized) { // runtime might be already destroyed by this moment
						I.trigger("Error", new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));

						if (MXI_DEBUG && Env.debug.runtime) {
							Env.log("\Silverlight failed to initialize within a specified period of time (5-10s).");	
						}
					}
				}, Env.OS !== 'Windows'? 10000 : 5000); // give it more time to initialize in non Windows OS (like Mac)
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					clearTimeout(initTimer); // initialization check might be still onwait
					options = initTimer = destroy = I = null;
				};
			}(this.destroy))

		}, extensions);
	}

	Runtime.addConstructor(type, SilverlightRuntime); 

	return extensions;
});

// Included from: src/javascript/runtime/silverlight/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/Blob
@private
*/
define("moxie/runtime/silverlight/file/Blob", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/Blob"
], function(extensions, Basic, Blob) {
	return (extensions.Blob = Basic.extend({}, Blob));
});

// Included from: src/javascript/runtime/silverlight/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileInput
@private
*/
define("moxie/runtime/silverlight/file/FileInput", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic"
], function(extensions, File, Basic) {

	function toFilters(accept) {
		var filter = '';
		for (var i = 0; i < accept.length; i++) {
			filter += (filter !== '' ? '|' : '') + accept[i].title + " | *." + accept[i].extensions.replace(/,/g, ';*.');
		}
		return filter;
	}

	
	var FileInput = {
		init: function(options) {
			var comp = this, I = this.getRuntime();

			this.bind("Change", function() {
				var files = I.shimExec.call(comp, 'FileInput', 'getFiles');
				comp.files = [];
				Basic.each(files, function(file) {
					comp.files.push(new File(I.uid, file));
				});
			}, 999);
			
			I.shimExec.call(this, 'FileInput', 'init', toFilters(options.accept), options.multiple);
			this.trigger('ready');
		},

		setOption: function(name, value) {
			if (name == 'accept') {
				value = toFilters(value);
			}
			this.getRuntime().shimExec.call(this, 'FileInput', 'setOption', name, value);
		}
	};

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/silverlight/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileDrop
@private
*/
define("moxie/runtime/silverlight/file/FileDrop", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Dom", 
	"moxie/core/utils/Events"
], function(extensions, Dom, Events) {

	// not exactly useful, since works only in safari (...crickets...)
	var FileDrop = {
		init: function() {
			var comp = this, self = comp.getRuntime(), dropZone;

			dropZone = self.getShimContainer();

			Events.addEvent(dropZone, 'dragover', function(e) {
				e.preventDefault();
				e.stopPropagation();
				e.dataTransfer.dropEffect = 'copy';
			}, comp.uid);

			Events.addEvent(dropZone, 'dragenter', function(e) {
				e.preventDefault();
				var flag = Dom.get(self.uid).dragEnter(e);
				// If handled, then stop propagation of event in DOM
				if (flag) {
					e.stopPropagation();
				}
			}, comp.uid);

			Events.addEvent(dropZone, 'drop', function(e) {
				e.preventDefault();
				var flag = Dom.get(self.uid).dragDrop(e);
				// If handled, then stop propagation of event in DOM
				if (flag) {
					e.stopPropagation();
				}
			}, comp.uid);

			return self.shimExec.call(this, 'FileDrop', 'init');
		}
	};

	return (extensions.FileDrop = FileDrop);
});

// Included from: src/javascript/runtime/silverlight/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileReader
@private
*/
define("moxie/runtime/silverlight/file/FileReader", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/FileReader"
], function(extensions, Basic, FileReader) {
	return (extensions.FileReader = Basic.extend({}, FileReader));
});

// Included from: src/javascript/runtime/silverlight/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileReaderSync
@private
*/
define("moxie/runtime/silverlight/file/FileReaderSync", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/FileReaderSync"
], function(extensions, Basic, FileReaderSync) {
	return (extensions.FileReaderSync = Basic.extend({}, FileReaderSync));
});

// Included from: src/javascript/runtime/silverlight/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/runtime/Transporter
@private
*/
define("moxie/runtime/silverlight/runtime/Transporter", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/runtime/Transporter"
], function(extensions, Basic, Transporter) {
	return (extensions.Transporter = Basic.extend({}, Transporter));
});

// Included from: src/javascript/runtime/silverlight/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/silverlight/xhr/XMLHttpRequest", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/xhr/XMLHttpRequest",
	"moxie/runtime/silverlight/file/FileReaderSync",
	"moxie/runtime/silverlight/runtime/Transporter"
], function(extensions, Basic, XMLHttpRequest, FileReaderSyncSilverlight, TransporterSilverlight) {
	return (extensions.XMLHttpRequest = Basic.extend({}, XMLHttpRequest));
});

// Included from: src/javascript/runtime/silverlight/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */
 
/**
@class moxie/runtime/silverlight/image/Image
@private
*/
define("moxie/runtime/silverlight/image/Image", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/file/Blob",
	"moxie/runtime/flash/image/Image"
], function(extensions, Basic, Blob, Image) {
	return (extensions.Image = Basic.extend({}, Image, {

		getInfo: function() {
			var self = this.getRuntime()
			, grps = ['tiff', 'exif', 'gps', 'thumb']
			, info = { meta: {} }
			, rawInfo = self.shimExec.call(this, 'Image', 'getInfo')
			;

			if (rawInfo.meta) {
				Basic.each(grps, function(grp) {
					var meta = rawInfo.meta[grp]
					, tag
					, i
					, length
					, value
					;
					if (meta && meta.keys) {
						info.meta[grp] = {};
						for (i = 0, length = meta.keys.length; i < length; i++) {
							tag = meta.keys[i];
							value = meta[tag];
							if (value) {
								// convert numbers
								if (/^(\d|[1-9]\d+)$/.test(value)) { // integer (make sure doesn't start with zero)
									value = parseInt(value, 10);
								} else if (/^\d*\.\d+$/.test(value)) { // double
									value = parseFloat(value);
								}
								info.meta[grp][tag] = value;
							}
						}
					}
				});

				// save thumb data as blob
				if (info.meta && info.meta.thumb && info.meta.thumb.data && !(self.meta.thumb.data instanceof Blob)) {
					info.meta.thumb.data = new Blob(self.uid, info.meta.thumb.data);
				}
			}

			info.width = parseInt(rawInfo.width, 10);
			info.height = parseInt(rawInfo.height, 10);
			info.size = parseInt(rawInfo.size, 10);
			info.type = rawInfo.type;
			info.name = rawInfo.name;

			return info;
		},

		resize: function(rect, ratio, opts) {
			this.getRuntime().shimExec.call(this, 'Image', 'resize', rect.x, rect.y, rect.width, rect.height, ratio, opts.preserveHeaders, opts.resample);
		}
	}));
});

// Included from: src/javascript/runtime/html4/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global File:true */

/**
Defines constructor for HTML4 runtime.

@class moxie/runtime/html4/Runtime
@private
*/
define("moxie/runtime/html4/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime",
	"moxie/core/utils/Env"
], function(Basic, x, Runtime, Env) {
	
	var type = 'html4', extensions = {};

	function Html4Runtime(options) {
		var I = this
		, Test = Runtime.capTest
		, True = Runtime.capTrue
		;

		Runtime.call(this, options, type, {
			access_binary: Test(window.FileReader || window.File && File.getAsDataURL),
			access_image_binary: false,
			display_media: Test(
				(Env.can('create_canvas') || Env.can('use_data_uri_over32kb')) && 
				defined('moxie/image/Image')
			),
			do_cors: false,
			drag_and_drop: false,
			filter_by_extension: Test(function() { // if you know how to feature-detect this, please suggest
				return !(
					(Env.browser === 'Chrome' && Env.verComp(Env.version, 28, '<')) || 
					(Env.browser === 'IE' && Env.verComp(Env.version, 10, '<')) || 
					(Env.browser === 'Safari' && Env.verComp(Env.version, 7, '<')) ||
					(Env.browser === 'Firefox' && Env.verComp(Env.version, 37, '<'))
				);
			}()),
			resize_image: function() {
				return extensions.Image && I.can('access_binary') && Env.can('create_canvas');
			},
			report_upload_progress: false,
			return_response_headers: false,
			return_response_type: function(responseType) {
				if (responseType === 'json' && !!window.JSON) {
					return true;
				} 
				return !!~Basic.inArray(responseType, ['text', 'document', '']);
			},
			return_status_code: function(code) {
				return !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: function() {
				return Env.can('use_fileinput');
			},
			select_multiple: false,
			send_binary_string: false,
			send_custom_headers: false,
			send_multipart: true,
			slice_blob: false,
			stream_upload: function() {
				return I.can('select_file');
			},
			summon_file_dialog: function() { // yeah... some dirty sniffing here...
				return I.can('select_file') && (
					(Env.browser === 'Firefox' && Env.verComp(Env.version, 4, '>=')) ||
					(Env.browser === 'Opera' && Env.verComp(Env.version, 12, '>=')) ||
					(Env.browser === 'IE' && Env.verComp(Env.version, 10, '>=')) ||
					!!~Basic.inArray(Env.browser, ['Chrome', 'Safari'])
				);
			},
			upload_filesize: True,
			use_http_method: function(methods) {
				return !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		});


		Basic.extend(this, {
			init : function() {
				this.trigger("Init");
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					destroy = I = null;
				};
			}(this.destroy))
		});

		Basic.extend(this.getShim(), extensions);
	}

	Runtime.addConstructor(type, Html4Runtime);

	return extensions;
});

// Included from: src/javascript/runtime/html4/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/file/FileInput
@private
*/
define("moxie/runtime/html4/file/FileInput", [
	"moxie/runtime/html4/Runtime",
	"moxie/file/File",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, File, Basic, Dom, Events, Mime, Env) {
	
	function FileInput() {
		var _uid, _mimes = [], _options, _browseBtnZIndex; // save original z-index;

		function addInput() {
			var comp = this, I = comp.getRuntime(), shimContainer, browseButton, currForm, form, input, uid;

			uid = Basic.guid('uid_');

			shimContainer = I.getShimContainer(); // we get new ref every time to avoid memory leaks in IE

			if (_uid) { // move previous form out of the view
				currForm = Dom.get(_uid + '_form');
				if (currForm) {
					Basic.extend(currForm.style, { top: '100%' });
				}
			}

			// build form in DOM, since innerHTML version not able to submit file for some reason
			form = document.createElement('form');
			form.setAttribute('id', uid + '_form');
			form.setAttribute('method', 'post');
			form.setAttribute('enctype', 'multipart/form-data');
			form.setAttribute('encoding', 'multipart/form-data');

			Basic.extend(form.style, {
				overflow: 'hidden',
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
				height: '100%'
			});

			input = document.createElement('input');
			input.setAttribute('id', uid);
			input.setAttribute('type', 'file');
			input.setAttribute('accept', _mimes.join(','));

			Basic.extend(input.style, {
				fontSize: '999px',
				opacity: 0
			});

			form.appendChild(input);
			shimContainer.appendChild(form);

			// prepare file input to be placed underneath the browse_button element
			Basic.extend(input.style, {
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
				height: '100%'
			});

			if (Env.browser === 'IE' && Env.verComp(Env.version, 10, '<')) {
				Basic.extend(input.style, {
					filter : "progid:DXImageTransform.Microsoft.Alpha(opacity=0)"
				});
			}

			input.onchange = function() { // there should be only one handler for this
				var file;

				if (!this.value) {
					return;
				}

				if (this.files) { // check if browser is fresh enough
					file = this.files[0];

					// ignore empty files (IE10 for example hangs if you try to send them via XHR)
					if (file.size === 0) {
						form.parentNode.removeChild(form);
						return;
					}
				} else {
					file = {
						name: this.value
					};
				}

				file = new File(I.uid, file);

				// clear event handler
				this.onchange = function() {}; 
				addInput.call(comp); 

				comp.files = [file];

				// substitute all ids with file uids (consider file.uid read-only - we cannot do it the other way around)
				input.setAttribute('id', file.uid);
				form.setAttribute('id', file.uid + '_form');
				
				comp.trigger('change');

				input = form = null;
			};


			// route click event to the input
			if (I.can('summon_file_dialog')) {
				browseButton = Dom.get(_options.browse_button);
				Events.removeEvent(browseButton, 'click', comp.uid);
				Events.addEvent(browseButton, 'click', function(e) {
					if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
						input.click();
					}
					e.preventDefault();
				}, comp.uid);
			}

			_uid = uid;

			shimContainer = currForm = browseButton = null;
		}

		Basic.extend(this, {
			init: function(options) {
				var comp = this, I = comp.getRuntime(), shimContainer;

				// figure out accept string
				_options = options;
				_mimes = options.accept.mimes || Mime.extList2mimes(options.accept, I.can('filter_by_extension'));

				shimContainer = I.getShimContainer();

				(function() {
					var browseButton, zIndex, top;

					browseButton = Dom.get(options.browse_button);
					_browseBtnZIndex = Dom.getStyle(browseButton, 'z-index') || 'auto';

					// Route click event to the input[type=file] element for browsers that support such behavior
					if (I.can('summon_file_dialog')) {
						if (Dom.getStyle(browseButton, 'position') === 'static') {
							browseButton.style.position = 'relative';
						}						

						comp.bind('Refresh', function() {
							zIndex = parseInt(_browseBtnZIndex, 10) || 1;

							Dom.get(_options.browse_button).style.zIndex = zIndex;
							this.getRuntime().getShimContainer().style.zIndex = zIndex - 1;
						});
					}

					/* Since we have to place input[type=file] on top of the browse_button for some browsers,
					browse_button loses interactivity, so we restore it here */
					top = I.can('summon_file_dialog') ? browseButton : shimContainer;

					Events.addEvent(top, 'mouseover', function() {
						comp.trigger('mouseenter');
					}, comp.uid);

					Events.addEvent(top, 'mouseout', function() {
						comp.trigger('mouseleave');
					}, comp.uid);

					Events.addEvent(top, 'mousedown', function() {
						comp.trigger('mousedown');
					}, comp.uid);

					Events.addEvent(Dom.get(options.container), 'mouseup', function() {
						comp.trigger('mouseup');
					}, comp.uid);

					browseButton = null;
				}());

				addInput.call(this);

				shimContainer = null;

				// trigger ready event asynchronously
				comp.trigger({
					type: 'ready',
					async: true
				});
			},

			setOption: function(name, value) {
				var I = this.getRuntime();
				var input;

				if (name == 'accept') {
					_mimes = value.mimes || Mime.extList2mimes(value, I.can('filter_by_extension'));
				}

				// update current input
				input = Dom.get(_uid)
				if (input) {
					input.setAttribute('accept', _mimes.join(','));
				}
			},


			disable: function(state) {
				var input;

				if ((input = Dom.get(_uid))) {
					input.disabled = !!state;
				}
			},

			destroy: function() {
				var I = this.getRuntime()
				, shim = I.getShim()
				, shimContainer = I.getShimContainer()
				, container = _options && Dom.get(_options.container)
				, browseButton = _options && Dom.get(_options.browse_button)
				;
				
				if (container) {
					Events.removeAllEvents(container, this.uid);
				}
				
				if (browseButton) {
					Events.removeAllEvents(browseButton, this.uid);
					browseButton.style.zIndex = _browseBtnZIndex; // reset to original value
				}
				
				if (shimContainer) {
					Events.removeAllEvents(shimContainer, this.uid);
					shimContainer.innerHTML = '';
				}

				shim.removeInstance(this.uid);

				_uid = _mimes = _options = shimContainer = container = browseButton = shim = null;
			}
		});
	}

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/html4/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/file/FileReader
@private
*/
define("moxie/runtime/html4/file/FileReader", [
	"moxie/runtime/html4/Runtime",
	"moxie/runtime/html5/file/FileReader"
], function(extensions, FileReader) {
	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/html4/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/html4/xhr/XMLHttpRequest", [
	"moxie/runtime/html4/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Url",
	"moxie/core/Exceptions",
	"moxie/core/utils/Events",
	"moxie/file/Blob",
	"moxie/xhr/FormData"
], function(extensions, Basic, Dom, Url, x, Events, Blob, FormData) {
	
	function XMLHttpRequest() {
		var _status, _response, _iframe;

		function cleanup(cb) {
			var target = this, uid, form, inputs, i, hasFile = false;

			if (!_iframe) {
				return;
			}

			uid = _iframe.id.replace(/_iframe$/, '');

			form = Dom.get(uid + '_form');
			if (form) {
				inputs = form.getElementsByTagName('input');
				i = inputs.length;

				while (i--) {
					switch (inputs[i].getAttribute('type')) {
						case 'hidden':
							inputs[i].parentNode.removeChild(inputs[i]);
							break;
						case 'file':
							hasFile = true; // flag the case for later
							break;
					}
				}
				inputs = [];

				if (!hasFile) { // we need to keep the form for sake of possible retries
					form.parentNode.removeChild(form);
				}
				form = null;
			}

			// without timeout, request is marked as canceled (in console)
			setTimeout(function() {
				Events.removeEvent(_iframe, 'load', target.uid);
				if (_iframe.parentNode) { // #382
					_iframe.parentNode.removeChild(_iframe);
				}

				// check if shim container has any other children, if - not, remove it as well
				var shimContainer = target.getRuntime().getShimContainer();
				if (!shimContainer.children.length) {
					shimContainer.parentNode.removeChild(shimContainer);
				}

				shimContainer = _iframe = null;
				cb();
			}, 1);
		}

		Basic.extend(this, {
			send: function(meta, data) {
				var target = this, I = target.getRuntime(), uid, form, input, blob;

				_status = _response = null;

				function createIframe() {
					var container = I.getShimContainer() || document.body
					, temp = document.createElement('div')
					;

					// IE 6 won't be able to set the name using setAttribute or iframe.name
					temp.innerHTML = '<iframe id="' + uid + '_iframe" name="' + uid + '_iframe" src="javascript:&quot;&quot;" style="display:none"></iframe>';
					_iframe = temp.firstChild;
					container.appendChild(_iframe);

					/* _iframe.onreadystatechange = function() {
						console.info(_iframe.readyState);
					};*/

					Events.addEvent(_iframe, 'load', function() { // _iframe.onload doesn't work in IE lte 8
						var el;

						try {
							el = _iframe.contentWindow.document || _iframe.contentDocument || window.frames[_iframe.id].document;

							// try to detect some standard error pages
							if (/^4(0[0-9]|1[0-7]|2[2346])\s/.test(el.title)) { // test if title starts with 4xx HTTP error
								_status = el.title.replace(/^(\d+).*$/, '$1');
							} else {
								_status = 200;
								// get result
								_response = Basic.trim(el.body.innerHTML);

								// we need to fire these at least once
								target.trigger({
									type: 'progress',
									loaded: _response.length,
									total: _response.length
								});

								if (blob) { // if we were uploading a file
									target.trigger({
										type: 'uploadprogress',
										loaded: blob.size || 1025,
										total: blob.size || 1025
									});
								}
							}
						} catch (ex) {
							if (Url.hasSameOrigin(meta.url)) {
								// if response is sent with error code, iframe in IE gets redirected to res://ieframe.dll/http_x.htm
								// which obviously results to cross domain error (wtf?)
								_status = 404;
							} else {
								cleanup.call(target, function() {
									target.trigger('error');
								});
								return;
							}
						}	
					
						cleanup.call(target, function() {
							target.trigger('load');
						});
					}, target.uid);
				} // end createIframe

				// prepare data to be sent and convert if required
				if (data instanceof FormData && data.hasBlob()) {
					blob = data.getBlob();
					uid = blob.uid;
					input = Dom.get(uid);
					form = Dom.get(uid + '_form');
					if (!form) {
						throw new x.DOMException(x.DOMException.NOT_FOUND_ERR);
					}
				} else {
					uid = Basic.guid('uid_');

					form = document.createElement('form');
					form.setAttribute('id', uid + '_form');
					form.setAttribute('method', meta.method);
					form.setAttribute('enctype', 'multipart/form-data');
					form.setAttribute('encoding', 'multipart/form-data');

					I.getShimContainer().appendChild(form);
				}

				// set upload target
				form.setAttribute('target', uid + '_iframe');

				if (data instanceof FormData) {
					data.each(function(value, name) {
						if (value instanceof Blob) {
							if (input) {
								input.setAttribute('name', name);
							}
						} else {
							var hidden = document.createElement('input');

							Basic.extend(hidden, {
								type : 'hidden',
								name : name,
								value : value
							});

							// make sure that input[type="file"], if it's there, comes last
							if (input) {
								form.insertBefore(hidden, input);
							} else {
								form.appendChild(hidden);
							}
						}
					});
				}

				// set destination url
				form.setAttribute("action", meta.url);

				createIframe();
				form.submit();
				target.trigger('loadstart');
			},

			getStatus: function() {
				return _status;
			},

			getResponse: function(responseType) {
				if ('json' === responseType) {
					// strip off <pre>..</pre> tags that might be enclosing the response
					if (Basic.typeOf(_response) === 'string' && !!window.JSON) {
						try {
							return JSON.parse(_response.replace(/^\s*<pre[^>]*>/, '').replace(/<\/pre>\s*$/, ''));
						} catch (ex) {
							return null;
						}
					} 
				} else if ('document' === responseType) {

				}
				return _response;
			},

			abort: function() {
				var target = this;

				if (_iframe && _iframe.contentWindow) {
					if (_iframe.contentWindow.stop) { // FireFox/Safari/Chrome
						_iframe.contentWindow.stop();
					} else if (_iframe.contentWindow.document.execCommand) { // IE
						_iframe.contentWindow.document.execCommand('Stop');
					} else {
						_iframe.src = "about:blank";
					}
				}

				cleanup.call(this, function() {
					// target.dispatchEvent('readystatechange');
					target.dispatchEvent('abort');
				});
			}
		});
	}

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/html4/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/image/Image
@private
*/
define("moxie/runtime/html4/image/Image", [
	"moxie/runtime/html4/Runtime",
	"moxie/runtime/html5/image/Image"
], function(extensions, Image) {
	return (extensions.Image = Image);
});

expose(["moxie/core/utils/Basic","moxie/core/utils/Encode","moxie/core/utils/Env","moxie/core/Exceptions","moxie/core/utils/Dom","moxie/core/EventTarget","moxie/runtime/Runtime","moxie/runtime/RuntimeClient","moxie/file/Blob","moxie/core/I18n","moxie/core/utils/Mime","moxie/file/FileInput","moxie/file/File","moxie/file/FileDrop","moxie/file/FileReader","moxie/core/utils/Url","moxie/runtime/RuntimeTarget","moxie/xhr/FormData","moxie/xhr/XMLHttpRequest","moxie/runtime/Transporter","moxie/image/Image","moxie/core/utils/Events","moxie/runtime/html5/image/ResizerCanvas"]);
})(this);
}));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Plupload - multi-runtime File Uploader
 * v2.3.1
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 *
 * Date: 2017-02-06
 */
;(function (global, factory) {
	var extract = function() {
		var ctx = {};
		factory.apply(ctx, arguments);
		return ctx.plupload;
	};
	
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (extract),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === "object" && module.exports) {
		module.exports = extract(require('../../../js-sdk-master 2/src/moxie'));
	} else {
		global.plupload = extract(global.moxie);
	}
}(this || window, function(moxie) {
/**
 * Plupload.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

;(function(exports, o, undef) {

var delay = window.setTimeout;
var fileFilters = {};
var u = o.core.utils;
var Runtime = o.runtime.Runtime;

// convert plupload features to caps acceptable by mOxie
function normalizeCaps(settings) {
	var features = settings.required_features, caps = {};

	function resolve(feature, value, strict) {
		// Feature notation is deprecated, use caps (this thing here is required for backward compatibility)
		var map = {
			chunks: 'slice_blob',
			jpgresize: 'send_binary_string',
			pngresize: 'send_binary_string',
			progress: 'report_upload_progress',
			multi_selection: 'select_multiple',
			dragdrop: 'drag_and_drop',
			drop_element: 'drag_and_drop',
			headers: 'send_custom_headers',
			urlstream_upload: 'send_binary_string',
			canSendBinary: 'send_binary',
			triggerDialog: 'summon_file_dialog'
		};

		if (map[feature]) {
			caps[map[feature]] = value;
		} else if (!strict) {
			caps[feature] = value;
		}
	}

	if (typeof(features) === 'string') {
		plupload.each(features.split(/\s*,\s*/), function(feature) {
			resolve(feature, true);
		});
	} else if (typeof(features) === 'object') {
		plupload.each(features, function(value, feature) {
			resolve(feature, value);
		});
	} else if (features === true) {
		// check settings for required features
		if (settings.chunk_size && settings.chunk_size > 0) {
			caps.slice_blob = true;
		}

		if (!plupload.isEmptyObj(settings.resize) || settings.multipart === false) {
			caps.send_binary_string = true;
		}

		if (settings.http_method) {
            caps.use_http_method = settings.http_method;
        }

		plupload.each(settings, function(value, feature) {
			resolve(feature, !!value, true); // strict check
		});
	}

	return caps;
}

/**
 * @module plupload
 * @static
 */
var plupload = {
	/**
	 * Plupload version will be replaced on build.
	 *
	 * @property VERSION
	 * @for Plupload
	 * @static
	 * @final
	 */
	VERSION : '2.3.1',

	/**
	 * The state of the queue before it has started and after it has finished
	 *
	 * @property STOPPED
	 * @static
	 * @final
	 */
	STOPPED : 1,

	/**
	 * Upload process is running
	 *
	 * @property STARTED
	 * @static
	 * @final
	 */
	STARTED : 2,

	/**
	 * File is queued for upload
	 *
	 * @property QUEUED
	 * @static
	 * @final
	 */
	QUEUED : 1,

	/**
	 * File is being uploaded
	 *
	 * @property UPLOADING
	 * @static
	 * @final
	 */
	UPLOADING : 2,

	/**
	 * File has failed to be uploaded
	 *
	 * @property FAILED
	 * @static
	 * @final
	 */
	FAILED : 4,

	/**
	 * File has been uploaded successfully
	 *
	 * @property DONE
	 * @static
	 * @final
	 */
	DONE : 5,

	// Error constants used by the Error event

	/**
	 * Generic error for example if an exception is thrown inside Silverlight.
	 *
	 * @property GENERIC_ERROR
	 * @static
	 * @final
	 */
	GENERIC_ERROR : -100,

	/**
	 * HTTP transport error. For example if the server produces a HTTP status other than 200.
	 *
	 * @property HTTP_ERROR
	 * @static
	 * @final
	 */
	HTTP_ERROR : -200,

	/**
	 * Generic I/O error. For example if it wasn't possible to open the file stream on local machine.
	 *
	 * @property IO_ERROR
	 * @static
	 * @final
	 */
	IO_ERROR : -300,

	/**
	 * @property SECURITY_ERROR
	 * @static
	 * @final
	 */
	SECURITY_ERROR : -400,

	/**
	 * Initialization error. Will be triggered if no runtime was initialized.
	 *
	 * @property INIT_ERROR
	 * @static
	 * @final
	 */
	INIT_ERROR : -500,

	/**
	 * File size error. If the user selects a file that is too large it will be blocked and an error of this type will be triggered.
	 *
	 * @property FILE_SIZE_ERROR
	 * @static
	 * @final
	 */
	FILE_SIZE_ERROR : -600,

	/**
	 * File extension error. If the user selects a file that isn't valid according to the filters setting.
	 *
	 * @property FILE_EXTENSION_ERROR
	 * @static
	 * @final
	 */
	FILE_EXTENSION_ERROR : -601,

	/**
	 * Duplicate file error. If prevent_duplicates is set to true and user selects the same file again.
	 *
	 * @property FILE_DUPLICATE_ERROR
	 * @static
	 * @final
	 */
	FILE_DUPLICATE_ERROR : -602,

	/**
	 * Runtime will try to detect if image is proper one. Otherwise will throw this error.
	 *
	 * @property IMAGE_FORMAT_ERROR
	 * @static
	 * @final
	 */
	IMAGE_FORMAT_ERROR : -700,

	/**
	 * While working on files runtime may run out of memory and will throw this error.
	 *
	 * @since 2.1.2
	 * @property MEMORY_ERROR
	 * @static
	 * @final
	 */
	MEMORY_ERROR : -701,

	/**
	 * Each runtime has an upper limit on a dimension of the image it can handle. If bigger, will throw this error.
	 *
	 * @property IMAGE_DIMENSIONS_ERROR
	 * @static
	 * @final
	 */
	IMAGE_DIMENSIONS_ERROR : -702,

	/**
	 * Mime type lookup table.
	 *
	 * @property mimeTypes
	 * @type Object
	 * @final
	 */
	mimeTypes : u.Mime.mimes,

	/**
	 * In some cases sniffing is the only way around :(
	 */
	ua: u.Env,

	/**
	 * Gets the true type of the built-in object (better version of typeof).
	 * @credits Angus Croll (http://javascriptweblog.wordpress.com/)
	 *
	 * @method typeOf
	 * @static
	 * @param {Object} o Object to check.
	 * @return {String} Object [[Class]]
	 */
	typeOf: u.Basic.typeOf,

	/**
	 * Extends the specified object with another object.
	 *
	 * @method extend
	 * @static
	 * @param {Object} target Object to extend.
	 * @param {Object..} obj Multiple objects to extend with.
	 * @return {Object} Same as target, the extended object.
	 */
	extend : u.Basic.extend,

	/**
	 * Generates an unique ID. This is 99.99% unique since it takes the current time and 5 random numbers.
	 * The only way a user would be able to get the same ID is if the two persons at the same exact millisecond manages
	 * to get 5 the same random numbers between 0-65535 it also uses a counter so each call will be guaranteed to be page unique.
	 * It's more probable for the earth to be hit with an asteriod. You can also if you want to be 100% sure set the plupload.guidPrefix property
	 * to an user unique key.
	 *
	 * @method guid
	 * @static
	 * @return {String} Virtually unique id.
	 */
	guid : u.Basic.guid,

	/**
	 * Get array of DOM Elements by their ids.
	 *
	 * @method get
	 * @param {String} id Identifier of the DOM Element
	 * @return {Array}
	*/
	getAll : function get(ids) {
		var els = [], el;

		if (plupload.typeOf(ids) !== 'array') {
			ids = [ids];
		}

		var i = ids.length;
		while (i--) {
			el = plupload.get(ids[i]);
			if (el) {
				els.push(el);
			}
		}

		return els.length ? els : null;
	},

	/**
	Get DOM element by id

	@method get
	@param {String} id Identifier of the DOM Element
	@return {Node}
	*/
	get: u.Dom.get,

	/**
	 * Executes the callback function for each item in array/object. If you return false in the
	 * callback it will break the loop.
	 *
	 * @method each
	 * @static
	 * @param {Object} obj Object to iterate.
	 * @param {function} callback Callback function to execute for each item.
	 */
	each : u.Basic.each,

	/**
	 * Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.
	 *
	 * @method getPos
	 * @static
	 * @param {Element} node HTML element or element id to get x, y position from.
	 * @param {Element} root Optional root element to stop calculations at.
	 * @return {object} Absolute position of the specified element object with x, y fields.
	 */
	getPos : u.Dom.getPos,

	/**
	 * Returns the size of the specified node in pixels.
	 *
	 * @method getSize
	 * @static
	 * @param {Node} node Node to get the size of.
	 * @return {Object} Object with a w and h property.
	 */
	getSize : u.Dom.getSize,

	/**
	 * Encodes the specified string.
	 *
	 * @method xmlEncode
	 * @static
	 * @param {String} s String to encode.
	 * @return {String} Encoded string.
	 */
	xmlEncode : function(str) {
		var xmlEncodeChars = {'<' : 'lt', '>' : 'gt', '&' : 'amp', '"' : 'quot', '\'' : '#39'}, xmlEncodeRegExp = /[<>&\"\']/g;

		return str ? ('' + str).replace(xmlEncodeRegExp, function(chr) {
			return xmlEncodeChars[chr] ? '&' + xmlEncodeChars[chr] + ';' : chr;
		}) : str;
	},

	/**
	 * Forces anything into an array.
	 *
	 * @method toArray
	 * @static
	 * @param {Object} obj Object with length field.
	 * @return {Array} Array object containing all items.
	 */
	toArray : u.Basic.toArray,

	/**
	 * Find an element in array and return its index if present, otherwise return -1.
	 *
	 * @method inArray
	 * @static
	 * @param {mixed} needle Element to find
	 * @param {Array} array
	 * @return {Int} Index of the element, or -1 if not found
	 */
	inArray : u.Basic.inArray,

	/**
	Recieve an array of functions (usually async) to call in sequence, each  function
	receives a callback as first argument that it should call, when it completes. Finally,
	after everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the sequence and invoke main callback
	immediately.

	@method inSeries
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of error
	*/
	inSeries: u.Basic.inSeries,

	/**
	 * Extends the language pack object with new items.
	 *
	 * @method addI18n
	 * @static
	 * @param {Object} pack Language pack items to add.
	 * @return {Object} Extended language pack object.
	 */
	addI18n : o.core.I18n.addI18n,

	/**
	 * Translates the specified string by checking for the english string in the language pack lookup.
	 *
	 * @method translate
	 * @static
	 * @param {String} str String to look for.
	 * @return {String} Translated string or the input string if it wasn't found.
	 */
	translate : o.core.I18n.translate,

	/**
	 * Pseudo sprintf implementation - simple way to replace tokens with specified values.
	 *
	 * @param {String} str String with tokens
	 * @return {String} String with replaced tokens
	 */
	sprintf : u.Basic.sprintf,

	/**
	 * Checks if object is empty.
	 *
	 * @method isEmptyObj
	 * @static
	 * @param {Object} obj Object to check.
	 * @return {Boolean}
	 */
	isEmptyObj : u.Basic.isEmptyObj,

	/**
	 * Checks if specified DOM element has specified class.
	 *
	 * @method hasClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	hasClass : u.Dom.hasClass,

	/**
	 * Adds specified className to specified DOM element.
	 *
	 * @method addClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	addClass : u.Dom.addClass,

	/**
	 * Removes specified className from specified DOM element.
	 *
	 * @method removeClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	removeClass : u.Dom.removeClass,

	/**
	 * Returns a given computed style of a DOM element.
	 *
	 * @method getStyle
	 * @static
	 * @param {Object} obj DOM element like object.
	 * @param {String} name Style you want to get from the DOM element
	 */
	getStyle : u.Dom.getStyle,

	/**
	 * Adds an event handler to the specified object and store reference to the handler
	 * in objects internal Plupload registry (@see removeEvent).
	 *
	 * @method addEvent
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Name to add event listener to.
	 * @param {Function} callback Function to call when event occurs.
	 * @param {String} (optional) key that might be used to add specifity to the event record.
	 */
	addEvent : u.Events.addEvent,

	/**
	 * Remove event handler from the specified object. If third argument (callback)
	 * is not specified remove all events with the specified name.
	 *
	 * @method removeEvent
	 * @static
	 * @param {Object} obj DOM element to remove event listener(s) from.
	 * @param {String} name Name of event listener to remove.
	 * @param {Function|String} (optional) might be a callback or unique key to match.
	 */
	removeEvent: u.Events.removeEvent,

	/**
	 * Remove all kind of events from the specified object
	 *
	 * @method removeAllEvents
	 * @static
	 * @param {Object} obj DOM element to remove event listeners from.
	 * @param {String} (optional) unique key to match, when removing events.
	 */
	removeAllEvents: u.Events.removeAllEvents,

	/**
	 * Cleans the specified name from national characters (diacritics). The result will be a name with only a-z, 0-9 and _.
	 *
	 * @method cleanName
	 * @static
	 * @param {String} s String to clean up.
	 * @return {String} Cleaned string.
	 */
	cleanName : function(name) {
		var i, lookup;

		// Replace diacritics
		lookup = [
			/[\300-\306]/g, 'A', /[\340-\346]/g, 'a',
			/\307/g, 'C', /\347/g, 'c',
			/[\310-\313]/g, 'E', /[\350-\353]/g, 'e',
			/[\314-\317]/g, 'I', /[\354-\357]/g, 'i',
			/\321/g, 'N', /\361/g, 'n',
			/[\322-\330]/g, 'O', /[\362-\370]/g, 'o',
			/[\331-\334]/g, 'U', /[\371-\374]/g, 'u'
		];

		for (i = 0; i < lookup.length; i += 2) {
			name = name.replace(lookup[i], lookup[i + 1]);
		}

		// Replace whitespace
		name = name.replace(/\s+/g, '_');

		// Remove anything else
		name = name.replace(/[^a-z0-9_\-\.]+/gi, '');

		return name;
	},

	/**
	 * Builds a full url out of a base URL and an object with items to append as query string items.
	 *
	 * @method buildUrl
	 * @static
	 * @param {String} url Base URL to append query string items to.
	 * @param {Object} items Name/value object to serialize as a querystring.
	 * @return {String} String with url + serialized query string items.
	 */
	buildUrl: function(url, items) {
		var query = '';

		plupload.each(items, function(value, name) {
			query += (query ? '&' : '') + encodeURIComponent(name) + '=' + encodeURIComponent(value);
		});

		if (query) {
			url += (url.indexOf('?') > 0 ? '&' : '?') + query;
		}

		return url;
	},

	/**
	 * Formats the specified number as a size string for example 1024 becomes 1 KB.
	 *
	 * @method formatSize
	 * @static
	 * @param {Number} size Size to format as string.
	 * @return {String} Formatted size string.
	 */
	formatSize : function(size) {

		if (size === undef || /\D/.test(size)) {
			return plupload.translate('N/A');
		}

		function round(num, precision) {
			return Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);
		}

		var boundary = Math.pow(1024, 4);

		// TB
		if (size > boundary) {
			return round(size / boundary, 1) + " " + plupload.translate('tb');
		}

		// GB
		if (size > (boundary/=1024)) {
			return round(size / boundary, 1) + " " + plupload.translate('gb');
		}

		// MB
		if (size > (boundary/=1024)) {
			return round(size / boundary, 1) + " " + plupload.translate('mb');
		}

		// KB
		if (size > 1024) {
			return Math.round(size / 1024) + " " + plupload.translate('kb');
		}

		return size + " " + plupload.translate('b');
	},


	/**
	 * Parses the specified size string into a byte value. For example 10kb becomes 10240.
	 *
	 * @method parseSize
	 * @static
	 * @param {String|Number} size String to parse or number to just pass through.
	 * @return {Number} Size in bytes.
	 */
	parseSize : u.Basic.parseSizeStr,


	/**
	 * A way to predict what runtime will be choosen in the current environment with the
	 * specified settings.
	 *
	 * @method predictRuntime
	 * @static
	 * @param {Object|String} config Plupload settings to check
	 * @param {String} [runtimes] Comma-separated list of runtimes to check against
	 * @return {String} Type of compatible runtime
	 */
	predictRuntime : function(config, runtimes) {
		var up, runtime;

		up = new plupload.Uploader(config);
		runtime = Runtime.thatCan(up.getOption().required_features, runtimes || config.runtimes);
		up.destroy();
		return runtime;
	},

	/**
	 * Registers a filter that will be executed for each file added to the queue.
	 * If callback returns false, file will not be added.
	 *
	 * Callback receives two arguments: a value for the filter as it was specified in settings.filters
	 * and a file to be filtered. Callback is executed in the context of uploader instance.
	 *
	 * @method addFileFilter
	 * @static
	 * @param {String} name Name of the filter by which it can be referenced in settings.filters
	 * @param {String} cb Callback - the actual routine that every added file must pass
	 */
	addFileFilter: function(name, cb) {
		fileFilters[name] = cb;
	}
};


plupload.addFileFilter('mime_types', function(filters, file, cb) {
	if (filters.length && !filters.regexp.test(file.name)) {
		this.trigger('Error', {
			code : plupload.FILE_EXTENSION_ERROR,
			message : plupload.translate('File extension error.'),
			file : file
		});
		cb(false);
	} else {
		cb(true);
	}
});


plupload.addFileFilter('max_file_size', function(maxSize, file, cb) {
	var undef;

	maxSize = plupload.parseSize(maxSize);

	// Invalid file size
	if (file.size !== undef && maxSize && file.size > maxSize) {
		this.trigger('Error', {
			code : plupload.FILE_SIZE_ERROR,
			message : plupload.translate('File size error.'),
			file : file
		});
		cb(false);
	} else {
		cb(true);
	}
});


plupload.addFileFilter('prevent_duplicates', function(value, file, cb) {
	if (value) {
		var ii = this.files.length;
		while (ii--) {
			// Compare by name and size (size might be 0 or undefined, but still equivalent for both)
			if (file.name === this.files[ii].name && file.size === this.files[ii].size) {
				this.trigger('Error', {
					code : plupload.FILE_DUPLICATE_ERROR,
					message : plupload.translate('Duplicate file error.'),
					file : file
				});
				cb(false);
				return;
			}
		}
	}
	cb(true);
});


/**
@class Uploader
@constructor

@param {Object} settings For detailed information about each option check documentation.
	@param {String|DOMElement} settings.browse_button id of the DOM element or DOM element itself to use as file dialog trigger.
	@param {Number|String} [settings.chunk_size=0] Chunk size in bytes to slice the file into. Shorcuts with b, kb, mb, gb, tb suffixes also supported. `e.g. 204800 or "204800b" or "200kb"`. By default - disabled.
	@param {String|DOMElement} [settings.container] id of the DOM element or DOM element itself that will be used to wrap uploader structures. Defaults to immediate parent of the `browse_button` element.
	@param {String|DOMElement} [settings.drop_element] id of the DOM element or DOM element itself to use as a drop zone for Drag-n-Drop.
	@param {String} [settings.file_data_name="file"] Name for the file field in Multipart formated message.
	@param {Object} [settings.filters={}] Set of file type filters.
		@param {String|Number} [settings.filters.max_file_size=0] Maximum file size that the user can pick, in bytes. Optionally supports b, kb, mb, gb, tb suffixes. `e.g. "10mb" or "1gb"`. By default - not set. Dispatches `plupload.FILE_SIZE_ERROR`.
		@param {Array} [settings.filters.mime_types=[]] List of file types to accept, each one defined by title and list of extensions. `e.g. {title : "Image files", extensions : "jpg,jpeg,gif,png"}`. Dispatches `plupload.FILE_EXTENSION_ERROR`
		@param {Boolean} [settings.filters.prevent_duplicates=false] Do not let duplicates into the queue. Dispatches `plupload.FILE_DUPLICATE_ERROR`.
	@param {String} [settings.flash_swf_url] URL of the Flash swf.
	@param {Object} [settings.headers] Custom headers to send with the upload. Hash of name/value pairs.
	@param {String} [settings.http_method="POST"] HTTP method to use during upload (only PUT or POST allowed).
	@param {Number} [settings.max_retries=0] How many times to retry the chunk or file, before triggering Error event.
	@param {Boolean} [settings.multipart=true] Whether to send file and additional parameters as Multipart formated message.
	@param {Object} [settings.multipart_params] Hash of key/value pairs to send with every file upload.
	@param {Boolean} [settings.multi_selection=true] Enable ability to select multiple files at once in file dialog.
	@param {String|Object} [settings.required_features] Either comma-separated list or hash of required features that chosen runtime should absolutely possess.
	@param {Object} [settings.resize] Enable resizng of images on client-side. Applies to `image/jpeg` and `image/png` only. `e.g. {width : 200, height : 200, quality : 90, crop: true}`
		@param {Number} [settings.resize.width] If image is bigger, it will be resized.
		@param {Number} [settings.resize.height] If image is bigger, it will be resized.
		@param {Number} [settings.resize.quality=90] Compression quality for jpegs (1-100).
		@param {Boolean} [settings.resize.crop=false] Whether to crop images to exact dimensions. By default they will be resized proportionally.
	@param {String} [settings.runtimes="html5,flash,silverlight,html4"] Comma separated list of runtimes, that Plupload will try in turn, moving to the next if previous fails.
	@param {String} [settings.silverlight_xap_url] URL of the Silverlight xap.
	@param {Boolean} [settings.send_chunk_number=true] Whether to send chunks and chunk numbers, or total and offset bytes.
	@param {Boolean} [settings.send_file_name=true] Whether to send file name as additional argument - 'name' (required for chunked uploads and some other cases where file name cannot be sent via normal ways).
	@param {String} settings.url URL of the server-side upload handler.
	@param {Boolean} [settings.unique_names=false] If true will generate unique filenames for uploaded files.

*/
plupload.Uploader = function(options) {
	/**
	Fires when the current RunTime has been initialized.

	@event Init
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires after the init event incase you need to perform actions there.

	@event PostInit
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires when the option is changed in via uploader.setOption().

	@event OptionChanged
	@since 2.1
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {String} name Name of the option that was changed
	@param {Mixed} value New value for the specified option
	@param {Mixed} oldValue Previous value of the option
	 */

	/**
	Fires when the silverlight/flash or other shim needs to move.

	@event Refresh
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires when the overall state is being changed for the upload queue.

	@event StateChanged
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires when browse_button is clicked and browse dialog shows.

	@event Browse
	@since 2.1.2
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires for every filtered file before it is added to the queue.

	@event FileFiltered
	@since 2.1
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file Another file that has to be added to the queue.
	 */

	/**
	Fires when the file queue is changed. In other words when files are added/removed to the files array of the uploader instance.

	@event QueueChanged
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	Fires after files were filtered and added to the queue.

	@event FilesAdded
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Array} files Array of file objects that were added to queue by the user.
	 */

	/**
	Fires when file is removed from the queue.

	@event FilesRemoved
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Array} files Array of files that got removed.
	 */

	/**
	Fires just before a file is uploaded. Can be used to cancel the upload for the specified file
	by returning false from the handler.

	@event BeforeUpload
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File to be uploaded.
	 */

	/**
	Fires when a file is to be uploaded by the runtime.

	@event UploadFile
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File to be uploaded.
	 */

	/**
	Fires while a file is being uploaded. Use this event to update the current file upload progress.

	@event UploadProgress
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File that is currently being uploaded.
	 */

	/**
	* Fires just before a chunk is uploaded. This event enables you to override settings
	* on the uploader instance before the chunk is uploaded.
	*
	* @event BeforeChunkUpload
	* @param {plupload.Uploader} uploader Uploader instance sending the event.
	* @param {plupload.File} file File to be uploaded.
	* @param {Object} args POST params to be sent.
	* @param {Blob} chunkBlob Current blob.
	* @param {offset} offset Current offset.
	*/

	/**
	Fires when file chunk is uploaded.

	@event ChunkUploaded
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File that the chunk was uploaded for.
	@param {Object} result Object with response properties.
		@param {Number} result.offset The amount of bytes the server has received so far, including this chunk.
		@param {Number} result.total The size of the file.
		@param {String} result.response The response body sent by the server.
		@param {Number} result.status The HTTP status code sent by the server.
		@param {String} result.responseHeaders All the response headers as a single string.
	 */

	/**
	Fires when a file is successfully uploaded.

	@event FileUploaded
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {plupload.File} file File that was uploaded.
	@param {Object} result Object with response properties.
		@param {String} result.response The response body sent by the server.
		@param {Number} result.status The HTTP status code sent by the server.
		@param {String} result.responseHeaders All the response headers as a single string.
	 */

	/**
	Fires when all files in a queue are uploaded.

	@event UploadComplete
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Array} files Array of file objects that was added to queue/selected by the user.
	 */

	/**
	Fires when a error occurs.

	@event Error
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	@param {Object} error Contains code, message and sometimes file and other details.
		@param {Number} error.code The plupload error code.
		@param {String} error.message Description of the error (uses i18n).
	 */

	/**
	Fires when destroy method is called.

	@event Destroy
	@param {plupload.Uploader} uploader Uploader instance sending the event.
	 */
	var uid = plupload.guid()
	, settings
	, files = []
	, preferred_caps = {}
	, fileInputs = []
	, fileDrops = []
	, startTime
	, total
	, disabled = false
	, xhr
	;


	// Private methods
	function uploadNext() {
		var file, count = 0, i;

		if (this.state == plupload.STARTED) {
			// Find first QUEUED file
			for (i = 0; i < files.length; i++) {
				if (!file && files[i].status == plupload.QUEUED) {
					file = files[i];
					if (this.trigger("BeforeUpload", file)) {
						file.status = plupload.UPLOADING;
						this.trigger("UploadFile", file);
					}
				} else {
					count++;
				}
			}

			// All files are DONE or FAILED
			if (count == files.length) {
				if (this.state !== plupload.STOPPED) {
					this.state = plupload.STOPPED;
					this.trigger("StateChanged");
				}
				this.trigger("UploadComplete", files);
			}
		}
	}


	function calcFile(file) {
		file.percent = file.size > 0 ? Math.ceil(file.loaded / file.size * 100) : 100;
		calc();
	}


	function calc() {
		var i, file;
		var loaded;
		var loadedDuringCurrentSession = 0;

		// Reset stats
		total.reset();

		// Check status, size, loaded etc on all files
		for (i = 0; i < files.length; i++) {
			file = files[i];

			if (file.size !== undef) {
				// We calculate totals based on original file size
				total.size += file.origSize;

				// Since we cannot predict file size after resize, we do opposite and
				// interpolate loaded amount to match magnitude of total
				loaded = file.loaded * file.origSize / file.size;

				if (!file.completeTimestamp || file.completeTimestamp > startTime) {
					loadedDuringCurrentSession += loaded;
				}

				total.loaded += loaded;
			} else {
				total.size = undef;
			}

			if (file.status == plupload.DONE) {
				total.uploaded++;
			} else if (file.status == plupload.FAILED) {
				total.failed++;
			} else {
				total.queued++;
			}
		}

		// If we couldn't calculate a total file size then use the number of files to calc percent
		if (total.size === undef) {
			total.percent = files.length > 0 ? Math.ceil(total.uploaded / files.length * 100) : 0;
		} else {
			total.bytesPerSec = Math.ceil(loadedDuringCurrentSession / ((+new Date() - startTime || 1) / 1000.0));
			total.percent = total.size > 0 ? Math.ceil(total.loaded / total.size * 100) : 0;
		}
	}


	function getRUID() {
		var ctrl = fileInputs[0] || fileDrops[0];
		if (ctrl) {
			return ctrl.getRuntime().uid;
		}
		return false;
	}


	function runtimeCan(file, cap) {
		if (file.ruid) {
			var info = Runtime.getInfo(file.ruid);
			if (info) {
				return info.can(cap);
			}
		}
		return false;
	}


	function bindEventListeners() {
		this.bind('FilesAdded FilesRemoved', function(up) {
			up.trigger('QueueChanged');
			up.refresh();
		});

		this.bind('CancelUpload', onCancelUpload);

		this.bind('BeforeUpload', onBeforeUpload);

		this.bind('UploadFile', onUploadFile);

		this.bind('UploadProgress', onUploadProgress);

		this.bind('StateChanged', onStateChanged);

		this.bind('QueueChanged', calc);

		this.bind('Error', onError);

		this.bind('FileUploaded', onFileUploaded);

		this.bind('Destroy', onDestroy);
	}


	function initControls(settings, cb) {
		var self = this, inited = 0, queue = [];

		// common settings
		var options = {
			runtime_order: settings.runtimes,
			required_caps: settings.required_features,
			preferred_caps: preferred_caps,
			swf_url: settings.flash_swf_url,
			xap_url: settings.silverlight_xap_url
		};

		// add runtime specific options if any
		plupload.each(settings.runtimes.split(/\s*,\s*/), function(runtime) {
			if (settings[runtime]) {
				options[runtime] = settings[runtime];
			}
		});

		// initialize file pickers - there can be many
		if (settings.browse_button) {
			plupload.each(settings.browse_button, function(el) {
				queue.push(function(cb) {
					var fileInput = new o.file.FileInput(plupload.extend({}, options, {
						accept: settings.filters.mime_types,
						name: settings.file_data_name,
						multiple: settings.multi_selection,
						container: settings.container,
						browse_button: el
					}));

					fileInput.onready = function() {
						var info = Runtime.getInfo(this.ruid);

						// for backward compatibility
						plupload.extend(self.features, {
							chunks: info.can('slice_blob'),
							multipart: info.can('send_multipart'),
							multi_selection: info.can('select_multiple')
						});

						inited++;
						fileInputs.push(this);
						cb();
					};

					fileInput.onchange = function() {
						self.addFile(this.files);
					};

					fileInput.bind('mouseenter mouseleave mousedown mouseup', function(e) {
						if (!disabled) {
							if (settings.browse_button_hover) {
								if ('mouseenter' === e.type) {
									plupload.addClass(el, settings.browse_button_hover);
								} else if ('mouseleave' === e.type) {
									plupload.removeClass(el, settings.browse_button_hover);
								}
							}

							if (settings.browse_button_active) {
								if ('mousedown' === e.type) {
									plupload.addClass(el, settings.browse_button_active);
								} else if ('mouseup' === e.type) {
									plupload.removeClass(el, settings.browse_button_active);
								}
							}
						}
					});

					fileInput.bind('mousedown', function() {
						self.trigger('Browse');
					});

					fileInput.bind('error runtimeerror', function() {
						fileInput = null;
						cb();
					});

					fileInput.init();
				});
			});
		}

		// initialize drop zones
		if (settings.drop_element) {
			plupload.each(settings.drop_element, function(el) {
				queue.push(function(cb) {
					var fileDrop = new o.file.FileDrop(plupload.extend({}, options, {
						drop_zone: el
					}));

					fileDrop.onready = function() {
						var info = Runtime.getInfo(this.ruid);

						// for backward compatibility
						plupload.extend(self.features, {
							chunks: info.can('slice_blob'),
							multipart: info.can('send_multipart'),
							dragdrop: info.can('drag_and_drop')
						});

						inited++;
						fileDrops.push(this);
						cb();
					};

					fileDrop.ondrop = function() {
						self.addFile(this.files);
					};

					fileDrop.bind('error runtimeerror', function() {
						fileDrop = null;
						cb();
					});

					fileDrop.init();
				});
			});
		}


		plupload.inSeries(queue, function() {
			if (typeof(cb) === 'function') {
				cb(inited);
			}
		});
	}


	function resizeImage(blob, params, cb) {
		var img = new o.image.Image();

		try {
			img.onload = function() {
				// no manipulation required if...
				if (params.width > this.width &&
					params.height > this.height &&
					params.quality === undef &&
					params.preserve_headers &&
					!params.crop
				) {
					this.destroy();
					return cb(blob);
				}
				// otherwise downsize
				img.downsize(params.width, params.height, params.crop, params.preserve_headers);
			};

			img.onresize = function() {
				cb(this.getAsBlob(blob.type, params.quality));
				this.destroy();
			};

			img.onerror = function() {
				cb(blob);
			};

			img.load(blob);
		} catch(ex) {
			cb(blob);
		}
	}


	function setOption(option, value, init) {
		var self = this, reinitRequired = false;

		function _setOption(option, value, init) {
			var oldValue = settings[option];

			switch (option) {
				case 'max_file_size':
					if (option === 'max_file_size') {
						settings.max_file_size = settings.filters.max_file_size = value;
					}
					break;

				case 'chunk_size':
					if (value = plupload.parseSize(value)) {
						settings[option] = value;
						settings.send_file_name = true;
					}
					break;

				case 'multipart':
					settings[option] = value;
					if (!value) {
						settings.send_file_name = true;
					}
					break;

				case 'http_method':
					settings[option] = value.toUpperCase() === 'PUT' ? 'PUT' : 'POST';
					break;

				case 'unique_names':
					settings[option] = value;
					if (value) {
						settings.send_file_name = true;
					}
					break;

				case 'filters':
					// for sake of backward compatibility
					if (plupload.typeOf(value) === 'array') {
						value = {
							mime_types: value
						};
					}

					if (init) {
						plupload.extend(settings.filters, value);
					} else {
						settings.filters = value;
					}

					// if file format filters are being updated, regenerate the matching expressions
					if (value.mime_types) {
						if (plupload.typeOf(value.mime_types) === 'string') {
							value.mime_types = o.core.utils.Mime.mimes2extList(value.mime_types);
						}

						value.mime_types.regexp = (function(filters) {
							var extensionsRegExp = [];

							plupload.each(filters, function(filter) {
								plupload.each(filter.extensions.split(/,/), function(ext) {
									if (/^\s*\*\s*$/.test(ext)) {
										extensionsRegExp.push('\\.*');
									} else {
										extensionsRegExp.push('\\.' + ext.replace(new RegExp('[' + ('/^$.*+?|()[]{}\\'.replace(/./g, '\\$&')) + ']', 'g'), '\\$&'));
									}
								});
							});

							return new RegExp('(' + extensionsRegExp.join('|') + ')$', 'i');
						}(value.mime_types));

						settings.filters.mime_types = value.mime_types;
					}
					break;

				case 'resize':
					if (value) {
						settings.resize = plupload.extend({
							preserve_headers: true,
							crop: false
						}, value);
					} else {
						settings.resize = false;
					}
					break;

				case 'prevent_duplicates':
					settings.prevent_duplicates = settings.filters.prevent_duplicates = !!value;
					break;

				// options that require reinitialisation
				case 'container':
				case 'browse_button':
				case 'drop_element':
						value = 'container' === option
							? plupload.get(value)
							: plupload.getAll(value)
							;

				case 'runtimes':
				case 'multi_selection':
				case 'flash_swf_url':
				case 'silverlight_xap_url':
					settings[option] = value;
					if (!init) {
						reinitRequired = true;
					}
					break;

				default:
					settings[option] = value;
			}

			if (!init) {
				self.trigger('OptionChanged', option, value, oldValue);
			}
		}

		if (typeof(option) === 'object') {
			plupload.each(option, function(value, option) {
				_setOption(option, value, init);
			});
		} else {
			_setOption(option, value, init);
		}

		if (init) {
			// Normalize the list of required capabilities
			settings.required_features = normalizeCaps(plupload.extend({}, settings));

			// Come up with the list of capabilities that can affect default mode in a multi-mode runtimes
			preferred_caps = normalizeCaps(plupload.extend({}, settings, {
				required_features: true
			}));
		} else if (reinitRequired) {
			self.trigger('Destroy');

			initControls.call(self, settings, function(inited) {
				if (inited) {
					self.runtime = Runtime.getInfo(getRUID()).type;
					self.trigger('Init', { runtime: self.runtime });
					self.trigger('PostInit');
				} else {
					self.trigger('Error', {
						code : plupload.INIT_ERROR,
						message : plupload.translate('Init error.')
					});
				}
			});
		}
	}


	// Internal event handlers
	function onBeforeUpload(up, file) {
		// Generate unique target filenames
		if (up.settings.unique_names) {
			var matches = file.name.match(/\.([^.]+)$/), ext = "part";
			if (matches) {
				ext = matches[1];
			}
			file.target_name = file.id + '.' + ext;
		}
	}


	function onUploadFile(up, file) {
		var url = up.settings.url
		, chunkSize = up.settings.chunk_size
		, retries = up.settings.max_retries
		, features = up.features
		, offset = 0
		, blob
		;

		// make sure we start at a predictable offset
		if (file.loaded) {
			offset = file.loaded = chunkSize ? chunkSize * Math.floor(file.loaded / chunkSize) : 0;
		}

		function handleError() {
			if (retries-- > 0) {
				delay(uploadNextChunk, 1000);
			} else {
				file.loaded = offset; // reset all progress

				up.trigger('Error', {
					code : plupload.HTTP_ERROR,
					message : plupload.translate('HTTP Error.'),
					file : file,
					response : xhr.responseText,
					status : xhr.status,
					responseHeaders: xhr.getAllResponseHeaders()
				});
			}
		}

		function uploadNextChunk() {
			var chunkBlob, args = {}, curChunkSize;

			// make sure that file wasn't cancelled and upload is not stopped in general
			if (file.status !== plupload.UPLOADING || up.state === plupload.STOPPED) {
				return;
			}

			// send additional 'name' parameter only if required
			if (up.settings.send_file_name) {
				args.name = file.target_name || file.name;
			}

			if (chunkSize && features.chunks && blob.size > chunkSize) { // blob will be of type string if it was loaded in memory
				curChunkSize = Math.min(chunkSize, blob.size - offset);
				chunkBlob = blob.slice(offset, offset + curChunkSize);
			} else {
				curChunkSize = blob.size;
				chunkBlob = blob;
			}

			// If chunking is enabled add corresponding args, no matter if file is bigger than chunk or smaller
			if (chunkSize && features.chunks) {
				// Setup query string arguments
				if (up.settings.send_chunk_number) {
					args.chunk = Math.ceil(offset / chunkSize);
					args.chunks = Math.ceil(blob.size / chunkSize);
				} else { // keep support for experimental chunk format, just in case
					args.offset = offset;
					args.total = blob.size;
				}
			}

			if (up.trigger('BeforeChunkUpload', file, args, chunkBlob, offset)) {
				uploadChunk(args, chunkBlob, curChunkSize);
			}
		}

		function uploadChunk(args, chunkBlob, curChunkSize) {
			var formData;

			xhr = new o.xhr.XMLHttpRequest();

			// Do we have upload progress support
			if (xhr.upload) {
				xhr.upload.onprogress = function(e) {
					file.loaded = Math.min(file.size, offset + e.loaded);
					up.trigger('UploadProgress', file);
				};
			}

			xhr.onload = function() {
				// check if upload made itself through
				if (xhr.status >= 400) {
					handleError();
					return;
				}

				retries = up.settings.max_retries; // reset the counter

				// Handle chunk response
				if (curChunkSize < blob.size) {
					chunkBlob.destroy();

					offset += curChunkSize;
					file.loaded = Math.min(offset, blob.size);

					up.trigger('ChunkUploaded', file, {
						offset : file.loaded,
						total : blob.size,
						response : xhr.responseText,
						status : xhr.status,
						responseHeaders: xhr.getAllResponseHeaders()
					});

					// stock Android browser doesn't fire upload progress events, but in chunking mode we can fake them
					if (plupload.ua.browser === 'Android Browser') {
						// doesn't harm in general, but is not required anywhere else
						up.trigger('UploadProgress', file);
					}
				} else {
					file.loaded = file.size;
				}

				chunkBlob = formData = null; // Free memory

				// Check if file is uploaded
				if (!offset || offset >= blob.size) {
					// If file was modified, destory the copy
					if (file.size != file.origSize) {
						blob.destroy();
						blob = null;
					}

					up.trigger('UploadProgress', file);

					file.status = plupload.DONE;
					file.completeTimestamp = +new Date();

					up.trigger('FileUploaded', file, {
						response : xhr.responseText,
						status : xhr.status,
						responseHeaders: xhr.getAllResponseHeaders()
					});
				} else {
					// Still chunks left
					delay(uploadNextChunk, 1); // run detached, otherwise event handlers interfere
				}
			};

			xhr.onerror = function() {
				handleError();
			};

			xhr.onloadend = function() {
				this.destroy();
				xhr = null;
			};

			// Build multipart request
			if (up.settings.multipart && features.multipart) {
				xhr.open(up.settings.http_method, url, true);

				// Set custom headers
				plupload.each(up.settings.headers, function(value, name) {
					xhr.setRequestHeader(name, value);
				});

				formData = new o.xhr.FormData();

				// Add multipart params
				plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
					formData.append(name, value);
				});

				// Add file and send it
				formData.append(up.settings.file_data_name, chunkBlob);
				xhr.send(formData, {
					runtime_order: up.settings.runtimes,
					required_caps: up.settings.required_features,
					preferred_caps: preferred_caps,
					swf_url: up.settings.flash_swf_url,
					xap_url: up.settings.silverlight_xap_url
				});
			} else {
				// if no multipart, send as binary stream
				url = plupload.buildUrl(up.settings.url, plupload.extend(args, up.settings.multipart_params));

				xhr.open(up.settings.http_method, url, true);

				// Set custom headers
				plupload.each(up.settings.headers, function(value, name) {
					xhr.setRequestHeader(name, value);
				});

				// do not set Content-Type, if it was defined previously (see #1203)
				if (!xhr.hasRequestHeader('Content-Type')) {
					xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // Binary stream header
				}

				xhr.send(chunkBlob, {
					runtime_order: up.settings.runtimes,
					required_caps: up.settings.required_features,
					preferred_caps: preferred_caps,
					swf_url: up.settings.flash_swf_url,
					xap_url: up.settings.silverlight_xap_url
				});
			}
		}


		blob = file.getSource();

		// Start uploading chunks
		if (!plupload.isEmptyObj(up.settings.resize) && runtimeCan(blob, 'send_binary_string') && plupload.inArray(blob.type, ['image/jpeg', 'image/png']) !== -1) {
			// Resize if required
			resizeImage.call(this, blob, up.settings.resize, function(resizedBlob) {
				blob = resizedBlob;
				file.size = resizedBlob.size;
				uploadNextChunk();
			});
		} else {
			uploadNextChunk();
		}
	}


	function onUploadProgress(up, file) {
		calcFile(file);
	}


	function onStateChanged(up) {
		if (up.state == plupload.STARTED) {
			// Get start time to calculate bps
			startTime = (+new Date());
		} else if (up.state == plupload.STOPPED) {
			// Reset currently uploading files
			for (var i = up.files.length - 1; i >= 0; i--) {
				if (up.files[i].status == plupload.UPLOADING) {
					up.files[i].status = plupload.QUEUED;
					calc();
				}
			}
		}
	}


	function onCancelUpload() {
		if (xhr) {
			xhr.abort();
		}
	}


	function onFileUploaded(up) {
		calc();

		// Upload next file but detach it from the error event
		// since other custom listeners might want to stop the queue
		delay(function() {
			uploadNext.call(up);
		}, 1);
	}


	function onError(up, err) {
		if (err.code === plupload.INIT_ERROR) {
			up.destroy();
		}
		// Set failed status if an error occured on a file
		else if (err.code === plupload.HTTP_ERROR) {
			err.file.status = plupload.FAILED;
			err.file.completeTimestamp = +new Date();
			calcFile(err.file);

			// Upload next file but detach it from the error event
			// since other custom listeners might want to stop the queue
			if (up.state == plupload.STARTED) { // upload in progress
				up.trigger('CancelUpload');
				delay(function() {
					uploadNext.call(up);
				}, 1);
			}
		}
	}


	function onDestroy(up) {
		up.stop();

		// Purge the queue
		plupload.each(files, function(file) {
			file.destroy();
		});
		files = [];

		if (fileInputs.length) {
			plupload.each(fileInputs, function(fileInput) {
				fileInput.destroy();
			});
			fileInputs = [];
		}

		if (fileDrops.length) {
			plupload.each(fileDrops, function(fileDrop) {
				fileDrop.destroy();
			});
			fileDrops = [];
		}

		preferred_caps = {};
		disabled = false;
		startTime = xhr = null;
		total.reset();
	}


	// Default settings
	settings = {
		chunk_size: 0,
		file_data_name: 'file',
		filters: {
			mime_types: [],
			prevent_duplicates: false,
			max_file_size: 0
		},
		flash_swf_url: 'js/Moxie.swf',
		http_method: 'POST',
		max_retries: 0,
		multipart: true,
		multi_selection: true,
		resize: false,
		runtimes: Runtime.order,
		send_file_name: true,
		send_chunk_number: true,
		silverlight_xap_url: 'js/Moxie.xap'
	};


	setOption.call(this, options, null, true);

	// Inital total state
	total = new plupload.QueueProgress();

	// Add public methods
	plupload.extend(this, {

		/**
		 * Unique id for the Uploader instance.
		 *
		 * @property id
		 * @type String
		 */
		id : uid,
		uid : uid, // mOxie uses this to differentiate between event targets

		/**
		 * Current state of the total uploading progress. This one can either be plupload.STARTED or plupload.STOPPED.
		 * These states are controlled by the stop/start methods. The default value is STOPPED.
		 *
		 * @property state
		 * @type Number
		 */
		state : plupload.STOPPED,

		/**
		 * Map of features that are available for the uploader runtime. Features will be filled
		 * before the init event is called, these features can then be used to alter the UI for the end user.
		 * Some of the current features that might be in this map is: dragdrop, chunks, jpgresize, pngresize.
		 *
		 * @property features
		 * @type Object
		 */
		features : {},

		/**
		 * Current runtime name.
		 *
		 * @property runtime
		 * @type String
		 */
		runtime : null,

		/**
		 * Current upload queue, an array of File instances.
		 *
		 * @property files
		 * @type Array
		 * @see plupload.File
		 */
		files : files,

		/**
		 * Object with name/value settings.
		 *
		 * @property settings
		 * @type Object
		 */
		settings : settings,

		/**
		 * Total progess information. How many files has been uploaded, total percent etc.
		 *
		 * @property total
		 * @type plupload.QueueProgress
		 */
		total : total,


		/**
		 * Initializes the Uploader instance and adds internal event listeners.
		 *
		 * @method init
		 */
		init : function() {
			var self = this, opt, preinitOpt, err;

			preinitOpt = self.getOption('preinit');
			if (typeof(preinitOpt) == "function") {
				preinitOpt(self);
			} else {
				plupload.each(preinitOpt, function(func, name) {
					self.bind(name, func);
				});
			}

			bindEventListeners.call(self);

			// Check for required options
			plupload.each(['container', 'browse_button', 'drop_element'], function(el) {
				if (self.getOption(el) === null) {
					err = {
						code : plupload.INIT_ERROR,
						message : plupload.sprintf(plupload.translate("%s specified, but cannot be found."), el)
					}
					return false;
				}
			});

			if (err) {
				return self.trigger('Error', err);
			}


			if (!settings.browse_button && !settings.drop_element) {
				return self.trigger('Error', {
					code : plupload.INIT_ERROR,
					message : plupload.translate("You must specify either browse_button or drop_element.")
				});
			}


			initControls.call(self, settings, function(inited) {
				var initOpt = self.getOption('init');
				if (typeof(initOpt) == "function") {
					initOpt(self);
				} else {
					plupload.each(initOpt, function(func, name) {
						self.bind(name, func);
					});
				}

				if (inited) {
					self.runtime = Runtime.getInfo(getRUID()).type;
					self.trigger('Init', { runtime: self.runtime });
					self.trigger('PostInit');
				} else {
					self.trigger('Error', {
						code : plupload.INIT_ERROR,
						message : plupload.translate('Init error.')
					});
				}
			});
		},

		/**
		 * Set the value for the specified option(s).
		 *
		 * @method setOption
		 * @since 2.1
		 * @param {String|Object} option Name of the option to change or the set of key/value pairs
		 * @param {Mixed} [value] Value for the option (is ignored, if first argument is object)
		 */
		setOption: function(option, value) {
			setOption.call(this, option, value, !this.runtime); // until runtime not set we do not need to reinitialize
		},

		/**
		 * Get the value for the specified option or the whole configuration, if not specified.
		 *
		 * @method getOption
		 * @since 2.1
		 * @param {String} [option] Name of the option to get
		 * @return {Mixed} Value for the option or the whole set
		 */
		getOption: function(option) {
			if (!option) {
				return settings;
			}
			return settings[option];
		},

		/**
		 * Refreshes the upload instance by dispatching out a refresh event to all runtimes.
		 * This would for example reposition flash/silverlight shims on the page.
		 *
		 * @method refresh
		 */
		refresh : function() {
			if (fileInputs.length) {
				plupload.each(fileInputs, function(fileInput) {
					fileInput.trigger('Refresh');
				});
			}
			this.trigger('Refresh');
		},

		/**
		 * Starts uploading the queued files.
		 *
		 * @method start
		 */
		start : function() {
			if (this.state != plupload.STARTED) {
				this.state = plupload.STARTED;
				this.trigger('StateChanged');

				uploadNext.call(this);
			}
		},

		/**
		 * Stops the upload of the queued files.
		 *
		 * @method stop
		 */
		stop : function() {
			if (this.state != plupload.STOPPED) {
				this.state = plupload.STOPPED;
				this.trigger('StateChanged');
				this.trigger('CancelUpload');
			}
		},


		/**
		 * Disables/enables browse button on request.
		 *
		 * @method disableBrowse
		 * @param {Boolean} disable Whether to disable or enable (default: true)
		 */
		disableBrowse : function() {
			disabled = arguments[0] !== undef ? arguments[0] : true;

			if (fileInputs.length) {
				plupload.each(fileInputs, function(fileInput) {
					fileInput.disable(disabled);
				});
			}

			this.trigger('DisableBrowse', disabled);
		},

		/**
		 * Returns the specified file object by id.
		 *
		 * @method getFile
		 * @param {String} id File id to look for.
		 * @return {plupload.File} File object or undefined if it wasn't found;
		 */
		getFile : function(id) {
			var i;
			for (i = files.length - 1; i >= 0; i--) {
				if (files[i].id === id) {
					return files[i];
				}
			}
		},

		/**
		 * Adds file to the queue programmatically. Can be native file, instance of Plupload.File,
		 * instance of mOxie.File, input[type="file"] element, or array of these. Fires FilesAdded,
		 * if any files were added to the queue. Otherwise nothing happens.
		 *
		 * @method addFile
		 * @since 2.0
		 * @param {plupload.File|mOxie.File|File|Node|Array} file File or files to add to the queue.
		 * @param {String} [fileName] If specified, will be used as a name for the file
		 */
		addFile : function(file, fileName) {
			var self = this
			, queue = []
			, filesAdded = []
			, ruid
			;

			function filterFile(file, cb) {
				var queue = [];
				plupload.each(self.settings.filters, function(rule, name) {
					if (fileFilters[name]) {
						queue.push(function(cb) {
							fileFilters[name].call(self, rule, file, function(res) {
								cb(!res);
							});
						});
					}
				});
				plupload.inSeries(queue, cb);
			}

			/**
			 * @method resolveFile
			 * @private
			 * @param {moxie.file.File|moxie.file.Blob|plupload.File|File|Blob|input[type="file"]} file
			 */
			function resolveFile(file) {
				var type = plupload.typeOf(file);

				// moxie.file.File
				if (file instanceof o.file.File) {
					if (!file.ruid && !file.isDetached()) {
						if (!ruid) { // weird case
							return false;
						}
						file.ruid = ruid;
						file.connectRuntime(ruid);
					}
					resolveFile(new plupload.File(file));
				}
				// moxie.file.Blob
				else if (file instanceof o.file.Blob) {
					resolveFile(file.getSource());
					file.destroy();
				}
				// plupload.File - final step for other branches
				else if (file instanceof plupload.File) {
					if (fileName) {
						file.name = fileName;
					}

					queue.push(function(cb) {
						// run through the internal and user-defined filters, if any
						filterFile(file, function(err) {
							if (!err) {
								// make files available for the filters by updating the main queue directly
								files.push(file);
								// collect the files that will be passed to FilesAdded event
								filesAdded.push(file);

								self.trigger("FileFiltered", file);
							}
							delay(cb, 1); // do not build up recursions or eventually we might hit the limits
						});
					});
				}
				// native File or blob
				else if (plupload.inArray(type, ['file', 'blob']) !== -1) {
					resolveFile(new o.file.File(null, file));
				}
				// input[type="file"]
				else if (type === 'node' && plupload.typeOf(file.files) === 'filelist') {
					// if we are dealing with input[type="file"]
					plupload.each(file.files, resolveFile);
				}
				// mixed array of any supported types (see above)
				else if (type === 'array') {
					fileName = null; // should never happen, but unset anyway to avoid funny situations
					plupload.each(file, resolveFile);
				}
			}

			ruid = getRUID();

			resolveFile(file);

			if (queue.length) {
				plupload.inSeries(queue, function() {
					// if any files left after filtration, trigger FilesAdded
					if (filesAdded.length) {
						self.trigger("FilesAdded", filesAdded);
					}
				});
			}
		},

		/**
		 * Removes a specific file.
		 *
		 * @method removeFile
		 * @param {plupload.File|String} file File to remove from queue.
		 */
		removeFile : function(file) {
			var id = typeof(file) === 'string' ? file : file.id;

			for (var i = files.length - 1; i >= 0; i--) {
				if (files[i].id === id) {
					return this.splice(i, 1)[0];
				}
			}
		},

		/**
		 * Removes part of the queue and returns the files removed. This will also trigger the FilesRemoved and QueueChanged events.
		 *
		 * @method splice
		 * @param {Number} start (Optional) Start index to remove from.
		 * @param {Number} length (Optional) Lengh of items to remove.
		 * @return {Array} Array of files that was removed.
		 */
		splice : function(start, length) {
			// Splice and trigger events
			var removed = files.splice(start === undef ? 0 : start, length === undef ? files.length : length);

			// if upload is in progress we need to stop it and restart after files are removed
			var restartRequired = false;
			if (this.state == plupload.STARTED) { // upload in progress
				plupload.each(removed, function(file) {
					if (file.status === plupload.UPLOADING) {
						restartRequired = true; // do not restart, unless file that is being removed is uploading
						return false;
					}
				});

				if (restartRequired) {
					this.stop();
				}
			}

			this.trigger("FilesRemoved", removed);

			// Dispose any resources allocated by those files
			plupload.each(removed, function(file) {
				file.destroy();
			});

			if (restartRequired) {
				this.start();
			}

			return removed;
		},

		/**
		Dispatches the specified event name and its arguments to all listeners.

		@method trigger
		@param {String} name Event name to fire.
		@param {Object..} Multiple arguments to pass along to the listener functions.
		*/

		// override the parent method to match Plupload-like event logic
		dispatchEvent: function(type) {
			var list, args, result;

			type = type.toLowerCase();

			list = this.hasEventListener(type);

			if (list) {
				// sort event list by priority
				list.sort(function(a, b) { return b.priority - a.priority; });

				// first argument should be current plupload.Uploader instance
				args = [].slice.call(arguments);
				args.shift();
				args.unshift(this);

				for (var i = 0; i < list.length; i++) {
					// Fire event, break chain if false is returned
					if (list[i].fn.apply(list[i].scope, args) === false) {
						return false;
					}
				}
			}
			return true;
		},

		/**
		Check whether uploader has any listeners to the specified event.

		@method hasEventListener
		@param {String} name Event name to check for.
		*/


		/**
		Adds an event listener by name.

		@method bind
		@param {String} name Event name to listen for.
		@param {function} fn Function to call ones the event gets fired.
		@param {Object} [scope] Optional scope to execute the specified function in.
		@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first
		*/
		bind: function(name, fn, scope, priority) {
			// adapt moxie EventTarget style to Plupload-like
			plupload.Uploader.prototype.bind.call(this, name, fn, priority, scope);
		},

		/**
		Removes the specified event listener.

		@method unbind
		@param {String} name Name of event to remove.
		@param {function} fn Function to remove from listener.
		*/

		/**
		Removes all event listeners.

		@method unbindAll
		*/


		/**
		 * Destroys Plupload instance and cleans after itself.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.trigger('Destroy');
			settings = total = null; // purge these exclusively
			this.unbindAll();
		}
	});
};

plupload.Uploader.prototype = o.core.EventTarget.instance;

/**
 * Constructs a new file instance.
 *
 * @class File
 * @constructor
 *
 * @param {Object} file Object containing file properties
 * @param {String} file.name Name of the file.
 * @param {Number} file.size File size.
 */
plupload.File = (function() {
	var filepool = {};

	function PluploadFile(file) {

		plupload.extend(this, {

			/**
			 * File id this is a globally unique id for the specific file.
			 *
			 * @property id
			 * @type String
			 */
			id: plupload.guid(),

			/**
			 * File name for example "myfile.gif".
			 *
			 * @property name
			 * @type String
			 */
			name: file.name || file.fileName,

			/**
			 * File type, `e.g image/jpeg`
			 *
			 * @property type
			 * @type String
			 */
			type: file.type || '',

			/**
			 * File size in bytes (may change after client-side manupilation).
			 *
			 * @property size
			 * @type Number
			 */
			size: file.size || file.fileSize,

			/**
			 * Original file size in bytes.
			 *
			 * @property origSize
			 * @type Number
			 */
			origSize: file.size || file.fileSize,

			/**
			 * Number of bytes uploaded of the files total size.
			 *
			 * @property loaded
			 * @type Number
			 */
			loaded: 0,

			/**
			 * Number of percentage uploaded of the file.
			 *
			 * @property percent
			 * @type Number
			 */
			percent: 0,

			/**
			 * Status constant matching the plupload states QUEUED, UPLOADING, FAILED, DONE.
			 *
			 * @property status
			 * @type Number
			 * @see plupload
			 */
			status: plupload.QUEUED,

			/**
			 * Date of last modification.
			 *
			 * @property lastModifiedDate
			 * @type {String}
			 */
			lastModifiedDate: file.lastModifiedDate || (new Date()).toLocaleString(), // Thu Aug 23 2012 19:40:00 GMT+0400 (GET)


			/**
			 * Set when file becomes plupload.DONE or plupload.FAILED. Is used to calculate proper plupload.QueueProgress.bytesPerSec.
			 * @private
			 * @property completeTimestamp
			 * @type {Number}
			 */
			completeTimestamp: 0,

			/**
			 * Returns native window.File object, when it's available.
			 *
			 * @method getNative
			 * @return {window.File} or null, if plupload.File is of different origin
			 */
			getNative: function() {
				var file = this.getSource().getSource();
				return plupload.inArray(plupload.typeOf(file), ['blob', 'file']) !== -1 ? file : null;
			},

			/**
			 * Returns mOxie.File - unified wrapper object that can be used across runtimes.
			 *
			 * @method getSource
			 * @return {mOxie.File} or null
			 */
			getSource: function() {
				if (!filepool[this.id]) {
					return null;
				}
				return filepool[this.id];
			},

			/**
			 * Destroys plupload.File object.
			 *
			 * @method destroy
			 */
			destroy: function() {
				var src = this.getSource();
				if (src) {
					src.destroy();
					delete filepool[this.id];
				}
			}
		});

		filepool[this.id] = file;
	}

	return PluploadFile;
}());


/**
 * Constructs a queue progress.
 *
 * @class QueueProgress
 * @constructor
 */
 plupload.QueueProgress = function() {
	var self = this; // Setup alias for self to reduce code size when it's compressed

	/**
	 * Total queue file size.
	 *
	 * @property size
	 * @type Number
	 */
	self.size = 0;

	/**
	 * Total bytes uploaded.
	 *
	 * @property loaded
	 * @type Number
	 */
	self.loaded = 0;

	/**
	 * Number of files uploaded.
	 *
	 * @property uploaded
	 * @type Number
	 */
	self.uploaded = 0;

	/**
	 * Number of files failed to upload.
	 *
	 * @property failed
	 * @type Number
	 */
	self.failed = 0;

	/**
	 * Number of files yet to be uploaded.
	 *
	 * @property queued
	 * @type Number
	 */
	self.queued = 0;

	/**
	 * Total percent of the uploaded bytes.
	 *
	 * @property percent
	 * @type Number
	 */
	self.percent = 0;

	/**
	 * Bytes uploaded per second.
	 *
	 * @property bytesPerSec
	 * @type Number
	 */
	self.bytesPerSec = 0;

	/**
	 * Resets the progress to its initial values.
	 *
	 * @method reset
	 */
	self.reset = function() {
		self.size = self.loaded = self.uploaded = self.failed = self.queued = self.percent = self.bytesPerSec = 0;
	};
};

exports.plupload = plupload;

}(this, moxie));

}));

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * qiniu-js-sdk v@VERSION
 *
 * Copyright 2015 by Qiniu
 * Released under GPL V2 License.
 *
 * GitHub: http://github.com/qiniu/js-sdk
 *
 * Date: @DATE
 */

/*global plupload ,moxie*/
/*global ActiveXObject */
/*exported Qiniu */
/*exported QiniuJsSDK */

;(function (global) {


    /**
     * Creates new cookie or removes cookie with negative expiration
     * @param  key       The key or identifier for the store
     * @param  value     Contents of the store
     * @param  exp       Expiration - creation defaults to 30 days
     */
    function createCookie(key, value, exp) {
        var date = new Date();
        date.setTime(date.getTime() + (exp * 24 * 60 * 60 * 1000));
        var expires = "; expires=" + date.toGMTString();
        document.cookie = key + "=" + value + expires + "; path=/";
    }

    /**
     * Returns contents of cookie
     * @param  key       The key or identifier for the store
     */
    function readCookie(key) {
        var nameEQ = key + "=";
        var ca = document.cookie.split(';');
        for (var i = 0, max = ca.length; i < max; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    }

    // if current browser is not support localStorage
    // use cookie to make a polyfill
    if (!window.localStorage) {
        window.localStorage = {
            setItem: function (key, value) {
                createCookie(key, value, 30);
            },
            getItem: function (key) {
                return readCookie(key);
            },
            removeItem: function (key) {
                createCookie(key, '', -1);
            }
        };
    }

    function QiniuJsSDK() {
        var moxie = __webpack_require__(0);
        window.moxie = moxie;
        var plupload = __webpack_require__(1);
        window.plupload = plupload;


        var that = this;

        /**
         * detect IE version
         * if current browser is not IE
         *     it will return false
         * else
         *     it will return version of current IE browser
         * @return {Number|Boolean} IE version or false
         */
        this.detectIEVersion = function () {
            var v = 4,
                div = document.createElement('div'),
                all = div.getElementsByTagName('i');
            while (
                div.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->',
                    all[0]
                ) {
                v++;
            }
            return v > 4 ? v : false;
        };

        var logger = {
            MUTE: 0,
            FATA: 1,
            ERROR: 2,
            WARN: 3,
            INFO: 4,
            DEBUG: 5,
            TRACE: 6,
            level: 0
        };

        function log(type, args) {
            var header = "[qiniu-js-sdk][" + type + "]";
            var msg = header;
            for (var i = 0; i < args.length; i++) {
                if (typeof args[i] === "string") {
                    msg += " " + args[i];
                } else {
                    msg += " " + that.stringifyJSON(args[i]);
                }
            }
            if (that.detectIEVersion()) {
                // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9
                //var log = Function.prototype.bind.call(console.log, console);
                //log.apply(console, args);
                console.log(msg);
            } else {
                args.unshift(header);
                console.log.apply(console, args);
            }
            if (document.getElementById('qiniu-js-sdk-log')) {
                document.getElementById('qiniu-js-sdk-log').innerHTML += '<p>' + msg + '</p>';
            }
        }

        function makeLogFunc(code) {
            var func = code.toLowerCase();
            logger[func] = function () {
                // logger[func].history = logger[func].history || [];
                // logger[func].history.push(arguments);
                if (window.console && window.console.log && logger.level >= logger[code]) {
                    var args = Array.prototype.slice.call(arguments);
                    log(func, args);
                }
            };
        }

        for (var property in logger) {
            if (logger.hasOwnProperty(property) && (typeof logger[property]) === "number" && !logger.hasOwnProperty(property.toLowerCase())) {
                makeLogFunc(property);
            }
        }


        var qiniuUploadUrl;
        if (window.location.protocol === 'https:') {
            qiniuUploadUrl = 'https://upload.qiniup.com';
        } else {
            qiniuUploadUrl = 'http://upload.qiniup.com';
        }

        /**
         * qiniu upload urls
         * 'qiniuUploadUrls' is used to change target when current url is not avaliable
         * @type {Array}
         */
        var qiniuUploadUrls = [
            "http://upload.qiniup.com",
            "http://up.qiniup.com"
        ];

        var qiniuUpHosts = {
            "http": [
                "http://upload.qiniup.com",
                "http://up.qiniup.com"
            ],
            "https": [
                "https://upload.qiniup.com"
            ]
        };

        var changeUrlTimes = 0;

        /**
         * reset upload url
         * if current page protocal is https
         *     it will always return 'https://up.qbox.me'
         * else
         *     it will set 'qiniuUploadUrl' value with 'qiniuUploadUrls' looply
         */
        this.resetUploadUrl = function (num) {
            logger.debug('num: ' + num);
            if( num == 0) {
                logger.debug("use main uphost");
                var hosts = qiniuUpHosts.main;
                qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[0] : "http://" + hosts[0];
            } else {
                logger.debug("use backup uphost");
                var hosts = qiniuUpHosts.backup;
                if( num % 2 == 0) {
                    qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[1] : "http://" + hosts[1];
                } else {
                    qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[0] : "http://" + hosts[0];
                }
            }
            //qiniuUploadUrl = window.location.protocol === 'https:' ? "https://" + hosts[0] : "http://" + hosts[0];
            logger.debug('resetUploadUrl: ' + qiniuUploadUrl);
        };
        // this.resetUploadUrl();


        /**
         * is image
         * @param  {String}  url of a file
         * @return {Boolean} file is a image or not
         */
        this.isImage = function (url) {
            url = url.split(/[?#]/)[0];
            return (/\.(png|jpg|jpeg|gif|bmp)$/i).test(url);
        };

        /**
         * get file extension
         * @param  {String} filename
         * @return {String} file extension
         * @example
         *     input: test.txt
         *     output: txt
         */
        this.getFileExtension = function (filename) {
            var tempArr = filename.split(".");
            var ext;
            if (tempArr.length === 1 || (tempArr[0] === "" && tempArr.length === 2)) {
                ext = "";
            } else {
                ext = tempArr.pop().toLowerCase(); //get the extension and make it lower-case
            }
            return ext;
        };

        /**
         * encode string by utf8
         * @param  {String} string to encode
         * @return {String} encoded string
         */
        this.utf8_encode = function (argString) {
            // http://kevin.vanzonneveld.net
            // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: sowberry
            // +    tweaked by: Jack
            // +   bugfixed by: Onno Marsman
            // +   improved by: Yves Sucaet
            // +   bugfixed by: Onno Marsman
            // +   bugfixed by: Ulrich
            // +   bugfixed by: Rafal Kukawski
            // +   improved by: kirilloid
            // +   bugfixed by: kirilloid
            // *     example 1: this.utf8_encode('Kevin van Zonneveld');
            // *     returns 1: 'Kevin van Zonneveld'

            if (argString === null || typeof argString === 'undefined') {
                return '';
            }

            var string = (argString + ''); // .replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            var utftext = '',
                start, end, stringl = 0;

            start = end = 0;
            stringl = string.length;
            for (var n = 0; n < stringl; n++) {
                var c1 = string.charCodeAt(n);
                var enc = null;

                if (c1 < 128) {
                    end++;
                } else if (c1 > 127 && c1 < 2048) {
                    enc = String.fromCharCode(
                        (c1 >> 6) | 192, (c1 & 63) | 128
                    );
                } else if (c1 & 0xF800 ^ 0xD800 > 0) {
                    enc = String.fromCharCode(
                        (c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128
                    );
                } else { // surrogate pairs
                    if (c1 & 0xFC00 ^ 0xD800 > 0) {
                        throw new RangeError('Unmatched trail surrogate at ' + n);
                    }
                    var c2 = string.charCodeAt(++n);
                    if (c2 & 0xFC00 ^ 0xDC00 > 0) {
                        throw new RangeError('Unmatched lead surrogate at ' + (n - 1));
                    }
                    c1 = ((c1 & 0x3FF) << 10) + (c2 & 0x3FF) + 0x10000;
                    enc = String.fromCharCode(
                        (c1 >> 18) | 240, ((c1 >> 12) & 63) | 128, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128
                    );
                }
                if (enc !== null) {
                    if (end > start) {
                        utftext += string.slice(start, end);
                    }
                    utftext += enc;
                    start = end = n + 1;
                }
            }

            if (end > start) {
                utftext += string.slice(start, stringl);
            }

            return utftext;
        };

        this.base64_decode = function (data) {
            // http://kevin.vanzonneveld.net
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Thunder.m
            // +      input by: Aman Gupta
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Onno Marsman
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +      input by: Brett Zamir (http://brett-zamir.me)
            // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
            // *     returns 1: 'Kevin van Zonneveld'
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window['atob'] == 'function') {
            //    return atob(data);
            //}
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                dec = "",
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data += '';

            do { // unpack four hexets into three octets using index points in b64
                h1 = b64.indexOf(data.charAt(i++));
                h2 = b64.indexOf(data.charAt(i++));
                h3 = b64.indexOf(data.charAt(i++));
                h4 = b64.indexOf(data.charAt(i++));

                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                o1 = bits >> 16 & 0xff;
                o2 = bits >> 8 & 0xff;
                o3 = bits & 0xff;

                if (h3 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1);
                } else if (h4 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2);
                } else {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
                }
            } while (i < data.length);

            dec = tmp_arr.join('');

            return dec;
        };

        /**
         * encode data by base64
         * @param  {String} data to encode
         * @return {String} encoded data
         */
        this.base64_encode = function (data) {
            // http://kevin.vanzonneveld.net
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // -    depends on: this.utf8_encode
            // *     example 1: this.base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window['atob'] == 'function') {
            //    return atob(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data = this.utf8_encode(data + '');

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            switch (data.length % 3) {
                case 1:
                    enc = enc.slice(0, -2) + '==';
                    break;
                case 2:
                    enc = enc.slice(0, -1) + '=';
                    break;
            }

            return enc;
        };

        /**
         * encode string in url by base64
         * @param {String} string in url
         * @return {String} encoded string
         */
        this.URLSafeBase64Encode = function (v) {
            v = this.base64_encode(v);
            return v.replace(/\//g, '_').replace(/\+/g, '-');
        };

        this.URLSafeBase64Decode = function (v) {
            v = v.replace(/_/g, '/').replace(/-/g, '+');
            return this.base64_decode(v);
        };

        // TODO: use mOxie
        /**
         * craete object used to AJAX
         * @return {Object}
         */
        this.createAjax = function (argument) {
            var xmlhttp = {};
            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            } else {
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            }
            return xmlhttp;
        };

        // TODO: enhance IE compatibility
        /**
         * parse json string to javascript object
         * @param  {String} json string
         * @return {Object} object
         */
        this.parseJSON = function (data) {
            // Attempt to parse using the native JSON parser first
            if (window.JSON && window.JSON.parse) {
                return window.JSON.parse(data);
            }

            //var rx_one = /^[\],:{}\s]*$/,
            //    rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
            //    rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            //    rx_four = /(?:^|:|,)(?:\s*\[)+/g,
            var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

            //var json;

            var text = String(data);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

            // todo 使用一下判断,增加安全性
            //if (
            //    rx_one.test(
            //        text
            //            .replace(rx_two, '@')
            //            .replace(rx_three, ']')
            //            .replace(rx_four, '')
            //    )
            //) {
            //    return eval('(' + text + ')');
            //}

            return eval('(' + text + ')');
        };

        /**
         * parse javascript object to json string
         * @param  {Object} object
         * @return {String} json string
         */
        this.stringifyJSON = function (obj) {
            // Attempt to parse using the native JSON parser first
            if (window.JSON && window.JSON.stringify) {
                return window.JSON.stringify(obj);
            }
            switch (typeof (obj)) {
                case 'string':
                    return '"' + obj.replace(/(["\\])/g, '\\$1') + '"';
                case 'array':
                    return '[' + obj.map(that.stringifyJSON).join(',') + ']';
                case 'object':
                    if (obj instanceof Array) {
                        var strArr = [];
                        var len = obj.length;
                        for (var i = 0; i < len; i++) {
                            strArr.push(that.stringifyJSON(obj[i]));
                        }
                        return '[' + strArr.join(',') + ']';
                    } else if (obj === null) {
                        return 'null';
                    } else {
                        var string = [];
                        for (var property in obj) {
                            if (obj.hasOwnProperty(property)) {
                                string.push(that.stringifyJSON(property) + ':' + that.stringifyJSON(obj[property]));
                            }
                        }
                        return '{' + string.join(',') + '}';
                    }
                    break;
                case 'number':
                    return obj;
                case false:
                    return obj;
                case 'boolean':
                    return obj;
            }
        };

        /**
         * trim space beside text
         * @param  {String} untrimed string
         * @return {String} trimed string
         */
        this.trim = function (text) {
            return text === null ? "" : text.replace(/^\s+|\s+$/g, '');
        };

        /**
         * create a uploader by QiniuJsSDK
         * @param  {object} options to create a new uploader
         * @return {object} uploader
         */
        this.uploader = function (op) {

            /********** inner function define start **********/

                // according the different condition to reset chunk size
                // and the upload strategy according with the chunk size
                // when chunk size is zero will cause to direct upload
                // see the statement binded on 'BeforeUpload' event
            var reset_chunk_size = function () {
                    var ie = that.detectIEVersion();
                    var BLOCK_BITS, MAX_CHUNK_SIZE, chunk_size;
                    // case Safari 5、Windows 7、iOS 7 set isSpecialSafari to true
                    var isSpecialSafari = (moxie.core.utils.Env.browser === "Safari" && moxie.core.utils.Env.version <= 5 && moxie.core.utils.Env.os === "Windows" && moxie.core.utils.Env.osVersion === "7") || (moxie.core.utils.Env.browser === "Safari" && moxie.core.utils.Env.os === "iOS" && moxie.core.utils.Env.osVersion === "7");
                    // case IE 9-，chunk_size is not empty and flash is included in runtimes
                    // set op.chunk_size to zero
                    //if (ie && ie < 9 && op.chunk_size && op.runtimes.indexOf('flash') >= 0) {
                    if (ie && ie < 9 && op.chunk_size && op.runtimes.indexOf('flash') >= 0) {
                        //  link: http://www.plupload.com/docs/Frequently-Asked-Questions#when-to-use-chunking-and-when-not
                        //  when plupload chunk_size setting is't null ,it cause bug in ie8/9  which runs  flash runtimes (not support html5) .
                        op.chunk_size = 0;
                    } else if (isSpecialSafari) {
                        // win7 safari / iOS7 safari have bug when in chunk upload mode
                        // reset chunk_size to 0
                        // disable chunk in special version safari
                        op.chunk_size = 0;
                    } else {
                        BLOCK_BITS = 20;
                        MAX_CHUNK_SIZE = 4 << BLOCK_BITS; //4M

                        chunk_size = plupload.parseSize(op.chunk_size);
                        if (chunk_size > MAX_CHUNK_SIZE) {
                            op.chunk_size = MAX_CHUNK_SIZE;
                        }
                        // qiniu service  max_chunk_size is 4m
                        // reset chunk_size to max_chunk_size(4m) when chunk_size > 4m
                    }
                    // if op.chunk_size set 0 will be cause to direct upload
                };

            var getHosts = function (hosts) {
                var result = [];
                var uploadIndex = -1;
                for (var i = 0; i < hosts.length; i++) {
                    var host = hosts[i];
                    if (host.indexOf("upload") !== -1) {
                        uploadIndex = i;
                    }
                    if (host.indexOf('-H') === 0) {
                        result.push(host.split(' ')[2]);
                    } else {
                        result.push(host);
                    }
                }

                if (uploadIndex !== -1) {
                    //make upload domains first
                    var uploadDomain = result[uploadIndex];
                    result[uploadIndex] = result[0];
                    result[0] = uploadDomain;
                }
                return result;
            };

            var getPutPolicy = function (uptoken) {
                var segments = uptoken.split(":");
                var ak = segments[0];
                var putPolicy = that.parseJSON(that.URLSafeBase64Decode(segments[2]));
                putPolicy.ak = ak;
                if (putPolicy.scope.indexOf(":") >= 0) {
                    putPolicy.bucket = putPolicy.scope.split(":")[0];
                    putPolicy.key = putPolicy.scope.split(":")[1];
                } else {
                    putPolicy.bucket = putPolicy.scope;
                }
                return putPolicy;
            };

            var getUpHosts = function (uptoken) {
                var putPolicy = getPutPolicy(uptoken);
                var uphosts_url = window.location.protocol === 'https:' ? "https://" + "//api.qiniu.com/v2/query?ak=" + putPolicy.ak + "&bucket=" + putPolicy.bucket : "http://" + "//api.qiniu.com/v2/query?ak=" + putPolicy.ak + "&bucket=" + putPolicy.bucket;
                logger.debug("putPolicy: ", putPolicy);
                logger.debug("get uphosts from: ", uphosts_url);
                var ie = that.detectIEVersion();
                var ajax;
                if (ie && ie <= 9) {
                    ajax = new moxie.xhr.XMLHttpRequest();
                    moxie.core.utils.Env.swf_url = op.flash_swf_url;
                } else {
                    ajax = that.createAjax();
                }
                ajax.open('GET', uphosts_url, false);
                var onreadystatechange = function () {
                    logger.debug("ajax.readyState: ", ajax.readyState);
                    if (ajax.readyState === 4) {
                        logger.debug("ajax.status: ", ajax.status);
                        if (ajax.status < 400) {
                            var res = that.parseJSON(ajax.responseText);
                            qiniuUpHosts.main = res.up.acc.main;
                            qiniuUpHosts.backup = res.up.acc.backup;
                            logger.debug("get new uphosts: ", qiniuUpHosts);
                            that.resetUploadUrl(0);
                        } else {
                            logger.error("get uphosts error: ", ajax.responseText);
                        }
                    }
                };
                if (ie && ie <= 9) {
                    ajax.bind('readystatechange', onreadystatechange);
                } else {
                    ajax.onreadystatechange = onreadystatechange;
                }
                ajax.send();
                // ajax.send();
                // if (ajax.status < 400) {
                //     var res = that.parseJSON(ajax.responseText);
                //     qiniuUpHosts.http = getHosts(res.http.up);
                //     qiniuUpHosts.https = getHosts(res.https.up);
                //     logger.debug("get new uphosts: ", qiniuUpHosts);
                //     that.resetUploadUrl();
                // } else {
                //     logger.error("get uphosts error: ", ajax.responseText);
                // }
                return;
            };

            var getUptoken = function (file) {
                if (!that.token || (op.uptoken_url && that.tokenInfo.isExpired())) {
                    return getNewUpToken(file);
                } else {
                    return that.token;
                }
            };

            // getNewUptoken maybe called at Init Event or BeforeUpload Event
            // case Init Event, the file param of getUptken will be set a null value
            // if op.uptoken has value, set uptoken with op.uptoken
            // else if op.uptoken_url has value, set uptoken from op.uptoken_url
            // else if op.uptoken_func has value, set uptoken by result of op.uptoken_func
            var getNewUpToken = function (file) {
                if (op.uptoken) {
                    that.token = op.uptoken;
                } else if (op.uptoken_url) {
                    logger.debug("get uptoken from: ", that.uptoken_url);
                    // TODO: use mOxie
                    var ajax = that.createAjax();
                    ajax.open('GET', that.uptoken_url, false);
                    // ajax.setRequestHeader("If-Modified-Since", "0");
                    // ajax.onreadystatechange = function() {
                    //     if (ajax.readyState === 4 && ajax.status === 200) {
                    //         var res = that.parseJSON(ajax.responseText);
                    //         that.token = res.uptoken;
                    //     }
                    // };
                    ajax.send();
                    if (ajax.status === 200) {
                        var res = that.parseJSON(ajax.responseText);
                        that.token = res.uptoken;
                        var segments = that.token.split(":");
                        var putPolicy = that.parseJSON(that.URLSafeBase64Decode(segments[2]));
                        if (!that.tokenMap) {
                            that.tokenMap = {};
                        }
                        var getTimestamp = function (time) {
                            return Math.ceil(time.getTime() / 1000);
                        };
                        var serverTime = getTimestamp(new Date(ajax.getResponseHeader("date")));
                        var clientTime = getTimestamp(new Date());
                        that.tokenInfo = {
                            serverDelay: clientTime - serverTime,
                            deadline: putPolicy.deadline,
                            isExpired: function () {
                                var leftTime = this.deadline - getTimestamp(new Date()) + this.serverDelay;
                                return leftTime < 600;
                            }
                        };
                        logger.debug("get new uptoken: ", that.token);
                        logger.debug("get token info: ", that.tokenInfo);
                    } else {
                        logger.error("get uptoken error: ", ajax.responseText);
                    }
                } else if (op.uptoken_func) {
                    logger.debug("get uptoken from uptoken_func");
                    that.token = op.uptoken_func(file);
                    logger.debug("get new uptoken: ", that.token);
                } else {
                    logger.error("one of [uptoken, uptoken_url, uptoken_func] settings in options is required!");
                }
                if (that.token) {
                    getUpHosts(that.token);
                }
                return that.token;
            };

            // get file key according with the user passed options
            var getFileKey = function (up, file, func) {
                // WARNING
                // When you set the key in putPolicy by "scope": "bucket:key"
                // You should understand the risk of override a file in the bucket
                // So the code below that automatically get key from uptoken has been commented
                // var putPolicy = getPutPolicy(that.token)
                // if (putPolicy.key) {
                //     logger.debug("key is defined in putPolicy.scope: ", putPolicy.key)
                //     return putPolicy.key
                // }
                var key = '',
                    unique_names = false;
                if (!op.save_key) {
                    unique_names = up.getOption && up.getOption('unique_names');
                    unique_names = unique_names || (up.settings && up.settings.unique_names);
                    if (unique_names) {
                        var ext = that.getFileExtension(file.name);
                        key = ext ? file.id + '.' + ext : file.id;
                    } else if (typeof func === 'function') {
                        key = func(up, file);
                    } else {
                        key = file.name;
                    }
                }
                return key;
            };

            var getDomainFromUrl = function (url) {
                if (url && url.match) {
                    var groups = url.match(/^https?:\/\/([^:^/]*)/);
                    return groups ? groups[1] : "";
                }
                return "";
            };

            var getPortFromUrl = function (url) {
                if (url && url.match) {
                    var groups = url.match(/(^https?)/);
                    if (!groups) {
                        return "";
                    }
                    var type = groups[1];
                    groups = url.match(/^https?:\/\/([^:^/]*):(\d*)/);
                    if (groups) {
                        return groups[2];
                    } else if (type === "http") {
                        return "80";
                    } else {
                        return "443";
                    }
                }
                return "";
            };

            /********** inner function define end **********/

            if (op.log_level) {
                logger.level = op.log_level;
            }

            if (!op.domain) {
                throw 'domain setting in options is required!';
            }

            if (!op.browse_button) {
                throw 'browse_button setting in options is required!';
            }

            if (!op.uptoken && !op.uptoken_url && !op.uptoken_func) {
                throw 'one of [uptoken, uptoken_url, uptoken_func] settings in options is required!';
            }

            logger.debug("init uploader start");

            logger.debug("environment: ", moxie.core.utils.Env);

            logger.debug("userAgent: ", navigator.userAgent);

            var option = {};

            // hold the handler from user passed options
            var _Error_Handler = op.init && op.init.Error;
            var _FileUploaded_Handler = op.init && op.init.FileUploaded;

            // replace the handler for intercept
            op.init.Error = function () {};
            op.init.FileUploaded = function () {};

            that.uptoken_url = op.uptoken_url;
            that.token = '';
            that.key_handler = typeof op.init.Key === 'function' ? op.init.Key : '';
            this.domain = op.domain;
            // TODO: ctx is global in scope of a uploader instance
            // this maybe cause error
            var ctx = '';
            var speedCalInfo = {
                isResumeUpload: false,
                resumeFilesize: 0,
                startTime: '',
                currentTime: ''
            };

            reset_chunk_size();
            logger.debug("invoke reset_chunk_size()");
            logger.debug("op.chunk_size: ", op.chunk_size);

            var defaultSetting = {
                url: qiniuUploadUrl,
                multipart_params: {
                    token: ''
                }
            };
            var ie = that.detectIEVersion();
            // case IE 9-
            // add accept in multipart params
            if (ie && ie <= 9) {
                defaultSetting.multipart_params.accept = 'text/plain; charset=utf-8';
                logger.debug("add accept text/plain in multipart params");
            }

            // compose options with user passed options and default setting
            plupload.extend(option, op, defaultSetting);

            logger.debug("option: ", option);

            // create a new uploader with composed options
            var uploader = new plupload.Uploader(option);

            logger.debug("new plupload.Uploader(option)");

            // bind getNewUpToken to 'Init' event
            uploader.bind('Init', function (up, params) {
                logger.debug("Init event activated");
                // if op.get_new_uptoken is not true
                //      invoke getNewUptoken when uploader init
                // else
                //      getNewUptoken everytime before a new file upload
                if (!op.get_new_uptoken) {
                    getNewUpToken(null);
                }
                //getNewUpToken(null);
            });

            logger.debug("bind Init event");

            // bind 'FilesAdded' event
            // when file be added and auto_start has set value
            // uploader will auto start upload the file
            uploader.bind('FilesAdded', function (up, files) {
                logger.debug("FilesAdded event activated");
                var auto_start = up.getOption && up.getOption('auto_start');
                auto_start = auto_start || (up.settings && up.settings.auto_start);
                logger.debug("auto_start: ", auto_start);
                logger.debug("files: ", files);

                // detect is iOS
                var is_ios = function () {
                    if (moxie.core.utils.Env.OS.toLowerCase() === "ios") {
                        return true;
                    } else {
                        return false;
                    }
                };

                // if current env os is iOS change file name to [time].[ext]
                if (is_ios()) {
                    for (var i = 0; i < files.length; i++) {
                        var file = files[i];
                        var ext = that.getFileExtension(file.name);
                        file.name = file.id + "." + ext;
                    }
                }

                if (auto_start) {
                    setTimeout(function () {
                        up.start();
                        logger.debug("invoke up.start()");
                    }, 0);
                    // up.start();
                    // plupload.each(files, function(i, file) {
                    //     up.start();
                    //     logger.debug("invoke up.start()")
                    //     logger.debug("file: ", file);
                    // });
                }
                up.refresh(); // Reposition Flash/Silverlight
            });

            logger.debug("bind FilesAdded event");

            // bind 'BeforeUpload' event
            // intercept the process of upload
            // - prepare uptoken
            // - according the chunk size to make differnt upload strategy
            // - resume upload with the last breakpoint of file
            uploader.bind('BeforeUpload', function (up, file) {
                logger.debug("BeforeUpload event activated");
                file._start_at = new Date();
                // add a key named speed for file object
                file.speed = file.speed || 0;
                ctx = '';

                if (op.get_new_uptoken) {
                    getNewUpToken(file);
                }

                var directUpload = function (up, file, func) {
                    speedCalInfo.startTime = new Date().getTime();
                    var multipart_params_obj;
                    if (op.save_key) {
                        multipart_params_obj = {
                            'token': that.token
                        };
                    } else {
                        multipart_params_obj = {
                            'key': getFileKey(up, file, func),
                            'token': that.token
                        };
                    }
                    var ie = that.detectIEVersion();
                    // case IE 9-
                    // add accept in multipart params
                    if (ie && ie <= 9) {
                        multipart_params_obj.accept = 'text/plain; charset=utf-8';
                        logger.debug("add accept text/plain in multipart params");
                    }

                    logger.debug("directUpload multipart_params_obj: ", multipart_params_obj);

                    var x_vars = op.x_vars;
                    if (x_vars !== undefined && typeof x_vars === 'object') {
                        for (var x_key in x_vars) {
                            if (x_vars.hasOwnProperty(x_key)) {
                                if (typeof x_vars[x_key] === 'function') {
                                    multipart_params_obj['x:' + x_key] = x_vars[x_key](up, file);
                                } else if (typeof x_vars[x_key] !== 'object') {
                                    multipart_params_obj['x:' + x_key] = x_vars[x_key];
                                }
                            }
                        }
                    }

                    up.setOption({
                        'url': qiniuUploadUrl,
                        'multipart': true,
                        'chunk_size': is_android_weixin_or_qq() ? op.max_file_size : undefined,
                        'multipart_params': multipart_params_obj
                    });
                };

                // detect is weixin or qq inner browser
                var is_android_weixin_or_qq = function () {
                    var ua = navigator.userAgent.toLowerCase();
                    if ((ua.match(/MicroMessenger/i) || moxie.core.utils.Env.browser === "QQBrowser" || ua.match(/V1_AND_SQ/i)) && moxie.core.utils.Env.OS.toLowerCase() === "android") {
                        return true;
                    } else {
                        return false;
                    }
                };

                var chunk_size = up.getOption && up.getOption('chunk_size');
                chunk_size = chunk_size || (up.settings && up.settings.chunk_size);

                logger.debug("uploader.runtime: ", uploader.runtime);
                logger.debug("chunk_size: ", chunk_size);

                // TODO: flash support chunk upload
                if ((uploader.runtime === 'html5' || uploader.runtime === 'flash') && chunk_size) {
                    if (file.size < chunk_size || is_android_weixin_or_qq()) {
                        logger.debug("directUpload because file.size < chunk_size || is_android_weixin_or_qq()");
                        // direct upload if file size is less then the chunk size
                        directUpload(up, file, that.key_handler);
                    } else {
                        // TODO: need a polifill to make it work in IE 9-
                        // ISSUE: if file.name is existed in localStorage
                        // but not the same file maybe cause error
                        var localFileInfo = localStorage.getItem(file.name);
                        var blockSize = chunk_size;
                        if (localFileInfo) {
                            // TODO: although only the html5 runtime will enter this statement
                            // but need uniform way to make convertion between string and json
                            localFileInfo = that.parseJSON(localFileInfo);
                            var now = (new Date()).getTime();
                            var before = localFileInfo.time || 0;
                            var aDay = 24 * 60 * 60 * 1000; //  milliseconds of one day
                            // if the last upload time is within one day
                            //      will upload continuously follow the last breakpoint
                            // else
                            //      will reupload entire file
                            if (now - before < aDay) {

                                if (localFileInfo.percent !== 100) {
                                    if (file.size === localFileInfo.total) {
                                        // TODO: if file.name and file.size is the same
                                        // but not the same file will cause error
                                        file.percent = localFileInfo.percent;
                                        file.loaded = localFileInfo.offset;
                                        ctx = localFileInfo.ctx;

                                        // set speed info
                                        speedCalInfo.isResumeUpload = true;
                                        speedCalInfo.resumeFilesize = localFileInfo.offset;

                                        // set block size
                                        if (localFileInfo.offset + blockSize > file.size) {
                                            blockSize = file.size - localFileInfo.offset;
                                        }
                                    } else {
                                        // remove file info when file.size is conflict with file info
                                        localStorage.removeItem(file.name);
                                    }

                                } else {
                                    // remove file info when upload percent is 100%
                                    // avoid 499 bug
                                    localStorage.removeItem(file.name);
                                }
                            } else {
                                // remove file info when last upload time is over one day
                                localStorage.removeItem(file.name);
                            }
                        }
                        speedCalInfo.startTime = new Date().getTime();
                        var multipart_params_obj = {};
                        var ie = that.detectIEVersion();
                        // case IE 9-
                        // add accept in multipart params
                        if (ie && ie <= 9) {
                            multipart_params_obj.accept = 'text/plain; charset=utf-8';
                            logger.debug("add accept text/plain in multipart params");
                        }
                        // TODO: to support bput
                        // http://developer.qiniu.com/docs/v6/api/reference/up/bput.html
                        up.setOption({
                            'url': qiniuUploadUrl + '/mkblk/' + blockSize,
                            'multipart': false,
                            'chunk_size': chunk_size,
                            'required_features': "chunks",
                            'headers': {
                                'Authorization': 'UpToken ' + getUptoken(file)
                            },
                            'multipart_params': multipart_params_obj
                        });
                    }
                } else {
                    logger.debug("directUpload because uploader.runtime !== 'html5' || uploader.runtime !== 'flash' || !chunk_size");
                    // direct upload if runtime is not html5
                    directUpload(up, file, that.key_handler);
                }
            });

            logger.debug("bind BeforeUpload event");

            // bind 'UploadProgress' event
            // calculate upload speed
            uploader.bind('UploadProgress', function (up, file) {
                logger.trace("UploadProgress event activated");
                speedCalInfo.currentTime = new Date().getTime();
                var timeUsed = speedCalInfo.currentTime - speedCalInfo.startTime; // ms
                var fileUploaded = file.loaded || 0;
                if (speedCalInfo.isResumeUpload) {
                    fileUploaded = file.loaded - speedCalInfo.resumeFilesize;
                }
                file.speed = (fileUploaded / timeUsed * 1000).toFixed(0) || 0; // unit: byte/s
            });

            logger.debug("bind UploadProgress event");

            // bind 'ChunkUploaded' event
            // store the chunk upload info and set next chunk upload url
            uploader.bind('ChunkUploaded', function (up, file, info) {
                logger.debug("ChunkUploaded event activated");
                logger.debug("ChunkUploaded file: ", file);
                logger.debug("ChunkUploaded info: ", info);
                var res = that.parseJSON(info.response);
                logger.debug("ChunkUploaded res: ", res);
                // ctx should look like '[chunk01_ctx],[chunk02_ctx],[chunk03_ctx],...'
                ctx = ctx ? ctx + ',' + res.ctx : res.ctx;
                var leftSize = info.total - info.offset;
                var chunk_size = up.getOption && up.getOption('chunk_size');
                chunk_size = chunk_size || (up.settings && up.settings.chunk_size);
                if (leftSize < chunk_size) {
                    up.setOption({
                        'url': qiniuUploadUrl + '/mkblk/' + leftSize
                    });
                    logger.debug("up.setOption url: ", qiniuUploadUrl + '/mkblk/' + leftSize);
                }
                up.setOption({
                    'headers': {
                        'Authorization': 'UpToken ' + getUptoken(file)
                    }
                });
                localStorage.setItem(file.name, that.stringifyJSON({
                    ctx: ctx,
                    percent: file.percent,
                    total: info.total,
                    offset: info.offset,
                    time: (new Date()).getTime()
                }));
            });

            logger.debug("bind ChunkUploaded event");

            var retries = op.max_retries;

            // if error is unkown switch upload url and retry
            var unknow_error_retry = function (file) {
                if (retries-- > 0) {
                    setTimeout(function () {
                        that.resetUploadUrl(retries);
                        file.status = plupload.QUEUED;
                        uploader.stop();
                        uploader.start();
                    }, 0);
                    return true;
                } else {
                    retries = qiniuUploadUrls.length;
                    return false;
                }
            };

            // bind 'Error' event
            // check the err.code and return the errTip
            uploader.bind('Error', (function (_Error_Handler) {
                return function (up, err) {
                    logger.error("Error event activated");
                    logger.error("err: ", err);
                    var nowTime = new Date();
                    var errTip = '';
                    var file = err.file;
                    if (file) {
                        switch (err.code) {
                            case plupload.FAILED:
                                errTip = '上传失败。请稍后再试。';
                                break;
                            case plupload.FILE_SIZE_ERROR:
                                var max_file_size = up.getOption && up.getOption('max_file_size');
                                max_file_size = max_file_size || (up.settings && up.settings.max_file_size);
                                errTip = '浏览器最大可上传' + max_file_size + '。更大文件请使用命令行工具。';
                                break;
                            case plupload.FILE_EXTENSION_ERROR:
                                errTip = '文件验证失败。请稍后重试。';
                                break;
                            case plupload.HTTP_ERROR:
                                if (err.response === '') {
                                    // Fix parseJSON error ,when http error is like net::ERR_ADDRESS_UNREACHABLE
                                    errTip = err.message || '未知网络错误。';
                                    if (!unknow_error_retry(file)) {
                                        return;
                                    }
                                    break;
                                }
                                var errorObj = that.parseJSON(err.response);
                                var errorText = errorObj.error;
                                switch (err.status) {
                                    case 400:
                                        errTip = "请求报文格式错误。";
                                        break;
                                    case 401:
                                        errTip = "客户端认证授权失败。请重试或提交反馈。";
                                        break;
                                    case 405:
                                        errTip = "客户端请求错误。请重试或提交反馈。";
                                        break;
                                    case 579:
                                        errTip = "资源上传成功，但回调失败。";
                                        break;
                                    case 599:
                                        errTip = "网络连接异常。请重试或提交反馈。";
                                        if (!unknow_error_retry(file)) {
                                            return;
                                        }
                                        break;
                                    case 614:
                                        errTip = "文件已存在。";
                                        try {
                                            errorObj = that.parseJSON(errorObj.error);
                                            errorText = errorObj.error || 'file exists';
                                        } catch (e) {
                                            errorText = errorObj.error || 'file exists';
                                        }
                                        break;
                                    case 631:
                                        errTip = "指定空间不存在。";
                                        break;
                                    case 701:
                                        errTip = "上传数据块校验出错。请重试或提交反馈。";
                                        break;
                                    default:
                                        errTip = "未知错误。";
                                        if (!unknow_error_retry(file)) {
                                            return;
                                        }
                                        break;
                                }
                                errTip = errTip + '(' + err.status + '：' + errorText + ')';
                                break;
                            case plupload.SECURITY_ERROR:
                                errTip = '安全配置错误。请联系网站管理员。';
                                break;
                            case plupload.GENERIC_ERROR:
                                errTip = '上传失败。请稍后再试。';
                                break;
                            case plupload.IO_ERROR:
                                errTip = '上传失败。请稍后再试。';
                                break;
                            case plupload.INIT_ERROR:
                                errTip = '网站配置错误。请联系网站管理员。';
                                uploader.destroy();
                                break;
                            default:
                                errTip = err.message + err.details;
                                if (!unknow_error_retry(file)) {
                                    return;
                                }
                                break;
                        }
                        if (_Error_Handler) {
                            _Error_Handler(up, err, errTip);
                        }
                    }
                    up.refresh(); // Reposition Flash/Silverlight
                };
            })(_Error_Handler));

            logger.debug("bind Error event");

            // bind 'FileUploaded' event
            // intercept the complete of upload
            // - get downtoken from downtoken_url if bucket is private
            // - invoke mkfile api to compose chunks if upload strategy is chunk upload
            uploader.bind('FileUploaded', (function (_FileUploaded_Handler) {
                return function (up, file, info) {
                    logger.debug("FileUploaded event activated");
                    logger.debug("FileUploaded file: ", file);
                    logger.debug("FileUploaded info: ", info);
                    var nowTime = new Date();
                    var last_step = function (up, file, info) {
                        logger.debug("FileUploaded last step:", info);
                        if (op.downtoken_url) {
                            // if op.dowontoken_url is not empty
                            // need get downtoken before invoke the _FileUploaded_Handler
                            var ajax_downtoken = that.createAjax();
                            ajax_downtoken.open('POST', op.downtoken_url, true);
                            ajax_downtoken.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
                            ajax_downtoken.onreadystatechange = function () {
                                if (ajax_downtoken.readyState === 4) {
                                    if (ajax_downtoken.status === 200) {
                                        var res_downtoken;
                                        try {
                                            res_downtoken = that.parseJSON(ajax_downtoken.responseText);
                                        } catch (e) {
                                            throw ('invalid json format');
                                        }
                                        var info_extended = {};
                                        plupload.extend(info_extended, that.parseJSON(info.response), res_downtoken);
                                        info.response = that.stringifyJSON(info_extended);
                                        if (_FileUploaded_Handler) {
                                            _FileUploaded_Handler(up, file, info);
                                        }
                                    } else {
                                        uploader.trigger('Error', {
                                            status: ajax_downtoken.status,
                                            response: ajax_downtoken.responseText,
                                            file: file,
                                            code: plupload.HTTP_ERROR
                                        });
                                    }
                                }
                            };
                            ajax_downtoken.send('key=' + that.parseJSON(info.response).key + '&domain=' + op.domain);
                        } else if (_FileUploaded_Handler) {
                            _FileUploaded_Handler(up, file, info);
                        }
                    };

                    var res = that.parseJSON(info.response);
                    ctx = ctx ? ctx : res.ctx;
                    // if ctx is not empty
                    //      that means the upload strategy is chunk upload
                    //      before the invoke the last_step
                    //      we need request the mkfile to compose all uploaded chunks
                    // else
                    //      invoke the last_step
                    logger.debug("ctx: ", ctx);
                    if (ctx) {
                        var key = '';
                        logger.debug("save_key: ", op.save_key);
                        if (!op.save_key) {
                            key = getFileKey(up, file, that.key_handler);
                            key = key ? '/key/' + that.URLSafeBase64Encode(key) : '';
                        }

                        var fname = '/fname/' + that.URLSafeBase64Encode(file.name);

                        logger.debug("op.x_vars: ", op.x_vars);
                        var x_vars = op.x_vars,
                            x_val = '',
                            x_vars_url = '';
                        if (x_vars !== undefined && typeof x_vars === 'object') {
                            for (var x_key in x_vars) {
                                if (x_vars.hasOwnProperty(x_key)) {
                                    if (typeof x_vars[x_key] === 'function') {
                                        x_val = that.URLSafeBase64Encode(x_vars[x_key](up, file));
                                    } else if (typeof x_vars[x_key] !== 'object') {
                                        x_val = that.URLSafeBase64Encode(x_vars[x_key]);
                                    }
                                    x_vars_url += '/x:' + x_key + '/' + x_val;
                                }
                            }
                        }

                        var url = qiniuUploadUrl + '/mkfile/' + file.size + key + fname + x_vars_url;

                        var ie = that.detectIEVersion();
                        var ajax;
                        if (ie && ie <= 9) {
                            ajax = new moxie.xhr.XMLHttpRequest();
                            moxie.core.utils.Env.swf_url = op.flash_swf_url;
                        } else {
                            ajax = that.createAjax();
                        }
                        ajax.open('POST', url, true);
                        ajax.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
                        console.log('uptoken:'+that.token);
                        ajax.setRequestHeader('Authorization', 'UpToken ' + that.token);
                        var onreadystatechange = function () {
                            logger.debug("ajax.readyState: ", ajax.readyState);
                            if (ajax.readyState === 4) {
                                localStorage.removeItem(file.name);
                                var ajaxInfo;
                                if (ajax.status === 200) {
                                    ajaxInfo = {
                                        status: ajax.status,
                                        response: ajax.responseText,
                                        responseHeaders: ajax.getAllResponseHeaders(),
                                    };
                                    logger.debug("mkfile is success: ", ajaxInfo);
                                    last_step(up, file, ajaxInfo);
                                } else {
                                    ajaxInfo = {
                                        status: ajax.status,
                                        response: ajax.responseText,
                                        file: file,
                                        code: -200,
                                        responseHeaders: ajax.getAllResponseHeaders()
                                    };
                                    logger.debug("mkfile is error: ", ajaxInfo);
                                    uploader.trigger('Error', ajaxInfo);
                                }
                            }
                        };
                        if (ie && ie <= 9) {
                            ajax.bind('readystatechange', onreadystatechange);
                        } else {
                            ajax.onreadystatechange = onreadystatechange;
                        }
                        ajax.send(ctx);
                        logger.debug("mkfile: ", url);
                    } else {
                        last_step(up, file, info);
                    }
                };
            })(_FileUploaded_Handler));

            logger.debug("bind FileUploaded event");

            // init uploader
            uploader.init();
            logger.debug("invoke uploader.init()");

            logger.debug("init uploader end");

            return uploader;
        };

        /**
         * get url by key
         * @param  {String} key of file
         * @return {String} url of file
         */
        this.getUrl = function (key) {
            if (!key) {
                return false;
            }
            key = encodeURI(key);
            var domain = this.domain;
            if (domain.slice(domain.length - 1) !== '/') {
                domain = domain + '/';
            }
            return domain + key;
        };
    }

    var Qiniu = new QiniuJsSDK();

    global.Qiniu = Qiniu;
    global.QiniuJsSDK = QiniuJsSDK;
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = QiniuJsSDK;
    } else if (true) {
        // register as 'qiniu-js', consistent with npm package name
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return QiniuJsSDK;
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        global.QiniuJsSDK = QiniuJsSDK;
    }
})(window);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTkxNGQ3ZDE2MDZkZWFkODAzMDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdXBsb2FkL21veGllLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVwbG9hZC9wbHVwbG9hZC5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Fpbml1LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQSxpR0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNI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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSxrRkFBa0YsaUJBQWlCOztBQUVuRztBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEIsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQixTQUFTLFFBQVE7QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZCxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsU0FBUztBQUNuQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9EQUFvRDs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxNQUFNO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixnQ0FBZ0MsRUFBRTs7QUFFaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSwyREFBMkQ7QUFDM0QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBOztBQUVBLFNBQVMsT0FBTztBQUNoQixTQUFTLE9BQU87QUFDaEIsU0FBUyxPQUFPO0FBQ2hCLFNBQVMsT0FBTztBQUNoQixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsRztBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEIsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEIsU0FBUyxjQUFjO0FBQ3ZCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkIsU0FBUyxPQUFPO0FBQ2hCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFNBQVMsT0FBTztBQUNoQixTQUFTLGVBQWU7QUFDeEIsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUI7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxtRjtBQUNBOztBQUVBO0FBQ0EsTTtBQUNBOztBQUVBO0FBQ0Esb0U7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLG1EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7OztBQUdBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFNBQVMsT0FBTztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsNENBQTRDO0FBQy9DLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLHNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSwwQkFBMEI7QUFDMUIsR0FBRztBQUNILDZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLFdBQVc7O0FBRVgsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrQkFBa0I7QUFDaEM7O0FBRUE7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7O0FBRUEsZ0JBQWdCLGlCQUFpQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQyxVQUFVLGtCQUFrQjtBQUM1QixVQUFVLE1BQU07QUFDaEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLGtCQUFrQjtBQUM1QjtBQUNBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnREFBZ0Q7QUFDdEQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEIsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkIsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlDQUFpQztBQUNqQyxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxtQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7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Q0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUF1QjtBQUN2QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQzs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FB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O0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscUNBQXFDO0FBQ3JDOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHVCQUF1Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHLEc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsdUU7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLGlHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEcsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQztBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtDQUErQyxpQkFBaUI7QUFDaEUsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7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YUFBYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUFBO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InFpbml1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNTkxNGQ3ZDE2MDZkZWFkODAzMDAiLCI7dmFyIE1YSV9ERUJVRyA9IHRydWU7XG4vKipcbiAqIG1PeGllIC0gbXVsdGktcnVudGltZSBGaWxlIEFQSSAmIFhNTEh0dHBSZXF1ZXN0IEwyIFBvbHlmaWxsXG4gKiB2MS41LjNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKlxuICogRGF0ZTogMjAxNy0wMi0wMlxuICovXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dmFyIGV4dHJhY3QgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0ge307XG5cdFx0ZmFjdG9yeS5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGN0eC5tb3hpZTtcblx0fTtcblx0XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShcIm1veGllXCIsIFtdLCBleHRyYWN0KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHRyYWN0KCk7XG5cdH0gZWxzZSB7XG5cdFx0Z2xvYmFsLm1veGllID0gZXh0cmFjdCgpO1xuXHR9XG59KHRoaXMgfHwgd2luZG93LCBmdW5jdGlvbigpIHtcbi8qKlxuICogQ29tcGlsZWQgaW5saW5lIHZlcnNpb24uIChMaWJyYXJ5IG1vZGUpXG4gKi9cblxuLypqc2hpbnQgc21hcnR0YWJzOnRydWUsIHVuZGVmOnRydWUsIGxhdGVkZWY6dHJ1ZSwgY3VybHk6dHJ1ZSwgYml0d2lzZTp0cnVlLCBjYW1lbGNhc2U6dHJ1ZSAqL1xuLypnbG9iYWxzICRjb2RlICovXG5cbihmdW5jdGlvbihleHBvcnRzLCB1bmRlZmluZWQpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIG1vZHVsZXMgPSB7fTtcblxuXHRmdW5jdGlvbiByZXF1aXJlKGlkcywgY2FsbGJhY2spIHtcblx0XHR2YXIgbW9kdWxlLCBkZWZzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0bW9kdWxlID0gbW9kdWxlc1tpZHNbaV1dIHx8IHJlc29sdmUoaWRzW2ldKTtcblx0XHRcdGlmICghbW9kdWxlKSB7XG5cdFx0XHRcdHRocm93ICdtb2R1bGUgZGVmaW5pdGlvbiBkZXBlbmRlY3kgbm90IGZvdW5kOiAnICsgaWRzW2ldO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZzLnB1c2gobW9kdWxlKTtcblx0XHR9XG5cblx0XHRjYWxsYmFjay5hcHBseShudWxsLCBkZWZzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlZmluZShpZCwgZGVwZW5kZW5jaWVzLCBkZWZpbml0aW9uKSB7XG5cdFx0aWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93ICdpbnZhbGlkIG1vZHVsZSBkZWZpbml0aW9uLCBtb2R1bGUgaWQgbXVzdCBiZSBkZWZpbmVkIGFuZCBiZSBhIHN0cmluZyc7XG5cdFx0fVxuXG5cdFx0aWYgKGRlcGVuZGVuY2llcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyAnaW52YWxpZCBtb2R1bGUgZGVmaW5pdGlvbiwgZGVwZW5kZW5jaWVzIG11c3QgYmUgc3BlY2lmaWVkJztcblx0XHR9XG5cblx0XHRpZiAoZGVmaW5pdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyAnaW52YWxpZCBtb2R1bGUgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbiBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCc7XG5cdFx0fVxuXG5cdFx0cmVxdWlyZShkZXBlbmRlbmNpZXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0bW9kdWxlc1tpZF0gPSBkZWZpbml0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWZpbmVkKGlkKSB7XG5cdFx0cmV0dXJuICEhbW9kdWxlc1tpZF07XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlKGlkKSB7XG5cdFx0dmFyIHRhcmdldCA9IGV4cG9ydHM7XG5cdFx0dmFyIGZyYWdtZW50cyA9IGlkLnNwbGl0KC9bLlxcL10vKTtcblxuXHRcdGZvciAodmFyIGZpID0gMDsgZmkgPCBmcmFnbWVudHMubGVuZ3RoOyArK2ZpKSB7XG5cdFx0XHRpZiAoIXRhcmdldFtmcmFnbWVudHNbZmldXSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRhcmdldCA9IHRhcmdldFtmcmFnbWVudHNbZmldXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3NlKGlkcykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZXhwb3J0cztcblx0XHRcdHZhciBpZCA9IGlkc1tpXTtcblx0XHRcdHZhciBmcmFnbWVudHMgPSBpZC5zcGxpdCgvWy5cXC9dLyk7XG5cblx0XHRcdGZvciAodmFyIGZpID0gMDsgZmkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgKytmaSkge1xuXHRcdFx0XHRpZiAodGFyZ2V0W2ZyYWdtZW50c1tmaV1dID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0YXJnZXRbZnJhZ21lbnRzW2ZpXV0gPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldCA9IHRhcmdldFtmcmFnbWVudHNbZmldXTtcblx0XHRcdH1cblxuXHRcdFx0dGFyZ2V0W2ZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV1dID0gbW9kdWxlc1tpZF07XG5cdFx0fVxuXHR9XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvdXRpbHMvQmFzaWMuanNcblxuLyoqXG4gKiBCYXNpYy5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXG5AcHVibGljXG5Ac3RhdGljXG4qL1xuZGVmaW5lKCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJywgW10sIGZ1bmN0aW9uKCkge1xuXHQvKipcblx0R2V0cyB0aGUgdHJ1ZSB0eXBlIG9mIHRoZSBidWlsdC1pbiBvYmplY3QgKGJldHRlciB2ZXJzaW9uIG9mIHR5cGVvZikuXG5cdEBhdXRob3IgQW5ndXMgQ3JvbGwgKGh0dHA6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vKVxuXG5cdEBtZXRob2QgdHlwZU9mXG5cdEBmb3IgVXRpbHNcblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gbyBPYmplY3QgdG8gY2hlY2suXG5cdEByZXR1cm4ge1N0cmluZ30gT2JqZWN0IFtbQ2xhc3NdXVxuXHQqL1xuXHRmdW5jdGlvbiB0eXBlT2Yobykge1xuXHRcdHZhciB1bmRlZjtcblxuXHRcdGlmIChvID09PSB1bmRlZikge1xuXHRcdFx0cmV0dXJuICd1bmRlZmluZWQnO1xuXHRcdH0gZWxzZSBpZiAobyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuICdudWxsJztcblx0XHR9IGVsc2UgaWYgKG8ubm9kZVR5cGUpIHtcblx0XHRcdHJldHVybiAnbm9kZSc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIHNuaXBwZXQgYmVsb3cgaXMgYXdlc29tZSwgaG93ZXZlciBpdCBmYWlscyB0byBkZXRlY3QgbnVsbCwgdW5kZWZpbmVkIGFuZCBhcmd1bWVudHMgdHlwZXMgaW4gSUUgbHRlIDhcblx0XHRyZXR1cm4gKHt9KS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0LyoqXG5cdEV4dGVuZHMgdGhlIHNwZWNpZmllZCBvYmplY3Qgd2l0aCBhbm90aGVyIG9iamVjdChzKS5cblxuXHRAbWV0aG9kIGV4dGVuZFxuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGV4dGVuZC5cblx0QHBhcmFtIHtPYmplY3R9IFtvYmpdKiBNdWx0aXBsZSBvYmplY3RzIHRvIGV4dGVuZCB3aXRoLlxuXHRAcmV0dXJuIHtPYmplY3R9IFNhbWUgYXMgdGFyZ2V0LCB0aGUgZXh0ZW5kZWQgb2JqZWN0LlxuXHQqL1xuXHRmdW5jdGlvbiBleHRlbmQoKSB7XG5cdFx0cmV0dXJuIG1lcmdlKGZhbHNlLCBmYWxzZSwgYXJndW1lbnRzKTtcblx0fVxuXG5cblx0LyoqXG5cdEV4dGVuZHMgdGhlIHNwZWNpZmllZCBvYmplY3Qgd2l0aCBhbm90aGVyIG9iamVjdChzKSwgYnV0IG9ubHkgaWYgdGhlIHByb3BlcnR5IGV4aXN0cyBpbiB0aGUgdGFyZ2V0LlxuXG5cdEBtZXRob2QgZXh0ZW5kSWZcblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0byBleHRlbmQuXG5cdEBwYXJhbSB7T2JqZWN0fSBbb2JqXSogTXVsdGlwbGUgb2JqZWN0cyB0byBleHRlbmQgd2l0aC5cblx0QHJldHVybiB7T2JqZWN0fSBTYW1lIGFzIHRhcmdldCwgdGhlIGV4dGVuZGVkIG9iamVjdC5cblx0Ki9cblx0ZnVuY3Rpb24gZXh0ZW5kSWYoKSB7XG5cdFx0cmV0dXJuIG1lcmdlKHRydWUsIGZhbHNlLCBhcmd1bWVudHMpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBleHRlbmRJbW11dGFibGUoKSB7XG5cdFx0cmV0dXJuIG1lcmdlKGZhbHNlLCB0cnVlLCBhcmd1bWVudHMpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBleHRlbmRJbW11dGFibGVJZigpIHtcblx0XHRyZXR1cm4gbWVyZ2UodHJ1ZSwgdHJ1ZSwgYXJndW1lbnRzKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqKSB7XG5cdFx0c3dpdGNoICh0eXBlT2Yob2JqKSkge1xuXHRcdFx0Y2FzZSAnYXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcblxuXHRcdFx0Y2FzZSAnb2JqZWN0Jzpcblx0XHRcdFx0cmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cblx0ZnVuY3Rpb24gbWVyZ2Uoc3RyaWN0LCBpbW11dGFibGUsIGFyZ3MpIHtcblx0XHR2YXIgdW5kZWY7XG5cdFx0dmFyIHRhcmdldCA9IGFyZ3NbMF07XG5cblx0XHRlYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZywgaSkge1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdGVhY2goYXJnLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdFx0dmFyIGlzQ29tcGxleCA9IGluQXJyYXkodHlwZU9mKHZhbHVlKSwgWydhcnJheScsICdvYmplY3QnXSkgIT09IC0xO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZiB8fCBzdHJpY3QgJiYgdGFyZ2V0W2tleV0gPT09IHVuZGVmKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXNDb21wbGV4ICYmIGltbXV0YWJsZSkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBzaGFsbG93Q29weSh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGVPZih0YXJnZXRba2V5XSkgPT09IHR5cGVPZih2YWx1ZSkgJiYgaXNDb21wbGV4KSB7XG5cdFx0XHRcdFx0XHRtZXJnZShzdHJpY3QsIGltbXV0YWJsZSwgW3RhcmdldFtrZXldLCB2YWx1ZV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblxuXHQvKipcblx0QSB3YXkgdG8gaW5oZXJpdCBvbmUgYGNsYXNzYCBmcm9tIGFub3RoZXIgaW4gYSBjb25zaXNzdGVudCB3YXkgKG1vcmUgb3IgbGVzcylcblxuXHRAbWV0aG9kIGluaGVyaXRcblx0QHN0YXRpY1xuXHRAc2luY2UgPjEuNC4xXG5cdEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG5cdEBwYXJhbSB7RnVuY3Rpb259IHBhcmVudFxuXHRAcmV0dXJuIHtGdW5jdGlvbn0gUHJlcGFyZWQgY29uc3RydWN0b3Jcblx0Ki9cblx0ZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgcGFyZW50KSB7XG5cdFx0Ly8gY29weSBvdmVyIGFsbCBwYXJlbnQgcHJvcGVydGllc1xuXHRcdGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcblx0XHRcdGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudCwga2V5KSkge1xuXHRcdFx0XHRjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZ2l2ZSBjaGlsZCBgY2xhc3NgIGEgcGxhY2UgdG8gZGVmaW5lIGl0cyBvd24gbWV0aG9kc1xuXHRcdGZ1bmN0aW9uIGN0b3IoKSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG5cdFx0fVxuXHRcdGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcblx0XHRjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xuXG5cdFx0Ly8ga2VlcCBhIHdheSB0byByZWZlcmVuY2UgcGFyZW50IG1ldGhvZHNcblx0XHRjaGlsZC5fX3BhcmVudF9fID0gcGFyZW50LnByb3RvdHlwZTtcblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH1cblxuXG5cdC8qKlxuXHRFeGVjdXRlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbSBpbiBhcnJheS9vYmplY3QuIElmIHlvdSByZXR1cm4gZmFsc2UgaW4gdGhlXG5cdGNhbGxiYWNrIGl0IHdpbGwgYnJlYWsgdGhlIGxvb3AuXG5cblx0QG1ldGhvZCBlYWNoXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gaXRlcmF0ZS5cblx0QHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBpdGVtLlxuXHQqL1xuXHRmdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcblx0XHR2YXIgbGVuZ3RoLCBrZXksIGksIHVuZGVmO1xuXG5cdFx0aWYgKG9iaikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdH0gY2F0Y2goZXgpIHtcblx0XHRcdFx0bGVuZ3RoID0gdW5kZWY7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsZW5ndGggPT09IHVuZGVmIHx8IHR5cGVvZihsZW5ndGgpICE9PSAnbnVtYmVyJykge1xuXHRcdFx0XHQvLyBMb29wIG9iamVjdCBpdGVtc1xuXHRcdFx0XHRmb3IgKGtleSBpbiBvYmopIHtcblx0XHRcdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdGlmIChjYWxsYmFjayhvYmpba2V5XSwga2V5KSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTG9vcCBhcnJheSBpdGVtc1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoY2FsbGJhY2sob2JqW2ldLCBpKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0Q2hlY2tzIGlmIG9iamVjdCBpcyBlbXB0eS5cblxuXHRAbWV0aG9kIGlzRW1wdHlPYmpcblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gbyBPYmplY3QgdG8gY2hlY2suXG5cdEByZXR1cm4ge0Jvb2xlYW59XG5cdCovXG5cdGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG5cdFx0dmFyIHByb3A7XG5cblx0XHRpZiAoIW9iaiB8fCB0eXBlT2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZvciAocHJvcCBpbiBvYmopIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHRSZWNpZXZlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyAodXN1YWxseSBhc3luYykgdG8gY2FsbCBpbiBzZXF1ZW5jZSwgZWFjaCAgZnVuY3Rpb25cblx0cmVjZWl2ZXMgYSBjYWxsYmFjayBhcyBmaXJzdCBhcmd1bWVudCB0aGF0IGl0IHNob3VsZCBjYWxsLCB3aGVuIGl0IGNvbXBsZXRlcy4gRmluYWxseSxcblx0YWZ0ZXIgZXZlcnl0aGluZyBpcyBjb21wbGV0ZSwgbWFpbiBjYWxsYmFjayBpcyBjYWxsZWQuIFBhc3NpbmcgdHJ1dGh5IHZhbHVlIHRvIHRoZVxuXHRjYWxsYmFjayBhcyBhIGZpcnN0IGFyZ3VtZW50IHdpbGwgaW50ZXJydXB0IHRoZSBzZXF1ZW5jZSBhbmQgaW52b2tlIG1haW4gY2FsbGJhY2tcblx0aW1tZWRpYXRlbHkuXG5cblx0QG1ldGhvZCBpblNlcmllc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7QXJyYXl9IHF1ZXVlIEFycmF5IG9mIGZ1bmN0aW9ucyB0byBjYWxsIGluIHNlcXVlbmNlXG5cdEBwYXJhbSB7RnVuY3Rpb259IGNiIE1haW4gY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgaW4gdGhlIGVuZCwgb3IgaW4gY2FzZSBvZiBlcnJvclxuXHQqL1xuXHRmdW5jdGlvbiBpblNlcmllcyhxdWV1ZSwgY2IpIHtcblx0XHR2YXIgaSA9IDAsIGxlbmd0aCA9IHF1ZXVlLmxlbmd0aDtcblxuXHRcdGlmICh0eXBlT2YoY2IpICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjYiA9IGZ1bmN0aW9uKCkge307XG5cdFx0fVxuXG5cdFx0aWYgKCFxdWV1ZSB8fCAhcXVldWUubGVuZ3RoKSB7XG5cdFx0XHRjYigpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhbGxOZXh0KGkpIHtcblx0XHRcdGlmICh0eXBlT2YocXVldWVbaV0pID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHF1ZXVlW2ldKGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdFx0Lypqc2hpbnQgZXhwcjp0cnVlICovXG5cdFx0XHRcdFx0KytpIDwgbGVuZ3RoICYmICFlcnJvciA/IGNhbGxOZXh0KGkpIDogY2IoZXJyb3IpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y2FsbE5leHQoaSk7XG5cdH1cblxuXG5cdC8qKlxuXHRSZWNpZXZlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyAodXN1YWxseSBhc3luYykgdG8gY2FsbCBpbiBwYXJhbGxlbCwgZWFjaCAgZnVuY3Rpb25cblx0cmVjZWl2ZXMgYSBjYWxsYmFjayBhcyBmaXJzdCBhcmd1bWVudCB0aGF0IGl0IHNob3VsZCBjYWxsLCB3aGVuIGl0IGNvbXBsZXRlcy4gQWZ0ZXJcblx0ZXZlcnl0aGluZyBpcyBjb21wbGV0ZSwgbWFpbiBjYWxsYmFjayBpcyBjYWxsZWQuIFBhc3NpbmcgdHJ1dGh5IHZhbHVlIHRvIHRoZVxuXHRjYWxsYmFjayBhcyBhIGZpcnN0IGFyZ3VtZW50IHdpbGwgaW50ZXJydXB0IHRoZSBwcm9jZXNzIGFuZCBpbnZva2UgbWFpbiBjYWxsYmFja1xuXHRpbW1lZGlhdGVseS5cblxuXHRAbWV0aG9kIGluUGFyYWxsZWxcblx0QHN0YXRpY1xuXHRAcGFyYW0ge0FycmF5fSBxdWV1ZSBBcnJheSBvZiBmdW5jdGlvbnMgdG8gY2FsbCBpbiBzZXF1ZW5jZVxuXHRAcGFyYW0ge0Z1bmN0aW9ufSBjYiBNYWluIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIGluIHRoZSBlbmQsIG9yIGluIGNhc2Ugb2YgZXJyb1xuXHQqL1xuXHRmdW5jdGlvbiBpblBhcmFsbGVsKHF1ZXVlLCBjYikge1xuXHRcdHZhciBjb3VudCA9IDAsIG51bSA9IHF1ZXVlLmxlbmd0aCwgY2JBcmdzID0gbmV3IEFycmF5KG51bSk7XG5cblx0XHRlYWNoKHF1ZXVlLCBmdW5jdGlvbihmbiwgaSkge1xuXHRcdFx0Zm4oZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNiKGVycm9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHRhcmdzLnNoaWZ0KCk7IC8vIHN0cmlwIGVycm9yIC0gdW5kZWZpbmVkIG9yIG5vdFxuXG5cdFx0XHRcdGNiQXJnc1tpXSA9IGFyZ3M7XG5cdFx0XHRcdGNvdW50Kys7XG5cblx0XHRcdFx0aWYgKGNvdW50ID09PSBudW0pIHtcblx0XHRcdFx0XHRjYkFyZ3MudW5zaGlmdChudWxsKTtcblx0XHRcdFx0XHRjYi5hcHBseSh0aGlzLCBjYkFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cblx0LyoqXG5cdEZpbmQgYW4gZWxlbWVudCBpbiBhcnJheSBhbmQgcmV0dXJuIGl0J3MgaW5kZXggaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHJldHVybiAtMS5cblxuXHRAbWV0aG9kIGluQXJyYXlcblx0QHN0YXRpY1xuXHRAcGFyYW0ge01peGVkfSBuZWVkbGUgRWxlbWVudCB0byBmaW5kXG5cdEBwYXJhbSB7QXJyYXl9IGFycmF5XG5cdEByZXR1cm4ge0ludH0gSW5kZXggb2YgdGhlIGVsZW1lbnQsIG9yIC0xIGlmIG5vdCBmb3VuZFxuXHQqL1xuXHRmdW5jdGlvbiBpbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcblx0XHRpZiAoYXJyYXkpIHtcblx0XHRcdGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuXHRcdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgbmVlZGxlKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnJheVtpXSA9PT0gbmVlZGxlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblxuXHQvKipcblx0UmV0dXJucyBlbGVtZW50cyBvZiBmaXJzdCBhcnJheSBpZiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBzZWNvbmQuIEFuZCBmYWxzZSAtIG90aGVyd2lzZS5cblxuXHRAcHJpdmF0ZVxuXHRAbWV0aG9kIGFycmF5RGlmZlxuXHRAcGFyYW0ge0FycmF5fSBuZWVkbGVzXG5cdEBwYXJhbSB7QXJyYXl9IGFycmF5XG5cdEByZXR1cm4ge0FycmF5fEJvb2xlYW59XG5cdCovXG5cdGZ1bmN0aW9uIGFycmF5RGlmZihuZWVkbGVzLCBhcnJheSkge1xuXHRcdHZhciBkaWZmID0gW107XG5cblx0XHRpZiAodHlwZU9mKG5lZWRsZXMpICE9PSAnYXJyYXknKSB7XG5cdFx0XHRuZWVkbGVzID0gW25lZWRsZXNdO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlT2YoYXJyYXkpICE9PSAnYXJyYXknKSB7XG5cdFx0XHRhcnJheSA9IFthcnJheV07XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSBpbiBuZWVkbGVzKSB7XG5cdFx0XHRpZiAoaW5BcnJheShuZWVkbGVzW2ldLCBhcnJheSkgPT09IC0xKSB7XG5cdFx0XHRcdGRpZmYucHVzaChuZWVkbGVzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGRpZmYubGVuZ3RoID8gZGlmZiA6IGZhbHNlO1xuXHR9XG5cblxuXHQvKipcblx0RmluZCBpbnRlcnNlY3Rpb24gb2YgdHdvIGFycmF5cy5cblxuXHRAcHJpdmF0ZVxuXHRAbWV0aG9kIGFycmF5SW50ZXJzZWN0XG5cdEBwYXJhbSB7QXJyYXl9IGFycmF5MVxuXHRAcGFyYW0ge0FycmF5fSBhcnJheTJcblx0QHJldHVybiB7QXJyYXl9IEludGVyc2VjdGlvbiBvZiB0d28gYXJyYXlzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZVxuXHQqL1xuXHRmdW5jdGlvbiBhcnJheUludGVyc2VjdChhcnJheTEsIGFycmF5Mikge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRlYWNoKGFycmF5MSwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGluQXJyYXkoaXRlbSwgYXJyYXkyKSAhPT0gLTEpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuXHR9XG5cblxuXHQvKipcblx0Rm9yY2VzIGFueXRoaW5nIGludG8gYW4gYXJyYXkuXG5cblx0QG1ldGhvZCB0b0FycmF5XG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3Qgd2l0aCBsZW5ndGggZmllbGQuXG5cdEByZXR1cm4ge0FycmF5fSBBcnJheSBvYmplY3QgY29udGFpbmluZyBhbGwgaXRlbXMuXG5cdCovXG5cdGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG5cdFx0dmFyIGksIGFyciA9IFtdO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXJyW2ldID0gb2JqW2ldO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXG5cdC8qKlxuXHRHZW5lcmF0ZXMgYW4gdW5pcXVlIElELiBUaGUgb25seSB3YXkgYSB1c2VyIHdvdWxkIGJlIGFibGUgdG8gZ2V0IHRoZSBzYW1lIElEIGlzIGlmIHRoZSB0d28gcGVyc29uc1xuXHRhdCB0aGUgc2FtZSBleGFjdCBtaWxsaXNlY29uZCBtYW5hZ2UgdG8gZ2V0IHRoZSBzYW1lIDUgcmFuZG9tIG51bWJlcnMgYmV0d2VlbiAwLTY1NTM1OyBpdCBhbHNvIHVzZXNcblx0YSBjb3VudGVyIHNvIGVhY2ggSUQgaXMgZ3VhcmFudGVlZCB0byBiZSB1bmlxdWUgZm9yIHRoZSBnaXZlbiBwYWdlLiBJdCBpcyBtb3JlIHByb2JhYmxlIGZvciB0aGUgZWFydGhcblx0dG8gYmUgaGl0IHdpdGggYW4gYXN0ZXJvaWQuXG5cblx0QG1ldGhvZCBndWlkXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHByZWZpeCB0byBwcmVwZW5kIChieSBkZWZhdWx0ICdvJyB3aWxsIGJlIHByZXBlbmRlZCkuXG5cdEBtZXRob2QgZ3VpZFxuXHRAcmV0dXJuIHtTdHJpbmd9IFZpcnR1YWxseSB1bmlxdWUgaWQuXG5cdCovXG5cdHZhciBndWlkID0gKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudGVyID0gMDtcblxuXHRcdHJldHVybiBmdW5jdGlvbihwcmVmaXgpIHtcblx0XHRcdHZhciBndWlkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoMzIpLCBpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG5cdFx0XHRcdGd1aWQgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjU1MzUpLnRvU3RyaW5nKDMyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIChwcmVmaXggfHwgJ29fJykgKyBndWlkICsgKGNvdW50ZXIrKykudG9TdHJpbmcoMzIpO1xuXHRcdH07XG5cdH0oKSk7XG5cblxuXHQvKipcblx0VHJpbXMgd2hpdGUgc3BhY2VzIGFyb3VuZCB0aGUgc3RyaW5nXG5cblx0QG1ldGhvZCB0cmltXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHN0clxuXHRAcmV0dXJuIHtTdHJpbmd9XG5cdCovXG5cdGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG5cdFx0aWYgKCFzdHIpIHtcblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fVxuXHRcdHJldHVybiBTdHJpbmcucHJvdG90eXBlLnRyaW0gPyBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpIDogc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG5cdH1cblxuXG5cdC8qKlxuXHRQYXJzZXMgdGhlIHNwZWNpZmllZCBzaXplIHN0cmluZyBpbnRvIGEgYnl0ZSB2YWx1ZS4gRm9yIGV4YW1wbGUgMTBrYiBiZWNvbWVzIDEwMjQwLlxuXG5cdEBtZXRob2QgcGFyc2VTaXplU3RyXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmcvTnVtYmVyfSBzaXplIFN0cmluZyB0byBwYXJzZSBvciBudW1iZXIgdG8ganVzdCBwYXNzIHRocm91Z2guXG5cdEByZXR1cm4ge051bWJlcn0gU2l6ZSBpbiBieXRlcy5cblx0Ki9cblx0ZnVuY3Rpb24gcGFyc2VTaXplU3RyKHNpemUpIHtcblx0XHRpZiAodHlwZW9mKHNpemUpICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHNpemU7XG5cdFx0fVxuXG5cdFx0dmFyIG11bHMgPSB7XG5cdFx0XHRcdHQ6IDEwOTk1MTE2Mjc3NzYsXG5cdFx0XHRcdGc6IDEwNzM3NDE4MjQsXG5cdFx0XHRcdG06IDEwNDg1NzYsXG5cdFx0XHRcdGs6IDEwMjRcblx0XHRcdH0sXG5cdFx0XHRtdWw7XG5cblx0XHRzaXplID0gL14oWzAtOVxcLl0rKShbdG1na10/KSQvLmV4ZWMoc2l6ZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teMC05XFwudG1rZ10vZywgJycpKTtcblx0XHRtdWwgPSBzaXplWzJdO1xuXHRcdHNpemUgPSArc2l6ZVsxXTtcblxuXHRcdGlmIChtdWxzLmhhc093blByb3BlcnR5KG11bCkpIHtcblx0XHRcdHNpemUgKj0gbXVsc1ttdWxdO1xuXHRcdH1cblx0XHRyZXR1cm4gTWF0aC5mbG9vcihzaXplKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFBzZXVkbyBzcHJpbnRmIGltcGxlbWVudGF0aW9uIC0gc2ltcGxlIHdheSB0byByZXBsYWNlIHRva2VucyB3aXRoIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHdpdGggdG9rZW5zXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHdpdGggcmVwbGFjZWQgdG9rZW5zXG5cdCAqL1xuXHRmdW5jdGlvbiBzcHJpbnRmKHN0cikge1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8lW2Etel0vZywgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBhcmdzLnNoaWZ0KCk7XG5cdFx0XHRyZXR1cm4gdHlwZU9mKHZhbHVlKSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICcnO1xuXHRcdH0pO1xuXHR9XG5cblxuXG5cdGZ1bmN0aW9uIGRlbGF5KGNiLCB0aW1lb3V0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRjYi5jYWxsKHNlbGYpO1xuXHRcdH0sIHRpbWVvdXQgfHwgMSk7XG5cdH1cblxuXG5cdHJldHVybiB7XG5cdFx0Z3VpZDogZ3VpZCxcblx0XHR0eXBlT2Y6IHR5cGVPZixcblx0XHRleHRlbmQ6IGV4dGVuZCxcblx0XHRleHRlbmRJZjogZXh0ZW5kSWYsXG5cdFx0ZXh0ZW5kSW1tdXRhYmxlOiBleHRlbmRJbW11dGFibGUsXG5cdFx0ZXh0ZW5kSW1tdXRhYmxlSWY6IGV4dGVuZEltbXV0YWJsZUlmLFxuXHRcdGluaGVyaXQ6IGluaGVyaXQsXG5cdFx0ZWFjaDogZWFjaCxcblx0XHRpc0VtcHR5T2JqOiBpc0VtcHR5T2JqLFxuXHRcdGluU2VyaWVzOiBpblNlcmllcyxcblx0XHRpblBhcmFsbGVsOiBpblBhcmFsbGVsLFxuXHRcdGluQXJyYXk6IGluQXJyYXksXG5cdFx0YXJyYXlEaWZmOiBhcnJheURpZmYsXG5cdFx0YXJyYXlJbnRlcnNlY3Q6IGFycmF5SW50ZXJzZWN0LFxuXHRcdHRvQXJyYXk6IHRvQXJyYXksXG5cdFx0dHJpbTogdHJpbSxcblx0XHRzcHJpbnRmOiBzcHJpbnRmLFxuXHRcdHBhcnNlU2l6ZVN0cjogcGFyc2VTaXplU3RyLFxuXHRcdGRlbGF5OiBkZWxheVxuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvdXRpbHMvRW5jb2RlLmpzXG5cbi8qKlxuICogRW5jb2RlLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvY29yZS91dGlscy9FbmNvZGUnLCBbXSwgZnVuY3Rpb24oKSB7XG5cblx0LyoqXG5cdEBjbGFzcyBtb3hpZS9jb3JlL3V0aWxzL0VuY29kZVxuXHQqL1xuXG5cdC8qKlxuXHRFbmNvZGUgc3RyaW5nIHdpdGggVVRGLThcblxuXHRAbWV0aG9kIHV0ZjhfZW5jb2RlXG5cdEBmb3IgVXRpbHNcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBlbmNvZGVcblx0QHJldHVybiB7U3RyaW5nfSBVVEYtOCBlbmNvZGVkIHN0cmluZ1xuXHQqL1xuXHR2YXIgdXRmOF9lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuXHR9O1xuXHRcblx0LyoqXG5cdERlY29kZSBVVEYtOCBlbmNvZGVkIHN0cmluZ1xuXG5cdEBtZXRob2QgdXRmOF9kZWNvZGVcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcblx0QHJldHVybiB7U3RyaW5nfSBEZWNvZGVkIHN0cmluZ1xuXHQqL1xuXHR2YXIgdXRmOF9kZWNvZGUgPSBmdW5jdGlvbihzdHJfZGF0YSkge1xuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cl9kYXRhKSk7XG5cdH07XG5cdFxuXHQvKipcblx0RGVjb2RlIEJhc2U2NCBlbmNvZGVkIHN0cmluZyAodXNlcyBicm93c2VyJ3MgZGVmYXVsdCBtZXRob2QgaWYgYXZhaWxhYmxlKSxcblx0ZnJvbTogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9rdnovcGhwanMvbWFzdGVyL2Z1bmN0aW9ucy91cmwvYmFzZTY0X2RlY29kZS5qc1xuXG5cdEBtZXRob2QgYXRvYlxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSBkYXRhIFN0cmluZyB0byBkZWNvZGVcblx0QHJldHVybiB7U3RyaW5nfSBEZWNvZGVkIHN0cmluZ1xuXHQqL1xuXHR2YXIgYXRvYiA9IGZ1bmN0aW9uKGRhdGEsIHV0ZjgpIHtcblx0XHRpZiAodHlwZW9mKHdpbmRvdy5hdG9iKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIHV0ZjggPyB1dGY4X2RlY29kZSh3aW5kb3cuYXRvYihkYXRhKSkgOiB3aW5kb3cuYXRvYihkYXRhKTtcblx0XHR9XG5cblx0XHQvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuXHRcdC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuXHRcdC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG5cdFx0Ly8gKyAgICAgIGlucHV0IGJ5OiBBbWFuIEd1cHRhXG5cdFx0Ly8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcblx0XHQvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuXHRcdC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuXHRcdC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG5cdFx0Ly8gKyAgICAgIGlucHV0IGJ5OiBCcmV0dCBaYW1pciAoaHR0cDovL2JyZXR0LXphbWlyLm1lKVxuXHRcdC8vICsgICBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG5cdFx0Ly8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZGVjb2RlKCdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09Jyk7XG5cdFx0Ly8gKiAgICAgcmV0dXJucyAxOiAnS2V2aW4gdmFuIFpvbm5ldmVsZCdcblx0XHQvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuXHRcdC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcblx0XHQvL2lmICh0eXBlb2YgdGhpcy53aW5kb3cuYXRvYiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG5cdFx0Ly99XG5cdFx0dmFyIGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcblx0XHR2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuXHRcdFx0YWMgPSAwLFxuXHRcdFx0ZGVjID0gXCJcIixcblx0XHRcdHRtcF9hcnIgPSBbXTtcblxuXHRcdGlmICghZGF0YSkge1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZGF0YSArPSAnJztcblxuXHRcdGRvIHsgLy8gdW5wYWNrIGZvdXIgaGV4ZXRzIGludG8gdGhyZWUgb2N0ZXRzIHVzaW5nIGluZGV4IHBvaW50cyBpbiBiNjRcblx0XHRcdGgxID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cdFx0XHRoMiA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXHRcdFx0aDMgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcblx0XHRcdGg0ID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cblx0XHRcdGJpdHMgPSBoMSA8PCAxOCB8IGgyIDw8IDEyIHwgaDMgPDwgNiB8IGg0O1xuXG5cdFx0XHRvMSA9IGJpdHMgPj4gMTYgJiAweGZmO1xuXHRcdFx0bzIgPSBiaXRzID4+IDggJiAweGZmO1xuXHRcdFx0bzMgPSBiaXRzICYgMHhmZjtcblxuXHRcdFx0aWYgKGgzID09IDY0KSB7XG5cdFx0XHRcdHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xKTtcblx0XHRcdH0gZWxzZSBpZiAoaDQgPT0gNjQpIHtcblx0XHRcdFx0dG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMiwgbzMpO1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cblx0XHRkZWMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG5cdFx0cmV0dXJuIHV0ZjggPyB1dGY4X2RlY29kZShkZWMpIDogZGVjO1xuXHR9O1xuXHRcblx0LyoqXG5cdEJhc2U2NCBlbmNvZGUgc3RyaW5nICh1c2VzIGJyb3dzZXIncyBkZWZhdWx0IG1ldGhvZCBpZiBhdmFpbGFibGUpLFxuXHRmcm9tOiBodHRwczovL3Jhdy5naXRodWIuY29tL2t2ei9waHBqcy9tYXN0ZXIvZnVuY3Rpb25zL3VybC9iYXNlNjRfZW5jb2RlLmpzXG5cblx0QG1ldGhvZCBidG9hXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IGRhdGEgU3RyaW5nIHRvIGVuY29kZVxuXHRAcmV0dXJuIHtTdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuXHQqL1xuXHR2YXIgYnRvYSA9IGZ1bmN0aW9uKGRhdGEsIHV0ZjgpIHtcblx0XHRpZiAodXRmOCkge1xuXHRcdFx0ZGF0YSA9IHV0ZjhfZW5jb2RlKGRhdGEpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Yod2luZG93LmJ0b2EpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93LmJ0b2EoZGF0YSk7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcblx0XHQvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcblx0XHQvLyArICAgaW1wcm92ZWQgYnk6IEJheXJvbiBHdWV2YXJhXG5cdFx0Ly8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cblx0XHQvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuXHRcdC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuXHRcdC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG5cdFx0Ly8gKyAgIGltcHJvdmVkIGJ5OiBSYWZhxYIgS3VrYXdza2kgKGh0dHA6Ly9rdWthd3NraS5wbClcblx0XHQvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcblx0XHQvLyAqICAgICByZXR1cm5zIDE6ICdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09J1xuXHRcdC8vIG1vemlsbGEgaGFzIHRoaXMgbmF0aXZlXG5cdFx0Ly8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuXHRcdHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cdFx0dmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcblx0XHRcdGFjID0gMCxcblx0XHRcdGVuYyA9IFwiXCIsXG5cdFx0XHR0bXBfYXJyID0gW107XG5cblx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuXHRcdFx0bzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblx0XHRcdG8yID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cdFx0XHRvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG5cdFx0XHRiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cblx0XHRcdGgxID0gYml0cyA+PiAxOCAmIDB4M2Y7XG5cdFx0XHRoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuXHRcdFx0aDMgPSBiaXRzID4+IDYgJiAweDNmO1xuXHRcdFx0aDQgPSBiaXRzICYgMHgzZjtcblxuXHRcdFx0Ly8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcblx0XHRcdHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcblx0XHR9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG5cdFx0ZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuXHRcdHZhciByID0gZGF0YS5sZW5ndGggJSAzO1xuXG5cdFx0cmV0dXJuIChyID8gZW5jLnNsaWNlKDAsIHIgLSAzKSA6IGVuYykgKyAnPT09Jy5zbGljZShyIHx8IDMpO1xuXHR9O1xuXG5cblx0cmV0dXJuIHtcblx0XHR1dGY4X2VuY29kZTogdXRmOF9lbmNvZGUsXG5cdFx0dXRmOF9kZWNvZGU6IHV0ZjhfZGVjb2RlLFxuXHRcdGF0b2I6IGF0b2IsXG5cdFx0YnRvYTogYnRvYVxuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvdXRpbHMvRW52LmpzXG5cbi8qKlxuICogRW52LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZShcIm1veGllL2NvcmUvdXRpbHMvRW52XCIsIFtcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCJcbl0sIGZ1bmN0aW9uKEJhc2ljKSB7XG5cdFxuXHQvKipcblx0ICogVUFQYXJzZXIuanMgdjAuNy43XG5cdCAqIExpZ2h0d2VpZ2h0IEphdmFTY3JpcHQtYmFzZWQgVXNlci1BZ2VudCBzdHJpbmcgcGFyc2VyXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWlzYWxtYW4vdWEtcGFyc2VyLWpzXG5cdCAqXG5cdCAqIENvcHlyaWdodCDCqSAyMDEyLTIwMTUgRmFpc2FsIFNhbG1hbiA8Znl6bG1hbkBnbWFpbC5jb20+XG5cdCAqIER1YWwgbGljZW5zZWQgdW5kZXIgR1BMdjIgJiBNSVRcblx0ICovXG5cdHZhciBVQVBhcnNlciA9IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cblx0ICAgIC8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBDb25zdGFudHNcblx0ICAgIC8vLy8vLy8vLy8vLy9cblxuXG5cdCAgICB2YXIgRU1QVFkgICAgICAgPSAnJyxcblx0ICAgICAgICBVTktOT1dOICAgICA9ICc/Jyxcblx0ICAgICAgICBGVU5DX1RZUEUgICA9ICdmdW5jdGlvbicsXG5cdCAgICAgICAgVU5ERUZfVFlQRSAgPSAndW5kZWZpbmVkJyxcblx0ICAgICAgICBPQkpfVFlQRSAgICA9ICdvYmplY3QnLFxuXHQgICAgICAgIE1BSk9SICAgICAgID0gJ21ham9yJyxcblx0ICAgICAgICBNT0RFTCAgICAgICA9ICdtb2RlbCcsXG5cdCAgICAgICAgTkFNRSAgICAgICAgPSAnbmFtZScsXG5cdCAgICAgICAgVFlQRSAgICAgICAgPSAndHlwZScsXG5cdCAgICAgICAgVkVORE9SICAgICAgPSAndmVuZG9yJyxcblx0ICAgICAgICBWRVJTSU9OICAgICA9ICd2ZXJzaW9uJyxcblx0ICAgICAgICBBUkNISVRFQ1RVUkU9ICdhcmNoaXRlY3R1cmUnLFxuXHQgICAgICAgIENPTlNPTEUgICAgID0gJ2NvbnNvbGUnLFxuXHQgICAgICAgIE1PQklMRSAgICAgID0gJ21vYmlsZScsXG5cdCAgICAgICAgVEFCTEVUICAgICAgPSAndGFibGV0JztcblxuXG5cdCAgICAvLy8vLy8vLy8vL1xuXHQgICAgLy8gSGVscGVyXG5cdCAgICAvLy8vLy8vLy8vXG5cblxuXHQgICAgdmFyIHV0aWwgPSB7XG5cdCAgICAgICAgaGFzIDogZnVuY3Rpb24gKHN0cjEsIHN0cjIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHN0cjIudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cjEudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbG93ZXJpemUgOiBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cblx0ICAgIC8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gTWFwIGhlbHBlclxuXHQgICAgLy8vLy8vLy8vLy8vLy9cblxuXG5cdCAgICB2YXIgbWFwcGVyID0ge1xuXG5cdCAgICAgICAgcmd4IDogZnVuY3Rpb24gKCkge1xuXG5cdCAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgcmVnZXhlcyBtYXBzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJlc3VsdCwgaSA9IDAsIGosIGssIHAsIHEsIG1hdGNoZXMsIG1hdGNoLCBhcmdzID0gYXJndW1lbnRzOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBhcmdzW2ldLCAgICAgICAvLyBldmVuIHNlcXVlbmNlICgwLDIsNCwuLilcblx0ICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGFyZ3NbaSArIDFdOyAgIC8vIG9kZCBzZXF1ZW5jZSAoMSwzLDUsLi4pXG5cblx0ICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdCBvYmplY3QgYmFyZWJvbmVzXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHJlc3VsdCkgPT09IFVOREVGX1RZUEUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHAgaW4gcHJvcHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHEpID09PSBPQkpfVFlQRSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FdID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyB0cnkgbWF0Y2hpbmcgdWFzdHJpbmcgd2l0aCByZWdleGVzXG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSBrID0gMDsgaiA8IHJlZ2V4Lmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHJlZ2V4W2pdLmV4ZWModGhpcy5nZXRVQSgpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISFtYXRjaGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWysra107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHJvcHNbcF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBnaXZlbiBwcm9wZXJ0eSBpcyBhY3R1YWxseSBhcnJheVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihxKSA9PT0gT0JKX1RZUEUgJiYgcS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID09IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihxWzFdKSA9PSBGVU5DX1RZUEUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBtb2RpZmllZCBtYXRjaFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBnaXZlbiB2YWx1ZSwgaWdub3JlIHJlZ2V4IG1hdGNoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcVswXV0gPSBxWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSAzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgZnVuY3Rpb24gb3IgcmVnZXhcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihxWzFdKSA9PT0gRlVOQ19UWVBFICYmICEocVsxXS5leGVjICYmIHFbMV0udGVzdCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgZnVuY3Rpb24gKHVzdWFsbHkgc3RyaW5nIG1hcHBlcilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxWzBdXSA9IG1hdGNoID8gcVsxXS5jYWxsKHRoaXMsIG1hdGNoLCBxWzJdKSA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbml0aXplIG1hdGNoIHVzaW5nIGdpdmVuIHJlZ2V4XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcVswXV0gPSBtYXRjaCA/IG1hdGNoLnJlcGxhY2UocVsxXSwgcVsyXSkgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHEubGVuZ3RoID09IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxWzBdXSA9IG1hdGNoID8gcVszXS5jYWxsKHRoaXMsIG1hdGNoLnJlcGxhY2UocVsxXSwgcVsyXSkpIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FdID0gbWF0Y2ggPyBtYXRjaCA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmKCEhbWF0Y2hlcykgYnJlYWs7IC8vIGJyZWFrIHRoZSBsb29wIGltbWVkaWF0ZWx5IGlmIG1hdGNoIGZvdW5kXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc3RyIDogZnVuY3Rpb24gKHN0ciwgbWFwKSB7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXApIHtcblx0ICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFycmF5XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mKG1hcFtpXSkgPT09IE9CSl9UWVBFICYmIG1hcFtpXS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXBbaV0ubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaGFzKG1hcFtpXVtqXSwgc3RyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaGFzKG1hcFtpXSwgc3RyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQgOiBpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBzdHI7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAvLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFN0cmluZyBtYXBcblx0ICAgIC8vLy8vLy8vLy8vLy8vXG5cblxuXHQgICAgdmFyIG1hcHMgPSB7XG5cblx0ICAgICAgICBicm93c2VyIDoge1xuXHQgICAgICAgICAgICBvbGRzYWZhcmkgOiB7XG5cdCAgICAgICAgICAgICAgICBtYWpvciA6IHtcblx0ICAgICAgICAgICAgICAgICAgICAnMScgOiBbJy84JywgJy8xJywgJy8zJ10sXG5cdCAgICAgICAgICAgICAgICAgICAgJzInIDogJy80Jyxcblx0ICAgICAgICAgICAgICAgICAgICAnPycgOiAnLydcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB2ZXJzaW9uIDoge1xuXHQgICAgICAgICAgICAgICAgICAgICcxLjAnICAgOiAnLzgnLFxuXHQgICAgICAgICAgICAgICAgICAgICcxLjInICAgOiAnLzEnLFxuXHQgICAgICAgICAgICAgICAgICAgICcxLjMnICAgOiAnLzMnLFxuXHQgICAgICAgICAgICAgICAgICAgICcyLjAnICAgOiAnLzQxMicsXG5cdCAgICAgICAgICAgICAgICAgICAgJzIuMC4yJyA6ICcvNDE2Jyxcblx0ICAgICAgICAgICAgICAgICAgICAnMi4wLjMnIDogJy80MTcnLFxuXHQgICAgICAgICAgICAgICAgICAgICcyLjAuNCcgOiAnLzQxOScsXG5cdCAgICAgICAgICAgICAgICAgICAgJz8nICAgICA6ICcvJ1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRldmljZSA6IHtcblx0ICAgICAgICAgICAgc3ByaW50IDoge1xuXHQgICAgICAgICAgICAgICAgbW9kZWwgOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgJ0V2byBTaGlmdCA0RycgOiAnNzM3M0tUJ1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHZlbmRvciA6IHtcblx0ICAgICAgICAgICAgICAgICAgICAnSFRDJyAgICAgICA6ICdBUEEnLFxuXHQgICAgICAgICAgICAgICAgICAgICdTcHJpbnQnICAgIDogJ1NwcmludCdcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBvcyA6IHtcblx0ICAgICAgICAgICAgd2luZG93cyA6IHtcblx0ICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgJ01FJyAgICAgICAgOiAnNC45MCcsXG5cdCAgICAgICAgICAgICAgICAgICAgJ05UIDMuMTEnICAgOiAnTlQzLjUxJyxcblx0ICAgICAgICAgICAgICAgICAgICAnTlQgNC4wJyAgICA6ICdOVDQuMCcsXG5cdCAgICAgICAgICAgICAgICAgICAgJzIwMDAnICAgICAgOiAnTlQgNS4wJyxcblx0ICAgICAgICAgICAgICAgICAgICAnWFAnICAgICAgICA6IFsnTlQgNS4xJywgJ05UIDUuMiddLFxuXHQgICAgICAgICAgICAgICAgICAgICdWaXN0YScgICAgIDogJ05UIDYuMCcsXG5cdCAgICAgICAgICAgICAgICAgICAgJzcnICAgICAgICAgOiAnTlQgNi4xJyxcblx0ICAgICAgICAgICAgICAgICAgICAnOCcgICAgICAgICA6ICdOVCA2LjInLFxuXHQgICAgICAgICAgICAgICAgICAgICc4LjEnICAgICAgIDogJ05UIDYuMycsXG5cdCAgICAgICAgICAgICAgICAgICAgJ1JUJyAgICAgICAgOiAnQVJNJ1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAvLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gUmVnZXggbWFwXG5cdCAgICAvLy8vLy8vLy8vLy8vXG5cblxuXHQgICAgdmFyIHJlZ2V4ZXMgPSB7XG5cblx0ICAgICAgICBicm93c2VyIDogW1tcblx0ICAgICAgICBcblx0ICAgICAgICAgICAgLy8gUHJlc3RvIGJhc2VkXG5cdCAgICAgICAgICAgIC8ob3BlcmFcXHNtaW5pKVxcLyhbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1pbmlcblx0ICAgICAgICAgICAgLyhvcGVyYVxcc1ttb2JpbGV0YWJdKykuK3ZlcnNpb25cXC8oW1xcd1xcLi1dKykvaSwgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgTW9iaS9UYWJsZXRcblx0ICAgICAgICAgICAgLyhvcGVyYSkuK3ZlcnNpb25cXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSA+IDkuODBcblx0ICAgICAgICAgICAgLyhvcGVyYSlbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgPCA5LjgwXG5cblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgL1xccyhvcHIpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgV2Via2l0XG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ09wZXJhJ10sIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLy8gTWl4ZWRcblx0ICAgICAgICAgICAgLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGVcblx0ICAgICAgICAgICAgLyhsdW5hc2NhcGV8bWF4dGhvbnxuZXRmcm9udHxqYXNtaW5lfGJsYXplcilbXFwvXFxzXT8oW1xcd1xcLl0rKSovaSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMdW5hc2NhcGUvTWF4dGhvbi9OZXRmcm9udC9KYXNtaW5lL0JsYXplclxuXG5cdCAgICAgICAgICAgIC8vIFRyaWRlbnQgYmFzZWRcblx0ICAgICAgICAgICAgLyhhdmFudFxcc3xpZW1vYmlsZXxzbGltfGJhaWR1KSg/OmJyb3dzZXIpP1tcXC9cXHNdPyhbXFx3XFwuXSopL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhbnQvSUVNb2JpbGUvU2xpbUJyb3dzZXIvQmFpZHVcblx0ICAgICAgICAgICAgLyg/Om1zfFxcKCkoaWUpXFxzKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXJcblxuXHQgICAgICAgICAgICAvLyBXZWJraXQvS0hUTUwgYmFzZWRcblx0ICAgICAgICAgICAgLyhyZWtvbnEpXFwvKFtcXHdcXC5dKykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWtvbnFcblx0ICAgICAgICAgICAgLyhjaHJvbWl1bXxmbG9ja3xyb2NrbWVsdHxtaWRvcml8ZXBpcGhhbnl8c2lsa3xza3lmaXJlfG92aWJyb3dzZXJ8Ym9sdHxpcm9ufHZpdmFsZGkpXFwvKFtcXHdcXC4tXSspL2lcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bS9GbG9jay9Sb2NrTWVsdC9NaWRvcmkvRXBpcGhhbnkvU2lsay9Ta3lmaXJlL0JvbHQvSXJvblxuXHQgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuXHQgICAgICAgICAgICAvKHRyaWRlbnQpLitydls6XFxzXShbXFx3XFwuXSspLitsaWtlXFxzZ2Vja28vaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTExXG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0lFJ10sIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLyhlZGdlKVxcLygoXFxkKyk/W1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEVkZ2Vcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLyh5YWJyb3dzZXIpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBZYW5kZXhcblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnWWFuZGV4J10sIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLyhjb21vZG9fZHJhZ29uKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21vZG8gRHJhZ29uXG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgL18vZywgJyAnXSwgVkVSU0lPTl0sIFtcblxuXHQgICAgICAgICAgICAvKGNocm9tZXxvbW5pd2VifGFyb3JhfFt0aXplbm9rYV17NX1cXHM/YnJvd3NlcilcXC92PyhbXFx3XFwuXSspL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lL09tbmlXZWIvQXJvcmEvVGl6ZW4vTm9raWFcblx0ICAgICAgICAgICAgLyh1Y1xccz9icm93c2VyfHFxYnJvd3NlcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUNCcm93c2VyL1FRQnJvd3NlclxuXHQgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuXHQgICAgICAgICAgICAvKGRvbGZpbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbHBoaW5cblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnRG9scGhpbiddLCBWRVJTSU9OXSwgW1xuXG5cdCAgICAgICAgICAgIC8oKD86YW5kcm9pZC4rKWNybW98Y3Jpb3MpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkL2lPU1xuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdDaHJvbWUnXSwgVkVSU0lPTl0sIFtcblxuXHQgICAgICAgICAgICAvWGlhb01pXFwvTWl1aUJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNSVVJIEJyb3dzZXJcblx0ICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnTUlVSSBCcm93c2VyJ11dLCBbXG5cblx0ICAgICAgICAgICAgL2FuZHJvaWQuK3ZlcnNpb25cXC8oW1xcd1xcLl0rKVxccysoPzptb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkvaSAgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlclxuXHQgICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdBbmRyb2lkIEJyb3dzZXInXV0sIFtcblxuXHQgICAgICAgICAgICAvRkJBVlxcLyhbXFx3XFwuXSspOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhY2Vib29rIEFwcCBmb3IgaU9TXG5cdCAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0ZhY2Vib29rJ11dLCBbXG5cblx0ICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLl0rKS4rP21vYmlsZVxcL1xcdytcXHMoc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgICAvLyBNb2JpbGUgU2FmYXJpXG5cdCAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01vYmlsZSBTYWZhcmknXV0sIFtcblxuXHQgICAgICAgICAgICAvdmVyc2lvblxcLyhbXFx3XFwuXSspLis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgJiBTYWZhcmkgTW9iaWxlXG5cdCAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXSwgW1xuXG5cdCAgICAgICAgICAgIC93ZWJraXQuKz8obW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpKFxcL1tcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8IDMuMFxuXHQgICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMuYnJvd3Nlci5vbGRzYWZhcmkudmVyc2lvbl1dLCBbXG5cblx0ICAgICAgICAgICAgLyhrb25xdWVyb3IpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLb25xdWVyb3Jcblx0ICAgICAgICAgICAgLyh3ZWJraXR8a2h0bWwpXFwvKFtcXHdcXC5dKykvaVxuXHQgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuXHQgICAgICAgICAgICAvLyBHZWNrbyBiYXNlZFxuXHQgICAgICAgICAgICAvKG5hdmlnYXRvcnxuZXRzY2FwZSlcXC8oW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHNjYXBlXG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ05ldHNjYXBlJ10sIFZFUlNJT05dLCBbXG5cdCAgICAgICAgICAgIC8oc3dpZnRmb3gpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpZnRmb3hcblx0ICAgICAgICAgICAgLyhpY2VkcmFnb258aWNld2Vhc2VsfGNhbWlub3xjaGltZXJhfGZlbm5lY3xtYWVtb1xcc2Jyb3dzZXJ8bWluaW1vfGNvbmtlcm9yKVtcXC9cXHNdPyhbXFx3XFwuXFwrXSspL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWNlRHJhZ29uL0ljZXdlYXNlbC9DYW1pbm8vQ2hpbWVyYS9GZW5uZWMvTWFlbW8vTWluaW1vL0Nvbmtlcm9yXG5cdCAgICAgICAgICAgIC8oZmlyZWZveHxzZWFtb25rZXl8ay1tZWxlb258aWNlY2F0fGljZWFwZXxmaXJlYmlyZHxwaG9lbml4KVxcLyhbXFx3XFwuLV0rKS9pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3gvU2VhTW9ua2V5L0stTWVsZW9uL0ljZUNhdC9JY2VBcGUvRmlyZWJpcmQvUGhvZW5peFxuXHQgICAgICAgICAgICAvKG1vemlsbGEpXFwvKFtcXHdcXC5dKykuK3J2XFw6LitnZWNrb1xcL1xcZCsvaSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vemlsbGFcblxuXHQgICAgICAgICAgICAvLyBPdGhlclxuXHQgICAgICAgICAgICAvKHBvbGFyaXN8bHlueHxkaWxsb3xpY2FifGRvcmlzfGFtYXlhfHczbXxuZXRzdXJmKVtcXC9cXHNdPyhbXFx3XFwuXSspL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sYXJpcy9MeW54L0RpbGxvL2lDYWIvRG9yaXMvQW1heWEvdzNtL05ldFN1cmZcblx0ICAgICAgICAgICAgLyhsaW5rcylcXHNcXCgoW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlua3Ncblx0ICAgICAgICAgICAgLyhnb2Jyb3dzZXIpXFwvPyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb0Jyb3dzZXJcblx0ICAgICAgICAgICAgLyhpY2VcXHM/YnJvd3NlcilcXC92PyhbXFx3XFwuX10rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUNFIEJyb3dzZXJcblx0ICAgICAgICAgICAgLyhtb3NhaWMpW1xcL1xcc10oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9zYWljXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXVxuXHQgICAgICAgIF0sXG5cblx0ICAgICAgICBlbmdpbmUgOiBbW1xuXG5cdCAgICAgICAgICAgIC93aW5kb3dzLitcXHNlZGdlXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVkZ2VIVE1MXG5cdCAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0VkZ2VIVE1MJ11dLCBbXG5cblx0ICAgICAgICAgICAgLyhwcmVzdG8pXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVzdG9cblx0ICAgICAgICAgICAgLyh3ZWJraXR8dHJpZGVudHxuZXRmcm9udHxuZXRzdXJmfGFtYXlhfGx5bnh8dzNtKVxcLyhbXFx3XFwuXSspL2ksICAgICAvLyBXZWJLaXQvVHJpZGVudC9OZXRGcm9udC9OZXRTdXJmL0FtYXlhL0x5bngvdzNtXG5cdCAgICAgICAgICAgIC8oa2h0bWx8dGFzbWFufGxpbmtzKVtcXC9cXHNdXFwoPyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLSFRNTC9UYXNtYW4vTGlua3Ncblx0ICAgICAgICAgICAgLyhpY2FiKVtcXC9cXHNdKFsyM11cXC5bXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlDYWJcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgL3J2XFw6KFtcXHdcXC5dKykuKihnZWNrbykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZWNrb1xuXHQgICAgICAgICAgICBdLCBbVkVSU0lPTiwgTkFNRV1cblx0ICAgICAgICBdLFxuXG5cdCAgICAgICAgb3MgOiBbW1xuXG5cdCAgICAgICAgICAgIC8vIFdpbmRvd3MgYmFzZWRcblx0ICAgICAgICAgICAgL21pY3Jvc29mdFxccyh3aW5kb3dzKVxccyh2aXN0YXx4cCkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgKGlUdW5lcylcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cdCAgICAgICAgICAgIC8od2luZG93cylcXHNudFxcczZcXC4yO1xccyhhcm0pL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgUlRcblx0ICAgICAgICAgICAgLyh3aW5kb3dzXFxzcGhvbmUoPzpcXHNvcykqfHdpbmRvd3NcXHNtb2JpbGV8d2luZG93cylbXFxzXFwvXT8oW250Y2VcXGRcXC5cXHNdK1xcdykvaVxuXHQgICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sIFtcblx0ICAgICAgICAgICAgLyh3aW4oPz0zfDl8bil8d2luXFxzOXhcXHMpKFtudFxcZFxcLl0rKS9pXG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1dpbmRvd3MnXSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sIFtcblxuXHQgICAgICAgICAgICAvLyBNb2JpbGUvRW1iZWRkZWQgT1Ncblx0ICAgICAgICAgICAgL1xcKChiYikoMTApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeSAxMFxuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdCbGFja0JlcnJ5J10sIFZFUlNJT05dLCBbXG5cdCAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlcXHcqXFwvPyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrYmVycnlcblx0ICAgICAgICAgICAgLyh0aXplbilbXFwvXFxzXShbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGl6ZW5cblx0ICAgICAgICAgICAgLyhhbmRyb2lkfHdlYm9zfHBhbG1cXG9zfHFueHxiYWRhfHJpbVxcc3RhYmxldFxcc29zfG1lZWdvfGNvbnRpa2kpW1xcL1xccy1dPyhbXFx3XFwuXSspKi9pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQvV2ViT1MvUGFsbS9RTlgvQmFkYS9SSU0vTWVlR28vQ29udGlraVxuXHQgICAgICAgICAgICAvbGludXg7Lisoc2FpbGZpc2gpOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhaWxmaXNoIE9TXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXHQgICAgICAgICAgICAvKHN5bWJpYW5cXHM/b3N8c3ltYm9zfHM2MCg/PTspKVtcXC9cXHMtXT8oW1xcd1xcLl0rKSovaSAgICAgICAgICAgICAgICAgLy8gU3ltYmlhblxuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdTeW1iaWFuJ10sIFZFUlNJT05dLCBbXG5cdCAgICAgICAgICAgIC9cXCgoc2VyaWVzNDApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcmllcyA0MFxuXHQgICAgICAgICAgICBdLCBbTkFNRV0sIFtcblx0ICAgICAgICAgICAgL21vemlsbGEuK1xcKG1vYmlsZTsuK2dlY2tvLitmaXJlZm94L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBPU1xuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdGaXJlZm94IE9TJ10sIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLy8gQ29uc29sZVxuXHQgICAgICAgICAgICAvKG5pbnRlbmRvfHBsYXlzdGF0aW9uKVxccyhbd2lkczNwb3J0YWJsZXZ1XSspL2ksICAgICAgICAgICAgICAgICAgICAvLyBOaW50ZW5kby9QbGF5c3RhdGlvblxuXG5cdCAgICAgICAgICAgIC8vIEdOVS9MaW51eCBiYXNlZFxuXHQgICAgICAgICAgICAvKG1pbnQpW1xcL1xcc1xcKF0/KFxcdyspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaW50XG5cdCAgICAgICAgICAgIC8obWFnZWlhfHZlY3RvcmxpbnV4KVs7XFxzXS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hZ2VpYS9WZWN0b3JMaW51eFxuXHQgICAgICAgICAgICAvKGpvbGl8W2t4bG5dP3VidW50dXxkZWJpYW58W29wZW5dKnN1c2V8Z2VudG9vfGFyY2h8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZGhhdHx6ZW53YWxrfGxpbnB1cylbXFwvXFxzLV0/KFtcXHdcXC4tXSspKi9pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvbGkvVWJ1bnR1L0RlYmlhbi9TVVNFL0dlbnRvby9BcmNoL1NsYWNrd2FyZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZlZG9yYS9NYW5kcml2YS9DZW50T1MvUENMaW51eE9TL1JlZEhhdC9aZW53YWxrL0xpbnB1c1xuXHQgICAgICAgICAgICAvKGh1cmR8bGludXgpXFxzPyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEh1cmQvTGludXhcblx0ICAgICAgICAgICAgLyhnbnUpXFxzPyhbXFx3XFwuXSspKi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHTlVcblx0ICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cblx0ICAgICAgICAgICAgLyhjcm9zKVxcc1tcXHddK1xccyhbXFx3XFwuXStcXHcpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bSBPU1xuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdDaHJvbWl1bSBPUyddLCBWRVJTSU9OXSxbXG5cblx0ICAgICAgICAgICAgLy8gU29sYXJpc1xuXHQgICAgICAgICAgICAvKHN1bm9zKVxccz8oW1xcd1xcLl0rXFxkKSovaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2xhcmlzXG5cdCAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1NvbGFyaXMnXSwgVkVSU0lPTl0sIFtcblxuXHQgICAgICAgICAgICAvLyBCU0QgYmFzZWRcblx0ICAgICAgICAgICAgL1xccyhbZnJlbnRvcGMtXXswLDR9YnNkfGRyYWdvbmZseSlcXHM/KFtcXHdcXC5dKykqL2kgICAgICAgICAgICAgICAgICAgLy8gRnJlZUJTRC9OZXRCU0QvT3BlbkJTRC9QQy1CU0QvRHJhZ29uRmx5XG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSxbXG5cblx0ICAgICAgICAgICAgLyhpcFtob25lYWRdKykoPzouKm9zXFxzKihbXFx3XSspKlxcc2xpa2VcXHNtYWN8O1xcc29wZXJhKS9pICAgICAgICAgICAgIC8vIGlPU1xuXHQgICAgICAgICAgICBdLCBbW05BTUUsICdpT1MnXSwgW1ZFUlNJT04sIC9fL2csICcuJ11dLCBbXG5cblx0ICAgICAgICAgICAgLyhtYWNcXHNvc1xcc3gpXFxzPyhbXFx3XFxzXFwuXStcXHcpKi9pLFxuXHQgICAgICAgICAgICAvKG1hY2ludG9zaHxtYWMoPz1fcG93ZXJwYylcXHMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWMgT1Ncblx0ICAgICAgICAgICAgXSwgW1tOQU1FLCAnTWFjIE9TJ10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgW1xuXG5cdCAgICAgICAgICAgIC8vIE90aGVyXG5cdCAgICAgICAgICAgIC8oKD86b3Blbik/c29sYXJpcylbXFwvXFxzLV0/KFtcXHdcXC5dKykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbGFyaXNcblx0ICAgICAgICAgICAgLyhoYWlrdSlcXHMoXFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhaWt1XG5cdCAgICAgICAgICAgIC8oYWl4KVxccygoXFxkKSg/PVxcLnxcXCl8XFxzKVtcXHdcXC5dKikqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFJWFxuXHQgICAgICAgICAgICAvKHBsYW5cXHM5fG1pbml4fGJlb3N8b3NcXC8yfGFtaWdhb3N8bW9ycGhvc3xyaXNjXFxzb3N8b3BlbnZtcykvaSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFuOS9NaW5peC9CZU9TL09TMi9BbWlnYU9TL01vcnBoT1MvUklTQ09TL09wZW5WTVNcblx0ICAgICAgICAgICAgLyh1bml4KVxccz8oW1xcd1xcLl0rKSovaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVTklYXG5cdCAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXVxuXHQgICAgICAgIF1cblx0ICAgIH07XG5cblxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIENvbnN0cnVjdG9yXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vXG5cblxuXHQgICAgdmFyIFVBUGFyc2VyID0gZnVuY3Rpb24gKHVhc3RyaW5nKSB7XG5cblx0ICAgICAgICB2YXIgdWEgPSB1YXN0cmluZyB8fCAoKHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogRU1QVFkpO1xuXG5cdCAgICAgICAgdGhpcy5nZXRCcm93c2VyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFwcGVyLnJneC5hcHBseSh0aGlzLCByZWdleGVzLmJyb3dzZXIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5nZXRFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBtYXBwZXIucmd4LmFwcGx5KHRoaXMsIHJlZ2V4ZXMuZW5naW5lKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuZ2V0T1MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBtYXBwZXIucmd4LmFwcGx5KHRoaXMsIHJlZ2V4ZXMub3MpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5nZXRSZXN1bHQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHVhICAgICAgOiB0aGlzLmdldFVBKCksXG5cdCAgICAgICAgICAgICAgICBicm93c2VyIDogdGhpcy5nZXRCcm93c2VyKCksXG5cdCAgICAgICAgICAgICAgICBlbmdpbmUgIDogdGhpcy5nZXRFbmdpbmUoKSxcblx0ICAgICAgICAgICAgICAgIG9zICAgICAgOiB0aGlzLmdldE9TKClcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuZ2V0VUEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB1YTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuc2V0VUEgPSBmdW5jdGlvbiAodWFzdHJpbmcpIHtcblx0ICAgICAgICAgICAgdWEgPSB1YXN0cmluZztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLnNldFVBKHVhKTtcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBVQVBhcnNlcjtcblx0fSkoKTtcblxuXG5cdGZ1bmN0aW9uIHZlcnNpb25fY29tcGFyZSh2MSwgdjIsIG9wZXJhdG9yKSB7XG5cdCAgLy8gRnJvbTogaHR0cDovL3BocGpzLm9yZy9mdW5jdGlvbnNcblx0ICAvLyArICAgICAgb3JpZ2luYWwgYnk6IFBoaWxpcHBlIEphdXNpb25zIChodHRwOi8vcGVhci5waHAubmV0L3VzZXIvamF1c2lvbnMpXG5cdCAgLy8gKyAgICAgIG9yaWdpbmFsIGJ5OiBBaWRhbiBMaXN0ZXIgKGh0dHA6Ly9haWRhbmxpc3Rlci5jb20vKVxuXHQgIC8vICsgcmVpbXBsZW1lbnRlZCBieTogS2Fua3JlbHVuZSAoaHR0cDovL3d3dy53ZWJmYWt0b3J5LmluZm8vKVxuXHQgIC8vICsgICAgICBpbXByb3ZlZCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcblx0ICAvLyArICAgICAgaW1wcm92ZWQgYnk6IFNjb3R0IEJha2VyXG5cdCAgLy8gKyAgICAgIGltcHJvdmVkIGJ5OiBUaGVyaWF1bHRcblx0ICAvLyAqICAgICAgICBleGFtcGxlIDE6IHZlcnNpb25fY29tcGFyZSgnOC4yLjVyYycsICc4LjIuNWEnKTtcblx0ICAvLyAqICAgICAgICByZXR1cm5zIDE6IDFcblx0ICAvLyAqICAgICAgICBleGFtcGxlIDI6IHZlcnNpb25fY29tcGFyZSgnOC4yLjUwJywgJzguMi41MicsICc8Jyk7XG5cdCAgLy8gKiAgICAgICAgcmV0dXJucyAyOiB0cnVlXG5cdCAgLy8gKiAgICAgICAgZXhhbXBsZSAzOiB2ZXJzaW9uX2NvbXBhcmUoJzUuMy4wLWRldicsICc1LjMuMCcpO1xuXHQgIC8vICogICAgICAgIHJldHVybnMgMzogLTFcblx0ICAvLyAqICAgICAgICBleGFtcGxlIDQ6IHZlcnNpb25fY29tcGFyZSgnNC4xLjAuNTInLCc0LjAxLjAuNTEnKTtcblx0ICAvLyAqICAgICAgICByZXR1cm5zIDQ6IDFcblxuXHQgIC8vIEltcG9ydGFudDogY29tcGFyZSBtdXN0IGJlIGluaXRpYWxpemVkIGF0IDAuXG5cdCAgdmFyIGkgPSAwLFxuXHQgICAgeCA9IDAsXG5cdCAgICBjb21wYXJlID0gMCxcblx0ICAgIC8vIHZtIG1hcHMgdGV4dHVhbCBQSFAgdmVyc2lvbnMgdG8gbmVnYXRpdmVzIHNvIHRoZXkncmUgbGVzcyB0aGFuIDAuXG5cdCAgICAvLyBQSFAgY3VycmVudGx5IGRlZmluZXMgdGhlc2UgYXMgQ0FTRS1TRU5TSVRJVkUuIEl0IGlzIGltcG9ydGFudCB0b1xuXHQgICAgLy8gbGVhdmUgdGhlc2UgYXMgbmVnYXRpdmVzIHNvIHRoYXQgdGhleSBjYW4gY29tZSBiZWZvcmUgbnVtZXJpY2FsIHZlcnNpb25zXG5cdCAgICAvLyBhbmQgYXMgaWYgbm8gbGV0dGVycyB3ZXJlIHRoZXJlIHRvIGJlZ2luIHdpdGguXG5cdCAgICAvLyAoMWFscGhhIGlzIDwgMSBhbmQgPCAxLjEgYnV0ID4gMWRldjEpXG5cdCAgICAvLyBJZiBhIG5vbi1udW1lcmljYWwgdmFsdWUgY2FuJ3QgYmUgbWFwcGVkIHRvIHRoaXMgdGFibGUsIGl0IHJlY2VpdmVzXG5cdCAgICAvLyAtNyBhcyBpdHMgdmFsdWUuXG5cdCAgICB2bSA9IHtcblx0ICAgICAgJ2Rldic6IC02LFxuXHQgICAgICAnYWxwaGEnOiAtNSxcblx0ICAgICAgJ2EnOiAtNSxcblx0ICAgICAgJ2JldGEnOiAtNCxcblx0ICAgICAgJ2InOiAtNCxcblx0ICAgICAgJ1JDJzogLTMsXG5cdCAgICAgICdyYyc6IC0zLFxuXHQgICAgICAnIyc6IC0yLFxuXHQgICAgICAncCc6IDEsXG5cdCAgICAgICdwbCc6IDFcblx0ICAgIH0sXG5cdCAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIHByZXBhcmUgZWFjaCB2ZXJzaW9uIGFyZ3VtZW50LlxuXHQgICAgLy8gSXQgcmVwbGFjZXMgZXZlcnkgXywgLSwgYW5kICsgd2l0aCBhIGRvdC5cblx0ICAgIC8vIEl0IHN1cnJvdW5kcyBhbnkgbm9uc2VxdWVuY2Ugb2YgbnVtYmVycy9kb3RzIHdpdGggZG90cy5cblx0ICAgIC8vIEl0IHJlcGxhY2VzIHNlcXVlbmNlcyBvZiBkb3RzIHdpdGggYSBzaW5nbGUgZG90LlxuXHQgICAgLy8gICAgdmVyc2lvbl9jb21wYXJlKCc0Li4wJywgJzQuMCcpID09IDBcblx0ICAgIC8vIEltcG9ydGFudDogQSBzdHJpbmcgb2YgMCBsZW5ndGggbmVlZHMgdG8gYmUgY29udmVydGVkIGludG8gYSB2YWx1ZVxuXHQgICAgLy8gZXZlbiBsZXNzIHRoYW4gYW4gdW5leGlzdGluZyB2YWx1ZSBpbiB2bSAoLTcpLCBoZW5jZSBbLThdLlxuXHQgICAgLy8gSXQncyBhbHNvIGltcG9ydGFudCB0byBub3Qgc3RyaXAgc3BhY2VzIGJlY2F1c2Ugb2YgdGhpcy5cblx0ICAgIC8vICAgdmVyc2lvbl9jb21wYXJlKCcnLCAnICcpID09IDFcblx0ICAgIHByZXBWZXJzaW9uID0gZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgdiA9ICgnJyArIHYpLnJlcGxhY2UoL1tfXFwtK10vZywgJy4nKTtcblx0ICAgICAgdiA9IHYucmVwbGFjZSgvKFteLlxcZF0rKS9nLCAnLiQxLicpLnJlcGxhY2UoL1xcLnsyLH0vZywgJy4nKTtcblx0ICAgICAgcmV0dXJuICghdi5sZW5ndGggPyBbLThdIDogdi5zcGxpdCgnLicpKTtcblx0ICAgIH0sXG5cdCAgICAvLyBUaGlzIGNvbnZlcnRzIGEgdmVyc2lvbiBjb21wb25lbnQgdG8gYSBudW1iZXIuXG5cdCAgICAvLyBFbXB0eSBjb21wb25lbnQgYmVjb21lcyAwLlxuXHQgICAgLy8gTm9uLW51bWVyaWNhbCBjb21wb25lbnQgYmVjb21lcyBhIG5lZ2F0aXZlIG51bWJlci5cblx0ICAgIC8vIE51bWVyaWNhbCBjb21wb25lbnQgYmVjb21lcyBpdHNlbGYgYXMgYW4gaW50ZWdlci5cblx0ICAgIG51bVZlcnNpb24gPSBmdW5jdGlvbiAodikge1xuXHQgICAgICByZXR1cm4gIXYgPyAwIDogKGlzTmFOKHYpID8gdm1bdl0gfHwgLTcgOiBwYXJzZUludCh2LCAxMCkpO1xuXHQgICAgfTtcblxuXHQgIHYxID0gcHJlcFZlcnNpb24odjEpO1xuXHQgIHYyID0gcHJlcFZlcnNpb24odjIpO1xuXHQgIHggPSBNYXRoLm1heCh2MS5sZW5ndGgsIHYyLmxlbmd0aCk7XG5cdCAgZm9yIChpID0gMDsgaSA8IHg7IGkrKykge1xuXHQgICAgaWYgKHYxW2ldID09IHYyW2ldKSB7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHQgICAgdjFbaV0gPSBudW1WZXJzaW9uKHYxW2ldKTtcblx0ICAgIHYyW2ldID0gbnVtVmVyc2lvbih2MltpXSk7XG5cdCAgICBpZiAodjFbaV0gPCB2MltpXSkge1xuXHQgICAgICBjb21wYXJlID0gLTE7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfSBlbHNlIGlmICh2MVtpXSA+IHYyW2ldKSB7XG5cdCAgICAgIGNvbXBhcmUgPSAxO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKCFvcGVyYXRvcikge1xuXHQgICAgcmV0dXJuIGNvbXBhcmU7XG5cdCAgfVxuXG5cdCAgLy8gSW1wb3J0YW50OiBvcGVyYXRvciBpcyBDQVNFLVNFTlNJVElWRS5cblx0ICAvLyBcIk5vIG9wZXJhdG9yXCIgc2VlbXMgdG8gYmUgdHJlYXRlZCBhcyBcIjwuXCJcblx0ICAvLyBBbnkgb3RoZXIgdmFsdWVzIHNlZW0gdG8gbWFrZSB0aGUgZnVuY3Rpb24gcmV0dXJuIG51bGwuXG5cdCAgc3dpdGNoIChvcGVyYXRvcikge1xuXHQgIGNhc2UgJz4nOlxuXHQgIGNhc2UgJ2d0Jzpcblx0ICAgIHJldHVybiAoY29tcGFyZSA+IDApO1xuXHQgIGNhc2UgJz49Jzpcblx0ICBjYXNlICdnZSc6XG5cdCAgICByZXR1cm4gKGNvbXBhcmUgPj0gMCk7XG5cdCAgY2FzZSAnPD0nOlxuXHQgIGNhc2UgJ2xlJzpcblx0ICAgIHJldHVybiAoY29tcGFyZSA8PSAwKTtcblx0ICBjYXNlICc9PSc6XG5cdCAgY2FzZSAnPSc6XG5cdCAgY2FzZSAnZXEnOlxuXHQgICAgcmV0dXJuIChjb21wYXJlID09PSAwKTtcblx0ICBjYXNlICc8Pic6XG5cdCAgY2FzZSAnIT0nOlxuXHQgIGNhc2UgJ25lJzpcblx0ICAgIHJldHVybiAoY29tcGFyZSAhPT0gMCk7XG5cdCAgY2FzZSAnJzpcblx0ICBjYXNlICc8Jzpcblx0ICBjYXNlICdsdCc6XG5cdCAgICByZXR1cm4gKGNvbXBhcmUgPCAwKTtcblx0ICBkZWZhdWx0OlxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHR9XG5cblxuXHR2YXIgY2FuID0gKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYXBzID0ge1xuXHRcdFx0XHRkZWZpbmVfcHJvcGVydHk6IChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvKiAvLyBjdXJyZW50bHkgdG9vIG11Y2ggZXh0cmEgY29kZSByZXF1aXJlZCwgbm90IGV4YWN0bHkgd29ydGggaXRcblx0XHRcdFx0XHR0cnkgeyAvLyBhcyBvZiBJRTgsIGdldHRlcnMvc2V0dGVycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gRE9NIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRcdFx0XHRpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdwcm9wJywge1xuXHRcdFx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoKGV4KSB7fVxuXG5cdFx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyAmJiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18pIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0qL1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSgpKSxcblxuXHRcdFx0XHRjcmVhdGVfY2FudmFzOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gT24gdGhlIFM2MCBhbmQgQkIgU3Rvcm0sIGdldENvbnRleHQgZXhpc3RzLCBidXQgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0Ly8gc28gd2UgYWN0dWFsbHkgaGF2ZSB0byBjYWxsIGdldENvbnRleHQoKSB0byB2ZXJpZnlcblx0XHRcdFx0XHQvLyBnaXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvaXNzdWVzL2lzc3VlLzk3L1xuXHRcdFx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdFx0XHRcdHJldHVybiAhIShlbC5nZXRDb250ZXh0ICYmIGVsLmdldENvbnRleHQoJzJkJykpO1xuXHRcdFx0XHR9KCkpLFxuXG5cdFx0XHRcdHJldHVybl9yZXNwb25zZV90eXBlOiBmdW5jdGlvbihyZXNwb25zZVR5cGUpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aWYgKEJhc2ljLmluQXJyYXkocmVzcG9uc2VUeXBlLCBbJycsICd0ZXh0JywgJ2RvY3VtZW50J10pICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0XHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdFx0XHRcdFx0eGhyLm9wZW4oJ2dldCcsICcvJyk7IC8vIG90aGVyd2lzZSBHZWNrbyB0aHJvd3MgYW4gZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuXHRcdFx0XHRcdFx0XHRcdC8vIGFzIG9mIDIzLjAuMTI3MS42NCwgQ2hyb21lIHN3aXRjaGVkIGZyb20gdGhyb3dpbmcgZXhjZXB0aW9uIHRvIG1lcmVseSBsb2dnaW5nIGl0IHRvIHRoZSBjb25zb2xlICh3aHk/IG8gd2h5Pylcblx0XHRcdFx0XHRcdFx0XHRpZiAoeGhyLnJlc3BvbnNlVHlwZSAhPT0gcmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHt9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIGlkZWFzIGZvciB0aGlzIGhlYXZpbHkgY29tZSBmcm9tIE1vZGVybml6ciAoaHR0cDovL21vZGVybml6ci5jb20vKVxuXHRcdFx0XHR1c2VfZGF0YV91cmk6IChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZHUgPSBuZXcgSW1hZ2UoKTtcblxuXHRcdFx0XHRcdGR1Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y2Fwcy51c2VfZGF0YV91cmkgPSAoZHUud2lkdGggPT09IDEgJiYgZHUuaGVpZ2h0ID09PSAxKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRkdS5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQVA4QUFBQUFBQ0g1QkFBQUFBQUFMQUFBQUFBQkFBRUFBQUlDUkFFQU93PT1cIjtcblx0XHRcdFx0XHR9LCAxKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0oKSksXG5cblx0XHRcdFx0dXNlX2RhdGFfdXJpX292ZXIzMmtiOiBmdW5jdGlvbigpIHsgLy8gSUU4XG5cdFx0XHRcdFx0cmV0dXJuIGNhcHMudXNlX2RhdGFfdXJpICYmIChFbnYuYnJvd3NlciAhPT0gJ0lFJyB8fCBFbnYudmVyc2lvbiA+PSA5KTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1c2VfZGF0YV91cmlfb2Y6IGZ1bmN0aW9uKGJ5dGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjYXBzLnVzZV9kYXRhX3VyaSAmJiBieXRlcyA8IDMzMDAwIHx8IGNhcHMudXNlX2RhdGFfdXJpX292ZXIzMmtiKCkpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVzZV9maWxlaW5wdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oQW5kcm9pZCAoMS4wfDEuMXwxLjV8MS42fDIuMHwyLjEpKXwoV2luZG93cyBQaG9uZSAoT1MgN3w4LjApKXwoWEJMV1ApfChadW5lV1ApfCh3KGViKT9PU0Jyb3dzZXIpfCh3ZWJPUyl8KEtpbmRsZVxcLygxLjB8Mi4wfDIuNXwzLjApKS8pKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblx0XHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuXHRcdFx0XHRcdHJldHVybiAhZWwuZGlzYWJsZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oY2FwKSB7XG5cdFx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdGFyZ3Muc2hpZnQoKTsgLy8gc2hpZnQgb2YgY2FwXG5cdFx0XHRyZXR1cm4gQmFzaWMudHlwZU9mKGNhcHNbY2FwXSkgPT09ICdmdW5jdGlvbicgPyBjYXBzW2NhcF0uYXBwbHkodGhpcywgYXJncykgOiAhIWNhcHNbY2FwXTtcblx0XHR9O1xuXHR9KCkpO1xuXG5cblx0dmFyIHVhUmVzdWx0ID0gbmV3IFVBUGFyc2VyKCkuZ2V0UmVzdWx0KCk7XG5cblxuXHR2YXIgRW52ID0ge1xuXHRcdGNhbjogY2FuLFxuXG5cdFx0dWFQYXJzZXI6IFVBUGFyc2VyLFxuXHRcdFxuXHRcdGJyb3dzZXI6IHVhUmVzdWx0LmJyb3dzZXIubmFtZSxcblx0XHR2ZXJzaW9uOiB1YVJlc3VsdC5icm93c2VyLnZlcnNpb24sXG5cdFx0b3M6IHVhUmVzdWx0Lm9zLm5hbWUsIC8vIGV2ZXJ5Ym9keSBpbnR1aXRpdmVseSB0eXBlcyBpdCBpbiBhIGxvd2VyY2FzZSBmb3Igc29tZSByZWFzb25cblx0XHRvc1ZlcnNpb246IHVhUmVzdWx0Lm9zLnZlcnNpb24sXG5cblx0XHR2ZXJDb21wOiB2ZXJzaW9uX2NvbXBhcmUsXG5cdFx0XG5cdFx0c3dmX3VybDogXCIuLi9mbGFzaC9Nb3hpZS5zd2ZcIixcblx0XHR4YXBfdXJsOiBcIi4uL3NpbHZlcmxpZ2h0L01veGllLnhhcFwiLFxuXHRcdGdsb2JhbF9ldmVudF9kaXNwYXRjaGVyOiBcIm1veGllLmNvcmUuRXZlbnRUYXJnZXQuaW5zdGFuY2UuZGlzcGF0Y2hFdmVudFwiXG5cdH07XG5cblx0Ly8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0Ly8gQGRlcHJlY2F0ZWQgVXNlIGBFbnYub3NgIGluc3RlYWRcblx0RW52Lk9TID0gRW52Lm9zO1xuXG5cdGlmIChNWElfREVCVUcpIHtcblx0XHRFbnYuZGVidWcgPSB7XG5cdFx0XHRydW50aW1lOiB0cnVlLFxuXHRcdFx0ZXZlbnRzOiBmYWxzZVxuXHRcdH07XG5cblx0XHRFbnYubG9nID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uIGxvZ09iaihkYXRhKSB7XG5cdFx0XHRcdC8vIFRPRE86IHRoaXMgc2hvdWxkIHJlY3Vyc2l2ZWx5IHByaW50IG91dCB0aGUgb2JqZWN0IGluIGEgcHJldHR5IHdheVxuXHRcdFx0XHRjb25zb2xlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEgKyBcIlxcblwiKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkYXRhID0gYXJndW1lbnRzWzBdO1xuXG5cdFx0XHRpZiAoQmFzaWMudHlwZU9mKGRhdGEpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkYXRhID0gQmFzaWMuc3ByaW50Zi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xuXHRcdFx0XHR3aW5kb3cuY29uc29sZS5sb2coZGF0YSk7XG5cdFx0XHR9IGVsc2UgaWYgKGRvY3VtZW50KSB7XG5cdFx0XHRcdHZhciBjb25zb2xlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21veGllLWNvbnNvbGUnKTtcblx0XHRcdFx0aWYgKCFjb25zb2xlKSB7XG5cdFx0XHRcdFx0Y29uc29sZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXHRcdFx0XHRcdGNvbnNvbGUuaWQgPSAnbW94aWUtY29uc29sZSc7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb25zb2xlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChCYXNpYy5pbkFycmF5KEJhc2ljLnR5cGVPZihkYXRhKSwgWydvYmplY3QnLCAnYXJyYXknXSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0bG9nT2JqKGRhdGEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSArIFwiXFxuXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gRW52O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvRXhjZXB0aW9ucy5qc1xuXG4vKipcbiAqIEV4Y2VwdGlvbnMuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9jb3JlL0V4Y2VwdGlvbnMnLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJ1xuXSwgZnVuY3Rpb24oQmFzaWMpIHtcblx0XG5cdGZ1bmN0aW9uIF9maW5kS2V5KG9iaiwgdmFsdWUpIHtcblx0XHR2YXIga2V5O1xuXHRcdGZvciAoa2V5IGluIG9iaikge1xuXHRcdFx0aWYgKG9ialtrZXldID09PSB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4ga2V5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHRAY2xhc3MgbW94aWUvY29yZS9FeGNlcHRpb25cblx0Ki9cblx0cmV0dXJuIHtcblx0XHRSdW50aW1lRXJyb3I6IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuYW1lY29kZXMgPSB7XG5cdFx0XHRcdE5PVF9JTklUX0VSUjogMSxcblx0XHRcdFx0RVhDRVBUSU9OX0VSUjogMyxcblx0XHRcdFx0Tk9UX1NVUFBPUlRFRF9FUlI6IDksXG5cdFx0XHRcdEpTX0VSUjogNFxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gUnVudGltZUVycm9yKGNvZGUsIG1lc3NhZ2UpIHtcblx0XHRcdFx0dGhpcy5jb2RlID0gY29kZTtcblx0XHRcdFx0dGhpcy5uYW1lID0gX2ZpbmRLZXkobmFtZWNvZGVzLCBjb2RlKTtcblx0XHRcdFx0dGhpcy5tZXNzYWdlID0gdGhpcy5uYW1lICsgKG1lc3NhZ2UgfHwgXCI6IFJ1bnRpbWVFcnJvciBcIiArIHRoaXMuY29kZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdEJhc2ljLmV4dGVuZChSdW50aW1lRXJyb3IsIG5hbWVjb2Rlcyk7XG5cdFx0XHRSdW50aW1lRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXHRcdFx0cmV0dXJuIFJ1bnRpbWVFcnJvcjtcblx0XHR9KCkpLFxuXHRcdFxuXHRcdE9wZXJhdGlvbk5vdEFsbG93ZWRFeGNlcHRpb246IChmdW5jdGlvbigpIHtcblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gT3BlcmF0aW9uTm90QWxsb3dlZEV4Y2VwdGlvbihjb2RlKSB7XG5cdFx0XHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0XHRcdHRoaXMubmFtZSA9ICdPcGVyYXRpb25Ob3RBbGxvd2VkRXhjZXB0aW9uJztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0QmFzaWMuZXh0ZW5kKE9wZXJhdGlvbk5vdEFsbG93ZWRFeGNlcHRpb24sIHtcblx0XHRcdFx0Tk9UX0FMTE9XRURfRVJSOiAxXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0T3BlcmF0aW9uTm90QWxsb3dlZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBPcGVyYXRpb25Ob3RBbGxvd2VkRXhjZXB0aW9uO1xuXHRcdH0oKSksXG5cblx0XHRJbWFnZUVycm9yOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmFtZWNvZGVzID0ge1xuXHRcdFx0XHRXUk9OR19GT1JNQVQ6IDEsXG5cdFx0XHRcdE1BWF9SRVNPTFVUSU9OX0VSUjogMixcblx0XHRcdFx0SU5WQUxJRF9NRVRBX0VSUjogM1xuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gSW1hZ2VFcnJvcihjb2RlKSB7XG5cdFx0XHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0XHRcdHRoaXMubmFtZSA9IF9maW5kS2V5KG5hbWVjb2RlcywgY29kZSk7XG5cdFx0XHRcdHRoaXMubWVzc2FnZSA9IHRoaXMubmFtZSArIFwiOiBJbWFnZUVycm9yIFwiICsgdGhpcy5jb2RlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRCYXNpYy5leHRlbmQoSW1hZ2VFcnJvciwgbmFtZWNvZGVzKTtcblx0XHRcdEltYWdlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG5cdFx0XHRyZXR1cm4gSW1hZ2VFcnJvcjtcblx0XHR9KCkpLFxuXG5cdFx0RmlsZUV4Y2VwdGlvbjogKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5hbWVjb2RlcyA9IHtcblx0XHRcdFx0Tk9UX0ZPVU5EX0VSUjogMSxcblx0XHRcdFx0U0VDVVJJVFlfRVJSOiAyLFxuXHRcdFx0XHRBQk9SVF9FUlI6IDMsXG5cdFx0XHRcdE5PVF9SRUFEQUJMRV9FUlI6IDQsXG5cdFx0XHRcdEVOQ09ESU5HX0VSUjogNSxcblx0XHRcdFx0Tk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiA2LFxuXHRcdFx0XHRJTlZBTElEX1NUQVRFX0VSUjogNyxcblx0XHRcdFx0U1lOVEFYX0VSUjogOFxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gRmlsZUV4Y2VwdGlvbihjb2RlKSB7XG5cdFx0XHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0XHRcdHRoaXMubmFtZSA9IF9maW5kS2V5KG5hbWVjb2RlcywgY29kZSk7XG5cdFx0XHRcdHRoaXMubWVzc2FnZSA9IHRoaXMubmFtZSArIFwiOiBGaWxlRXhjZXB0aW9uIFwiICsgdGhpcy5jb2RlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRCYXNpYy5leHRlbmQoRmlsZUV4Y2VwdGlvbiwgbmFtZWNvZGVzKTtcblx0XHRcdEZpbGVFeGNlcHRpb24ucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXHRcdFx0cmV0dXJuIEZpbGVFeGNlcHRpb247XG5cdFx0fSgpKSxcblx0XHRcblx0XHRET01FeGNlcHRpb246IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuYW1lY29kZXMgPSB7XG5cdFx0XHRcdElOREVYX1NJWkVfRVJSOiAxLFxuXHRcdFx0XHRET01TVFJJTkdfU0laRV9FUlI6IDIsXG5cdFx0XHRcdEhJRVJBUkNIWV9SRVFVRVNUX0VSUjogMyxcblx0XHRcdFx0V1JPTkdfRE9DVU1FTlRfRVJSOiA0LFxuXHRcdFx0XHRJTlZBTElEX0NIQVJBQ1RFUl9FUlI6IDUsXG5cdFx0XHRcdE5PX0RBVEFfQUxMT1dFRF9FUlI6IDYsXG5cdFx0XHRcdE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUjogNyxcblx0XHRcdFx0Tk9UX0ZPVU5EX0VSUjogOCxcblx0XHRcdFx0Tk9UX1NVUFBPUlRFRF9FUlI6IDksXG5cdFx0XHRcdElOVVNFX0FUVFJJQlVURV9FUlI6IDEwLFxuXHRcdFx0XHRJTlZBTElEX1NUQVRFX0VSUjogMTEsXG5cdFx0XHRcdFNZTlRBWF9FUlI6IDEyLFxuXHRcdFx0XHRJTlZBTElEX01PRElGSUNBVElPTl9FUlI6IDEzLFxuXHRcdFx0XHROQU1FU1BBQ0VfRVJSOiAxNCxcblx0XHRcdFx0SU5WQUxJRF9BQ0NFU1NfRVJSOiAxNSxcblx0XHRcdFx0VkFMSURBVElPTl9FUlI6IDE2LFxuXHRcdFx0XHRUWVBFX01JU01BVENIX0VSUjogMTcsXG5cdFx0XHRcdFNFQ1VSSVRZX0VSUjogMTgsXG5cdFx0XHRcdE5FVFdPUktfRVJSOiAxOSxcblx0XHRcdFx0QUJPUlRfRVJSOiAyMCxcblx0XHRcdFx0VVJMX01JU01BVENIX0VSUjogMjEsXG5cdFx0XHRcdFFVT1RBX0VYQ0VFREVEX0VSUjogMjIsXG5cdFx0XHRcdFRJTUVPVVRfRVJSOiAyMyxcblx0XHRcdFx0SU5WQUxJRF9OT0RFX1RZUEVfRVJSOiAyNCxcblx0XHRcdFx0REFUQV9DTE9ORV9FUlI6IDI1XG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiBET01FeGNlcHRpb24oY29kZSkge1xuXHRcdFx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdFx0XHR0aGlzLm5hbWUgPSBfZmluZEtleShuYW1lY29kZXMsIGNvZGUpO1xuXHRcdFx0XHR0aGlzLm1lc3NhZ2UgPSB0aGlzLm5hbWUgKyBcIjogRE9NRXhjZXB0aW9uIFwiICsgdGhpcy5jb2RlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRCYXNpYy5leHRlbmQoRE9NRXhjZXB0aW9uLCBuYW1lY29kZXMpO1xuXHRcdFx0RE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblx0XHRcdHJldHVybiBET01FeGNlcHRpb247XG5cdFx0fSgpKSxcblx0XHRcblx0XHRFdmVudEV4Y2VwdGlvbjogKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuY3Rpb24gRXZlbnRFeGNlcHRpb24oY29kZSkge1xuXHRcdFx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdFx0XHR0aGlzLm5hbWUgPSAnRXZlbnRFeGNlcHRpb24nO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRCYXNpYy5leHRlbmQoRXZlbnRFeGNlcHRpb24sIHtcblx0XHRcdFx0VU5TUEVDSUZJRURfRVZFTlRfVFlQRV9FUlI6IDBcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRFdmVudEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBFdmVudEV4Y2VwdGlvbjtcblx0XHR9KCkpXG5cdH07XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvY29yZS91dGlscy9Eb20uanNcblxuLyoqXG4gKiBEb20uanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9jb3JlL3V0aWxzL0RvbScsIFsnbW94aWUvY29yZS91dGlscy9FbnYnXSwgZnVuY3Rpb24oRW52KSB7XG5cblx0LyoqXG5cdEdldCBET00gRWxlbWVudCBieSBpdCdzIGlkLlxuXG5cdEBtZXRob2QgZ2V0XG5cdEBmb3IgVXRpbHNcblx0QHBhcmFtIHtTdHJpbmd9IGlkIElkZW50aWZpZXIgb2YgdGhlIERPTSBFbGVtZW50XG5cdEByZXR1cm4ge0RPTUVsZW1lbnR9XG5cdCovXG5cdHZhciBnZXQgPSBmdW5jdGlvbihpZCkge1xuXHRcdGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gaWQ7XG5cdFx0fVxuXHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cdH07XG5cblx0LyoqXG5cdENoZWNrcyBpZiBzcGVjaWZpZWQgRE9NIGVsZW1lbnQgaGFzIHNwZWNpZmllZCBjbGFzcy5cblxuXHRAbWV0aG9kIGhhc0NsYXNzXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG9iaiBET00gZWxlbWVudCBsaWtlIG9iamVjdCB0byBhZGQgaGFuZGxlciB0by5cblx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgQ2xhc3MgbmFtZVxuXHQqL1xuXHR2YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbihvYmosIG5hbWUpIHtcblx0XHRpZiAoIW9iai5jbGFzc05hbWUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKylcIituYW1lK1wiKFxcXFxzK3wkKVwiKTtcblx0XHRyZXR1cm4gcmVnRXhwLnRlc3Qob2JqLmNsYXNzTmFtZSk7XG5cdH07XG5cblx0LyoqXG5cdEFkZHMgc3BlY2lmaWVkIGNsYXNzTmFtZSB0byBzcGVjaWZpZWQgRE9NIGVsZW1lbnQuXG5cblx0QG1ldGhvZCBhZGRDbGFzc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWVcblx0Ki9cblx0dmFyIGFkZENsYXNzID0gZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG5cdFx0aWYgKCFoYXNDbGFzcyhvYmosIG5hbWUpKSB7XG5cdFx0XHRvYmouY2xhc3NOYW1lID0gIW9iai5jbGFzc05hbWUgPyBuYW1lIDogb2JqLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMrJC8sICcnKSArICcgJyArIG5hbWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHRSZW1vdmVzIHNwZWNpZmllZCBjbGFzc05hbWUgZnJvbSBzcGVjaWZpZWQgRE9NIGVsZW1lbnQuXG5cblx0QG1ldGhvZCByZW1vdmVDbGFzc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWVcblx0Ki9cblx0dmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG5cdFx0aWYgKG9iai5jbGFzc05hbWUpIHtcblx0XHRcdHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMrKVwiK25hbWUrXCIoXFxcXHMrfCQpXCIpO1xuXHRcdFx0b2JqLmNsYXNzTmFtZSA9IG9iai5jbGFzc05hbWUucmVwbGFjZShyZWdFeHAsIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcblx0XHRcdFx0cmV0dXJuICQxID09PSAnICcgJiYgJDIgPT09ICcgJyA/ICcgJyA6ICcnO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHRSZXR1cm5zIGEgZ2l2ZW4gY29tcHV0ZWQgc3R5bGUgb2YgYSBET00gZWxlbWVudC5cblxuXHRAbWV0aG9kIGdldFN0eWxlXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG9iaiBET00gZWxlbWVudCBsaWtlIG9iamVjdC5cblx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgU3R5bGUgeW91IHdhbnQgdG8gZ2V0IGZyb20gdGhlIERPTSBlbGVtZW50XG5cdCovXG5cdHZhciBnZXRTdHlsZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuXHRcdGlmIChvYmouY3VycmVudFN0eWxlKSB7XG5cdFx0XHRyZXR1cm4gb2JqLmN1cnJlbnRTdHlsZVtuYW1lXTtcblx0XHR9IGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUob2JqLCBudWxsKVtuYW1lXTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0UmV0dXJucyB0aGUgYWJzb2x1dGUgeCwgeSBwb3NpdGlvbiBvZiBhbiBFbGVtZW50LiBUaGUgcG9zaXRpb24gd2lsbCBiZSByZXR1cm5lZCBpbiBhIG9iamVjdCB3aXRoIHgsIHkgZmllbGRzLlxuXG5cdEBtZXRob2QgZ2V0UG9zXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtFbGVtZW50fSBub2RlIEhUTUwgZWxlbWVudCBvciBlbGVtZW50IGlkIHRvIGdldCB4LCB5IHBvc2l0aW9uIGZyb20uXG5cdEBwYXJhbSB7RWxlbWVudH0gcm9vdCBPcHRpb25hbCByb290IGVsZW1lbnQgdG8gc3RvcCBjYWxjdWxhdGlvbnMgYXQuXG5cdEByZXR1cm4ge29iamVjdH0gQWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IG9iamVjdCB3aXRoIHgsIHkgZmllbGRzLlxuXHQqL1xuXHR2YXIgZ2V0UG9zID0gZnVuY3Rpb24obm9kZSwgcm9vdCkge1xuXHRcdHZhciB4ID0gMCwgeSA9IDAsIHBhcmVudCwgZG9jID0gZG9jdW1lbnQsIG5vZGVSZWN0LCByb290UmVjdDtcblxuXHRcdG5vZGUgPSBub2RlO1xuXHRcdHJvb3QgPSByb290IHx8IGRvYy5ib2R5O1xuXG5cdFx0Ly8gUmV0dXJucyB0aGUgeCwgeSBjb3JkaW5hdGUgZm9yIGFuIGVsZW1lbnQgb24gSUUgNiBhbmQgSUUgN1xuXHRcdGZ1bmN0aW9uIGdldElFUG9zKG5vZGUpIHtcblx0XHRcdHZhciBib2R5RWxtLCByZWN0LCB4ID0gMCwgeSA9IDA7XG5cblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRib2R5RWxtID0gZG9jLmNvbXBhdE1vZGUgPT09IFwiQ1NTMUNvbXBhdFwiID8gZG9jLmRvY3VtZW50RWxlbWVudCA6IGRvYy5ib2R5O1xuXHRcdFx0XHR4ID0gcmVjdC5sZWZ0ICsgYm9keUVsbS5zY3JvbGxMZWZ0O1xuXHRcdFx0XHR5ID0gcmVjdC50b3AgKyBib2R5RWxtLnNjcm9sbFRvcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eCA6IHgsXG5cdFx0XHRcdHkgOiB5XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gSUUgNiBhbmQgSUUgNyBidXQgbm90IG9uIElFIDggaW4gc3RhbmRhcmRzIG1vZGVcblx0XHRpZiAobm9kZSAmJiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBFbnYuYnJvd3NlciA9PT0gJ0lFJyAmJiAoIWRvYy5kb2N1bWVudE1vZGUgfHwgZG9jLmRvY3VtZW50TW9kZSA8IDgpKSB7XG5cdFx0XHRub2RlUmVjdCA9IGdldElFUG9zKG5vZGUpO1xuXHRcdFx0cm9vdFJlY3QgPSBnZXRJRVBvcyhyb290KTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eCA6IG5vZGVSZWN0LnggLSByb290UmVjdC54LFxuXHRcdFx0XHR5IDogbm9kZVJlY3QueSAtIHJvb3RSZWN0Lnlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cGFyZW50ID0gbm9kZTtcblx0XHR3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPSByb290ICYmIHBhcmVudC5ub2RlVHlwZSkge1xuXHRcdFx0eCArPSBwYXJlbnQub2Zmc2V0TGVmdCB8fCAwO1xuXHRcdFx0eSArPSBwYXJlbnQub2Zmc2V0VG9wIHx8IDA7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdH1cblxuXHRcdHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHR3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPSByb290ICYmIHBhcmVudC5ub2RlVHlwZSkge1xuXHRcdFx0eCAtPSBwYXJlbnQuc2Nyb2xsTGVmdCB8fCAwO1xuXHRcdFx0eSAtPSBwYXJlbnQuc2Nyb2xsVG9wIHx8IDA7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eCA6IHgsXG5cdFx0XHR5IDogeVxuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdFJldHVybnMgdGhlIHNpemUgb2YgdGhlIHNwZWNpZmllZCBub2RlIGluIHBpeGVscy5cblxuXHRAbWV0aG9kIGdldFNpemVcblx0QHN0YXRpY1xuXHRAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBnZXQgdGhlIHNpemUgb2YuXG5cdEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggYSB3IGFuZCBoIHByb3BlcnR5LlxuXHQqL1xuXHR2YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dyA6IG5vZGUub2Zmc2V0V2lkdGggfHwgbm9kZS5jbGllbnRXaWR0aCxcblx0XHRcdGggOiBub2RlLm9mZnNldEhlaWdodCB8fCBub2RlLmNsaWVudEhlaWdodFxuXHRcdH07XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRoYXNDbGFzczogaGFzQ2xhc3MsXG5cdFx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRcdHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcblx0XHRnZXRTdHlsZTogZ2V0U3R5bGUsXG5cdFx0Z2V0UG9zOiBnZXRQb3MsXG5cdFx0Z2V0U2l6ZTogZ2V0U2l6ZVxuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvRXZlbnRUYXJnZXQuanNcblxuLyoqXG4gKiBFdmVudFRhcmdldC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL2NvcmUvRXZlbnRUYXJnZXQnLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0VudicsXG5cdCdtb3hpZS9jb3JlL0V4Y2VwdGlvbnMnLFxuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYydcbl0sIGZ1bmN0aW9uKEVudiwgeCwgQmFzaWMpIHtcblxuXHQvLyBoYXNoIG9mIGV2ZW50IGxpc3RlbmVycyBieSBvYmplY3QgdWlkXG5cdHZhciBldmVudHBvb2wgPSB7fTtcblxuXHQvKipcblx0UGFyZW50IG9iamVjdCBmb3IgYWxsIGV2ZW50IGRpc3BhdGNoaW5nIGNvbXBvbmVudHMgYW5kIG9iamVjdHNcblxuXHRAY2xhc3MgbW94aWUvY29yZS9FdmVudFRhcmdldFxuXHRAY29uc3RydWN0b3IgRXZlbnRUYXJnZXRcblx0Ki9cblx0ZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG5cdFx0LyoqXG5cdFx0VW5pcXVlIGlkIG9mIHRoZSBldmVudCBkaXNwYXRjaGVyLCB1c3VhbGx5IG92ZXJyaWRlbiBieSBjaGlsZHJlblxuXG5cdFx0QHByb3BlcnR5IHVpZFxuXHRcdEB0eXBlIFN0cmluZ1xuXHRcdCovXG5cdFx0dGhpcy51aWQgPSBCYXNpYy5ndWlkKCk7XG5cdH1cblxuXG5cdEJhc2ljLmV4dGVuZChFdmVudFRhcmdldC5wcm90b3R5cGUsIHtcblxuXHRcdC8qKlxuXHRcdENhbiBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBjaGlsZCAgaW4gb3JkZXIgdG8gYWNxdWlyZSB1bmlxaWUgaWQgaW4gYXV0b21hdGVkIG1hbm5lclxuXG5cdFx0QG1ldGhvZCBpbml0XG5cdFx0Ki9cblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy51aWQpIHtcblx0XHRcdFx0dGhpcy51aWQgPSBCYXNpYy5ndWlkKCd1aWRfJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdFJlZ2lzdGVyIGEgaGFuZGxlciB0byBhIHNwZWNpZmljIGV2ZW50IGRpc3BhdGNoZWQgYnkgdGhlIG9iamVjdFxuXG5cdFx0QG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG5cdFx0QHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvciBiYXNpY2FsbHkgYSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG9cblx0XHRAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gZXZlbnQgaGFwcGVuc1xuXHRcdEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHk9MF0gUHJpb3JpdHkgb2YgdGhlIGV2ZW50IGhhbmRsZXIgLSBoYW5kbGVycyB3aXRoIGhpZ2hlciBwcmlvcml0aWVzIHdpbGwgYmUgY2FsbGVkIGZpcnN0XG5cdFx0QHBhcmFtIHtPYmplY3R9IFtzY29wZT10aGlzXSBBIHNjb3BlIHRvIGludm9rZSBldmVudCBoYW5kbGVyIGluXG5cdFx0Ki9cblx0XHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBmbiwgcHJpb3JpdHksIHNjb3BlKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIGxpc3Q7XG5cblx0XHRcdC8vIHdpdGhvdXQgdWlkIG5vIGV2ZW50IGhhbmRsZXJzIGNhbiBiZSBhZGRlZCwgc28gbWFrZSBzdXJlIHdlIGdvdCBvbmVcblx0XHRcdGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgndWlkJykpIHtcblx0XHRcdFx0dGhpcy51aWQgPSBCYXNpYy5ndWlkKCd1aWRfJyk7XG5cdFx0XHR9XG5cblx0XHRcdHR5cGUgPSBCYXNpYy50cmltKHR5cGUpO1xuXG5cdFx0XHRpZiAoL1xccy8udGVzdCh0eXBlKSkge1xuXHRcdFx0XHQvLyBtdWx0aXBsZSBldmVudCB0eXBlcyB3ZXJlIHBhc3NlZCBmb3Igb25lIGhhbmRsZXJcblx0XHRcdFx0QmFzaWMuZWFjaCh0eXBlLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHRzZWxmLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIHByaW9yaXR5LCBzY29wZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRwcmlvcml0eSA9IHBhcnNlSW50KHByaW9yaXR5LCAxMCkgfHwgMDtcblxuXHRcdFx0bGlzdCA9IGV2ZW50cG9vbFt0aGlzLnVpZF0gJiYgZXZlbnRwb29sW3RoaXMudWlkXVt0eXBlXSB8fCBbXTtcblx0XHRcdGxpc3QucHVzaCh7Zm4gOiBmbiwgcHJpb3JpdHkgOiBwcmlvcml0eSwgc2NvcGUgOiBzY29wZSB8fCB0aGlzfSk7XG5cblx0XHRcdGlmICghZXZlbnRwb29sW3RoaXMudWlkXSkge1xuXHRcdFx0XHRldmVudHBvb2xbdGhpcy51aWRdID0ge307XG5cdFx0XHR9XG5cdFx0XHRldmVudHBvb2xbdGhpcy51aWRdW3R5cGVdID0gbGlzdDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0Q2hlY2sgaWYgYW55IGhhbmRsZXJzIHdlcmUgcmVnaXN0ZXJlZCB0byB0aGUgc3BlY2lmaWVkIGV2ZW50XG5cblx0XHRAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJcblx0XHRAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFR5cGUgb3IgYmFzaWNhbGx5IGEgbmFtZSBvZiB0aGUgZXZlbnQgdG8gY2hlY2tcblx0XHRAcmV0dXJuIHtNaXhlZH0gUmV0dXJucyBhIGhhbmRsZXIgaWYgaXQgd2FzIGZvdW5kIGFuZCBmYWxzZSwgaWYgLSBub3Rcblx0XHQqL1xuXHRcdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBsaXN0O1xuXHRcdFx0aWYgKHR5cGUpIHtcblx0XHRcdFx0dHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0bGlzdCA9IGV2ZW50cG9vbFt0aGlzLnVpZF0gJiYgZXZlbnRwb29sW3RoaXMudWlkXVt0eXBlXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpc3QgPSBldmVudHBvb2xbdGhpcy51aWRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxpc3QgPyBsaXN0IDogZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdFVucmVnaXN0ZXIgdGhlIGhhbmRsZXIgZnJvbSB0aGUgZXZlbnQsIG9yIGlmIGZvcm1lciB3YXMgbm90IHNwZWNpZmllZCAtIHVucmVnaXN0ZXIgYWxsIGhhbmRsZXJzXG5cblx0XHRAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcblx0XHRAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9yIGJhc2ljYWxseSBhIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0QHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBIYW5kbGVyIHRvIHVucmVnaXN0ZXJcblx0XHQqL1xuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIGxpc3QsIGk7XG5cblx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICgvXFxzLy50ZXN0KHR5cGUpKSB7XG5cdFx0XHRcdC8vIG11bHRpcGxlIGV2ZW50IHR5cGVzIHdlcmUgcGFzc2VkIGZvciBvbmUgaGFuZGxlclxuXHRcdFx0XHRCYXNpYy5lYWNoKHR5cGUuc3BsaXQoL1xccysvKSwgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRcdHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxpc3QgPSBldmVudHBvb2xbdGhpcy51aWRdICYmIGV2ZW50cG9vbFt0aGlzLnVpZF1bdHlwZV07XG5cblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGlmIChmbikge1xuXHRcdFx0XHRcdGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdGlmIChsaXN0W2ldLmZuID09PSBmbikge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRlbGV0ZSBldmVudCBsaXN0IGlmIGl0IGhhcyBiZWNvbWUgZW1wdHlcblx0XHRcdFx0aWYgKCFsaXN0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGRlbGV0ZSBldmVudHBvb2xbdGhpcy51aWRdW3R5cGVdO1xuXG5cdFx0XHRcdFx0Ly8gYW5kIG9iamVjdCBzcGVjaWZpYyBlbnRyeSBpbiBhIGhhc2ggaWYgaXQgaGFzIG5vIG1vcmUgbGlzdGVuZXJzIGF0dGFjaGVkXG5cdFx0XHRcdFx0aWYgKEJhc2ljLmlzRW1wdHlPYmooZXZlbnRwb29sW3RoaXMudWlkXSkpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBldmVudHBvb2xbdGhpcy51aWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHRSZW1vdmUgYWxsIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlIG9iamVjdFxuXG5cdFx0QG1ldGhvZCByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xuXHRcdCovXG5cdFx0cmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGV2ZW50cG9vbFt0aGlzLnVpZF0pIHtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50cG9vbFt0aGlzLnVpZF07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoIHRoZSBldmVudFxuXG5cdFx0QG1ldGhvZCBkaXNwYXRjaEV2ZW50XG5cdFx0QHBhcmFtIHtTdHJpbmcvT2JqZWN0fSBUeXBlIG9mIGV2ZW50IG9yIGV2ZW50IG9iamVjdCB0byBkaXNwYXRjaFxuXHRcdEBwYXJhbSB7TWl4ZWR9IFsuLi5dIFZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGEgaGFuZGxlcnNcblx0XHRAcmV0dXJuIHtCb29sZWFufSB0cnVlIGJ5IGRlZmF1bHQgYW5kIGZhbHNlIGlmIGFueSBoYW5kbGVyIHJldHVybmVkIGZhbHNlXG5cdFx0Ki9cblx0XHRkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgdWlkLCBsaXN0LCBhcmdzLCB0bXBFdnQsIGV2dCA9IHt9LCByZXN1bHQgPSB0cnVlLCB1bmRlZjtcblxuXHRcdFx0aWYgKEJhc2ljLnR5cGVPZih0eXBlKSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gd2UgY2FuJ3QgdXNlIG9yaWdpbmFsIG9iamVjdCBkaXJlY3RseSAoYmVjYXVzZSBvZiBTaWx2ZXJsaWdodClcblx0XHRcdFx0dG1wRXZ0ID0gdHlwZTtcblxuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKHRtcEV2dC50eXBlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0eXBlID0gdG1wRXZ0LnR5cGU7XG5cblx0XHRcdFx0XHRpZiAodG1wRXZ0LnRvdGFsICE9PSB1bmRlZiAmJiB0bXBFdnQubG9hZGVkICE9PSB1bmRlZikgeyAvLyBwcm9ncmVzcyBldmVudFxuXHRcdFx0XHRcdFx0ZXZ0LnRvdGFsID0gdG1wRXZ0LnRvdGFsO1xuXHRcdFx0XHRcdFx0ZXZ0LmxvYWRlZCA9IHRtcEV2dC5sb2FkZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV2dC5hc3luYyA9IHRtcEV2dC5hc3luYyB8fCBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5FdmVudEV4Y2VwdGlvbih4LkV2ZW50RXhjZXB0aW9uLlVOU1BFQ0lGSUVEX0VWRU5UX1RZUEVfRVJSKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpZiBldmVudCBpcyBtZWFudCB0byBiZSBkaXNwYXRjaGVkIG9uIGFuIG9iamVjdCBoYXZpbmcgc3BlY2lmaWMgdWlkXG5cdFx0XHRpZiAodHlwZS5pbmRleE9mKCc6OicpICE9PSAtMSkge1xuXHRcdFx0XHQoZnVuY3Rpb24oYXJyKSB7XG5cdFx0XHRcdFx0dWlkID0gYXJyWzBdO1xuXHRcdFx0XHRcdHR5cGUgPSBhcnJbMV07XG5cdFx0XHRcdH0odHlwZS5zcGxpdCgnOjonKSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dWlkID0gdGhpcy51aWQ7XG5cdFx0XHR9XG5cblx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGxpc3QgPSBldmVudHBvb2xbdWlkXSAmJiBldmVudHBvb2xbdWlkXVt0eXBlXTtcblxuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0Ly8gc29ydCBldmVudCBsaXN0IGJ5IHByb3JpdHlcblx0XHRcdFx0bGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5OyB9KTtcblxuXHRcdFx0XHRhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIGZpcnN0IGFyZ3VtZW50IHdpbGwgYmUgcHNldWRvLWV2ZW50IG9iamVjdFxuXHRcdFx0XHRhcmdzLnNoaWZ0KCk7XG5cdFx0XHRcdGV2dC50eXBlID0gdHlwZTtcblx0XHRcdFx0YXJncy51bnNoaWZ0KGV2dCk7XG5cblx0XHRcdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcuZXZlbnRzKSB7XG5cdFx0XHRcdFx0RW52LmxvZyhcIkV2ZW50ICclcycgZmlyZWQgb24gJXVcIiwgZXZ0LnR5cGUsIHVpZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEaXNwYXRjaCBldmVudCB0byBhbGwgbGlzdGVuZXJzXG5cdFx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRCYXNpYy5lYWNoKGxpc3QsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHRcdFx0XHQvLyBleHBsaWNpdGx5IHNldCB0aGUgdGFyZ2V0LCBvdGhlcndpc2UgZXZlbnRzIGZpcmVkIGZyb20gc2hpbXMgZG8gbm90IGdldCBpdFxuXHRcdFx0XHRcdGFyZ3NbMF0udGFyZ2V0ID0gaGFuZGxlci5zY29wZTtcblx0XHRcdFx0XHQvLyBpZiBldmVudCBpcyBtYXJrZWQgYXMgYXN5bmMsIGRldGFjaCB0aGUgaGFuZGxlclxuXHRcdFx0XHRcdGlmIChldnQuYXN5bmMpIHtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRjYihoYW5kbGVyLmZuLmFwcGx5KGhhbmRsZXIuc2NvcGUsIGFyZ3MpID09PSBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH0sIDEpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRcdFx0Y2IoaGFuZGxlci5mbi5hcHBseShoYW5kbGVyLnNjb3BlLCBhcmdzKSA9PT0gZmFsc2UpOyAvLyBpZiBoYW5kbGVyIHJldHVybnMgZmFsc2Ugc3RvcCBwcm9wYWdhdGlvblxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdEJhc2ljLmluU2VyaWVzKHF1ZXVlLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9ICFlcnI7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdFJlZ2lzdGVyIGEgaGFuZGxlciB0byB0aGUgZXZlbnQgdHlwZSB0aGF0IHdpbGwgcnVuIG9ubHkgb25jZVxuXG5cdFx0QG1ldGhvZCBiaW5kT25jZVxuXHRcdEBzaW5jZSA+MS40LjFcblx0XHRAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9yIGJhc2ljYWxseSBhIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuXHRcdEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBldmVudCBoYXBwZW5zXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT0wXSBQcmlvcml0eSBvZiB0aGUgZXZlbnQgaGFuZGxlciAtIGhhbmRsZXJzIHdpdGggaGlnaGVyIHByaW9yaXRpZXMgd2lsbCBiZSBjYWxsZWQgZmlyc3Rcblx0XHRAcGFyYW0ge09iamVjdH0gW3Njb3BlPXRoaXNdIEEgc2NvcGUgdG8gaW52b2tlIGV2ZW50IGhhbmRsZXIgaW5cblx0XHQqL1xuXHRcdGJpbmRPbmNlOiBmdW5jdGlvbih0eXBlLCBmbiwgcHJpb3JpdHksIHNjb3BlKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmJpbmQuY2FsbCh0aGlzLCB0eXBlLCBmdW5jdGlvbiBjYigpIHtcblx0XHRcdFx0c2VsZi51bmJpbmQodHlwZSwgY2IpO1xuXHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH0sIHByaW9yaXR5LCBzY29wZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdEFsaWFzIGZvciBhZGRFdmVudExpc3RlbmVyXG5cblx0XHRAbWV0aG9kIGJpbmRcblx0XHRAcHJvdGVjdGVkXG5cdFx0Ki9cblx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHRBbGlhcyBmb3IgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuXG5cdFx0QG1ldGhvZCB1bmJpbmRcblx0XHRAcHJvdGVjdGVkXG5cdFx0Ki9cblx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdEFsaWFzIGZvciByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xuXG5cdFx0QG1ldGhvZCB1bmJpbmRBbGxcblx0XHRAcHJvdGVjdGVkXG5cdFx0Ki9cblx0XHR1bmJpbmRBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHRBbGlhcyBmb3IgZGlzcGF0Y2hFdmVudFxuXG5cdFx0QG1ldGhvZCB0cmlnZ2VyXG5cdFx0QHByb3RlY3RlZFxuXHRcdCovXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0SGFuZGxlIHByb3BlcnRpZXMgb2Ygb25bZXZlbnRdIHR5cGUuXG5cblx0XHRAbWV0aG9kIGhhbmRsZUV2ZW50UHJvcHNcblx0XHRAcHJpdmF0ZVxuXHRcdCovXG5cdFx0aGFuZGxlRXZlbnRQcm9wczogZnVuY3Rpb24oZGlzcGF0Y2hlcykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLmJpbmQoZGlzcGF0Y2hlcy5qb2luKCcgJyksIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0dmFyIHByb3AgPSAnb24nICsgZS50eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmIChCYXNpYy50eXBlT2YodGhpc1twcm9wXSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aGlzW3Byb3BdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBvYmplY3QgbXVzdCBoYXZlIGRlZmluZWQgZXZlbnQgcHJvcGVydGllcywgZXZlbiBpZiBpdCBkb2Vzbid0IG1ha2UgdXNlIG9mIHRoZW1cblx0XHRcdEJhc2ljLmVhY2goZGlzcGF0Y2hlcywgZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0XHRwcm9wID0gJ29uJyArIHByb3AudG9Mb3dlckNhc2UocHJvcCk7XG5cdFx0XHRcdGlmIChCYXNpYy50eXBlT2Yoc2VsZltwcm9wXSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0c2VsZltwcm9wXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9KTtcblxuXG5cdEV2ZW50VGFyZ2V0Lmluc3RhbmNlID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG5cblx0cmV0dXJuIEV2ZW50VGFyZ2V0O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvUnVudGltZS5qc1xuXG4vKipcbiAqIFJ1bnRpbWUuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9ydW50aW1lL1J1bnRpbWUnLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9FbnZcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9Eb21cIixcblx0XCJtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0XCJcbl0sIGZ1bmN0aW9uKEVudiwgQmFzaWMsIERvbSwgRXZlbnRUYXJnZXQpIHtcblx0dmFyIHJ1bnRpbWVDb25zdHJ1Y3RvcnMgPSB7fSwgcnVudGltZXMgPSB7fTtcblxuXHQvKipcblx0Q29tbW9uIHNldCBvZiBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGZvciBldmVyeSBydW50aW1lIGluc3RhbmNlXG5cblx0QGNsYXNzIG1veGllL3J1bnRpbWUvUnVudGltZVxuXG5cdEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdEBwYXJhbSB7U3RyaW5nfSB0eXBlIFNhbml0aXplZCBuYW1lIG9mIHRoZSBydW50aW1lXG5cdEBwYXJhbSB7T2JqZWN0fSBbY2Fwc10gU2V0IG9mIGNhcGFiaWxpdGllcyB0aGF0IGRpZmZlcmVudGlhdGUgc3BlY2lmaWVkIHJ1bnRpbWVcblx0QHBhcmFtIHtPYmplY3R9IFttb2RlQ2Fwc10gU2V0IG9mIGNhcGFiaWxpdGllcyB0aGF0IGRvIHJlcXVpcmUgc3BlY2lmaWMgb3BlcmF0aW9uYWwgbW9kZVxuXHRAcGFyYW0ge1N0cmluZ30gW3ByZWZlcnJlZE1vZGU9J2Jyb3dzZXInXSBQcmVmZXJyZWQgb3BlcmF0aW9uYWwgbW9kZSB0byBjaG9vc2UgaWYgbm8gcmVxdWlyZWQgY2FwYWJpbGl0aWVzIHdlcmUgcmVxdWVzdGVkXG5cdCovXG5cdGZ1bmN0aW9uIFJ1bnRpbWUob3B0aW9ucywgdHlwZSwgY2FwcywgbW9kZUNhcHMsIHByZWZlcnJlZE1vZGUpIHtcblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gcnVudGltZSBpcyBpbml0aWFsaXplZCBhbmQgcmVhZHkuXG5cdFx0UmVzdWx0cyBpbiBSdW50aW1lSW5pdCBvbiBhIGNvbm5lY3RlZCBjb21wb25lbnQuXG5cblx0XHRAZXZlbnQgSW5pdFxuXHRcdCovXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gcnVudGltZSBmYWlscyB0byBpbml0aWFsaXplLlxuXHRcdFJlc3VsdHMgaW4gUnVudGltZUVycm9yIG9uIGEgY29ubmVjdGVkIGNvbXBvbmVudC5cblxuXHRcdEBldmVudCBFcnJvclxuXHRcdCovXG5cblx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHQsIF9zaGltXG5cdFx0LCBfdWlkID0gQmFzaWMuZ3VpZCh0eXBlICsgJ18nKVxuXHRcdCwgZGVmYXVsdE1vZGUgPSBwcmVmZXJyZWRNb2RlIHx8ICdicm93c2VyJ1xuXHRcdDtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gcmVnaXN0ZXIgcnVudGltZSBpbiBwcml2YXRlIGhhc2hcblx0XHRydW50aW1lc1tfdWlkXSA9IHRoaXM7XG5cblx0XHQvKipcblx0XHREZWZhdWx0IHNldCBvZiBjYXBhYmlsaXRpZXMsIHdoaWNoIGNhbiBiZSByZWRpZmluZWQgbGF0ZXIgYnkgc3BlY2lmaWMgcnVudGltZVxuXG5cdFx0QHByaXZhdGVcblx0XHRAcHJvcGVydHkgY2Fwc1xuXHRcdEB0eXBlIE9iamVjdFxuXHRcdCovXG5cdFx0Y2FwcyA9IEJhc2ljLmV4dGVuZCh7XG5cdFx0XHQvLyBSdW50aW1lIGNhbjogXG5cdFx0XHQvLyBwcm92aWRlIGFjY2VzcyB0byByYXcgYmluYXJ5IGRhdGEgb2YgdGhlIGZpbGVcblx0XHRcdGFjY2Vzc19iaW5hcnk6IGZhbHNlLFxuXHRcdFx0Ly8gcHJvdmlkZSBhY2Nlc3MgdG8gcmF3IGJpbmFyeSBkYXRhIG9mIHRoZSBpbWFnZSAoaW1hZ2UgZXh0ZW5zaW9uIGlzIG9wdGlvbmFsKSBcblx0XHRcdGFjY2Vzc19pbWFnZV9iaW5hcnk6IGZhbHNlLFxuXHRcdFx0Ly8gZGlzcGxheSBiaW5hcnkgZGF0YSBhcyB0aHVtYnMgZm9yIGV4YW1wbGVcblx0XHRcdGRpc3BsYXlfbWVkaWE6IGZhbHNlLFxuXHRcdFx0Ly8gbWFrZSBjcm9zcy1kb21haW4gcmVxdWVzdHNcblx0XHRcdGRvX2NvcnM6IGZhbHNlLFxuXHRcdFx0Ly8gYWNjZXB0IGZpbGVzIGRyYWdnZWQgYW5kIGRyb3BwZWQgZnJvbSB0aGUgZGVza3RvcFxuXHRcdFx0ZHJhZ19hbmRfZHJvcDogZmFsc2UsXG5cdFx0XHQvLyBmaWx0ZXIgZmlsZXMgaW4gc2VsZWN0aW9uIGRpYWxvZyBieSB0aGVpciBleHRlbnNpb25zXG5cdFx0XHRmaWx0ZXJfYnlfZXh0ZW5zaW9uOiB0cnVlLFxuXHRcdFx0Ly8gcmVzaXplIGltYWdlIChhbmQgbWFuaXB1bGF0ZSBpdCByYXcgZGF0YSBvZiBhbnkgZmlsZSBpbiBnZW5lcmFsKVxuXHRcdFx0cmVzaXplX2ltYWdlOiBmYWxzZSxcblx0XHRcdC8vIHBlcmlvZGljYWxseSByZXBvcnQgaG93IG1hbnkgYnl0ZXMgb2YgdG90YWwgaW4gdGhlIGZpbGUgd2VyZSB1cGxvYWRlZCAobG9hZGVkKVxuXHRcdFx0cmVwb3J0X3VwbG9hZF9wcm9ncmVzczogZmFsc2UsXG5cdFx0XHQvLyBwcm92aWRlIGFjY2VzcyB0byB0aGUgaGVhZGVycyBvZiBodHRwIHJlc3BvbnNlIFxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX2hlYWRlcnM6IGZhbHNlLFxuXHRcdFx0Ly8gc3VwcG9ydCByZXNwb25zZSBvZiBzcGVjaWZpYyB0eXBlLCB3aGljaCBzaG91bGQgYmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG5cdFx0XHQvLyBlLmcuIHJ1bnRpbWUuY2FuKCdyZXR1cm5fcmVzcG9uc2VfdHlwZScsICdibG9iJylcblx0XHRcdHJldHVybl9yZXNwb25zZV90eXBlOiBmYWxzZSxcblx0XHRcdC8vIHJldHVybiBodHRwIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZVxuXHRcdFx0cmV0dXJuX3N0YXR1c19jb2RlOiB0cnVlLFxuXHRcdFx0Ly8gc2VuZCBjdXN0b20gaHR0cCBoZWFkZXIgd2l0aCB0aGUgcmVxdWVzdFxuXHRcdFx0c2VuZF9jdXN0b21faGVhZGVyczogZmFsc2UsXG5cdFx0XHQvLyBwaWNrIHVwIHRoZSBmaWxlcyBmcm9tIGEgZGlhbG9nXG5cdFx0XHRzZWxlY3RfZmlsZTogZmFsc2UsXG5cdFx0XHQvLyBzZWxlY3Qgd2hvbGUgZm9sZGVyIGluIGZpbGUgYnJvd3NlIGRpYWxvZ1xuXHRcdFx0c2VsZWN0X2ZvbGRlcjogZmFsc2UsXG5cdFx0XHQvLyBzZWxlY3QgbXVsdGlwbGUgZmlsZXMgYXQgb25jZSBpbiBmaWxlIGJyb3dzZSBkaWFsb2dcblx0XHRcdHNlbGVjdF9tdWx0aXBsZTogdHJ1ZSxcblx0XHRcdC8vIHNlbmQgcmF3IGJpbmFyeSBkYXRhLCB0aGF0IGlzIGdlbmVyYXRlZCBhZnRlciBpbWFnZSByZXNpemluZyBvciBtYW5pcHVsYXRpb24gb2Ygb3RoZXIga2luZFxuXHRcdFx0c2VuZF9iaW5hcnlfc3RyaW5nOiBmYWxzZSxcblx0XHRcdC8vIHNlbmQgY29va2llcyB3aXRoIGh0dHAgcmVxdWVzdCBhbmQgdGhlcmVmb3JlIHJldGFpbiBzZXNzaW9uXG5cdFx0XHRzZW5kX2Jyb3dzZXJfY29va2llczogdHJ1ZSxcblx0XHRcdC8vIHNlbmQgZGF0YSBmb3JtYXR0ZWQgYXMgbXVsdGlwYXJ0L2Zvcm0tZGF0YVxuXHRcdFx0c2VuZF9tdWx0aXBhcnQ6IHRydWUsXG5cdFx0XHQvLyBzbGljZSB0aGUgZmlsZSBvciBibG9iIHRvIHNtYWxsZXIgcGFydHNcblx0XHRcdHNsaWNlX2Jsb2I6IGZhbHNlLFxuXHRcdFx0Ly8gdXBsb2FkIGZpbGUgd2l0aG91dCBwcmVsb2FkaW5nIGl0IHRvIG1lbW9yeSwgc3RyZWFtIGl0IG91dCBkaXJlY3RseSBmcm9tIGRpc2tcblx0XHRcdHN0cmVhbV91cGxvYWQ6IGZhbHNlLFxuXHRcdFx0Ly8gcHJvZ3JhbW1hdGljYWxseSB0cmlnZ2VyIGZpbGUgYnJvd3NlIGRpYWxvZ1xuXHRcdFx0c3VtbW9uX2ZpbGVfZGlhbG9nOiBmYWxzZSxcblx0XHRcdC8vIHVwbG9hZCBmaWxlIG9mIHNwZWNpZmljIHNpemUsIHNpemUgc2hvdWxkIGJlIHBhc3NlZCBhcyBhcmd1bWVudFxuXHRcdFx0Ly8gZS5nLiBydW50aW1lLmNhbigndXBsb2FkX2ZpbGVzaXplJywgJzUwMG1iJylcblx0XHRcdHVwbG9hZF9maWxlc2l6ZTogdHJ1ZSxcblx0XHRcdC8vIGluaXRpYXRlIGh0dHAgcmVxdWVzdCB3aXRoIHNwZWNpZmljIGh0dHAgbWV0aG9kLCBtZXRob2Qgc2hvdWxkIGJlIHBhc3NlZCBhcyBhcmd1bWVudFxuXHRcdFx0Ly8gZS5nLiBydW50aW1lLmNhbigndXNlX2h0dHBfbWV0aG9kJywgJ3B1dCcpXG5cdFx0XHR1c2VfaHR0cF9tZXRob2Q6IHRydWVcblx0XHR9LCBjYXBzKTtcblx0XHRcdFxuXHRcblx0XHQvLyBkZWZhdWx0IHRvIHRoZSBtb2RlIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHByZWZlcnJlZCBjYXBzXG5cdFx0aWYgKG9wdGlvbnMucHJlZmVycmVkX2NhcHMpIHtcblx0XHRcdGRlZmF1bHRNb2RlID0gUnVudGltZS5nZXRNb2RlKG1vZGVDYXBzLCBvcHRpb25zLnByZWZlcnJlZF9jYXBzLCBkZWZhdWx0TW9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcucnVudGltZSkge1xuXHRcdFx0RW52LmxvZyhcIlxcdGRlZmF1bHQgbW9kZTogJXNcIiwgZGVmYXVsdE1vZGUpO1x0XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHNtYWxsIGV4dGVuc2lvbiBmYWN0b3J5IGhlcmUgKGlzIG1lYW50IHRvIGJlIGV4dGVuZGVkIHdpdGggYWN0dWFsIGV4dGVuc2lvbnMgY29uc3RydWN0b3JzKVxuXHRcdF9zaGltID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9ianBvb2wgPSB7fTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKHVpZCwgY29tcCwgZm4sIGFyZ3MpIHtcblx0XHRcdFx0XHRpZiAoX3NoaW1bY29tcF0pIHtcblx0XHRcdFx0XHRcdGlmICghb2JqcG9vbFt1aWRdKSB7XG5cdFx0XHRcdFx0XHRcdG9ianBvb2xbdWlkXSA9IHtcblx0XHRcdFx0XHRcdFx0XHRjb250ZXh0OiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlOiBuZXcgX3NoaW1bY29tcF0oKVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9ianBvb2xbdWlkXS5pbnN0YW5jZVtmbl0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG9ianBvb2xbdWlkXS5pbnN0YW5jZVtmbl0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHJlbW92ZUluc3RhbmNlOiBmdW5jdGlvbih1aWQpIHtcblx0XHRcdFx0XHRkZWxldGUgb2JqcG9vbFt1aWRdO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHJlbW92ZUFsbEluc3RhbmNlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XHRcdEJhc2ljLmVhY2gob2JqcG9vbCwgZnVuY3Rpb24ob2JqLCB1aWQpIHtcblx0XHRcdFx0XHRcdGlmIChCYXNpYy50eXBlT2Yob2JqLmluc3RhbmNlLmRlc3Ryb3kpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRcdG9iai5pbnN0YW5jZS5kZXN0cm95LmNhbGwob2JqLmNvbnRleHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVJbnN0YW5jZSh1aWQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0oKSk7XG5cblxuXHRcdC8vIHB1YmxpYyBtZXRob2RzXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0U3BlY2lmaWVzIHdoZXRoZXIgcnVudGltZSBpbnN0YW5jZSB3YXMgaW5pdGlhbGl6ZWQgb3Igbm90XG5cblx0XHRcdEBwcm9wZXJ0eSBpbml0aWFsaXplZFxuXHRcdFx0QHR5cGUge0Jvb2xlYW59XG5cdFx0XHRAZGVmYXVsdCBmYWxzZVxuXHRcdFx0Ki9cblx0XHRcdGluaXRpYWxpemVkOiBmYWxzZSwgLy8gc2hpbXMgcmVxdWlyZSB0aGlzIGZsYWcgdG8gc3RvcCBpbml0aWFsaXphdGlvbiByZXRyaWVzXG5cblx0XHRcdC8qKlxuXHRcdFx0VW5pcXVlIElEIG9mIHRoZSBydW50aW1lXG5cblx0XHRcdEBwcm9wZXJ0eSB1aWRcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0dWlkOiBfdWlkLFxuXG5cdFx0XHQvKipcblx0XHRcdFJ1bnRpbWUgdHlwZSAoZS5nLiBmbGFzaCwgaHRtbDUsIGV0YylcblxuXHRcdFx0QHByb3BlcnR5IHR5cGVcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0dHlwZTogdHlwZSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSdW50aW1lIChub3QgbmF0aXZlIG9uZSkgbWF5IG9wZXJhdGUgaW4gYnJvd3NlciBvciBjbGllbnQgbW9kZS5cblxuXHRcdFx0QHByb3BlcnR5IG1vZGVcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAdHlwZSB7U3RyaW5nfEJvb2xlYW59IGN1cnJlbnQgbW9kZSBvciBmYWxzZSwgaWYgbm9uZSBwb3NzaWJsZVxuXHRcdFx0Ki9cblx0XHRcdG1vZGU6IFJ1bnRpbWUuZ2V0TW9kZShtb2RlQ2FwcywgKG9wdGlvbnMucmVxdWlyZWRfY2FwcyksIGRlZmF1bHRNb2RlKSxcblxuXHRcdFx0LyoqXG5cdFx0XHRpZCBvZiB0aGUgRE9NIGNvbnRhaW5lciBmb3IgdGhlIHJ1bnRpbWUgKGlmIGF2YWlsYWJsZSlcblxuXHRcdFx0QHByb3BlcnR5IHNoaW1pZFxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdCovXG5cdFx0XHRzaGltaWQ6IF91aWQgKyAnX2NvbnRhaW5lcicsXG5cblx0XHRcdC8qKlxuXHRcdFx0TnVtYmVyIG9mIGNvbm5lY3RlZCBjbGllbnRzLiBJZiBlcXVhbCB0byB6ZXJvLCBydW50aW1lIGNhbiBiZSBkZXN0cm95ZWRcblxuXHRcdFx0QHByb3BlcnR5IGNsaWVudHNcblx0XHRcdEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQqL1xuXHRcdFx0Y2xpZW50czogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHRSdW50aW1lIGluaXRpYWxpemF0aW9uIG9wdGlvbnNcblxuXHRcdFx0QHByb3BlcnR5IG9wdGlvbnNcblx0XHRcdEB0eXBlIHtPYmplY3R9XG5cdFx0XHQqL1xuXHRcdFx0b3B0aW9uczogb3B0aW9ucyxcblxuXHRcdFx0LyoqXG5cdFx0XHRDaGVja3MgaWYgdGhlIHJ1bnRpbWUgaGFzIHNwZWNpZmljIGNhcGFiaWxpdHlcblxuXHRcdFx0QG1ldGhvZCBjYW5cblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBjYXAgTmFtZSBvZiBjYXBhYmlsaXR5IHRvIGNoZWNrXG5cdFx0XHRAcGFyYW0ge01peGVkfSBbdmFsdWVdIElmIHBhc3NlZCwgY2FwYWJpbGl0eSBzaG91bGQgc29tZWhvdyBjb3JyZWxhdGUgdG8gdGhlIHZhbHVlXG5cdFx0XHRAcGFyYW0ge09iamVjdH0gW3JlZkNhcHNdIFNldCBvZiBjYXBhYmlsaXRpZXMgdG8gY2hlY2sgdGhlIHNwZWNpZmllZCBjYXAgYWdhaW5zdCAoZGVmYXVsdHMgdG8gaW50ZXJuYWwgc2V0KVxuXHRcdFx0QHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBydW50aW1lIGhhcyBzdWNoIGNhcGFiaWxpdHkgYW5kIGZhbHNlLCBpZiAtIG5vdFxuXHRcdFx0Ki9cblx0XHRcdGNhbjogZnVuY3Rpb24oY2FwLCB2YWx1ZSkge1xuXHRcdFx0XHR2YXIgcmVmQ2FwcyA9IGFyZ3VtZW50c1syXSB8fCBjYXBzO1xuXG5cdFx0XHRcdC8vIGlmIGNhcCB2YXIgaXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBjYXBzLCBjb252ZXJ0IGl0IHRvIG9iamVjdCAoa2V5L3ZhbHVlKVxuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKGNhcCkgPT09ICdzdHJpbmcnICYmIEJhc2ljLnR5cGVPZih2YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0Y2FwID0gUnVudGltZS5wYXJzZUNhcHMoY2FwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChCYXNpYy50eXBlT2YoY2FwKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gY2FwKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuY2FuKGtleSwgY2FwW2tleV0sIHJlZkNhcHMpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayB0aGUgaW5kaXZpZHVhbCBjYXBcblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZihyZWZDYXBzW2NhcF0pID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZkNhcHNbY2FwXS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gKHZhbHVlID09PSByZWZDYXBzW2NhcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHVybnMgY29udGFpbmVyIGZvciB0aGUgcnVudGltZSBhcyBET00gZWxlbWVudFxuXG5cdFx0XHRAbWV0aG9kIGdldFNoaW1Db250YWluZXJcblx0XHRcdEByZXR1cm4ge0RPTUVsZW1lbnR9XG5cdFx0XHQqL1xuXHRcdFx0Z2V0U2hpbUNvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBjb250YWluZXIsIHNoaW1Db250YWluZXIgPSBEb20uZ2V0KHRoaXMuc2hpbWlkKTtcblxuXHRcdFx0XHQvLyBpZiBubyBjb250YWluZXIgZm9yIHNoaW0sIGNyZWF0ZSBvbmVcblx0XHRcdFx0aWYgKCFzaGltQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gRG9tLmdldCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSB8fCBkb2N1bWVudC5ib2R5O1xuXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIHNoaW0gY29udGFpbmVyIGFuZCBpbnNlcnQgaXQgYXQgYW4gYWJzb2x1dGUgcG9zaXRpb24gaW50byB0aGUgb3V0ZXIgY29udGFpbmVyXG5cdFx0XHRcdFx0c2hpbUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHRcdHNoaW1Db250YWluZXIuaWQgPSB0aGlzLnNoaW1pZDtcblx0XHRcdFx0XHRzaGltQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdtb3hpZS1zaGltIG1veGllLXNoaW0tJyArIHRoaXMudHlwZTtcblxuXHRcdFx0XHRcdEJhc2ljLmV4dGVuZChzaGltQ29udGFpbmVyLnN0eWxlLCB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHRcdHRvcDogJzBweCcsXG5cdFx0XHRcdFx0XHRsZWZ0OiAnMHB4Jyxcblx0XHRcdFx0XHRcdHdpZHRoOiAnMXB4Jyxcblx0XHRcdFx0XHRcdGhlaWdodDogJzFweCcsXG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbidcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzaGltQ29udGFpbmVyKTtcblx0XHRcdFx0XHRjb250YWluZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHNoaW1Db250YWluZXI7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHVybnMgcnVudGltZSBhcyBET00gZWxlbWVudCAoaWYgYXBwcm9wcmlhdGUpXG5cblx0XHRcdEBtZXRob2QgZ2V0U2hpbVxuXHRcdFx0QHJldHVybiB7RE9NRWxlbWVudH1cblx0XHRcdCovXG5cdFx0XHRnZXRTaGltOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9zaGltO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRJbnZva2VzIGEgbWV0aG9kIHdpdGhpbiB0aGUgcnVudGltZSBpdHNlbGYgKG1pZ2h0IGRpZmZlciBhY3Jvc3MgdGhlIHJ1bnRpbWVzKVxuXG5cdFx0XHRAbWV0aG9kIHNoaW1FeGVjXG5cdFx0XHRAcGFyYW0ge01peGVkfSBbXVxuXHRcdFx0QHByb3RlY3RlZFxuXHRcdFx0QHJldHVybiB7TWl4ZWR9IERlcGVuZHMgb24gdGhlIGFjdGlvbiBhbmQgY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0c2hpbUV4ZWM6IGZ1bmN0aW9uKGNvbXBvbmVudCwgYWN0aW9uKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5nZXRTaGltKCkuZXhlYy5jYWxsKHRoaXMsIHRoaXMudWlkLCBjb21wb25lbnQsIGFjdGlvbiwgYXJncyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdE9wZXJhaW9uYWwgaW50ZXJmYWNlIHRoYXQgaXMgdXNlZCBieSBjb21wb25lbnRzIHRvIGludm9rZSBzcGVjaWZpYyBhY3Rpb25zIG9uIHRoZSBydW50aW1lXG5cdFx0XHQoaXMgaW52b2tlZCBpbiB0aGUgc2NvcGUgb2YgY29tcG9uZW50KVxuXG5cdFx0XHRAbWV0aG9kIGV4ZWNcblx0XHRcdEBwYXJhbSB7TWl4ZWR9IFtdKlxuXHRcdFx0QHByb3RlY3RlZFxuXHRcdFx0QHJldHVybiB7TWl4ZWR9IERlcGVuZHMgb24gdGhlIGFjdGlvbiBhbmQgY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0ZXhlYzogZnVuY3Rpb24oY29tcG9uZW50LCBhY3Rpb24pIHsgLy8gdGhpcyBpcyBjYWxsZWQgaW4gdGhlIGNvbnRleHQgb2YgY29tcG9uZW50LCBub3QgcnVudGltZVxuXHRcdFx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblxuXHRcdFx0XHRpZiAoc2VsZltjb21wb25lbnRdICYmIHNlbGZbY29tcG9uZW50XVthY3Rpb25dKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGZbY29tcG9uZW50XVthY3Rpb25dLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZWxmLnNoaW1FeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdERlc3Ryb3lzIHRoZSBydW50aW1lIChyZW1vdmVzIGFsbCBldmVudHMgYW5kIGRlbGV0ZXMgRE9NIHN0cnVjdHVyZXMpXG5cblx0XHRcdEBtZXRob2QgZGVzdHJveVxuXHRcdFx0Ki9cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIXNlbGYpIHtcblx0XHRcdFx0XHRyZXR1cm47IC8vIG9idmlvdXNseSBhbHJlYWR5IGRlc3Ryb3llZFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHNoaW1Db250YWluZXIgPSBEb20uZ2V0KHRoaXMuc2hpbWlkKTtcblx0XHRcdFx0aWYgKHNoaW1Db250YWluZXIpIHtcblx0XHRcdFx0XHRzaGltQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2hpbUNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoX3NoaW0pIHtcblx0XHRcdFx0XHRfc2hpbS5yZW1vdmVBbGxJbnN0YW5jZXMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cdFx0XHRcdGRlbGV0ZSBydW50aW1lc1t0aGlzLnVpZF07XG5cdFx0XHRcdHRoaXMudWlkID0gbnVsbDsgLy8gbWFyayB0aGlzIHJ1bnRpbWUgYXMgZGVzdHJveWVkXG5cdFx0XHRcdF91aWQgPSBzZWxmID0gX3NoaW0gPSBzaGltQ29udGFpbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIG9uY2Ugd2UgZ290IHRoZSBtb2RlLCB0ZXN0IGFnYWluc3QgYWxsIGNhcHNcblx0XHRpZiAodGhpcy5tb2RlICYmIG9wdGlvbnMucmVxdWlyZWRfY2FwcyAmJiAhdGhpcy5jYW4ob3B0aW9ucy5yZXF1aXJlZF9jYXBzKSkge1xuXHRcdFx0dGhpcy5tb2RlID0gZmFsc2U7XG5cdFx0fVx0XG5cdH1cblxuXG5cdC8qKlxuXHREZWZhdWx0IG9yZGVyIHRvIHRyeSBkaWZmZXJlbnQgcnVudGltZSB0eXBlc1xuXG5cdEBwcm9wZXJ0eSBvcmRlclxuXHRAdHlwZSBTdHJpbmdcblx0QHN0YXRpY1xuXHQqL1xuXHRSdW50aW1lLm9yZGVyID0gJ2h0bWw1LGZsYXNoLHNpbHZlcmxpZ2h0LGh0bWw0JztcblxuXG5cdC8qKlxuXHRSZXRyaWV2ZXMgcnVudGltZSBmcm9tIHByaXZhdGUgaGFzaCBieSBpdCdzIHVpZFxuXG5cdEBtZXRob2QgZ2V0UnVudGltZVxuXHRAcHJpdmF0ZVxuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSB1aWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJ1bnRpbWVcblx0QHJldHVybiB7UnVudGltZXxCb29sZWFufSBSZXR1cm5zIHJ1bnRpbWUsIGlmIGl0IGV4aXN0cyBhbmQgZmFsc2UsIGlmIC0gbm90XG5cdCovXG5cdFJ1bnRpbWUuZ2V0UnVudGltZSA9IGZ1bmN0aW9uKHVpZCkge1xuXHRcdHJldHVybiBydW50aW1lc1t1aWRdID8gcnVudGltZXNbdWlkXSA6IGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdFJlZ2lzdGVyIGNvbnN0cnVjdG9yIGZvciB0aGUgUnVudGltZSBvZiBuZXcgKG9yIHBlcmhhcHMgbW9kaWZpZWQpIHR5cGVcblxuXHRAbWV0aG9kIGFkZENvbnN0cnVjdG9yXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHR5cGUgUnVudGltZSB0eXBlIChlLmcuIGZsYXNoLCBodG1sNSwgZXRjKVxuXHRAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3QgQ29uc3RydWN0b3IgZm9yIHRoZSBSdW50aW1lIHR5cGVcblx0Ki9cblx0UnVudGltZS5hZGRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHR5cGUsIGNvbnN0cnVjdG9yKSB7XG5cdFx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cdFx0cnVudGltZUNvbnN0cnVjdG9yc1t0eXBlXSA9IGNvbnN0cnVjdG9yO1xuXHR9O1xuXG5cblx0LyoqXG5cdEdldCB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cblxuXHRtZXRob2QgZ2V0Q29uc3RydWN0b3Jcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gdHlwZSBSdW50aW1lIHR5cGUgKGUuZy4gZmxhc2gsIGh0bWw1LCBldGMpXG5cdEByZXR1cm4ge0Z1bmN0aW9ufSBDb25zdHJ1Y3RvciBmb3IgdGhlIFJ1bnRpbWUgdHlwZVxuXHQqL1xuXHRSdW50aW1lLmdldENvbnN0cnVjdG9yID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiBydW50aW1lQ29uc3RydWN0b3JzW3R5cGVdIHx8IG51bGw7XG5cdH07XG5cblxuXHQvKipcblx0R2V0IGluZm8gYWJvdXQgdGhlIHJ1bnRpbWUgKHVpZCwgdHlwZSwgY2FwYWJpbGl0aWVzKVxuXG5cdEBtZXRob2QgZ2V0SW5mb1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSB1aWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJ1bnRpbWVcblx0QHJldHVybiB7TWl4ZWR9IEluZm8gb2JqZWN0IG9yIG51bGwgaWYgcnVudGltZSBkb2Vzbid0IGV4aXN0XG5cdCovXG5cdFJ1bnRpbWUuZ2V0SW5mbyA9IGZ1bmN0aW9uKHVpZCkge1xuXHRcdHZhciBydW50aW1lID0gUnVudGltZS5nZXRSdW50aW1lKHVpZCk7XG5cblx0XHRpZiAocnVudGltZSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dWlkOiBydW50aW1lLnVpZCxcblx0XHRcdFx0dHlwZTogcnVudGltZS50eXBlLFxuXHRcdFx0XHRtb2RlOiBydW50aW1lLm1vZGUsXG5cdFx0XHRcdGNhbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJ1bnRpbWUuY2FuLmFwcGx5KHJ1bnRpbWUsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdENvbnZlcnQgY2FwcyByZXByZXNlbnRlZCBieSBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgdG8gdGhlIG9iamVjdCByZXByZXNlbnRhdGlvbi5cblxuXHRAbWV0aG9kIHBhcnNlQ2Fwc1xuXHRAc3RhdGljXG5cdEBwYXJhbSB7U3RyaW5nfSBjYXBTdHIgQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgY2FwYWJpbGl0aWVzXG5cdEByZXR1cm4ge09iamVjdH1cblx0Ki9cblx0UnVudGltZS5wYXJzZUNhcHMgPSBmdW5jdGlvbihjYXBTdHIpIHtcblx0XHR2YXIgY2FwT2JqID0ge307XG5cblx0XHRpZiAoQmFzaWMudHlwZU9mKGNhcFN0cikgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gY2FwU3RyIHx8IHt9O1xuXHRcdH1cblxuXHRcdEJhc2ljLmVhY2goY2FwU3RyLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0Y2FwT2JqW2tleV0gPSB0cnVlOyAvLyB3ZSBhc3N1bWUgaXQgdG8gYmUgLSB0cnVlXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY2FwT2JqO1xuXHR9O1xuXG5cdC8qKlxuXHRUZXN0IHRoZSBzcGVjaWZpZWQgcnVudGltZSBmb3Igc3BlY2lmaWMgY2FwYWJpbGl0aWVzLlxuXG5cdEBtZXRob2QgY2FuXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd9IHR5cGUgUnVudGltZSB0eXBlIChlLmcuIGZsYXNoLCBodG1sNSwgZXRjKVxuXHRAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNhcHMgU2V0IG9mIGNhcGFiaWxpdGllcyB0byBjaGVja1xuXHRAcmV0dXJuIHtCb29sZWFufSBSZXN1bHQgb2YgdGhlIHRlc3Rcblx0Ki9cblx0UnVudGltZS5jYW4gPSBmdW5jdGlvbih0eXBlLCBjYXBzKSB7XG5cdFx0dmFyIHJ1bnRpbWVcblx0XHQsIGNvbnN0cnVjdG9yID0gUnVudGltZS5nZXRDb25zdHJ1Y3Rvcih0eXBlKVxuXHRcdCwgbW9kZVxuXHRcdDtcblx0XHRpZiAoY29uc3RydWN0b3IpIHtcblx0XHRcdHJ1bnRpbWUgPSBuZXcgY29uc3RydWN0b3Ioe1xuXHRcdFx0XHRyZXF1aXJlZF9jYXBzOiBjYXBzXG5cdFx0XHR9KTtcblx0XHRcdG1vZGUgPSBydW50aW1lLm1vZGU7XG5cdFx0XHRydW50aW1lLmRlc3Ryb3koKTtcblx0XHRcdHJldHVybiAhIW1vZGU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHRGaWd1cmUgb3V0IGEgcnVudGltZSB0aGF0IHN1cHBvcnRzIHNwZWNpZmllZCBjYXBhYmlsaXRpZXMuXG5cblx0QG1ldGhvZCB0aGF0Q2FuXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjYXBzIFNldCBvZiBjYXBhYmlsaXRpZXMgdG8gY2hlY2tcblx0QHBhcmFtIHtTdHJpbmd9IFtydW50aW1lT3JkZXJdIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJ1bnRpbWVzIHRvIGNoZWNrIGFnYWluc3Rcblx0QHJldHVybiB7U3RyaW5nfSBVc2FibGUgcnVudGltZSBpZGVudGlmaWVyIG9yIG51bGxcblx0Ki9cblx0UnVudGltZS50aGF0Q2FuID0gZnVuY3Rpb24oY2FwcywgcnVudGltZU9yZGVyKSB7XG5cdFx0dmFyIHR5cGVzID0gKHJ1bnRpbWVPcmRlciB8fCBSdW50aW1lLm9yZGVyKS5zcGxpdCgvXFxzKixcXHMqLyk7XG5cdFx0Zm9yICh2YXIgaSBpbiB0eXBlcykge1xuXHRcdFx0aWYgKFJ1bnRpbWUuY2FuKHR5cGVzW2ldLCBjYXBzKSkge1xuXHRcdFx0XHRyZXR1cm4gdHlwZXNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdEZpZ3VyZSBvdXQgYW4gb3BlcmF0aW9uYWwgbW9kZSBmb3IgdGhlIHNwZWNpZmllZCBzZXQgb2YgY2FwYWJpbGl0aWVzLlxuXG5cdEBtZXRob2QgZ2V0TW9kZVxuXHRAc3RhdGljXG5cdEBwYXJhbSB7T2JqZWN0fSBtb2RlQ2FwcyBTZXQgb2YgY2FwYWJpbGl0aWVzIHRoYXQgZGVwZW5kIG9uIHBhcnRpY3VsYXIgcnVudGltZSBtb2RlXG5cdEBwYXJhbSB7T2JqZWN0fSBbcmVxdWlyZWRDYXBzXSBTdXBwbGllZCBzZXQgb2YgY2FwYWJpbGl0aWVzIHRvIGZpbmQgb3BlcmF0aW9uYWwgbW9kZSBmb3Jcblx0QHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gW2RlZmF1bHRNb2RlPSdicm93c2VyJ10gRGVmYXVsdCBtb2RlIHRvIHVzZSBcblx0QHJldHVybiB7U3RyaW5nfEJvb2xlYW59IENvbXBhdGlibGUgb3BlcmF0aW9uYWwgbW9kZVxuXHQqL1xuXHRSdW50aW1lLmdldE1vZGUgPSBmdW5jdGlvbihtb2RlQ2FwcywgcmVxdWlyZWRDYXBzLCBkZWZhdWx0TW9kZSkge1xuXHRcdHZhciBtb2RlID0gbnVsbDtcblxuXHRcdGlmIChCYXNpYy50eXBlT2YoZGVmYXVsdE1vZGUpID09PSAndW5kZWZpbmVkJykgeyAvLyBvbmx5IGlmIG5vdCBzcGVjaWZpZWRcblx0XHRcdGRlZmF1bHRNb2RlID0gJ2Jyb3dzZXInO1xuXHRcdH1cblxuXHRcdGlmIChyZXF1aXJlZENhcHMgJiYgIUJhc2ljLmlzRW1wdHlPYmoobW9kZUNhcHMpKSB7XG5cdFx0XHQvLyBsb29wIG92ZXIgcmVxdWlyZWQgY2FwcyBhbmQgY2hlY2sgaWYgdGhleSBkbyByZXF1aXJlIHRoZSBzYW1lIG1vZGVcblx0XHRcdEJhc2ljLmVhY2gocmVxdWlyZWRDYXBzLCBmdW5jdGlvbih2YWx1ZSwgY2FwKSB7XG5cdFx0XHRcdGlmIChtb2RlQ2Fwcy5oYXNPd25Qcm9wZXJ0eShjYXApKSB7XG5cdFx0XHRcdFx0dmFyIGNhcE1vZGUgPSBtb2RlQ2Fwc1tjYXBdKHZhbHVlKTtcblxuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhbiBhcnJheVxuXHRcdFx0XHRcdGlmICh0eXBlb2YoY2FwTW9kZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRjYXBNb2RlID0gW2NhcE1vZGVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIW1vZGUpIHtcblx0XHRcdFx0XHRcdG1vZGUgPSBjYXBNb2RlO1x0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIShtb2RlID0gQmFzaWMuYXJyYXlJbnRlcnNlY3QobW9kZSwgY2FwTW9kZSkpKSB7XG5cdFx0XHRcdFx0XHQvLyBpZiBjYXAgcmVxdWlyZXMgY29uZmxpY3RpbmcgbW9kZSAtIHJ1bnRpbWUgY2Fubm90IGZ1bGZpbGwgcmVxdWlyZWQgY2Fwc1xuXG5cdFx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRcdEVudi5sb2coXCJcXHRcXHQlYzogJXYgKGNvbmZsaWN0aW5nIG1vZGUgcmVxdWVzdGVkOiAlcylcIiwgY2FwLCB2YWx1ZSwgY2FwTW9kZSk7XHRcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIChtb2RlID0gZmFsc2UpO1xuXHRcdFx0XHRcdH1cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0RW52LmxvZyhcIlxcdFxcdCVjOiAldiAoY29tcGF0aWJsZSBtb2RlczogJXMpXCIsIGNhcCwgdmFsdWUsIG1vZGUpO1x0XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAobW9kZSkge1xuXHRcdFx0XHRyZXR1cm4gQmFzaWMuaW5BcnJheShkZWZhdWx0TW9kZSwgbW9kZSkgIT09IC0xID8gZGVmYXVsdE1vZGUgOiBtb2RlWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChtb2RlID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZWZhdWx0TW9kZTsgXG5cdH07XG5cblxuXHQvKipcblx0Q2FwYWJpbGl0eSBjaGVjayB0aGF0IGFsd2F5cyByZXR1cm5zIHRydWVcblxuXHRAcHJpdmF0ZVxuXHRAc3RhdGljXG5cdEByZXR1cm4ge1RydWV9XG5cdCovXG5cdFJ1bnRpbWUuY2FwVHJ1ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHRDYXBhYmlsaXR5IGNoZWNrIHRoYXQgYWx3YXlzIHJldHVybnMgZmFsc2VcblxuXHRAcHJpdmF0ZVxuXHRAc3RhdGljXG5cdEByZXR1cm4ge0ZhbHNlfVxuXHQqL1xuXHRSdW50aW1lLmNhcEZhbHNlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHRFdmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiB0byBib29sZWFuIHZhbHVlIGFuZCBjcmVhdGUgYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGl0LlxuXG5cdEBwcml2YXRlXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtNaXhlZH0gZXhwciBFeHByZXNzaW9uIHRvIGV2YWx1YXRlXG5cdEByZXR1cm4ge0Z1bmN0aW9ufSBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiBldmFsdWF0aW9uXG5cdCovXG5cdFJ1bnRpbWUuY2FwVGVzdCA9IGZ1bmN0aW9uKGV4cHIpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gISFleHByO1xuXHRcdH07XG5cdH07XG5cblx0cmV0dXJuIFJ1bnRpbWU7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9SdW50aW1lQ2xpZW50LmpzXG5cbi8qKlxuICogUnVudGltZUNsaWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL3J1bnRpbWUvUnVudGltZUNsaWVudCcsIFtcblx0J21veGllL2NvcmUvdXRpbHMvRW52Jyxcblx0J21veGllL2NvcmUvRXhjZXB0aW9ucycsXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJyxcblx0J21veGllL3J1bnRpbWUvUnVudGltZSdcbl0sIGZ1bmN0aW9uKEVudiwgeCwgQmFzaWMsIFJ1bnRpbWUpIHtcblx0LyoqXG5cdFNldCBvZiBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzLCByZXF1aXJlZCBieSBhIGNvbXBvbmVudCB0byBhY3F1aXJlIGFiaWxpdHkgdG8gY29ubmVjdCB0byBhIHJ1bnRpbWVcblxuXHRAY2xhc3MgbW94aWUvcnVudGltZS9SdW50aW1lQ2xpZW50XG5cdCovXG5cdHJldHVybiBmdW5jdGlvbiBSdW50aW1lQ2xpZW50KCkge1xuXHRcdHZhciBydW50aW1lO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0Q29ubmVjdHMgdG8gdGhlIHJ1bnRpbWUgc3BlY2lmaWVkIGJ5IHRoZSBvcHRpb25zLiBXaWxsIGVpdGhlciBjb25uZWN0IHRvIGV4aXN0aW5nIHJ1bnRpbWUgb3IgY3JlYXRlIGEgbmV3IG9uZS5cblx0XHRcdEluY3JlbWVudHMgbnVtYmVyIG9mIGNsaWVudHMgY29ubmVjdGVkIHRvIHRoZSBzcGVjaWZpZWQgcnVudGltZS5cblxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBtZXRob2QgY29ubmVjdFJ1bnRpbWVcblx0XHRcdEBwYXJhbSB7TWl4ZWR9IG9wdGlvbnMgQ2FuIGJlIGEgcnVudG1lIHVpZCBvciBhIHNldCBvZiBrZXktdmFsdWUgcGFpcnMgZGVmaW5pbmcgcmVxdWlyZW1lbnRzIGFuZCBwcmUtcmVxdWlzaXRlc1xuXHRcdFx0Ki9cblx0XHRcdGNvbm5lY3RSdW50aW1lOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBjb21wID0gdGhpcywgcnVpZDtcblxuXHRcdFx0XHRmdW5jdGlvbiBpbml0aWFsaXplKGl0ZW1zKSB7XG5cdFx0XHRcdFx0dmFyIHR5cGUsIGNvbnN0cnVjdG9yO1xuXG5cdFx0XHRcdFx0Ly8gaWYgd2UgcmFuIG91dCBvZiBydW50aW1lc1xuXHRcdFx0XHRcdGlmICghaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb21wLnRyaWdnZXIoJ1J1bnRpbWVFcnJvcicsIG5ldyB4LlJ1bnRpbWVFcnJvcih4LlJ1bnRpbWVFcnJvci5OT1RfSU5JVF9FUlIpKTtcblx0XHRcdFx0XHRcdHJ1bnRpbWUgPSBudWxsO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHR5cGUgPSBpdGVtcy5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0Y29uc3RydWN0b3IgPSBSdW50aW1lLmdldENvbnN0cnVjdG9yKHR5cGUpO1xuXHRcdFx0XHRcdGlmICghY29uc3RydWN0b3IpIHtcblx0XHRcdFx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdFx0RW52LmxvZyhcIkNvbnN0cnVjdG9yIGZvciAnJXMnIHJ1bnRpbWUgaXMgbm90IGF2YWlsYWJsZS5cIiwgdHlwZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbml0aWFsaXplKGl0ZW1zKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRFbnYubG9nKFwiVHJ5aW5nIHJ1bnRpbWU6ICVzXCIsIHR5cGUpO1xuXHRcdFx0XHRcdFx0RW52LmxvZyhvcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0cnkgaW5pdGlhbGl6aW5nIHRoZSBydW50aW1lXG5cdFx0XHRcdFx0cnVudGltZSA9IG5ldyBjb25zdHJ1Y3RvcihvcHRpb25zKTtcblxuXHRcdFx0XHRcdHJ1bnRpbWUuYmluZCgnSW5pdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Ly8gbWFyayBydW50aW1lIGFzIGluaXRpYWxpemVkXG5cdFx0XHRcdFx0XHRydW50aW1lLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcucnVudGltZSkge1xuXHRcdFx0XHRcdFx0XHRFbnYubG9nKFwiUnVudGltZSAnJXMnIGluaXRpYWxpemVkXCIsIHJ1bnRpbWUudHlwZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGphaWxicmVhayAuLi5cblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bnRpbWUuY2xpZW50cysrO1xuXHRcdFx0XHRcdFx0XHRjb21wLnJ1aWQgPSBydW50aW1lLnVpZDtcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyB3aWxsIGJlIHRyaWdnZXJlZCBvbiBjb21wb25lbnRcblx0XHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdSdW50aW1lSW5pdCcsIHJ1bnRpbWUpO1xuXHRcdFx0XHRcdFx0fSwgMSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRydW50aW1lLmJpbmQoJ0Vycm9yJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoTVhJX0RFQlVHICYmIEVudi5kZWJ1Zy5ydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRcdEVudi5sb2coXCJSdW50aW1lICclcycgZmFpbGVkIHRvIGluaXRpYWxpemVcIiwgcnVudGltZS50eXBlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cnVudGltZS5kZXN0cm95KCk7IC8vIHJ1bnRpbWUgY2Fubm90IGRlc3Ryb3kgaXRzZWxmIGZyb20gaW5zaWRlIGF0IGEgcmlnaHQgbW9tZW50LCB0aHVzIHdlIGRvIGl0IGhlcmVcblx0XHRcdFx0XHRcdGluaXRpYWxpemUoaXRlbXMpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cnVudGltZS5iaW5kKCdFeGNlcHRpb24nLCBmdW5jdGlvbihlLCBlcnIpIHtcblx0XHRcdFx0XHRcdHZhciBtZXNzYWdlID0gZXJyLm5hbWUgKyBcIigjXCIgKyBlcnIuY29kZSArIFwiKVwiICsgKGVyci5tZXNzYWdlID8gXCIsIGZyb206IFwiICsgZXJyLm1lc3NhZ2UgOiAnJyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdFx0RW52LmxvZyhcIlJ1bnRpbWUgJyVzJyBoYXMgdGhyb3duIGFuIGV4Y2VwdGlvbjogJXNcIiwgdGhpcy50eXBlLCBtZXNzYWdlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbXAudHJpZ2dlcignUnVudGltZUVycm9yJywgbmV3IHguUnVudGltZUVycm9yKHguUnVudGltZUVycm9yLkVYQ0VQVElPTl9FUlIsIG1lc3NhZ2UpKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdEVudi5sb2coXCJcXHRzZWxlY3RlZCBtb2RlOiAlc1wiLCBydW50aW1lLm1vZGUpO1x0XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgcnVudGltZSBtYW5hZ2VkIHRvIHBpY2stdXAgb3BlcmF0aW9uYWwgbW9kZVxuXHRcdFx0XHRcdGlmICghcnVudGltZS5tb2RlKSB7XG5cdFx0XHRcdFx0XHRydW50aW1lLnRyaWdnZXIoJ0Vycm9yJyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cnVudGltZS5pbml0KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBpZiBhIHBhcnRpY3VsYXIgcnVudGltZSB3YXMgcmVxdWVzdGVkXG5cdFx0XHRcdGlmIChCYXNpYy50eXBlT2Yob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cnVpZCA9IG9wdGlvbnM7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQmFzaWMudHlwZU9mKG9wdGlvbnMucnVpZCkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cnVpZCA9IG9wdGlvbnMucnVpZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChydWlkKSB7XG5cdFx0XHRcdFx0cnVudGltZSA9IFJ1bnRpbWUuZ2V0UnVudGltZShydWlkKTtcblx0XHRcdFx0XHRpZiAocnVudGltZSkge1xuXHRcdFx0XHRcdFx0Y29tcC5ydWlkID0gcnVpZDtcblx0XHRcdFx0XHRcdHJ1bnRpbWUuY2xpZW50cysrO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJ1bnRpbWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHRoZXJlIHNob3VsZCBiZSBhIHJ1bnRpbWUgYW5kIHRoZXJlJ3Mgbm9uZSAtIHdlaXJkIGNhc2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyB4LlJ1bnRpbWVFcnJvcih4LlJ1bnRpbWVFcnJvci5OT1RfSU5JVF9FUlIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGluaXRpYWxpemUgYSBmcmVzaCBvbmUsIHRoYXQgZml0cyBydW50aW1lIGxpc3QgYW5kIHJlcXVpcmVkIGZlYXR1cmVzIGJlc3Rcblx0XHRcdFx0aW5pdGlhbGl6ZSgob3B0aW9ucy5ydW50aW1lX29yZGVyIHx8IFJ1bnRpbWUub3JkZXIpLnNwbGl0KC9cXHMqLFxccyovKSk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0RGlzY29ubmVjdHMgZnJvbSB0aGUgcnVudGltZS4gRGVjcmVtZW50cyBudW1iZXIgb2YgY2xpZW50cyBjb25uZWN0ZWQgdG8gdGhlIHNwZWNpZmllZCBydW50aW1lLlxuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QG1ldGhvZCBkaXNjb25uZWN0UnVudGltZVxuXHRcdFx0Ki9cblx0XHRcdGRpc2Nvbm5lY3RSdW50aW1lOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHJ1bnRpbWUgJiYgLS1ydW50aW1lLmNsaWVudHMgPD0gMCkge1xuXHRcdFx0XHRcdHJ1bnRpbWUuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gb25jZSB0aGUgY29tcG9uZW50IGlzIGRpc2Nvbm5lY3RlZCwgaXQgc2hvdWxkbid0IGhhdmUgYWNjZXNzIHRvIHRoZSBydW50aW1lXG5cdFx0XHRcdHJ1bnRpbWUgPSBudWxsO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdFJldHVybnMgdGhlIHJ1bnRpbWUgdG8gd2hpY2ggdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgY29ubmVjdGVkLlxuXG5cdFx0XHRAbWV0aG9kIGdldFJ1bnRpbWVcblx0XHRcdEByZXR1cm4ge1J1bnRpbWV9IFJ1bnRpbWUgb3IgbnVsbCBpZiBjbGllbnQgaXMgbm90IGNvbm5lY3RlZFxuXHRcdFx0Ki9cblx0XHRcdGdldFJ1bnRpbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAocnVudGltZSAmJiBydW50aW1lLnVpZCkge1xuXHRcdFx0XHRcdHJldHVybiBydW50aW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBydW50aW1lID0gbnVsbDsgLy8gbWFrZSBzdXJlIHdlIGRvIG5vdCBsZWF2ZSB6b21iaWVzIHJhbWJsaW5nIGFyb3VuZFxuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdEhhbmR5IHNob3J0Y3V0IHRvIHNhZmVseSBpbnZva2UgcnVudGltZSBleHRlbnNpb24gbWV0aG9kcy5cblx0XHRcdFxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBtZXRob2QgZXhlY1xuXHRcdFx0QHJldHVybiB7TWl4ZWR9IFdoYXRldmVyIHJ1bnRpbWUgZXh0ZW5zaW9uIG1ldGhvZCByZXR1cm5zXG5cdFx0XHQqL1xuXHRcdFx0ZXhlYzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBydW50aW1lID8gcnVudGltZS5leGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBudWxsO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdFRlc3QgcnVudGltZSBjbGllbnQgZm9yIHNwZWNpZmljIGNhcGFiaWxpdHlcblx0XHRcdFxuXHRcdFx0QG1ldGhvZCBjYW5cblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBjYXBcblx0XHRcdEByZXR1cm4ge0Jvb2x9XG5cdFx0XHQqL1xuXHRcdFx0Y2FuOiBmdW5jdGlvbihjYXApIHtcblx0XHRcdFx0cmV0dXJuIHJ1bnRpbWUgPyBydW50aW1lLmNhbihjYXApIDogZmFsc2U7XG5cdFx0XHR9XG5cblx0XHR9KTtcblx0fTtcblxuXG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvZmlsZS9CbG9iLmpzXG5cbi8qKlxuICogQmxvYi5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL2ZpbGUvQmxvYicsIFtcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnLFxuXHQnbW94aWUvY29yZS91dGlscy9FbmNvZGUnLFxuXHQnbW94aWUvcnVudGltZS9SdW50aW1lQ2xpZW50J1xuXSwgZnVuY3Rpb24oQmFzaWMsIEVuY29kZSwgUnVudGltZUNsaWVudCkge1xuXHRcblx0dmFyIGJsb2Jwb29sID0ge307XG5cblx0LyoqXG5cdEBjbGFzcyBtb3hpZS9maWxlL0Jsb2Jcblx0QGNvbnN0cnVjdG9yXG5cdEBwYXJhbSB7U3RyaW5nfSBydWlkIFVuaXF1ZSBpZCBvZiB0aGUgcnVudGltZSwgdG8gd2hpY2ggdGhpcyBibG9iIGJlbG9uZ3MgdG9cblx0QHBhcmFtIHtPYmplY3R9IGJsb2IgT2JqZWN0IFwiTmF0aXZlXCIgYmxvYiBvYmplY3QsIGFzIGl0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBydW50aW1lXG5cdCovXG5cdGZ1bmN0aW9uIEJsb2IocnVpZCwgYmxvYikge1xuXG5cdFx0ZnVuY3Rpb24gX3NsaWNlRGV0YWNoZWQoc3RhcnQsIGVuZCwgdHlwZSkge1xuXHRcdFx0dmFyIGJsb2IsIGRhdGEgPSBibG9icG9vbFt0aGlzLnVpZF07XG5cblx0XHRcdGlmIChCYXNpYy50eXBlT2YoZGF0YSkgIT09ICdzdHJpbmcnIHx8ICFkYXRhLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDsgLy8gb3IgdGhyb3cgZXhjZXB0aW9uXG5cdFx0XHR9XG5cblx0XHRcdGJsb2IgPSBuZXcgQmxvYihudWxsLCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdHNpemU6IGVuZCAtIHN0YXJ0XG5cdFx0XHR9KTtcblx0XHRcdGJsb2IuZGV0YWNoKGRhdGEuc3Vic3RyKHN0YXJ0LCBibG9iLnNpemUpKTtcblxuXHRcdFx0cmV0dXJuIGJsb2I7XG5cdFx0fVxuXG5cdFx0UnVudGltZUNsaWVudC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHJ1aWQpIHtcdFxuXHRcdFx0dGhpcy5jb25uZWN0UnVudGltZShydWlkKTtcblx0XHR9XG5cblx0XHRpZiAoIWJsb2IpIHtcblx0XHRcdGJsb2IgPSB7fTtcblx0XHR9IGVsc2UgaWYgKEJhc2ljLnR5cGVPZihibG9iKSA9PT0gJ3N0cmluZycpIHsgLy8gZGF0YVVybCBvciBiaW5hcnkgc3RyaW5nXG5cdFx0XHRibG9iID0geyBkYXRhOiBibG9iIH07XG5cdFx0fVxuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRVbmlxdWUgaWQgb2YgdGhlIGNvbXBvbmVudFxuXG5cdFx0XHRAcHJvcGVydHkgdWlkXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0Ki9cblx0XHRcdHVpZDogYmxvYi51aWQgfHwgQmFzaWMuZ3VpZCgndWlkXycpLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdFVuaXF1ZSBpZCBvZiB0aGUgY29ubmVjdGVkIHJ1bnRpbWUsIGlmIGZhbHN5LCB0aGVuIHJ1bnRpbWUgd2lsbCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIFxuXHRcdFx0YmVmb3JlIHRoaXMgQmxvYiBjYW4gYmUgdXNlZCwgbW9kaWZpZWQgb3Igc2VudFxuXG5cdFx0XHRAcHJvcGVydHkgcnVpZFxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdCovXG5cdFx0XHRydWlkOiBydWlkLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0U2l6ZSBvZiBibG9iXG5cblx0XHRcdEBwcm9wZXJ0eSBzaXplXG5cdFx0XHRAdHlwZSB7TnVtYmVyfVxuXHRcdFx0QGRlZmF1bHQgMFxuXHRcdFx0Ki9cblx0XHRcdHNpemU6IGJsb2Iuc2l6ZSB8fCAwLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdE1pbWUgdHlwZSBvZiBibG9iXG5cblx0XHRcdEBwcm9wZXJ0eSB0eXBlXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0QGRlZmF1bHQgJydcblx0XHRcdCovXG5cdFx0XHR0eXBlOiBibG9iLnR5cGUgfHwgJycsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0QG1ldGhvZCBzbGljZVxuXHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtzdGFydD0wXVxuXHRcdFx0Ki9cblx0XHRcdHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kLCB0eXBlKSB7XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5pc0RldGFjaGVkKCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3NsaWNlRGV0YWNoZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSdW50aW1lKCkuZXhlYy5jYWxsKHRoaXMsICdCbG9iJywgJ3NsaWNlJywgdGhpcy5nZXRTb3VyY2UoKSwgc3RhcnQsIGVuZCwgdHlwZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHVybnMgXCJuYXRpdmVcIiBibG9iIG9iamVjdCAoYXMgaXQgaXMgcmVwcmVzZW50ZWQgaW4gY29ubmVjdGVkIHJ1bnRpbWUpIG9yIG51bGwgaWYgbm90IGZvdW5kXG5cblx0XHRcdEBtZXRob2QgZ2V0U291cmNlXG5cdFx0XHRAcmV0dXJuIHtCbG9ifSBSZXR1cm5zIFwibmF0aXZlXCIgYmxvYiBvYmplY3Qgb3IgbnVsbCBpZiBub3QgZm91bmRcblx0XHRcdCovXG5cdFx0XHRnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIWJsb2Jwb29sW3RoaXMudWlkXSkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1x0XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGJsb2Jwb29sW3RoaXMudWlkXTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKiBcblx0XHRcdERldGFjaGVzIGJsb2IgZnJvbSBhbnkgcnVudGltZSB0aGF0IGl0IGRlcGVuZHMgb24gYW5kIGluaXRpYWxpemUgd2l0aCBzdGFuZGFsb25lIHZhbHVlXG5cblx0XHRcdEBtZXRob2QgZGV0YWNoXG5cdFx0XHRAcHJvdGVjdGVkXG5cdFx0XHRAcGFyYW0ge0RPTVN0cmluZ30gW2RhdGE9JyddIFN0YW5kYWxvbmUgdmFsdWVcblx0XHRcdCovXG5cdFx0XHRkZXRhY2g6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0aWYgKHRoaXMucnVpZCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0UnVudGltZSgpLmV4ZWMuY2FsbCh0aGlzLCAnQmxvYicsICdkZXN0cm95Jyk7XG5cdFx0XHRcdFx0dGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuXHRcdFx0XHRcdHRoaXMucnVpZCA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCAnJztcblxuXHRcdFx0XHQvLyBpZiBkYXRhVXJsLCBjb252ZXJ0IHRvIGJpbmFyeSBzdHJpbmdcblx0XHRcdFx0aWYgKGRhdGEuc3Vic3RyKDAsIDUpID09ICdkYXRhOicpIHtcblx0XHRcdFx0XHR2YXIgYmFzZTY0T2Zmc2V0ID0gZGF0YS5pbmRleE9mKCc7YmFzZTY0LCcpO1xuXHRcdFx0XHRcdHRoaXMudHlwZSA9IGRhdGEuc3Vic3RyaW5nKDUsIGJhc2U2NE9mZnNldCk7XG5cdFx0XHRcdFx0ZGF0YSA9IEVuY29kZS5hdG9iKGRhdGEuc3Vic3RyaW5nKGJhc2U2NE9mZnNldCArIDgpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2l6ZSA9IGRhdGEubGVuZ3RoO1xuXG5cdFx0XHRcdGJsb2Jwb29sW3RoaXMudWlkXSA9IGRhdGE7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdENoZWNrcyBpZiBibG9iIGlzIHN0YW5kYWxvbmUgKGRldGFjaGVkIG9mIGFueSBydW50aW1lKVxuXHRcdFx0XG5cdFx0XHRAbWV0aG9kIGlzRGV0YWNoZWRcblx0XHRcdEBwcm90ZWN0ZWRcblx0XHRcdEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0XHQqL1xuXHRcdFx0aXNEZXRhY2hlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhdGhpcy5ydWlkICYmIEJhc2ljLnR5cGVPZihibG9icG9vbFt0aGlzLnVpZF0pID09PSAnc3RyaW5nJztcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKiBcblx0XHRcdERlc3Ryb3kgQmxvYiBhbmQgZnJlZSBhbnkgcmVzb3VyY2VzIGl0IHdhcyB1c2luZ1xuXG5cdFx0XHRAbWV0aG9kIGRlc3Ryb3lcblx0XHRcdCovXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kZXRhY2goKTtcblx0XHRcdFx0ZGVsZXRlIGJsb2Jwb29sW3RoaXMudWlkXTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdFxuXHRcdGlmIChibG9iLmRhdGEpIHtcblx0XHRcdHRoaXMuZGV0YWNoKGJsb2IuZGF0YSk7IC8vIGF1dG8tZGV0YWNoIGlmIHBheWxvYWQgaGFzIGJlZW4gcGFzc2VkXG5cdFx0fSBlbHNlIHtcblx0XHRcdGJsb2Jwb29sW3RoaXMudWlkXSA9IGJsb2I7XHRcblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiBCbG9iO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L2NvcmUvSTE4bi5qc1xuXG4vKipcbiAqIEkxOG4uanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKFwibW94aWUvY29yZS9JMThuXCIsIFtcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCJcbl0sIGZ1bmN0aW9uKEJhc2ljKSB7XG5cdHZhciBpMThuID0ge307XG5cblx0LyoqXG5cdEBjbGFzcyBtb3hpZS9jb3JlL0kxOG5cblx0Ki9cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBFeHRlbmRzIHRoZSBsYW5ndWFnZSBwYWNrIG9iamVjdCB3aXRoIG5ldyBpdGVtcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrIExhbmd1YWdlIHBhY2sgaXRlbXMgdG8gYWRkLlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5kZWQgbGFuZ3VhZ2UgcGFjayBvYmplY3QuXG5cdFx0ICovXG5cdFx0YWRkSTE4bjogZnVuY3Rpb24ocGFjaykge1xuXHRcdFx0cmV0dXJuIEJhc2ljLmV4dGVuZChpMThuLCBwYWNrKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNsYXRlcyB0aGUgc3BlY2lmaWVkIHN0cmluZyBieSBjaGVja2luZyBmb3IgdGhlIGVuZ2xpc2ggc3RyaW5nIGluIHRoZSBsYW5ndWFnZSBwYWNrIGxvb2t1cC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIGxvb2sgZm9yLlxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gVHJhbnNsYXRlZCBzdHJpbmcgb3IgdGhlIGlucHV0IHN0cmluZyBpZiBpdCB3YXNuJ3QgZm91bmQuXG5cdFx0ICovXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBpMThuW3N0cl0gfHwgc3RyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTaG9ydGN1dCBmb3IgdHJhbnNsYXRlIGZ1bmN0aW9uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBsb29rIGZvci5cblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRyYW5zbGF0ZWQgc3RyaW5nIG9yIHRoZSBpbnB1dCBzdHJpbmcgaWYgaXQgd2Fzbid0IGZvdW5kLlxuXHRcdCAqL1xuXHRcdF86IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlKHN0cik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBzZXVkbyBzcHJpbnRmIGltcGxlbWVudGF0aW9uIC0gc2ltcGxlIHdheSB0byByZXBsYWNlIHRva2VucyB3aXRoIHNwZWNpZmllZCB2YWx1ZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB3aXRoIHRva2Vuc1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHdpdGggcmVwbGFjZWQgdG9rZW5zXG5cdFx0ICovXG5cdFx0c3ByaW50ZjogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8lW2Etel0vZywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGFyZ3Muc2hpZnQoKTtcblx0XHRcdFx0cmV0dXJuIEJhc2ljLnR5cGVPZih2YWx1ZSkgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAnJztcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL3V0aWxzL01pbWUuanNcblxuLyoqXG4gKiBNaW1lLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZShcIm1veGllL2NvcmUvdXRpbHMvTWltZVwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvSTE4blwiXG5dLCBmdW5jdGlvbihCYXNpYywgSTE4bikge1xuXHRcblx0dmFyIG1pbWVEYXRhID0gXCJcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi9tc3dvcmQsZG9jIGRvdCxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi9wZGYscGRmLFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmUscGdwLFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3Bvc3RzY3JpcHQscHMgYWkgZXBzLFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3J0ZixydGYsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLHhscyB4bGIsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQscHB0IHBwcyBwb3QsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vemlwLHppcCxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCxzd2Ygc3dmbCxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCxkb2N4LFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlLGRvdHgsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQseGxzeCxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uLHBwdHgsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnRlbXBsYXRlLHBvdHgsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlc2hvdyxwcHN4LFwiICtcblx0XHRcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCxqcyxcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi9qc29uLGpzb24sXCIgK1xuXHRcdFwiYXVkaW8vbXBlZyxtcDMgbXBnYSBtcGVnYSBtcDIsXCIgK1xuXHRcdFwiYXVkaW8veC13YXYsd2F2LFwiICtcblx0XHRcImF1ZGlvL3gtbTRhLG00YSxcIiArXG5cdFx0XCJhdWRpby9vZ2csb2dhIG9nZyxcIiArXG5cdFx0XCJhdWRpby9haWZmLGFpZmYgYWlmLFwiICtcblx0XHRcImF1ZGlvL2ZsYWMsZmxhYyxcIiArXG5cdFx0XCJhdWRpby9hYWMsYWFjLFwiICtcblx0XHRcImF1ZGlvL2FjMyxhYzMsXCIgK1xuXHRcdFwiYXVkaW8veC1tcy13bWEsd21hLFwiICtcblx0XHRcImltYWdlL2JtcCxibXAsXCIgK1xuXHRcdFwiaW1hZ2UvZ2lmLGdpZixcIiArXG5cdFx0XCJpbWFnZS9qcGVnLGpwZyBqcGVnIGpwZSxcIiArXG5cdFx0XCJpbWFnZS9waG90b3Nob3AscHNkLFwiICtcblx0XHRcImltYWdlL3BuZyxwbmcsXCIgK1xuXHRcdFwiaW1hZ2Uvc3ZnK3htbCxzdmcgc3ZneixcIiArXG5cdFx0XCJpbWFnZS90aWZmLHRpZmYgdGlmLFwiICtcblx0XHRcInRleHQvcGxhaW4sYXNjIHR4dCB0ZXh0IGRpZmYgbG9nLFwiICtcblx0XHRcInRleHQvaHRtbCxodG0gaHRtbCB4aHRtbCxcIiArXG5cdFx0XCJ0ZXh0L2Nzcyxjc3MsXCIgK1xuXHRcdFwidGV4dC9jc3YsY3N2LFwiICtcblx0XHRcInRleHQvcnRmLHJ0ZixcIiArXG5cdFx0XCJ2aWRlby9tcGVnLG1wZWcgbXBnIG1wZSBtMnYsXCIgK1xuXHRcdFwidmlkZW8vcXVpY2t0aW1lLHF0IG1vdixcIiArXG5cdFx0XCJ2aWRlby9tcDQsbXA0LFwiICtcblx0XHRcInZpZGVvL3gtbTR2LG00dixcIiArXG5cdFx0XCJ2aWRlby94LWZsdixmbHYsXCIgK1xuXHRcdFwidmlkZW8veC1tcy13bXYsd212LFwiICtcblx0XHRcInZpZGVvL2F2aSxhdmksXCIgK1xuXHRcdFwidmlkZW8vd2VibSx3ZWJtLFwiICtcblx0XHRcInZpZGVvLzNncHAsM2dwcCAzZ3AsXCIgK1xuXHRcdFwidmlkZW8vM2dwcDIsM2cyLFwiICtcblx0XHRcInZpZGVvL3ZuZC5ybi1yZWFsdmlkZW8scnYsXCIgK1xuXHRcdFwidmlkZW8vb2dnLG9ndixcIiArIFxuXHRcdFwidmlkZW8veC1tYXRyb3NrYSxta3YsXCIgK1xuXHRcdFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhLXRlbXBsYXRlLG90ZixcIiArXG5cdFx0XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0sZXhlXCI7XG5cdFxuXHRcblx0dmFyIE1pbWUgPSB7XG5cblx0XHRtaW1lczoge30sXG5cblx0XHRleHRlbnNpb25zOiB7fSxcblxuXHRcdC8vIFBhcnNlcyB0aGUgZGVmYXVsdCBtaW1lIHR5cGVzIHN0cmluZyBpbnRvIGEgbWltZXMgYW5kIGV4dGVuc2lvbnMgbG9va3VwIG1hcHNcblx0XHRhZGRNaW1lVHlwZTogZnVuY3Rpb24gKG1pbWVEYXRhKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBtaW1lRGF0YS5zcGxpdCgvLC8pLCBpLCBpaSwgZXh0O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0ZXh0ID0gaXRlbXNbaSArIDFdLnNwbGl0KC8gLyk7XG5cblx0XHRcdFx0Ly8gZXh0ZW5zaW9uIHRvIG1pbWUgbG9va3VwXG5cdFx0XHRcdGZvciAoaWkgPSAwOyBpaSA8IGV4dC5sZW5ndGg7IGlpKyspIHtcblx0XHRcdFx0XHR0aGlzLm1pbWVzW2V4dFtpaV1dID0gaXRlbXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbWltZSB0byBleHRlbnNpb24gbG9va3VwXG5cdFx0XHRcdHRoaXMuZXh0ZW5zaW9uc1tpdGVtc1tpXV0gPSBleHQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXG5cdFx0ZXh0TGlzdDJtaW1lczogZnVuY3Rpb24gKGZpbHRlcnMsIGFkZE1pc3NpbmdFeHRlbnNpb25zKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIGV4dCwgaSwgaWksIHR5cGUsIG1pbWVzID0gW107XG5cdFx0XHRcblx0XHRcdC8vIGNvbnZlcnQgZXh0ZW5zaW9ucyB0byBtaW1lIHR5cGVzIGxpc3Rcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGV4dCA9IGZpbHRlcnNbaV0uZXh0ZW5zaW9ucy50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMqLFxccyovKTtcblxuXHRcdFx0XHRmb3IgKGlpID0gMDsgaWkgPCBleHQubGVuZ3RoOyBpaSsrKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUncyBhbiBhc3RlcmlzayBpbiB0aGUgbGlzdCwgdGhlbiBhY2NlcHQgYXR0cmlidXRlIGlzIG5vdCByZXF1aXJlZFxuXHRcdFx0XHRcdGlmIChleHRbaWldID09PSAnKicpIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0eXBlID0gc2VsZi5taW1lc1tleHRbaWldXTtcblxuXHRcdFx0XHRcdC8vIGZ1dHVyZSBicm93c2VycyBzaG91bGQgZmlsdGVyIGJ5IGV4dGVuc2lvbiwgZmluYWxseVxuXHRcdFx0XHRcdGlmIChhZGRNaXNzaW5nRXh0ZW5zaW9ucyAmJiAvXlxcdyskLy50ZXN0KGV4dFtpaV0pKSB7XG5cdFx0XHRcdFx0XHRtaW1lcy5wdXNoKCcuJyArIGV4dFtpaV0pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSAmJiBCYXNpYy5pbkFycmF5KHR5cGUsIG1pbWVzKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdG1pbWVzLnB1c2godHlwZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghdHlwZSkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgaGF2ZSBubyB0eXBlIGluIG91ciBtYXAsIHRoZW4gYWNjZXB0IGFsbFxuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1pbWVzO1xuXHRcdH0sXG5cblxuXHRcdG1pbWVzMmV4dHM6IGZ1bmN0aW9uKG1pbWVzKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIGV4dHMgPSBbXTtcblx0XHRcdFxuXHRcdFx0QmFzaWMuZWFjaChtaW1lcywgZnVuY3Rpb24obWltZSkge1xuXHRcdFx0XHRtaW1lID0gbWltZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdGlmIChtaW1lID09PSAnKicpIHtcblx0XHRcdFx0XHRleHRzID0gW107XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhpcyB0aGluZyBsb29rcyBsaWtlIG1pbWUgdHlwZVxuXHRcdFx0XHR2YXIgbSA9IG1pbWUubWF0Y2goL14oXFx3KylcXC8oXFwqfFxcdyspJC8pO1xuXHRcdFx0XHRpZiAobSkge1xuXHRcdFx0XHRcdGlmIChtWzJdID09PSAnKicpIHsgXG5cdFx0XHRcdFx0XHQvLyB3aWxkY2FyZCBtaW1lIHR5cGUgZGV0ZWN0ZWRcblx0XHRcdFx0XHRcdEJhc2ljLmVhY2goc2VsZi5leHRlbnNpb25zLCBmdW5jdGlvbihhcnIsIG1pbWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKChuZXcgUmVnRXhwKCdeJyArIG1bMV0gKyAnLycpKS50ZXN0KG1pbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0W10ucHVzaC5hcHBseShleHRzLCBzZWxmLmV4dGVuc2lvbnNbbWltZV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuZXh0ZW5zaW9uc1ttaW1lXSkge1xuXHRcdFx0XHRcdFx0W10ucHVzaC5hcHBseShleHRzLCBzZWxmLmV4dGVuc2lvbnNbbWltZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gZXh0cztcblx0XHR9LFxuXG5cblx0XHRtaW1lczJleHRMaXN0OiBmdW5jdGlvbihtaW1lcykge1xuXHRcdFx0dmFyIGFjY2VwdCA9IFtdLCBleHRzID0gW107XG5cblx0XHRcdGlmIChCYXNpYy50eXBlT2YobWltZXMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRtaW1lcyA9IEJhc2ljLnRyaW0obWltZXMpLnNwbGl0KC9cXHMqLFxccyovKTtcblx0XHRcdH1cblxuXHRcdFx0ZXh0cyA9IHRoaXMubWltZXMyZXh0cyhtaW1lcyk7XG5cdFx0XHRcblx0XHRcdGFjY2VwdC5wdXNoKHtcblx0XHRcdFx0dGl0bGU6IEkxOG4udHJhbnNsYXRlKCdGaWxlcycpLFxuXHRcdFx0XHRleHRlbnNpb25zOiBleHRzLmxlbmd0aCA/IGV4dHMuam9pbignLCcpIDogJyonXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gc2F2ZSBvcmlnaW5hbCBtaW1lcyBzdHJpbmdcblx0XHRcdGFjY2VwdC5taW1lcyA9IG1pbWVzO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXB0O1xuXHRcdH0sXG5cblxuXHRcdGdldEZpbGVFeHRlbnNpb246IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IGZpbGVOYW1lICYmIGZpbGVOYW1lLm1hdGNoKC9cXC4oW14uXSspJC8pO1xuXHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnJztcblx0XHR9LFxuXG5cdFx0Z2V0RmlsZU1pbWU6IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5taW1lc1t0aGlzLmdldEZpbGVFeHRlbnNpb24oZmlsZU5hbWUpXSB8fCAnJztcblx0XHR9XG5cdH07XG5cblx0TWltZS5hZGRNaW1lVHlwZShtaW1lRGF0YSk7XG5cblx0cmV0dXJuIE1pbWU7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvZmlsZS9GaWxlSW5wdXQuanNcblxuLyoqXG4gKiBGaWxlSW5wdXQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9maWxlL0ZpbGVJbnB1dCcsIFtcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnLFxuXHQnbW94aWUvY29yZS91dGlscy9FbnYnLFxuXHQnbW94aWUvY29yZS91dGlscy9NaW1lJyxcblx0J21veGllL2NvcmUvdXRpbHMvRG9tJyxcblx0J21veGllL2NvcmUvRXhjZXB0aW9ucycsXG5cdCdtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0Jyxcblx0J21veGllL2NvcmUvSTE4bicsXG5cdCdtb3hpZS9ydW50aW1lL1J1bnRpbWUnLFxuXHQnbW94aWUvcnVudGltZS9SdW50aW1lQ2xpZW50J1xuXSwgZnVuY3Rpb24oQmFzaWMsIEVudiwgTWltZSwgRG9tLCB4LCBFdmVudFRhcmdldCwgSTE4biwgUnVudGltZSwgUnVudGltZUNsaWVudCkge1xuXHQvKipcblx0UHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byBjcmVhdGUgY3Jvc3MtYnJvd3NlciBmaWxlLXBpY2tlci4gR2VuZXJhdGVzIGZpbGUgc2VsZWN0aW9uIGRpYWxvZyBvbiBjbGljayxcblx0Y29udmVydHMgc2VsZWN0ZWQgZmlsZXMgdG8gX0ZpbGVfIG9iamVjdHMsIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBfSW1hZ2VfLCBwcmVsb2FkZWQgaW4gbWVtb3J5XG5cdHdpdGggX0ZpbGVSZWFkZXJfIG9yIHVwbG9hZGVkIHRvIGEgc2VydmVyIHRocm91Z2ggX1hNTEh0dHBSZXF1ZXN0Xy5cblxuXHRAY2xhc3MgbW94aWUvZmlsZS9GaWxlSW5wdXRcblx0QGNvbnN0cnVjdG9yXG5cdEBleHRlbmRzIEV2ZW50VGFyZ2V0XG5cdEB1c2VzIFJ1bnRpbWVDbGllbnRcblx0QHBhcmFtIHtPYmplY3R8U3RyaW5nfERPTUVsZW1lbnR9IG9wdGlvbnMgSWYgb3B0aW9ucyBpcyBzdHJpbmcgb3Igbm9kZSwgYXJndW1lbnQgaXMgY29uc2lkZXJlZCBhcyBfYnJvd3NlXFxfYnV0dG9uXy5cblx0XHRAcGFyYW0ge1N0cmluZ3xET01FbGVtZW50fSBvcHRpb25zLmJyb3dzZV9idXR0b24gRE9NIEVsZW1lbnQgdG8gdHVybiBpbnRvIGZpbGUgcGlja2VyLlxuXHRcdEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmFjY2VwdF0gQXJyYXkgb2YgbWltZSB0eXBlcyB0byBhY2NlcHQuIEJ5IGRlZmF1bHQgYWNjZXB0cyBhbGwuXG5cdFx0QHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aXBsZT1mYWxzZV0gRW5hYmxlIHNlbGVjdGlvbiBvZiBtdWx0aXBsZSBmaWxlcy5cblx0XHRAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRpcmVjdG9yeT1mYWxzZV0gVHVybiBmaWxlIGlucHV0IGludG8gdGhlIGZvbGRlciBpbnB1dCAoY2Fubm90IGJlIGJvdGggYXQgdGhlIHNhbWUgdGltZSkuXG5cdFx0QHBhcmFtIHtTdHJpbmd8RE9NRWxlbWVudH0gW29wdGlvbnMuY29udGFpbmVyXSBET00gRWxlbWVudCB0byB1c2UgYXMgYSBjb250YWluZXIgZm9yIGZpbGUtcGlja2VyLiBEZWZhdWx0cyB0byBwYXJlbnROb2RlIFxuXHRcdGZvciBfYnJvd3NlXFxfYnV0dG9uXy5cblx0XHRAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnJlcXVpcmVkX2NhcHNdIFNldCBvZiByZXF1aXJlZCBjYXBhYmlsaXRpZXMsIHRoYXQgY2hvc2VuIHJ1bnRpbWUgbXVzdCBzdXBwb3J0LlxuXG5cdEBleGFtcGxlXG5cdFx0PGRpdiBpZD1cImNvbnRhaW5lclwiPlxuXHRcdFx0PGEgaWQ9XCJmaWxlLXBpY2tlclwiIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj5Ccm93c2UuLi48L2E+XG5cdFx0PC9kaXY+XG5cblx0XHQ8c2NyaXB0PlxuXHRcdFx0dmFyIGZpbGVJbnB1dCA9IG5ldyBtT3hpZS5GaWxlSW5wdXQoe1xuXHRcdFx0XHRicm93c2VfYnV0dG9uOiAnZmlsZS1waWNrZXInLCAvLyBvciBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZS1waWNrZXInKVxuXHRcdFx0XHRjb250YWluZXI6ICdjb250YWluZXInLFxuXHRcdFx0XHRhY2NlcHQ6IFtcblx0XHRcdFx0XHR7dGl0bGU6IFwiSW1hZ2UgZmlsZXNcIiwgZXh0ZW5zaW9uczogXCJqcGcsZ2lmLHBuZ1wifSAvLyBhY2NlcHQgb25seSBpbWFnZXNcblx0XHRcdFx0XSxcblx0XHRcdFx0bXVsdGlwbGU6IHRydWUgLy8gYWxsb3cgbXVsdGlwbGUgZmlsZSBzZWxlY3Rpb25cblx0XHRcdH0pO1xuXG5cdFx0XHRmaWxlSW5wdXQub25jaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdC8vIGRvIHNvbWV0aGluZyB0byBmaWxlcyBhcnJheVxuXHRcdFx0XHRjb25zb2xlLmluZm8oZS50YXJnZXQuZmlsZXMpOyAvLyBvciB0aGlzLmZpbGVzIG9yIGZpbGVJbnB1dC5maWxlc1xuXHRcdFx0fTtcblxuXHRcdFx0ZmlsZUlucHV0LmluaXQoKTsgLy8gaW5pdGlhbGl6ZVxuXHRcdDwvc2NyaXB0PlxuXHQqL1xuXHR2YXIgZGlzcGF0Y2hlcyA9IFtcblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gcnVudGltZSBpcyBjb25uZWN0ZWQgYW5kIGZpbGUtcGlja2VyIGlzIHJlYWR5IHRvIGJlIHVzZWQuXG5cblx0XHRAZXZlbnQgcmVhZHlcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdyZWFkeScsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHJpZ2h0IGFmdGVyIFtyZWFkeV0oI2V2ZW50X3JlYWR5KSBldmVudCwgYW5kIHdoZW5ldmVyIFtyZWZyZXNoKCldKCNtZXRob2RfcmVmcmVzaCkgaXMgaW52b2tlZC4gXG5cdFx0Q2hlY2sgW2NvcnJlc3BvbmRpbmcgZG9jdW1lbnRhdGlvbiBlbnRyeV0oI21ldGhvZF9yZWZyZXNoKSBmb3IgbW9yZSBpbmZvLlxuXG5cdFx0QGV2ZW50IHJlZnJlc2hcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIHNlbGVjdGlvbiBvZiBmaWxlcyBpbiB0aGUgZGlhbG9nIGlzIGNvbXBsZXRlLlxuXG5cdFx0QGV2ZW50IGNoYW5nZVxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2NoYW5nZScsXG5cblx0XHQnY2FuY2VsJywgLy8gVE9ETzogbWlnaHQgYmUgdXNlZnVsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gbW91c2UgY3Vyc29yIGVudGVycyBmaWxlLXBpY2tlciBhcmVhLiBDYW4gYmUgdXNlZCB0byBzdHlsZSBlbGVtZW50XG5cdFx0YWNjb3JkaW5nbHkuXG5cblx0XHRAZXZlbnQgbW91c2VlbnRlclxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J21vdXNlZW50ZXInLFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIG1vdXNlIGN1cnNvciBsZWF2ZXMgZmlsZS1waWNrZXIgYXJlYS4gQ2FuIGJlIHVzZWQgdG8gc3R5bGUgZWxlbWVudFxuXHRcdGFjY29yZGluZ2x5LlxuXG5cdFx0QGV2ZW50IG1vdXNlbGVhdmVcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdtb3VzZWxlYXZlJyxcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgd2hlbiBmdW5jdGlvbmFsIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkIG9uIHRvcCBvZiBmaWxlLXBpY2tlciBhcmVhLlxuXG5cdFx0QGV2ZW50IG1vdXNlZG93blxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J21vdXNlZG93bicsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gZnVuY3Rpb25hbCBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQgb24gdG9wIG9mIGZpbGUtcGlja2VyIGFyZWEuXG5cblx0XHRAZXZlbnQgbW91c2V1cFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J21vdXNldXAnXG5cdF07XG5cblx0ZnVuY3Rpb24gRmlsZUlucHV0KG9wdGlvbnMpIHtcblx0XHRpZiAoTVhJX0RFQlVHKSB7XG5cdFx0XHRFbnYubG9nKFwiSW5zdGFudGlhdGluZyBGaWxlSW5wdXQuLi5cIik7XHRcblx0XHR9XG5cblx0XHR2YXIgY29udGFpbmVyLCBicm93c2VCdXR0b24sIGRlZmF1bHRzO1xuXG5cdFx0Ly8gaWYgZmxhdCBhcmd1bWVudCBwYXNzZWQgaXQgc2hvdWxkIGJlIGJyb3dzZV9idXR0b24gaWRcblx0XHRpZiAoQmFzaWMuaW5BcnJheShCYXNpYy50eXBlT2Yob3B0aW9ucyksIFsnc3RyaW5nJywgJ25vZGUnXSkgIT09IC0xKSB7XG5cdFx0XHRvcHRpb25zID0geyBicm93c2VfYnV0dG9uIDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdC8vIHRoaXMgd2lsbCBoZWxwIHVzIHRvIGZpbmQgcHJvcGVyIGRlZmF1bHQgY29udGFpbmVyXG5cdFx0YnJvd3NlQnV0dG9uID0gRG9tLmdldChvcHRpb25zLmJyb3dzZV9idXR0b24pO1xuXHRcdGlmICghYnJvd3NlQnV0dG9uKSB7XG5cdFx0XHQvLyBicm93c2UgYnV0dG9uIGlzIHJlcXVpcmVkXG5cdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uTk9UX0ZPVU5EX0VSUik7XG5cdFx0fVxuXG5cdFx0Ly8gZmlndXJlIG91dCB0aGUgb3B0aW9uc1xuXHRcdGRlZmF1bHRzID0ge1xuXHRcdFx0YWNjZXB0OiBbe1xuXHRcdFx0XHR0aXRsZTogSTE4bi50cmFuc2xhdGUoJ0FsbCBGaWxlcycpLFxuXHRcdFx0XHRleHRlbnNpb25zOiAnKidcblx0XHRcdH1dLFxuXHRcdFx0bXVsdGlwbGU6IGZhbHNlLFxuXHRcdFx0cmVxdWlyZWRfY2FwczogZmFsc2UsXG5cdFx0XHRjb250YWluZXI6IGJyb3dzZUJ1dHRvbi5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHlcblx0XHR9O1xuXHRcdFxuXHRcdG9wdGlvbnMgPSBCYXNpYy5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcblxuXHRcdC8vIGNvbnZlcnQgdG8gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG5cdFx0aWYgKHR5cGVvZihvcHRpb25zLnJlcXVpcmVkX2NhcHMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0b3B0aW9ucy5yZXF1aXJlZF9jYXBzID0gUnVudGltZS5wYXJzZUNhcHMob3B0aW9ucy5yZXF1aXJlZF9jYXBzKTtcblx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0Ly8gbm9ybWFsaXplIGFjY2VwdCBvcHRpb24gKGNvdWxkIGJlIGxpc3Qgb2YgbWltZSB0eXBlcyBvciBhcnJheSBvZiB0aXRsZS9leHRlbnNpb25zIHBhaXJzKVxuXHRcdGlmICh0eXBlb2Yob3B0aW9ucy5hY2NlcHQpID09PSAnc3RyaW5nJykge1xuXHRcdFx0b3B0aW9ucy5hY2NlcHQgPSBNaW1lLm1pbWVzMmV4dExpc3Qob3B0aW9ucy5hY2NlcHQpO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lciA9IERvbS5nZXQob3B0aW9ucy5jb250YWluZXIpO1xuXHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGNvbnRhaW5lclxuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRjb250YWluZXIgPSBkb2N1bWVudC5ib2R5O1xuXHRcdH1cblxuXHRcdC8vIG1ha2UgY29udGFpbmVyIHJlbGF0aXZlLCBpZiBpdCdzIG5vdFxuXHRcdGlmIChEb20uZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyID0gYnJvd3NlQnV0dG9uID0gbnVsbDsgLy8gSUVcblx0XHRcdFx0XHRcdFxuXHRcdFJ1bnRpbWVDbGllbnQuY2FsbCh0aGlzKTtcblx0XHRcblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0LyoqXG5cdFx0XHRVbmlxdWUgaWQgb2YgdGhlIGNvbXBvbmVudFxuXG5cdFx0XHRAcHJvcGVydHkgdWlkXG5cdFx0XHRAcHJvdGVjdGVkXG5cdFx0XHRAcmVhZE9ubHlcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHRAZGVmYXVsdCBVSURcblx0XHRcdCovXG5cdFx0XHR1aWQ6IEJhc2ljLmd1aWQoJ3VpZF8nKSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRVbmlxdWUgaWQgb2YgdGhlIGNvbm5lY3RlZCBydW50aW1lLCBpZiBhbnkuXG5cblx0XHRcdEBwcm9wZXJ0eSBydWlkXG5cdFx0XHRAcHJvdGVjdGVkXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0Ki9cblx0XHRcdHJ1aWQ6IG51bGwsXG5cblx0XHRcdC8qKlxuXHRcdFx0VW5pcXVlIGlkIG9mIHRoZSBydW50aW1lIGNvbnRhaW5lci4gVXNlZnVsIHRvIGdldCBob2xkIG9mIGl0IGZvciB2YXJpb3VzIG1hbmlwdWxhdGlvbnMuXG5cblx0XHRcdEBwcm9wZXJ0eSBzaGltaWRcblx0XHRcdEBwcm90ZWN0ZWRcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0c2hpbWlkOiBudWxsLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdEFycmF5IG9mIHNlbGVjdGVkIG1PeGllLkZpbGUgb2JqZWN0c1xuXG5cdFx0XHRAcHJvcGVydHkgZmlsZXNcblx0XHRcdEB0eXBlIHtBcnJheX1cblx0XHRcdEBkZWZhdWx0IG51bGxcblx0XHRcdCovXG5cdFx0XHRmaWxlczogbnVsbCxcblxuXHRcdFx0LyoqXG5cdFx0XHRJbml0aWFsaXplcyB0aGUgZmlsZS1waWNrZXIsIGNvbm5lY3RzIGl0IHRvIHJ1bnRpbWUgYW5kIGRpc3BhdGNoZXMgZXZlbnQgcmVhZHkgd2hlbiBkb25lLlxuXG5cdFx0XHRAbWV0aG9kIGluaXRcblx0XHRcdCovXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHRcdHNlbGYuYmluZCgnUnVudGltZUluaXQnLCBmdW5jdGlvbihlLCBydW50aW1lKSB7XG5cdFx0XHRcdFx0c2VsZi5ydWlkID0gcnVudGltZS51aWQ7XG5cdFx0XHRcdFx0c2VsZi5zaGltaWQgPSBydW50aW1lLnNoaW1pZDtcblxuXHRcdFx0XHRcdHNlbGYuYmluZChcIlJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi50cmlnZ2VyKFwiUmVmcmVzaFwiKTtcblx0XHRcdFx0XHR9LCA5OTkpO1xuXG5cdFx0XHRcdFx0Ly8gcmUtcG9zaXRpb24gYW5kIHJlc2l6ZSBzaGltIGNvbnRhaW5lclxuXHRcdFx0XHRcdHNlbGYuYmluZCgnUmVmcmVzaCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIHBvcywgc2l6ZSwgYnJvd3NlQnV0dG9uLCBzaGltQ29udGFpbmVyLCB6SW5kZXg7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGJyb3dzZUJ1dHRvbiA9IERvbS5nZXQob3B0aW9ucy5icm93c2VfYnV0dG9uKTtcblx0XHRcdFx0XHRcdHNoaW1Db250YWluZXIgPSBEb20uZ2V0KHJ1bnRpbWUuc2hpbWlkKTsgLy8gZG8gbm90IHVzZSBydW50aW1lLmdldFNoaW1Db250YWluZXIoKSwgc2luY2UgaXQgd2lsbCBjcmVhdGUgY29udGFpbmVyIGlmIGl0IGRvZXNuJ3QgZXhpc3RcblxuXHRcdFx0XHRcdFx0aWYgKGJyb3dzZUJ1dHRvbikge1xuXHRcdFx0XHRcdFx0XHRwb3MgPSBEb20uZ2V0UG9zKGJyb3dzZUJ1dHRvbiwgRG9tLmdldChvcHRpb25zLmNvbnRhaW5lcikpO1xuXHRcdFx0XHRcdFx0XHRzaXplID0gRG9tLmdldFNpemUoYnJvd3NlQnV0dG9uKTtcblx0XHRcdFx0XHRcdFx0ekluZGV4ID0gcGFyc2VJbnQoRG9tLmdldFN0eWxlKGJyb3dzZUJ1dHRvbiwgJ3otaW5kZXgnKSwgMTApIHx8IDA7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHNoaW1Db250YWluZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRCYXNpYy5leHRlbmQoc2hpbUNvbnRhaW5lci5zdHlsZSwge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG9wOiBwb3MueSArICdweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWZ0OiBwb3MueCArICdweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHR3aWR0aDogc2l6ZS53ICsgJ3B4Jyxcblx0XHRcdFx0XHRcdFx0XHRcdGhlaWdodDogc2l6ZS5oICsgJ3B4Jyxcblx0XHRcdFx0XHRcdFx0XHRcdHpJbmRleDogekluZGV4ICsgMVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzaGltQ29udGFpbmVyID0gYnJvd3NlQnV0dG9uID0gbnVsbDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRydW50aW1lLmV4ZWMuY2FsbChzZWxmLCAnRmlsZUlucHV0JywgJ2luaXQnLCBvcHRpb25zKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcnVudGltZSBuZWVkczogb3B0aW9ucy5yZXF1aXJlZF9mZWF0dXJlcywgb3B0aW9ucy5ydW50aW1lX29yZGVyIGFuZCBvcHRpb25zLmNvbnRhaW5lclxuXHRcdFx0XHRzZWxmLmNvbm5lY3RSdW50aW1lKEJhc2ljLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuXHRcdFx0XHRcdHJlcXVpcmVkX2NhcHM6IHtcblx0XHRcdFx0XHRcdHNlbGVjdF9maWxlOiB0cnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogR2V0IGN1cnJlbnQgb3B0aW9uIHZhbHVlIGJ5IGl0cyBuYW1lXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBnZXRPcHRpb25cblx0XHRcdCAqIEBwYXJhbSBuYW1lXG5cdFx0XHQgKiBAcmV0dXJuIHtNaXhlZH1cblx0XHRcdCAqL1xuXHRcdFx0Z2V0T3B0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBvcHRpb25zW25hbWVdO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldHMgYSBuZXcgdmFsdWUgZm9yIHRoZSBvcHRpb24gc3BlY2lmaWVkIGJ5IG5hbWVcblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIHNldE9wdGlvblxuXHRcdFx0ICogQHBhcmFtIG5hbWVcblx0XHRcdCAqIEBwYXJhbSB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRzZXRPcHRpb246IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRcdGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvbGRWYWx1ZSA9IG9wdGlvbnNbbmFtZV07XG5cblx0XHRcdFx0c3dpdGNoIChuYW1lKSB7XG5cdFx0XHRcdFx0Y2FzZSAnYWNjZXB0Jzpcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YodmFsdWUpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IE1pbWUubWltZXMyZXh0TGlzdCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnRhaW5lcic6XG5cdFx0XHRcdFx0Y2FzZSAncmVxdWlyZWRfY2Fwcyc6XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5GaWxlRXhjZXB0aW9uKHguRmlsZUV4Y2VwdGlvbi5OT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLmV4ZWMoJ0ZpbGVJbnB1dCcsICdzZXRPcHRpb24nLCBuYW1lLCB2YWx1ZSk7XG5cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdPcHRpb25DaGFuZ2VkJywgbmFtZSwgdmFsdWUsIG9sZFZhbHVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0RGlzYWJsZXMgZmlsZS1waWNrZXIgZWxlbWVudCwgc28gdGhhdCBpdCBkb2Vzbid0IHJlYWN0IHRvIG1vdXNlIGNsaWNrcy5cblxuXHRcdFx0QG1ldGhvZCBkaXNhYmxlXG5cdFx0XHRAcGFyYW0ge0Jvb2xlYW59IFtzdGF0ZT10cnVlXSBEaXNhYmxlIGNvbXBvbmVudCBpZiAtIHRydWUsIGVuYWJsZSBpZiAtIGZhbHNlXG5cdFx0XHQqL1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRcdFx0dmFyIHJ1bnRpbWUgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblx0XHRcdFx0aWYgKHJ1bnRpbWUpIHtcblx0XHRcdFx0XHR0aGlzLmV4ZWMoJ0ZpbGVJbnB1dCcsICdkaXNhYmxlJywgQmFzaWMudHlwZU9mKHN0YXRlKSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc3RhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0UmVwb3NpdGlvbiBhbmQgcmVzaXplIGRpYWxvZyB0cmlnZ2VyIHRvIG1hdGNoIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBicm93c2VfYnV0dG9uIGVsZW1lbnQuXG5cblx0XHRcdEBtZXRob2QgcmVmcmVzaFxuXHRcdFx0Ki9cblx0XHRcdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJSZWZyZXNoXCIpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdERlc3Ryb3kgY29tcG9uZW50LlxuXG5cdFx0XHRAbWV0aG9kIGRlc3Ryb3lcblx0XHRcdCovXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJ1bnRpbWUgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblx0XHRcdFx0aWYgKHJ1bnRpbWUpIHtcblx0XHRcdFx0XHRydW50aW1lLmV4ZWMuY2FsbCh0aGlzLCAnRmlsZUlucHV0JywgJ2Rlc3Ryb3knKTtcblx0XHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RSdW50aW1lKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKHRoaXMuZmlsZXMpID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0Ly8gbm8gc2Vuc2UgaW4gbGVhdmluZyBhc3NvY2lhdGVkIGZpbGVzIGJlaGluZFxuXHRcdFx0XHRcdEJhc2ljLmVhY2godGhpcy5maWxlcywgZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRcdFx0ZmlsZS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gXG5cdFx0XHRcdHRoaXMuZmlsZXMgPSBudWxsO1xuXG5cdFx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmhhbmRsZUV2ZW50UHJvcHMoZGlzcGF0Y2hlcyk7XG5cdH1cblxuXHRGaWxlSW5wdXQucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cblx0cmV0dXJuIEZpbGVJbnB1dDtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9maWxlL0ZpbGUuanNcblxuLyoqXG4gKiBGaWxlLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvZmlsZS9GaWxlJywgW1xuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYycsXG5cdCdtb3hpZS9jb3JlL3V0aWxzL01pbWUnLFxuXHQnbW94aWUvZmlsZS9CbG9iJ1xuXSwgZnVuY3Rpb24oQmFzaWMsIE1pbWUsIEJsb2IpIHtcblx0LyoqXG5cdEBjbGFzcyBtb3hpZS9maWxlL0ZpbGVcblx0QGV4dGVuZHMgQmxvYlxuXHRAY29uc3RydWN0b3Jcblx0QHBhcmFtIHtTdHJpbmd9IHJ1aWQgVW5pcXVlIGlkIG9mIHRoZSBydW50aW1lLCB0byB3aGljaCB0aGlzIGJsb2IgYmVsb25ncyB0b1xuXHRAcGFyYW0ge09iamVjdH0gZmlsZSBPYmplY3QgXCJOYXRpdmVcIiBmaWxlIG9iamVjdCwgYXMgaXQgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHJ1bnRpbWVcblx0Ki9cblx0ZnVuY3Rpb24gRmlsZShydWlkLCBmaWxlKSB7XG5cdFx0aWYgKCFmaWxlKSB7IC8vIGF2b2lkIGV4dHJhIGVycm9ycyBpbiBjYXNlIHdlIG92ZXJsb29rZWQgc29tZXRoaW5nXG5cdFx0XHRmaWxlID0ge307XG5cdFx0fVxuXG5cdFx0QmxvYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0aWYgKCF0aGlzLnR5cGUpIHtcblx0XHRcdHRoaXMudHlwZSA9IE1pbWUuZ2V0RmlsZU1pbWUoZmlsZS5uYW1lKTtcblx0XHR9XG5cblx0XHQvLyBzYW5pdGl6ZSBmaWxlIG5hbWUgb3IgZ2VuZXJhdGUgbmV3IG9uZVxuXHRcdHZhciBuYW1lO1xuXHRcdGlmIChmaWxlLm5hbWUpIHtcblx0XHRcdG5hbWUgPSBmaWxlLm5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXHRcdFx0bmFtZSA9IG5hbWUuc3Vic3RyKG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy50eXBlKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gdGhpcy50eXBlLnNwbGl0KCcvJylbMF07XG5cdFx0XHRuYW1lID0gQmFzaWMuZ3VpZCgocHJlZml4ICE9PSAnJyA/IHByZWZpeCA6ICdmaWxlJykgKyAnXycpO1xuXHRcdFx0XG5cdFx0XHRpZiAoTWltZS5leHRlbnNpb25zW3RoaXMudHlwZV0pIHtcblx0XHRcdFx0bmFtZSArPSAnLicgKyBNaW1lLmV4dGVuc2lvbnNbdGhpcy50eXBlXVswXTsgLy8gYXBwZW5kIHByb3BlciBleHRlbnNpb24gaWYgcG9zc2libGVcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0RmlsZSBuYW1lXG5cblx0XHRcdEBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0QGRlZmF1bHQgVUlEXG5cdFx0XHQqL1xuXHRcdFx0bmFtZTogbmFtZSB8fCBCYXNpYy5ndWlkKCdmaWxlXycpLFxuXG5cdFx0XHQvKipcblx0XHRcdFJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUgaW5zaWRlIGEgZGlyZWN0b3J5XG5cblx0XHRcdEBwcm9wZXJ0eSByZWxhdGl2ZVBhdGhcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHRAZGVmYXVsdCAnJ1xuXHRcdFx0Ki9cblx0XHRcdHJlbGF0aXZlUGF0aDogJycsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0RGF0ZSBvZiBsYXN0IG1vZGlmaWNhdGlvblxuXG5cdFx0XHRAcHJvcGVydHkgbGFzdE1vZGlmaWVkRGF0ZVxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdEBkZWZhdWx0IG5vd1xuXHRcdFx0Ki9cblx0XHRcdGxhc3RNb2RpZmllZERhdGU6IGZpbGUubGFzdE1vZGlmaWVkRGF0ZSB8fCAobmV3IERhdGUoKSkudG9Mb2NhbGVTdHJpbmcoKSAvLyBUaHUgQXVnIDIzIDIwMTIgMTk6NDA6MDAgR01UKzA0MDAgKEdFVClcblx0XHR9KTtcblx0fVxuXG5cdEZpbGUucHJvdG90eXBlID0gQmxvYi5wcm90b3R5cGU7XG5cblx0cmV0dXJuIEZpbGU7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvZmlsZS9GaWxlRHJvcC5qc1xuXG4vKipcbiAqIEZpbGVEcm9wLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbmRlZmluZSgnbW94aWUvZmlsZS9GaWxlRHJvcCcsIFtcblx0J21veGllL2NvcmUvSTE4bicsXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0RvbScsXG5cdCdtb3hpZS9jb3JlL0V4Y2VwdGlvbnMnLFxuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYycsXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0VudicsXG5cdCdtb3hpZS9maWxlL0ZpbGUnLFxuXHQnbW94aWUvcnVudGltZS9SdW50aW1lQ2xpZW50Jyxcblx0J21veGllL2NvcmUvRXZlbnRUYXJnZXQnLFxuXHQnbW94aWUvY29yZS91dGlscy9NaW1lJ1xuXSwgZnVuY3Rpb24oSTE4biwgRG9tLCB4LCBCYXNpYywgRW52LCBGaWxlLCBSdW50aW1lQ2xpZW50LCBFdmVudFRhcmdldCwgTWltZSkge1xuXHQvKipcblx0VHVybiBhcmJpdHJhcnkgRE9NIGVsZW1lbnQgdG8gYSBkcm9wIHpvbmUgYWNjZXB0aW5nIGZpbGVzLiBDb252ZXJ0cyBzZWxlY3RlZCBmaWxlcyB0byBfRmlsZV8gb2JqZWN0cywgdG8gYmUgdXNlZCBcblx0aW4gY29uanVuY3Rpb24gd2l0aCBfSW1hZ2VfLCBwcmVsb2FkZWQgaW4gbWVtb3J5IHdpdGggX0ZpbGVSZWFkZXJfIG9yIHVwbG9hZGVkIHRvIGEgc2VydmVyIHRocm91Z2ggXG5cdF9YTUxIdHRwUmVxdWVzdF8uXG5cblx0QGV4YW1wbGVcblx0XHQ8ZGl2IGlkPVwiZHJvcF96b25lXCI+XG5cdFx0XHREcm9wIGZpbGVzIGhlcmVcblx0XHQ8L2Rpdj5cblx0XHQ8YnIgLz5cblx0XHQ8ZGl2IGlkPVwiZmlsZWxpc3RcIj48L2Rpdj5cblxuXHRcdDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPlxuXHRcdFx0dmFyIGZpbGVEcm9wID0gbmV3IG1PeGllLkZpbGVEcm9wKCdkcm9wX3pvbmUnKSwgZmlsZUxpc3QgPSBtT3hpZS5nZXQoJ2ZpbGVsaXN0Jyk7XG5cblx0XHRcdGZpbGVEcm9wLm9uZHJvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtT3hpZS5lYWNoKHRoaXMuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRmaWxlTGlzdC5pbm5lckhUTUwgKz0gJzxkaXY+JyArIGZpbGUubmFtZSArICc8L2Rpdj4nO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRcdGZpbGVEcm9wLmluaXQoKTtcblx0XHQ8L3NjcmlwdD5cblxuXHRAY2xhc3MgbW94aWUvZmlsZS9GaWxlRHJvcFxuXHRAY29uc3RydWN0b3Jcblx0QGV4dGVuZHMgRXZlbnRUYXJnZXRcblx0QHVzZXMgUnVudGltZUNsaWVudFxuXHRAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdGlvbnMgSWYgb3B0aW9ucyBoYXMgdHlwZW9mIHN0cmluZywgYXJndW1lbnQgaXMgY29uc2lkZXJlZCBhcyBvcHRpb25zLmRyb3Bfem9uZVxuXHRcdEBwYXJhbSB7U3RyaW5nfERPTUVsZW1lbnR9IG9wdGlvbnMuZHJvcF96b25lIERPTSBFbGVtZW50IHRvIHR1cm4gaW50byBhIGRyb3Agem9uZVxuXHRcdEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmFjY2VwdF0gQXJyYXkgb2YgbWltZSB0eXBlcyB0byBhY2NlcHQuIEJ5IGRlZmF1bHQgYWNjZXB0cyBhbGxcblx0XHRAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnJlcXVpcmVkX2NhcHNdIFNldCBvZiByZXF1aXJlZCBjYXBhYmlsaXRpZXMsIHRoYXQgY2hvc2VuIHJ1bnRpbWUgbXVzdCBzdXBwb3J0XG5cdCovXG5cdHZhciBkaXNwYXRjaGVzID0gW1xuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgd2hlbiBydW50aW1lIGlzIGNvbm5lY3RlZCBhbmQgZHJvcCB6b25lIGlzIHJlYWR5IHRvIGFjY2VwdCBmaWxlcy5cblxuXHRcdEBldmVudCByZWFkeVxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J3JlYWR5JywgXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gZHJhZ2dpbmcgY3Vyc29yIGVudGVycyB0aGUgZHJvcCB6b25lLlxuXG5cdFx0QGV2ZW50IGRyYWdlbnRlclxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2RyYWdlbnRlcicsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gZHJhZ2dpbmcgY3Vyc29yIGxlYXZlcyB0aGUgZHJvcCB6b25lLlxuXG5cdFx0QGV2ZW50IGRyYWdsZWF2ZVxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2RyYWdsZWF2ZScsIFxuXG5cdFx0LyoqXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIGZpbGUgaXMgZHJvcHBlZCBvbnRvIHRoZSBkcm9wIHpvbmUuXG5cblx0XHRAZXZlbnQgZHJvcFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2Ryb3AnLCBcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgaWYgZXJyb3Igb2NjdXJzLlxuXG5cdFx0QGV2ZW50IGVycm9yXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQnZXJyb3InXG5cdF07XG5cblx0ZnVuY3Rpb24gRmlsZURyb3Aob3B0aW9ucykge1xuXHRcdGlmIChNWElfREVCVUcpIHtcblx0XHRcdEVudi5sb2coXCJJbnN0YW50aWF0aW5nIEZpbGVEcm9wLi4uXCIpO1x0XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBkZWZhdWx0cztcblxuXHRcdC8vIGlmIGZsYXQgYXJndW1lbnQgcGFzc2VkIGl0IHNob3VsZCBiZSBkcm9wX3pvbmUgaWRcblx0XHRpZiAodHlwZW9mKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0b3B0aW9ucyA9IHsgZHJvcF96b25lIDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdC8vIGZpZ3VyZSBvdXQgdGhlIG9wdGlvbnNcblx0XHRkZWZhdWx0cyA9IHtcblx0XHRcdGFjY2VwdDogW3tcblx0XHRcdFx0dGl0bGU6IEkxOG4udHJhbnNsYXRlKCdBbGwgRmlsZXMnKSxcblx0XHRcdFx0ZXh0ZW5zaW9uczogJyonXG5cdFx0XHR9XSxcblx0XHRcdHJlcXVpcmVkX2NhcHM6IHtcblx0XHRcdFx0ZHJhZ19hbmRfZHJvcDogdHJ1ZVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0b3B0aW9ucyA9IHR5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcgPyBCYXNpYy5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKSA6IGRlZmF1bHRzO1xuXG5cdFx0Ly8gdGhpcyB3aWxsIGhlbHAgdXMgdG8gZmluZCBwcm9wZXIgZGVmYXVsdCBjb250YWluZXJcblx0XHRvcHRpb25zLmNvbnRhaW5lciA9IERvbS5nZXQob3B0aW9ucy5kcm9wX3pvbmUpIHx8IGRvY3VtZW50LmJvZHk7XG5cblx0XHQvLyBtYWtlIGNvbnRhaW5lciByZWxhdGl2ZSwgaWYgaXQgaXMgbm90XG5cdFx0aWYgKERvbS5nZXRTdHlsZShvcHRpb25zLmNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG5cdFx0XHRvcHRpb25zLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdFx0fVxuXHRcdFx0XHRcdFxuXHRcdC8vIG5vcm1hbGl6ZSBhY2NlcHQgb3B0aW9uIChjb3VsZCBiZSBsaXN0IG9mIG1pbWUgdHlwZXMgb3IgYXJyYXkgb2YgdGl0bGUvZXh0ZW5zaW9ucyBwYWlycylcblx0XHRpZiAodHlwZW9mKG9wdGlvbnMuYWNjZXB0KSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdG9wdGlvbnMuYWNjZXB0ID0gTWltZS5taW1lczJleHRMaXN0KG9wdGlvbnMuYWNjZXB0KTtcblx0XHR9XG5cblx0XHRSdW50aW1lQ2xpZW50LmNhbGwoc2VsZik7XG5cblx0XHRCYXNpYy5leHRlbmQoc2VsZiwge1xuXHRcdFx0dWlkOiBCYXNpYy5ndWlkKCd1aWRfJyksXG5cblx0XHRcdHJ1aWQ6IG51bGwsXG5cblx0XHRcdGZpbGVzOiBudWxsLFxuXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcdFx0XG5cdFx0XHRcdHNlbGYuYmluZCgnUnVudGltZUluaXQnLCBmdW5jdGlvbihlLCBydW50aW1lKSB7XG5cdFx0XHRcdFx0c2VsZi5ydWlkID0gcnVudGltZS51aWQ7XG5cdFx0XHRcdFx0cnVudGltZS5leGVjLmNhbGwoc2VsZiwgJ0ZpbGVEcm9wJywgJ2luaXQnLCBvcHRpb25zKTtcblx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoJ3JlYWR5Jyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0Ly8gcnVudGltZSBuZWVkczogb3B0aW9ucy5yZXF1aXJlZF9mZWF0dXJlcywgb3B0aW9ucy5ydW50aW1lX29yZGVyIGFuZCBvcHRpb25zLmNvbnRhaW5lclxuXHRcdFx0XHRzZWxmLmNvbm5lY3RSdW50aW1lKG9wdGlvbnMpOyAvLyB0aHJvd3MgUnVudGltZUVycm9yXG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJ1bnRpbWUgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblx0XHRcdFx0aWYgKHJ1bnRpbWUpIHtcblx0XHRcdFx0XHRydW50aW1lLmV4ZWMuY2FsbCh0aGlzLCAnRmlsZURyb3AnLCAnZGVzdHJveScpO1xuXHRcdFx0XHRcdHRoaXMuZGlzY29ubmVjdFJ1bnRpbWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpbGVzID0gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmhhbmRsZUV2ZW50UHJvcHMoZGlzcGF0Y2hlcyk7XG5cdH1cblxuXHRGaWxlRHJvcC5wcm90b3R5cGUgPSBFdmVudFRhcmdldC5pbnN0YW5jZTtcblxuXHRyZXR1cm4gRmlsZURyb3A7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvZmlsZS9GaWxlUmVhZGVyLmpzXG5cbi8qKlxuICogRmlsZVJlYWRlci5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL2ZpbGUvRmlsZVJlYWRlcicsIFtcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnLFxuXHQnbW94aWUvY29yZS91dGlscy9FbmNvZGUnLFxuXHQnbW94aWUvY29yZS9FeGNlcHRpb25zJyxcblx0J21veGllL2NvcmUvRXZlbnRUYXJnZXQnLFxuXHQnbW94aWUvZmlsZS9CbG9iJyxcblx0J21veGllL3J1bnRpbWUvUnVudGltZUNsaWVudCdcbl0sIGZ1bmN0aW9uKEJhc2ljLCBFbmNvZGUsIHgsIEV2ZW50VGFyZ2V0LCBCbG9iLCBSdW50aW1lQ2xpZW50KSB7XG5cdC8qKlxuXHRVdGlsaXR5IGZvciBwcmVsb2FkaW5nIG8uQmxvYi9vLkZpbGUgb2JqZWN0cyBpbiBtZW1vcnkuIEJ5IGRlc2lnbiBjbG9zZWx5IGZvbGxvd3MgW1czQyBGaWxlUmVhZGVyXShodHRwOi8vd3d3LnczLm9yZy9UUi9GaWxlQVBJLyNkZm4tZmlsZXJlYWRlcilcblx0aW50ZXJmYWNlLiBXaGVyZSBwb3NzaWJsZSB1c2VzIG5hdGl2ZSBGaWxlUmVhZGVyLCB3aGVyZSAtIG5vdCBmYWxscyBiYWNrIHRvIHNoaW1zLlxuXG5cdEBjbGFzcyBtb3hpZS9maWxlL0ZpbGVSZWFkZXJcblx0QGNvbnN0cnVjdG9yIEZpbGVSZWFkZXJcblx0QGV4dGVuZHMgRXZlbnRUYXJnZXRcblx0QHVzZXMgUnVudGltZUNsaWVudFxuXHQqL1xuXHR2YXIgZGlzcGF0Y2hlcyA9IFtcblxuXHRcdC8qKiBcblx0XHREaXNwYXRjaGVkIHdoZW4gdGhlIHJlYWQgc3RhcnRzLlxuXG5cdFx0QGV2ZW50IGxvYWRzdGFydFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2xvYWRzdGFydCcsIFxuXG5cdFx0LyoqIFxuXHRcdERpc3BhdGNoZWQgd2hpbGUgcmVhZGluZyAoYW5kIGRlY29kaW5nKSBibG9iLCBhbmQgcmVwb3J0aW5nIHBhcnRpYWwgQmxvYiBkYXRhIChwcm9nZXNzLmxvYWRlZC9wcm9ncmVzcy50b3RhbCkuXG5cblx0XHRAZXZlbnQgcHJvZ3Jlc3Ncblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdwcm9ncmVzcycsIFxuXG5cdFx0LyoqIFxuXHRcdERpc3BhdGNoZWQgd2hlbiB0aGUgcmVhZCBoYXMgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZC5cblxuXHRcdEBldmVudCBsb2FkXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQnbG9hZCcsIFxuXG5cdFx0LyoqIFxuXHRcdERpc3BhdGNoZWQgd2hlbiB0aGUgcmVhZCBoYXMgYmVlbiBhYm9ydGVkLiBGb3IgaW5zdGFuY2UsIGJ5IGludm9raW5nIHRoZSBhYm9ydCgpIG1ldGhvZC5cblxuXHRcdEBldmVudCBhYm9ydFxuXHRcdEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHRcdCovXG5cdFx0J2Fib3J0JywgXG5cblx0XHQvKiogXG5cdFx0RGlzcGF0Y2hlZCB3aGVuIHRoZSByZWFkIGhhcyBmYWlsZWQuXG5cblx0XHRAZXZlbnQgZXJyb3Jcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdlcnJvcicsIFxuXG5cdFx0LyoqIFxuXHRcdERpc3BhdGNoZWQgd2hlbiB0aGUgcmVxdWVzdCBoYXMgY29tcGxldGVkIChlaXRoZXIgaW4gc3VjY2VzcyBvciBmYWlsdXJlKS5cblxuXHRcdEBldmVudCBsb2FkZW5kXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQnbG9hZGVuZCdcblx0XTtcblx0XG5cdGZ1bmN0aW9uIEZpbGVSZWFkZXIoKSB7XG5cblx0XHRSdW50aW1lQ2xpZW50LmNhbGwodGhpcyk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0LyoqXG5cdFx0XHRVSUQgb2YgdGhlIGNvbXBvbmVudCBpbnN0YW5jZS5cblxuXHRcdFx0QHByb3BlcnR5IHVpZFxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdCovXG5cdFx0XHR1aWQ6IEJhc2ljLmd1aWQoJ3VpZF8nKSxcblxuXHRcdFx0LyoqXG5cdFx0XHRDb250YWlucyBjdXJyZW50IHN0YXRlIG9mIEZpbGVSZWFkZXIgb2JqZWN0LiBDYW4gdGFrZSB2YWx1ZXMgb2YgRmlsZVJlYWRlci5FTVBUWSwgRmlsZVJlYWRlci5MT0FESU5HXG5cdFx0XHRhbmQgRmlsZVJlYWRlci5ET05FLlxuXG5cdFx0XHRAcHJvcGVydHkgcmVhZHlTdGF0ZVxuXHRcdFx0QHR5cGUge051bWJlcn1cblx0XHRcdEBkZWZhdWx0IEZpbGVSZWFkZXIuRU1QVFlcblx0XHRcdCovXG5cdFx0XHRyZWFkeVN0YXRlOiBGaWxlUmVhZGVyLkVNUFRZLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdFJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCByZWFkIG9wZXJhdGlvbi5cblxuXHRcdFx0QHByb3BlcnR5IHJlc3VsdFxuXHRcdFx0QHR5cGUge1N0cmluZ31cblx0XHRcdCovXG5cdFx0XHRyZXN1bHQ6IG51bGwsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0U3RvcmVzIHRoZSBlcnJvciBvZiBmYWlsZWQgYXN5bmNocm9ub3VzIHJlYWQgb3BlcmF0aW9uLlxuXG5cdFx0XHRAcHJvcGVydHkgZXJyb3Jcblx0XHRcdEB0eXBlIHtET01FcnJvcn1cblx0XHRcdCovXG5cdFx0XHRlcnJvcjogbnVsbCxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRJbml0aWF0ZXMgcmVhZGluZyBvZiBGaWxlL0Jsb2Igb2JqZWN0IGNvbnRlbnRzIHRvIGJpbmFyeSBzdHJpbmcuXG5cblx0XHRcdEBtZXRob2QgcmVhZEFzQmluYXJ5U3RyaW5nXG5cdFx0XHRAcGFyYW0ge0Jsb2J8RmlsZX0gYmxvYiBPYmplY3QgdG8gcHJlbG9hZFxuXHRcdFx0Ki9cblx0XHRcdHJlYWRBc0JpbmFyeVN0cmluZzogZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0XHRfcmVhZC5jYWxsKHRoaXMsICdyZWFkQXNCaW5hcnlTdHJpbmcnLCBibG9iKTtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0SW5pdGlhdGVzIHJlYWRpbmcgb2YgRmlsZS9CbG9iIG9iamVjdCBjb250ZW50cyB0byBkYXRhVVJMIHN0cmluZy5cblxuXHRcdFx0QG1ldGhvZCByZWFkQXNEYXRhVVJMXG5cdFx0XHRAcGFyYW0ge0Jsb2J8RmlsZX0gYmxvYiBPYmplY3QgdG8gcHJlbG9hZFxuXHRcdFx0Ki9cblx0XHRcdHJlYWRBc0RhdGFVUkw6IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdFx0X3JlYWQuY2FsbCh0aGlzLCAncmVhZEFzRGF0YVVSTCcsIGJsb2IpO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRJbml0aWF0ZXMgcmVhZGluZyBvZiBGaWxlL0Jsb2Igb2JqZWN0IGNvbnRlbnRzIHRvIHN0cmluZy5cblxuXHRcdFx0QG1ldGhvZCByZWFkQXNUZXh0XG5cdFx0XHRAcGFyYW0ge0Jsb2J8RmlsZX0gYmxvYiBPYmplY3QgdG8gcHJlbG9hZFxuXHRcdFx0Ki9cblx0XHRcdHJlYWRBc1RleHQ6IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdFx0X3JlYWQuY2FsbCh0aGlzLCAncmVhZEFzVGV4dCcsIGJsb2IpO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHRBYm9ydHMgcHJlbG9hZGluZyBwcm9jZXNzLlxuXG5cdFx0XHRAbWV0aG9kIGFib3J0XG5cdFx0XHQqL1xuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlc3VsdCA9IG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoQmFzaWMuaW5BcnJheSh0aGlzLnJlYWR5U3RhdGUsIFtGaWxlUmVhZGVyLkVNUFRZLCBGaWxlUmVhZGVyLkRPTkVdKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBGaWxlUmVhZGVyLkxPQURJTkcpIHtcblx0XHRcdFx0XHR0aGlzLnJlYWR5U3RhdGUgPSBGaWxlUmVhZGVyLkRPTkU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmV4ZWMoJ0ZpbGVSZWFkZXInLCAnYWJvcnQnKTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignYWJvcnQnKTtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdsb2FkZW5kJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdERlc3Ryb3kgY29tcG9uZW50IGFuZCByZWxlYXNlIHJlc291cmNlcy5cblxuXHRcdFx0QG1ldGhvZCBkZXN0cm95XG5cdFx0XHQqL1xuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuYWJvcnQoKTtcblx0XHRcdFx0dGhpcy5leGVjKCdGaWxlUmVhZGVyJywgJ2Rlc3Ryb3knKTtcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuXHRcdFx0XHR0aGlzLnVuYmluZEFsbCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gdWlkIG11c3QgYWxyZWFkeSBiZSBhc3NpZ25lZFxuXHRcdHRoaXMuaGFuZGxlRXZlbnRQcm9wcyhkaXNwYXRjaGVzKTtcblxuXHRcdHRoaXMuYmluZCgnRXJyb3InLCBmdW5jdGlvbihlLCBlcnIpIHtcblx0XHRcdHRoaXMucmVhZHlTdGF0ZSA9IEZpbGVSZWFkZXIuRE9ORTtcblx0XHRcdHRoaXMuZXJyb3IgPSBlcnI7XG5cdFx0fSwgOTk5KTtcblx0XHRcblx0XHR0aGlzLmJpbmQoJ0xvYWQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHR0aGlzLnJlYWR5U3RhdGUgPSBGaWxlUmVhZGVyLkRPTkU7XG5cdFx0fSwgOTk5KTtcblxuXHRcdFxuXHRcdGZ1bmN0aW9uIF9yZWFkKG9wLCBibG9iKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XHRcdFx0XG5cblx0XHRcdHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG5cblx0XHRcdGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IEZpbGVSZWFkZXIuTE9BRElORykge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2Vycm9yJywgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKSk7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignbG9hZGVuZCcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHNvdXJjZSBpcyBub3Qgby5CbG9iL28uRmlsZVxuXHRcdFx0aWYgKCEoYmxvYiBpbnN0YW5jZW9mIEJsb2IpKSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignZXJyb3InLCBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uTk9UX0ZPVU5EX0VSUikpO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWRlbmQnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlc3VsdCA9IG51bGw7XG5cdFx0XHR0aGlzLnJlYWR5U3RhdGUgPSBGaWxlUmVhZGVyLkxPQURJTkc7XG5cdFx0XHRcblx0XHRcdGlmIChibG9iLmlzRGV0YWNoZWQoKSkge1xuXHRcdFx0XHR2YXIgc3JjID0gYmxvYi5nZXRTb3VyY2UoKTtcblx0XHRcdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0XHRcdGNhc2UgJ3JlYWRBc1RleHQnOlxuXHRcdFx0XHRcdGNhc2UgJ3JlYWRBc0JpbmFyeVN0cmluZyc6XG5cdFx0XHRcdFx0XHR0aGlzLnJlc3VsdCA9IHNyYztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3JlYWRBc0RhdGFVUkwnOlxuXHRcdFx0XHRcdFx0dGhpcy5yZXN1bHQgPSAnZGF0YTonICsgYmxvYi50eXBlICsgJztiYXNlNjQsJyArIEVuY29kZS5idG9hKHNyYyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJlYWR5U3RhdGUgPSBGaWxlUmVhZGVyLkRPTkU7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignbG9hZCcpO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWRlbmQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY29ubmVjdFJ1bnRpbWUoYmxvYi5ydWlkKTtcblx0XHRcdFx0dGhpcy5leGVjKCdGaWxlUmVhZGVyJywgJ3JlYWQnLCBvcCwgYmxvYik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0SW5pdGlhbCBGaWxlUmVhZGVyIHN0YXRlXG5cblx0QHByb3BlcnR5IEVNUFRZXG5cdEB0eXBlIHtOdW1iZXJ9XG5cdEBmaW5hbFxuXHRAc3RhdGljXG5cdEBkZWZhdWx0IDBcblx0Ki9cblx0RmlsZVJlYWRlci5FTVBUWSA9IDA7XG5cblx0LyoqXG5cdEZpbGVSZWFkZXIgc3dpdGNoZXMgdG8gdGhpcyBzdGF0ZSB3aGVuIGl0IGlzIHByZWxvYWRpbmcgdGhlIHNvdXJjZVxuXG5cdEBwcm9wZXJ0eSBMT0FESU5HXG5cdEB0eXBlIHtOdW1iZXJ9XG5cdEBmaW5hbFxuXHRAc3RhdGljXG5cdEBkZWZhdWx0IDFcblx0Ki9cblx0RmlsZVJlYWRlci5MT0FESU5HID0gMTtcblxuXHQvKipcblx0UHJlbG9hZGluZyBpcyBjb21wbGV0ZSwgdGhpcyBpcyBhIGZpbmFsIHN0YXRlXG5cblx0QHByb3BlcnR5IERPTkVcblx0QHR5cGUge051bWJlcn1cblx0QGZpbmFsXG5cdEBzdGF0aWNcblx0QGRlZmF1bHQgMlxuXHQqL1xuXHRGaWxlUmVhZGVyLkRPTkUgPSAyO1xuXG5cdEZpbGVSZWFkZXIucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cblx0cmV0dXJuIEZpbGVSZWFkZXI7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvY29yZS91dGlscy9VcmwuanNcblxuLyoqXG4gKiBVcmwuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9jb3JlL3V0aWxzL1VybCcsIFtcblx0J21veGllL2NvcmUvdXRpbHMvQmFzaWMnXG5dLCBmdW5jdGlvbihCYXNpYykge1xuXHQvKipcblx0UGFyc2UgdXJsIGludG8gc2VwYXJhdGUgY29tcG9uZW50cyBhbmQgZmlsbCBpbiBhYnNlbnQgcGFydHMgd2l0aCBwYXJ0cyBmcm9tIGN1cnJlbnQgdXJsLFxuXHRiYXNlZCBvbiBodHRwczovL3Jhdy5naXRodWIuY29tL2t2ei9waHBqcy9tYXN0ZXIvZnVuY3Rpb25zL3VybC9wYXJzZV91cmwuanNcblxuXHRAbWV0aG9kIHBhcnNlVXJsXG5cdEBmb3IgVXRpbHNcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ30gdXJsIFVybCB0byBwYXJzZSAoZGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nIGlmIHVuZGVmaW5lZClcblx0QHJldHVybiB7T2JqZWN0fSBIYXNoIGNvbnRhaW5pbmcgZXh0cmFjdGVkIHVyaSBjb21wb25lbnRzXG5cdCovXG5cdHZhciBwYXJzZVVybCA9IGZ1bmN0aW9uKHVybCwgY3VycmVudFVybCkge1xuXHRcdHZhciBrZXkgPSBbJ3NvdXJjZScsICdzY2hlbWUnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzcycsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdmcmFnbWVudCddXG5cdFx0LCBpID0ga2V5Lmxlbmd0aFxuXHRcdCwgcG9ydHMgPSB7XG5cdFx0XHRodHRwOiA4MCxcblx0XHRcdGh0dHBzOiA0NDNcblx0XHR9XG5cdFx0LCB1cmkgPSB7fVxuXHRcdCwgcmVnZXggPSAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygpKD86KD86KCkoPzooW146QFxcL10qKTo/KFteOkBcXC9dKikpP0ApPyhcXFtbXFxkYS1mQS1GOl0rXFxdfFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KCkoPzooKCkoPzooPzpbXj8jXFwvXSpcXC8pKikoKSg/OltePyNdKikpKD86XFxcXD8oW14jXSopKT8oPzojKC4qKSk/KS9cblx0XHQsIG0gPSByZWdleC5leGVjKHVybCB8fCAnJylcblx0XHQsIGlzUmVsYXRpdmVcblx0XHQsIGlzU2NoZW1lTGVzcyA9IC9eXFwvXFwvXFx3Ly50ZXN0KHVybClcblx0XHQ7XG5cblx0XHRzd2l0Y2ggKEJhc2ljLnR5cGVPZihjdXJyZW50VXJsKSkge1xuXHRcdFx0Y2FzZSAndW5kZWZpbmVkJzpcblx0XHRcdFx0Y3VycmVudFVybCA9IHBhcnNlVXJsKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsIGZhbHNlKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdGN1cnJlbnRVcmwgPSBwYXJzZVVybChjdXJyZW50VXJsLCBmYWxzZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChtW2ldKSB7XG5cdFx0XHRcdHVyaVtrZXlbaV1dID0gbVtpXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpc1JlbGF0aXZlID0gIWlzU2NoZW1lTGVzcyAmJiAhdXJpLnNjaGVtZTtcblxuXHRcdGlmIChpc1NjaGVtZUxlc3MgfHwgaXNSZWxhdGl2ZSkge1xuXHRcdFx0dXJpLnNjaGVtZSA9IGN1cnJlbnRVcmwuc2NoZW1lO1xuXHRcdH1cblxuXHRcdC8vIHdoZW4gdXJsIGlzIHJlbGF0aXZlLCB3ZSBzZXQgdGhlIG9yaWdpbiBhbmQgdGhlIHBhdGggb3Vyc2VsdmVzXG5cdFx0aWYgKGlzUmVsYXRpdmUpIHtcblx0XHRcdHVyaS5ob3N0ID0gY3VycmVudFVybC5ob3N0O1xuXHRcdFx0dXJpLnBvcnQgPSBjdXJyZW50VXJsLnBvcnQ7XG5cblx0XHRcdHZhciBwYXRoID0gJyc7XG5cdFx0XHQvLyBmb3IgdXJscyB3aXRob3V0IHRyYWlsaW5nIHNsYXNoIHdlIG5lZWQgdG8gZmlndXJlIG91dCB0aGUgcGF0aFxuXHRcdFx0aWYgKC9eW15cXC9dLy50ZXN0KHVyaS5wYXRoKSkge1xuXHRcdFx0XHRwYXRoID0gY3VycmVudFVybC5wYXRoO1xuXHRcdFx0XHQvLyBpZiBwYXRoIGVuZHMgd2l0aCBhIGZpbGVuYW1lLCBzdHJpcCBpdFxuXHRcdFx0XHRpZiAoL1xcL1teXFwvXSpcXC5bXlxcL10qJC8udGVzdChwYXRoKSkge1xuXHRcdFx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcL1teXFwvXSskLywgJy8nKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBhdm9pZCBkb3VibGUgc2xhc2ggYXQgdGhlIGVuZCAoc2VlICMxMjcpXG5cdFx0XHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvPyQvLCAnLycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR1cmkucGF0aCA9IHBhdGggKyAodXJpLnBhdGggfHwgJycpOyAvLyBzaXRlIG1heSByZXNpZGUgYXQgZG9tYWluLmNvbSBvciBkb21haW4uY29tL3N1YmRpclxuXHRcdH1cblxuXHRcdGlmICghdXJpLnBvcnQpIHtcblx0XHRcdHVyaS5wb3J0ID0gcG9ydHNbdXJpLnNjaGVtZV0gfHwgODA7XG5cdFx0fVxuXG5cdFx0dXJpLnBvcnQgPSBwYXJzZUludCh1cmkucG9ydCwgMTApO1xuXG5cdFx0aWYgKCF1cmkucGF0aCkge1xuXHRcdFx0dXJpLnBhdGggPSBcIi9cIjtcblx0XHR9XG5cblx0XHRkZWxldGUgdXJpLnNvdXJjZTtcblxuXHRcdHJldHVybiB1cmk7XG5cdH07XG5cblx0LyoqXG5cdFJlc29sdmUgdXJsIC0gYW1vbmcgb3RoZXIgdGhpbmdzIHdpbGwgdHVybiByZWxhdGl2ZSB1cmwgdG8gYWJzb2x1dGVcblxuXHRAbWV0aG9kIHJlc29sdmVVcmxcblx0QHN0YXRpY1xuXHRAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVybCBFaXRoZXIgYWJzb2x1dGUgb3IgcmVsYXRpdmUsIG9yIGEgcmVzdWx0IG9mIHBhcnNlVXJsIGNhbGxcblx0QHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCwgYWJzb2x1dGUgdXJsXG5cdCovXG5cdHZhciByZXNvbHZlVXJsID0gZnVuY3Rpb24odXJsKSB7XG5cdFx0dmFyIHBvcnRzID0geyAvLyB3ZSBpZ25vcmUgZGVmYXVsdCBwb3J0c1xuXHRcdFx0aHR0cDogODAsXG5cdFx0XHRodHRwczogNDQzXG5cdFx0fVxuXHRcdCwgdXJscCA9IHR5cGVvZih1cmwpID09PSAnb2JqZWN0JyA/IHVybCA6IHBhcnNlVXJsKHVybCk7XG5cdFx0O1xuXG5cdFx0cmV0dXJuIHVybHAuc2NoZW1lICsgJzovLycgKyB1cmxwLmhvc3QgKyAodXJscC5wb3J0ICE9PSBwb3J0c1t1cmxwLnNjaGVtZV0gPyAnOicgKyB1cmxwLnBvcnQgOiAnJykgKyB1cmxwLnBhdGggKyAodXJscC5xdWVyeSA/IHVybHAucXVlcnkgOiAnJyk7XG5cdH07XG5cblx0LyoqXG5cdENoZWNrIGlmIHNwZWNpZmllZCB1cmwgaGFzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBkb2N1bWVudFxuXG5cdEBtZXRob2QgaGFzU2FtZU9yaWdpblxuXHRAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVybFxuXHRAcmV0dXJuIHtCb29sZWFufVxuXHQqL1xuXHR2YXIgaGFzU2FtZU9yaWdpbiA9IGZ1bmN0aW9uKHVybCkge1xuXHRcdGZ1bmN0aW9uIG9yaWdpbih1cmwpIHtcblx0XHRcdHJldHVybiBbdXJsLnNjaGVtZSwgdXJsLmhvc3QsIHVybC5wb3J0XS5qb2luKCcvJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR1cmwgPSBwYXJzZVVybCh1cmwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBvcmlnaW4ocGFyc2VVcmwoKSkgPT09IG9yaWdpbih1cmwpO1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0cGFyc2VVcmw6IHBhcnNlVXJsLFxuXHRcdHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG5cdFx0aGFzU2FtZU9yaWdpbjogaGFzU2FtZU9yaWdpblxuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvUnVudGltZVRhcmdldC5qc1xuXG4vKipcbiAqIFJ1bnRpbWVUYXJnZXQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9ydW50aW1lL1J1bnRpbWVUYXJnZXQnLCBbXG5cdCdtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljJyxcblx0J21veGllL3J1bnRpbWUvUnVudGltZUNsaWVudCcsXG5cdFwibW94aWUvY29yZS9FdmVudFRhcmdldFwiXG5dLCBmdW5jdGlvbihCYXNpYywgUnVudGltZUNsaWVudCwgRXZlbnRUYXJnZXQpIHtcblx0LyoqXG5cdEluc3RhbmNlIG9mIHRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgYXMgYSB0YXJnZXQgZm9yIHRoZSBldmVudHMgZGlzcGF0Y2hlZCBieSBzaGltcyxcblx0d2hlbiBhbGxvd2luZyB0aGVtIG9udG8gY29tcG9uZW50cyBpcyBmb3IgZWl0aGVyIHJlYXNvbiBpbmFwcHJvcHJpYXRlXG5cblx0QGNsYXNzIG1veGllL3J1bnRpbWUvUnVudGltZVRhcmdldFxuXHRAY29uc3RydWN0b3Jcblx0QHByb3RlY3RlZFxuXHRAZXh0ZW5kcyBFdmVudFRhcmdldFxuXHQqL1xuXHRmdW5jdGlvbiBSdW50aW1lVGFyZ2V0KCkge1xuXHRcdHRoaXMudWlkID0gQmFzaWMuZ3VpZCgndWlkXycpO1xuXHRcdFxuXHRcdFJ1bnRpbWVDbGllbnQuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuXHRcdFx0dGhpcy51bmJpbmRBbGwoKTtcblx0XHR9O1xuXHR9XG5cblx0UnVudGltZVRhcmdldC5wcm90b3R5cGUgPSBFdmVudFRhcmdldC5pbnN0YW5jZTtcblxuXHRyZXR1cm4gUnVudGltZVRhcmdldDtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9maWxlL0ZpbGVSZWFkZXJTeW5jLmpzXG5cbi8qKlxuICogRmlsZVJlYWRlclN5bmMuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKCdtb3hpZS9maWxlL0ZpbGVSZWFkZXJTeW5jJywgW1xuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYycsXG5cdCdtb3hpZS9ydW50aW1lL1J1bnRpbWVDbGllbnQnLFxuXHQnbW94aWUvY29yZS91dGlscy9FbmNvZGUnXG5dLCBmdW5jdGlvbihCYXNpYywgUnVudGltZUNsaWVudCwgRW5jb2RlKSB7XG5cdC8qKlxuXHRTeW5jaHJvbm91cyBGaWxlUmVhZGVyIGltcGxlbWVudGF0aW9uLiBTb21ldGhpbmcgbGlrZSB0aGlzIGlzIGF2YWlsYWJsZSBpbiBXZWJXb3JrZXJzIGVudmlyb25tZW50LCBoZXJlXG5cdGl0IGNhbiBiZSB1c2VkIHRvIHJlYWQgb25seSBwcmVsb2FkZWQgYmxvYnMvZmlsZXMgYW5kIG9ubHkgYmVsb3cgY2VydGFpbiBzaXplIChub3QgeWV0IHN1cmUgd2hhdCB0aGF0J2QgYmUsXG5cdGJ1dCBwcm9iYWJseSA8IDFtYikuIE5vdCBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5IGJ5IHVzZXIuXG5cblx0QGNsYXNzIG1veGllL2ZpbGUvRmlsZVJlYWRlclN5bmNcblx0QHByaXZhdGVcblx0QGNvbnN0cnVjdG9yXG5cdCovXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRSdW50aW1lQ2xpZW50LmNhbGwodGhpcyk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0dWlkOiBCYXNpYy5ndWlkKCd1aWRfJyksXG5cblx0XHRcdHJlYWRBc0JpbmFyeVN0cmluZzogZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gX3JlYWQuY2FsbCh0aGlzLCAncmVhZEFzQmluYXJ5U3RyaW5nJywgYmxvYik7XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHRyZWFkQXNEYXRhVVJMOiBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHRcdHJldHVybiBfcmVhZC5jYWxsKHRoaXMsICdyZWFkQXNEYXRhVVJMJywgYmxvYik7XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHQvKnJlYWRBc0FycmF5QnVmZmVyOiBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHRcdHJldHVybiBfcmVhZC5jYWxsKHRoaXMsICdyZWFkQXNBcnJheUJ1ZmZlcicsIGJsb2IpO1xuXHRcdFx0fSwqL1xuXHRcdFx0XG5cdFx0XHRyZWFkQXNUZXh0OiBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHRcdHJldHVybiBfcmVhZC5jYWxsKHRoaXMsICdyZWFkQXNUZXh0JywgYmxvYik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBfcmVhZChvcCwgYmxvYikge1xuXHRcdFx0aWYgKGJsb2IuaXNEZXRhY2hlZCgpKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBibG9iLmdldFNvdXJjZSgpO1xuXHRcdFx0XHRzd2l0Y2ggKG9wKSB7XG5cdFx0XHRcdFx0Y2FzZSAncmVhZEFzQmluYXJ5U3RyaW5nJzpcblx0XHRcdFx0XHRcdHJldHVybiBzcmM7XG5cdFx0XHRcdFx0Y2FzZSAncmVhZEFzRGF0YVVSTCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ2RhdGE6JyArIGJsb2IudHlwZSArICc7YmFzZTY0LCcgKyBFbmNvZGUuYnRvYShzcmMpO1xuXHRcdFx0XHRcdGNhc2UgJ3JlYWRBc1RleHQnOlxuXHRcdFx0XHRcdFx0dmFyIHR4dCA9ICcnO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNyYy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0eHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzcmNbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHR4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuY29ubmVjdFJ1bnRpbWUoYmxvYi5ydWlkKS5leGVjLmNhbGwodGhpcywgJ0ZpbGVSZWFkZXJTeW5jJywgJ3JlYWQnLCBvcCwgYmxvYik7XG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdFJ1bnRpbWUoKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQveGhyL0Zvcm1EYXRhLmpzXG5cbi8qKlxuICogRm9ybURhdGEuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKFwibW94aWUveGhyL0Zvcm1EYXRhXCIsIFtcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCJcbl0sIGZ1bmN0aW9uKHgsIEJhc2ljLCBCbG9iKSB7XG5cdC8qKlxuXHRGb3JtRGF0YVxuXG5cdEBjbGFzcyBtb3hpZS94aHIvRm9ybURhdGFcblx0QGNvbnN0cnVjdG9yXG5cdCovXG5cdGZ1bmN0aW9uIEZvcm1EYXRhKCkge1xuXHRcdHZhciBfYmxvYiwgX2ZpZWxkcyA9IFtdO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdC8qKlxuXHRcdFx0QXBwZW5kIGFub3RoZXIga2V5LXZhbHVlIHBhaXIgdG8gdGhlIEZvcm1EYXRhIG9iamVjdFxuXG5cdFx0XHRAbWV0aG9kIGFwcGVuZFxuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBmb3IgdGhlIG5ldyBmaWVsZFxuXHRcdFx0QHBhcmFtIHtTdHJpbmd8QmxvYnxBcnJheXxPYmplY3R9IHZhbHVlIFZhbHVlIGZvciB0aGUgZmllbGRcblx0XHRcdCovXG5cdFx0XHRhcHBlbmQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcywgdmFsdWVUeXBlID0gQmFzaWMudHlwZU9mKHZhbHVlKTtcblxuXHRcdFx0XHQvLyBhY2NvcmRpbmcgdG8gc3BlY3MgdmFsdWUgbWlnaHQgYmUgZWl0aGVyIEJsb2Igb3IgU3RyaW5nXG5cdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRfYmxvYiA9IHtcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUgLy8gdW5mb3J0dW5hdGVseSB3ZSBjYW4gb25seSBzZW5kIHNpbmdsZSBCbG9iIGluIG9uZSBGb3JtRGF0YVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoJ2FycmF5JyA9PT0gdmFsdWVUeXBlKSB7XG5cdFx0XHRcdFx0bmFtZSArPSAnW10nO1xuXG5cdFx0XHRcdFx0QmFzaWMuZWFjaCh2YWx1ZSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdHNlbGYuYXBwZW5kKG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdmFsdWVUeXBlKSB7XG5cdFx0XHRcdFx0QmFzaWMuZWFjaCh2YWx1ZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHRcdFx0c2VsZi5hcHBlbmQobmFtZSArICdbJyArIGtleSArICddJywgdmFsdWUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCdudWxsJyA9PT0gdmFsdWVUeXBlIHx8ICd1bmRlZmluZWQnID09PSB2YWx1ZVR5cGUgfHwgJ251bWJlcicgPT09IHZhbHVlVHlwZSAmJiBpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0XHRzZWxmLmFwcGVuZChuYW1lLCBcImZhbHNlXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9maWVsZHMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvU3RyaW5nKClcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRDaGVja3MgaWYgRm9ybURhdGEgY29udGFpbnMgQmxvYi5cblxuXHRcdFx0QG1ldGhvZCBoYXNCbG9iXG5cdFx0XHRAcmV0dXJuIHtCb29sZWFufVxuXHRcdFx0Ki9cblx0XHRcdGhhc0Jsb2I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISF0aGlzLmdldEJsb2IoKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0UmV0cmlldmVzIGJsb2IuXG5cblx0XHRcdEBtZXRob2QgZ2V0QmxvYlxuXHRcdFx0QHJldHVybiB7T2JqZWN0fSBFaXRoZXIgQmxvYiBpZiBmb3VuZCBvciBudWxsXG5cdFx0XHQqL1xuXHRcdFx0Z2V0QmxvYjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfYmxvYiAmJiBfYmxvYi52YWx1ZSB8fCBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXRyaWV2ZXMgYmxvYiBmaWVsZCBuYW1lLlxuXG5cdFx0XHRAbWV0aG9kIGdldEJsb2JOYW1lXG5cdFx0XHRAcmV0dXJuIHtTdHJpbmd9IEVpdGhlciBCbG9iIGZpZWxkIG5hbWUgb3IgbnVsbFxuXHRcdFx0Ki9cblx0XHRcdGdldEJsb2JOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9ibG9iICYmIF9ibG9iLm5hbWUgfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0TG9vcCBvdmVyIHRoZSBmaWVsZHMgaW4gRm9ybURhdGEgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlbS5cblxuXHRcdFx0QG1ldGhvZCBlYWNoXG5cdFx0XHRAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGZpZWxkXG5cdFx0XHQqL1xuXHRcdFx0ZWFjaDogZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0QmFzaWMuZWFjaChfZmllbGRzLCBmdW5jdGlvbihmaWVsZCkge1xuXHRcdFx0XHRcdGNiKGZpZWxkLnZhbHVlLCBmaWVsZC5uYW1lKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKF9ibG9iKSB7XG5cdFx0XHRcdFx0Y2IoX2Jsb2IudmFsdWUsIF9ibG9iLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X2Jsb2IgPSBudWxsO1xuXHRcdFx0XHRfZmllbGRzID0gW107XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gRm9ybURhdGE7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQveGhyL1hNTEh0dHBSZXF1ZXN0LmpzXG5cbi8qKlxuICogWE1MSHR0cFJlcXVlc3QuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuZGVmaW5lKFwibW94aWUveGhyL1hNTEh0dHBSZXF1ZXN0XCIsIFtcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvY29yZS9FdmVudFRhcmdldFwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW5jb2RlXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9VcmxcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVUYXJnZXRcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVSZWFkZXJTeW5jXCIsXG5cdFwibW94aWUveGhyL0Zvcm1EYXRhXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbnZcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL01pbWVcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIHgsIEV2ZW50VGFyZ2V0LCBFbmNvZGUsIFVybCwgUnVudGltZSwgUnVudGltZVRhcmdldCwgQmxvYiwgRmlsZVJlYWRlclN5bmMsIEZvcm1EYXRhLCBFbnYsIE1pbWUpIHtcblxuXHR2YXIgaHR0cENvZGUgPSB7XG5cdFx0MTAwOiAnQ29udGludWUnLFxuXHRcdDEwMTogJ1N3aXRjaGluZyBQcm90b2NvbHMnLFxuXHRcdDEwMjogJ1Byb2Nlc3NpbmcnLFxuXG5cdFx0MjAwOiAnT0snLFxuXHRcdDIwMTogJ0NyZWF0ZWQnLFxuXHRcdDIwMjogJ0FjY2VwdGVkJyxcblx0XHQyMDM6ICdOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbicsXG5cdFx0MjA0OiAnTm8gQ29udGVudCcsXG5cdFx0MjA1OiAnUmVzZXQgQ29udGVudCcsXG5cdFx0MjA2OiAnUGFydGlhbCBDb250ZW50Jyxcblx0XHQyMDc6ICdNdWx0aS1TdGF0dXMnLFxuXHRcdDIyNjogJ0lNIFVzZWQnLFxuXG5cdFx0MzAwOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG5cdFx0MzAxOiAnTW92ZWQgUGVybWFuZW50bHknLFxuXHRcdDMwMjogJ0ZvdW5kJyxcblx0XHQzMDM6ICdTZWUgT3RoZXInLFxuXHRcdDMwNDogJ05vdCBNb2RpZmllZCcsXG5cdFx0MzA1OiAnVXNlIFByb3h5Jyxcblx0XHQzMDY6ICdSZXNlcnZlZCcsXG5cdFx0MzA3OiAnVGVtcG9yYXJ5IFJlZGlyZWN0JyxcblxuXHRcdDQwMDogJ0JhZCBSZXF1ZXN0Jyxcblx0XHQ0MDE6ICdVbmF1dGhvcml6ZWQnLFxuXHRcdDQwMjogJ1BheW1lbnQgUmVxdWlyZWQnLFxuXHRcdDQwMzogJ0ZvcmJpZGRlbicsXG5cdFx0NDA0OiAnTm90IEZvdW5kJyxcblx0XHQ0MDU6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuXHRcdDQwNjogJ05vdCBBY2NlcHRhYmxlJyxcblx0XHQ0MDc6ICdQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcsXG5cdFx0NDA4OiAnUmVxdWVzdCBUaW1lb3V0Jyxcblx0XHQ0MDk6ICdDb25mbGljdCcsXG5cdFx0NDEwOiAnR29uZScsXG5cdFx0NDExOiAnTGVuZ3RoIFJlcXVpcmVkJyxcblx0XHQ0MTI6ICdQcmVjb25kaXRpb24gRmFpbGVkJyxcblx0XHQ0MTM6ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnLFxuXHRcdDQxNDogJ1JlcXVlc3QtVVJJIFRvbyBMb25nJyxcblx0XHQ0MTU6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcblx0XHQ0MTY6ICdSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlJyxcblx0XHQ0MTc6ICdFeHBlY3RhdGlvbiBGYWlsZWQnLFxuXHRcdDQyMjogJ1VucHJvY2Vzc2FibGUgRW50aXR5Jyxcblx0XHQ0MjM6ICdMb2NrZWQnLFxuXHRcdDQyNDogJ0ZhaWxlZCBEZXBlbmRlbmN5Jyxcblx0XHQ0MjY6ICdVcGdyYWRlIFJlcXVpcmVkJyxcblxuXHRcdDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG5cdFx0NTAxOiAnTm90IEltcGxlbWVudGVkJyxcblx0XHQ1MDI6ICdCYWQgR2F0ZXdheScsXG5cdFx0NTAzOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG5cdFx0NTA0OiAnR2F0ZXdheSBUaW1lb3V0Jyxcblx0XHQ1MDU6ICdIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZCcsXG5cdFx0NTA2OiAnVmFyaWFudCBBbHNvIE5lZ290aWF0ZXMnLFxuXHRcdDUwNzogJ0luc3VmZmljaWVudCBTdG9yYWdlJyxcblx0XHQ1MTA6ICdOb3QgRXh0ZW5kZWQnXG5cdH07XG5cblx0ZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3RVcGxvYWQoKSB7XG5cdFx0dGhpcy51aWQgPSBCYXNpYy5ndWlkKCd1aWRfJyk7XG5cdH1cblxuXHRYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUgPSBFdmVudFRhcmdldC5pbnN0YW5jZTtcblxuXHQvKipcblx0SW1wbGVtZW50YXRpb24gb2YgWE1MSHR0cFJlcXVlc3RcblxuXHRAY2xhc3MgbW94aWUveGhyL1hNTEh0dHBSZXF1ZXN0XG5cdEBjb25zdHJ1Y3RvclxuXHRAdXNlcyBSdW50aW1lQ2xpZW50XG5cdEBleHRlbmRzIEV2ZW50VGFyZ2V0XG5cdCovXG5cdHZhciBkaXNwYXRjaGVzID0gW1xuXHRcdCdsb2Fkc3RhcnQnLFxuXG5cdFx0J3Byb2dyZXNzJyxcblxuXHRcdCdhYm9ydCcsXG5cblx0XHQnZXJyb3InLFxuXG5cdFx0J2xvYWQnLFxuXG5cdFx0J3RpbWVvdXQnLFxuXG5cdFx0J2xvYWRlbmQnXG5cblx0XHQvLyByZWFkeXN0YXRlY2hhbmdlIChmb3IgaGlzdG9yaWNhbCByZWFzb25zKVxuXHRdO1xuXG5cdHZhciBOQVRJVkUgPSAxLCBSVU5USU1FID0gMjtcblxuXHRmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdCgpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHQvLyB0aGlzICh0b2dldGhlciB3aXRoIF9wKCkgQHNlZSBiZWxvdykgaXMgaGVyZSB0byBncmFjZWZ1bGx5IHVwZ3JhZGUgdG8gc2V0dGVyL2dldHRlciBzeW50YXggd2hlcmUgcG9zc2libGVcblx0XHRcdHByb3BzID0ge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0VGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYSByZXF1ZXN0IGNhbiB0YWtlIGJlZm9yZSBiZWluZyB0ZXJtaW5hdGVkLiBJbml0aWFsbHkgemVyby4gWmVybyBtZWFucyB0aGVyZSBpcyBubyB0aW1lb3V0LlxuXG5cdFx0XHRcdEBwcm9wZXJ0eSB0aW1lb3V0XG5cdFx0XHRcdEB0eXBlIE51bWJlclxuXHRcdFx0XHRAZGVmYXVsdCAwXG5cdFx0XHRcdCovXG5cdFx0XHRcdHRpbWVvdXQ6IDAsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdEN1cnJlbnQgc3RhdGUsIGNhbiB0YWtlIGZvbGxvd2luZyB2YWx1ZXM6XG5cdFx0XHRcdFVOU0VOVCAobnVtZXJpYyB2YWx1ZSAwKVxuXHRcdFx0XHRUaGUgb2JqZWN0IGhhcyBiZWVuIGNvbnN0cnVjdGVkLlxuXG5cdFx0XHRcdE9QRU5FRCAobnVtZXJpYyB2YWx1ZSAxKVxuXHRcdFx0XHRUaGUgb3BlbigpIG1ldGhvZCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgaW52b2tlZC4gRHVyaW5nIHRoaXMgc3RhdGUgcmVxdWVzdCBoZWFkZXJzIGNhbiBiZSBzZXQgdXNpbmcgc2V0UmVxdWVzdEhlYWRlcigpIGFuZCB0aGUgcmVxdWVzdCBjYW4gYmUgbWFkZSB1c2luZyB0aGUgc2VuZCgpIG1ldGhvZC5cblxuXHRcdFx0XHRIRUFERVJTX1JFQ0VJVkVEIChudW1lcmljIHZhbHVlIDIpXG5cdFx0XHRcdEFsbCByZWRpcmVjdHMgKGlmIGFueSkgaGF2ZSBiZWVuIGZvbGxvd2VkIGFuZCBhbGwgSFRUUCBoZWFkZXJzIG9mIHRoZSBmaW5hbCByZXNwb25zZSBoYXZlIGJlZW4gcmVjZWl2ZWQuIFNldmVyYWwgcmVzcG9uc2UgbWVtYmVycyBvZiB0aGUgb2JqZWN0IGFyZSBub3cgYXZhaWxhYmxlLlxuXG5cdFx0XHRcdExPQURJTkcgKG51bWVyaWMgdmFsdWUgMylcblx0XHRcdFx0VGhlIHJlc3BvbnNlIGVudGl0eSBib2R5IGlzIGJlaW5nIHJlY2VpdmVkLlxuXG5cdFx0XHRcdERPTkUgKG51bWVyaWMgdmFsdWUgNClcblxuXHRcdFx0XHRAcHJvcGVydHkgcmVhZHlTdGF0ZVxuXHRcdFx0XHRAdHlwZSBOdW1iZXJcblx0XHRcdFx0QGRlZmF1bHQgMCAoVU5TRU5UKVxuXHRcdFx0XHQqL1xuXHRcdFx0XHRyZWFkeVN0YXRlOiBYTUxIdHRwUmVxdWVzdC5VTlNFTlQsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdFRydWUgd2hlbiB1c2VyIGNyZWRlbnRpYWxzIGFyZSB0byBiZSBpbmNsdWRlZCBpbiBhIGNyb3NzLW9yaWdpbiByZXF1ZXN0LiBGYWxzZSB3aGVuIHRoZXkgYXJlIHRvIGJlIGV4Y2x1ZGVkXG5cdFx0XHRcdGluIGEgY3Jvc3Mtb3JpZ2luIHJlcXVlc3QgYW5kIHdoZW4gY29va2llcyBhcmUgdG8gYmUgaWdub3JlZCBpbiBpdHMgcmVzcG9uc2UuIEluaXRpYWxseSBmYWxzZS5cblxuXHRcdFx0XHRAcHJvcGVydHkgd2l0aENyZWRlbnRpYWxzXG5cdFx0XHRcdEB0eXBlIEJvb2xlYW5cblx0XHRcdFx0QGRlZmF1bHQgZmFsc2Vcblx0XHRcdFx0Ki9cblx0XHRcdFx0d2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0UmV0dXJucyB0aGUgSFRUUCBzdGF0dXMgY29kZS5cblxuXHRcdFx0XHRAcHJvcGVydHkgc3RhdHVzXG5cdFx0XHRcdEB0eXBlIE51bWJlclxuXHRcdFx0XHRAZGVmYXVsdCAwXG5cdFx0XHRcdCovXG5cdFx0XHRcdHN0YXR1czogMCxcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0UmV0dXJucyB0aGUgSFRUUCBzdGF0dXMgdGV4dC5cblxuXHRcdFx0XHRAcHJvcGVydHkgc3RhdHVzVGV4dFxuXHRcdFx0XHRAdHlwZSBTdHJpbmdcblx0XHRcdFx0Ki9cblx0XHRcdFx0c3RhdHVzVGV4dDogXCJcIixcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0UmV0dXJucyB0aGUgcmVzcG9uc2UgdHlwZS4gQ2FuIGJlIHNldCB0byBjaGFuZ2UgdGhlIHJlc3BvbnNlIHR5cGUuIFZhbHVlcyBhcmU6XG5cdFx0XHRcdHRoZSBlbXB0eSBzdHJpbmcgKGRlZmF1bHQpLCBcImFycmF5YnVmZmVyXCIsIFwiYmxvYlwiLCBcImRvY3VtZW50XCIsIFwianNvblwiLCBhbmQgXCJ0ZXh0XCIuXG5cblx0XHRcdFx0QHByb3BlcnR5IHJlc3BvbnNlVHlwZVxuXHRcdFx0XHRAdHlwZSBTdHJpbmdcblx0XHRcdFx0Ki9cblx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlwiLFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHRSZXR1cm5zIHRoZSBkb2N1bWVudCByZXNwb25zZSBlbnRpdHkgYm9keS5cblxuXHRcdFx0XHRUaHJvd3MgYW4gXCJJbnZhbGlkU3RhdGVFcnJvclwiIGV4Y2VwdGlvbiBpZiByZXNwb25zZVR5cGUgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcgb3IgXCJkb2N1bWVudFwiLlxuXG5cdFx0XHRcdEBwcm9wZXJ0eSByZXNwb25zZVhNTFxuXHRcdFx0XHRAdHlwZSBEb2N1bWVudFxuXHRcdFx0XHQqL1xuXHRcdFx0XHRyZXNwb25zZVhNTDogbnVsbCxcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0UmV0dXJucyB0aGUgdGV4dCByZXNwb25zZSBlbnRpdHkgYm9keS5cblxuXHRcdFx0XHRUaHJvd3MgYW4gXCJJbnZhbGlkU3RhdGVFcnJvclwiIGV4Y2VwdGlvbiBpZiByZXNwb25zZVR5cGUgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcgb3IgXCJ0ZXh0XCIuXG5cblx0XHRcdFx0QHByb3BlcnR5IHJlc3BvbnNlVGV4dFxuXHRcdFx0XHRAdHlwZSBTdHJpbmdcblx0XHRcdFx0Ki9cblx0XHRcdFx0cmVzcG9uc2VUZXh0OiBudWxsLFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHRSZXR1cm5zIHRoZSByZXNwb25zZSBlbnRpdHkgYm9keSAoaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3Jlc3BvbnNlLWVudGl0eS1ib2R5KS5cblx0XHRcdFx0Q2FuIGJlY29tZTogQXJyYXlCdWZmZXIsIEJsb2IsIERvY3VtZW50LCBKU09OLCBUZXh0XG5cblx0XHRcdFx0QHByb3BlcnR5IHJlc3BvbnNlXG5cdFx0XHRcdEB0eXBlIE1peGVkXG5cdFx0XHRcdCovXG5cdFx0XHRcdHJlc3BvbnNlOiBudWxsXG5cdFx0XHR9LFxuXG5cdFx0XHRfYXN5bmMgPSB0cnVlLFxuXHRcdFx0X3VybCxcblx0XHRcdF9tZXRob2QsXG5cdFx0XHRfaGVhZGVycyA9IHt9LFxuXHRcdFx0X3VzZXIsXG5cdFx0XHRfcGFzc3dvcmQsXG5cdFx0XHRfZW5jb2RpbmcgPSBudWxsLFxuXHRcdFx0X21pbWVUeXBlID0gbnVsbCxcblxuXHRcdFx0Ly8gZmxhZ3Ncblx0XHRcdF9zeW5jX2ZsYWcgPSBmYWxzZSxcblx0XHRcdF9zZW5kX2ZsYWcgPSBmYWxzZSxcblx0XHRcdF91cGxvYWRfZXZlbnRzX2ZsYWcgPSBmYWxzZSxcblx0XHRcdF91cGxvYWRfY29tcGxldGVfZmxhZyA9IGZhbHNlLFxuXHRcdFx0X2Vycm9yX2ZsYWcgPSBmYWxzZSxcblx0XHRcdF9zYW1lX29yaWdpbl9mbGFnID0gZmFsc2UsXG5cblx0XHRcdC8vIHRpbWVzXG5cdFx0XHRfc3RhcnRfdGltZSxcblx0XHRcdF90aW1lb3V0c2V0X3RpbWUsXG5cblx0XHRcdF9maW5hbE1pbWUgPSBudWxsLFxuXHRcdFx0X2ZpbmFsQ2hhcnNldCA9IG51bGwsXG5cblx0XHRcdF9vcHRpb25zID0ge30sXG5cdFx0XHRfeGhyLFxuXHRcdFx0X3Jlc3BvbnNlSGVhZGVycyA9ICcnLFxuXHRcdFx0X3Jlc3BvbnNlSGVhZGVyc0JhZ1xuXHRcdFx0O1xuXG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywgcHJvcHMsIHtcblx0XHRcdC8qKlxuXHRcdFx0VW5pcXVlIGlkIG9mIHRoZSBjb21wb25lbnRcblxuXHRcdFx0QHByb3BlcnR5IHVpZFxuXHRcdFx0QHR5cGUgU3RyaW5nXG5cdFx0XHQqL1xuXHRcdFx0dWlkOiBCYXNpYy5ndWlkKCd1aWRfJyksXG5cblx0XHRcdC8qKlxuXHRcdFx0VGFyZ2V0IGZvciBVcGxvYWQgZXZlbnRzXG5cblx0XHRcdEBwcm9wZXJ0eSB1cGxvYWRcblx0XHRcdEB0eXBlIFhNTEh0dHBSZXF1ZXN0VXBsb2FkXG5cdFx0XHQqL1xuXHRcdFx0dXBsb2FkOiBuZXcgWE1MSHR0cFJlcXVlc3RVcGxvYWQoKSxcblxuXG5cdFx0XHQvKipcblx0XHRcdFNldHMgdGhlIHJlcXVlc3QgbWV0aG9kLCByZXF1ZXN0IFVSTCwgc3luY2hyb25vdXMgZmxhZywgcmVxdWVzdCB1c2VybmFtZSwgYW5kIHJlcXVlc3QgcGFzc3dvcmQuXG5cblx0XHRcdFRocm93cyBhIFwiU3ludGF4RXJyb3JcIiBleGNlcHRpb24gaWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcblxuXHRcdFx0bWV0aG9kIGlzIG5vdCBhIHZhbGlkIEhUVFAgbWV0aG9kLlxuXHRcdFx0dXJsIGNhbm5vdCBiZSByZXNvbHZlZC5cblx0XHRcdHVybCBjb250YWlucyB0aGUgXCJ1c2VyOnBhc3N3b3JkXCIgZm9ybWF0IGluIHRoZSB1c2VyaW5mbyBwcm9kdWN0aW9uLlxuXHRcdFx0VGhyb3dzIGEgXCJTZWN1cml0eUVycm9yXCIgZXhjZXB0aW9uIGlmIG1ldGhvZCBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIENPTk5FQ1QsIFRSQUNFIG9yIFRSQUNLLlxuXG5cdFx0XHRUaHJvd3MgYW4gXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiBleGNlcHRpb24gaWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcblxuXHRcdFx0RWl0aGVyIHVzZXIgb3IgcGFzc3dvcmQgaXMgcGFzc2VkIGFzIGFyZ3VtZW50IGFuZCB0aGUgb3JpZ2luIG9mIHVybCBkb2VzIG5vdCBtYXRjaCB0aGUgWE1MSHR0cFJlcXVlc3Qgb3JpZ2luLlxuXHRcdFx0VGhlcmUgaXMgYW4gYXNzb2NpYXRlZCBYTUxIdHRwUmVxdWVzdCBkb2N1bWVudCBhbmQgZWl0aGVyIHRoZSB0aW1lb3V0IGF0dHJpYnV0ZSBpcyBub3QgemVybyxcblx0XHRcdHRoZSB3aXRoQ3JlZGVudGlhbHMgYXR0cmlidXRlIGlzIHRydWUsIG9yIHRoZSByZXNwb25zZVR5cGUgYXR0cmlidXRlIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLlxuXG5cblx0XHRcdEBtZXRob2Qgb3BlblxuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBIVFRQIG1ldGhvZCB0byB1c2Ugb24gcmVxdWVzdFxuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gcmVxdWVzdFxuXHRcdFx0QHBhcmFtIHtCb29sZWFufSBbYXN5bmM9dHJ1ZV0gSWYgZmFsc2UgcmVxdWVzdCB3aWxsIGJlIGRvbmUgaW4gc3luY2hyb25vdXMgbWFubmVyLiBBc3luY2hyb25vdXMgYnkgZGVmYXVsdC5cblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBbdXNlcl0gVXNlcm5hbWUgdG8gdXNlIGluIEhUVFAgYXV0aGVudGljYXRpb24gcHJvY2VzcyBvbiBzZXJ2ZXItc2lkZVxuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IFtwYXNzd29yZF0gUGFzc3dvcmQgdG8gdXNlIGluIEhUVFAgYXV0aGVudGljYXRpb24gcHJvY2VzcyBvbiBzZXJ2ZXItc2lkZVxuXHRcdFx0Ki9cblx0XHRcdG9wZW46IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpIHtcblx0XHRcdFx0dmFyIHVybHA7XG5cblx0XHRcdFx0Ly8gZmlyc3QgdHdvIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWRcblx0XHRcdFx0aWYgKCFtZXRob2QgfHwgIXVybCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5TWU5UQVhfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDIgLSBjaGVjayBpZiBhbnkgY29kZSBwb2ludCBpbiBtZXRob2QgaXMgaGlnaGVyIHRoYW4gVSswMEZGIG9yIGFmdGVyIGRlZmxhdGluZyBtZXRob2QgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIG1ldGhvZFxuXHRcdFx0XHRpZiAoL1tcXHUwMTAwLVxcdWZmZmZdLy50ZXN0KG1ldGhvZCkgfHwgRW5jb2RlLnV0ZjhfZW5jb2RlKG1ldGhvZCkgIT09IG1ldGhvZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5TWU5UQVhfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDNcblx0XHRcdFx0aWYgKCEhfkJhc2ljLmluQXJyYXkobWV0aG9kLnRvVXBwZXJDYXNlKCksIFsnQ09OTkVDVCcsICdERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCcsICdUUkFDRScsICdUUkFDSyddKSkge1xuXHRcdFx0XHRcdF9tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Ly8gNCAtIGFsbG93aW5nIHRoZXNlIG1ldGhvZHMgcG9zZXMgYSBzZWN1cml0eSByaXNrXG5cdFx0XHRcdGlmICghIX5CYXNpYy5pbkFycmF5KF9tZXRob2QsIFsnQ09OTkVDVCcsICdUUkFDRScsICdUUkFDSyddKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5TRUNVUklUWV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gNVxuXHRcdFx0XHR1cmwgPSBFbmNvZGUudXRmOF9lbmNvZGUodXJsKTtcblxuXHRcdFx0XHQvLyA2IC0gUmVzb2x2ZSB1cmwgcmVsYXRpdmUgdG8gdGhlIFhNTEh0dHBSZXF1ZXN0IGJhc2UgVVJMLiBJZiB0aGUgYWxnb3JpdGhtIHJldHVybnMgYW4gZXJyb3IsIHRocm93IGEgXCJTeW50YXhFcnJvclwiLlxuXHRcdFx0XHR1cmxwID0gVXJsLnBhcnNlVXJsKHVybCk7XG5cblx0XHRcdFx0X3NhbWVfb3JpZ2luX2ZsYWcgPSBVcmwuaGFzU2FtZU9yaWdpbih1cmxwKTtcblxuXHRcdFx0XHQvLyA3IC0gbWFudWFsbHkgYnVpbGQgdXAgYWJzb2x1dGUgdXJsXG5cdFx0XHRcdF91cmwgPSBVcmwucmVzb2x2ZVVybCh1cmwpO1xuXG5cdFx0XHRcdC8vIDktMTAsIDEyLTEzXG5cdFx0XHRcdGlmICgodXNlciB8fCBwYXNzd29yZCkgJiYgIV9zYW1lX29yaWdpbl9mbGFnKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfQUNDRVNTX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfdXNlciA9IHVzZXIgfHwgdXJscC51c2VyO1xuXHRcdFx0XHRfcGFzc3dvcmQgPSBwYXNzd29yZCB8fCB1cmxwLnBhc3M7XG5cblx0XHRcdFx0Ly8gMTFcblx0XHRcdFx0X2FzeW5jID0gYXN5bmMgfHwgdHJ1ZTtcblxuXHRcdFx0XHRpZiAoX2FzeW5jID09PSBmYWxzZSAmJiAoX3AoJ3RpbWVvdXQnKSB8fCBfcCgnd2l0aENyZWRlbnRpYWxzJykgfHwgX3AoJ3Jlc3BvbnNlVHlwZScpICE9PSBcIlwiKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX0FDQ0VTU19FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gMTQgLSB0ZXJtaW5hdGUgYWJvcnQoKVxuXG5cdFx0XHRcdC8vIDE1IC0gdGVybWluYXRlIHNlbmQoKVxuXG5cdFx0XHRcdC8vIDE4XG5cdFx0XHRcdF9zeW5jX2ZsYWcgPSAhX2FzeW5jO1xuXHRcdFx0XHRfc2VuZF9mbGFnID0gZmFsc2U7XG5cdFx0XHRcdF9oZWFkZXJzID0ge307XG5cdFx0XHRcdF9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0XHRcdC8vIDE5XG5cdFx0XHRcdF9wKCdyZWFkeVN0YXRlJywgWE1MSHR0cFJlcXVlc3QuT1BFTkVEKTtcblxuXHRcdFx0XHQvLyAyMFxuXHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlYWR5c3RhdGVjaGFuZ2UnKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0QXBwZW5kcyBhbiBoZWFkZXIgdG8gdGhlIGxpc3Qgb2YgYXV0aG9yIHJlcXVlc3QgaGVhZGVycywgb3IgaWYgaGVhZGVyIGlzIGFscmVhZHlcblx0XHRcdGluIHRoZSBsaXN0IG9mIGF1dGhvciByZXF1ZXN0IGhlYWRlcnMsIGNvbWJpbmVzIGl0cyB2YWx1ZSB3aXRoIHZhbHVlLlxuXG5cdFx0XHRUaHJvd3MgYW4gXCJJbnZhbGlkU3RhdGVFcnJvclwiIGV4Y2VwdGlvbiBpZiB0aGUgc3RhdGUgaXMgbm90IE9QRU5FRCBvciBpZiB0aGUgc2VuZCgpIGZsYWcgaXMgc2V0LlxuXHRcdFx0VGhyb3dzIGEgXCJTeW50YXhFcnJvclwiIGV4Y2VwdGlvbiBpZiBoZWFkZXIgaXMgbm90IGEgdmFsaWQgSFRUUCBoZWFkZXIgZmllbGQgbmFtZSBvciBpZiB2YWx1ZVxuXHRcdFx0aXMgbm90IGEgdmFsaWQgSFRUUCBoZWFkZXIgZmllbGQgdmFsdWUuXG5cblx0XHRcdEBtZXRob2Qgc2V0UmVxdWVzdEhlYWRlclxuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IGhlYWRlclxuXHRcdFx0QHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZVxuXHRcdFx0Ki9cblx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlciwgdmFsdWUpIHtcblx0XHRcdFx0dmFyIHVhSGVhZGVycyA9IFsgLy8gdGhlc2UgaGVhZGVycyBhcmUgY29udHJvbGxlZCBieSB0aGUgdXNlciBhZ2VudFxuXHRcdFx0XHRcdFx0XCJhY2NlcHQtY2hhcnNldFwiLFxuXHRcdFx0XHRcdFx0XCJhY2NlcHQtZW5jb2RpbmdcIixcblx0XHRcdFx0XHRcdFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCIsXG5cdFx0XHRcdFx0XHRcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG5cdFx0XHRcdFx0XHRcImNvbm5lY3Rpb25cIixcblx0XHRcdFx0XHRcdFwiY29udGVudC1sZW5ndGhcIixcblx0XHRcdFx0XHRcdFwiY29va2llXCIsXG5cdFx0XHRcdFx0XHRcImNvb2tpZTJcIixcblx0XHRcdFx0XHRcdFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiLFxuXHRcdFx0XHRcdFx0XCJkYXRlXCIsXG5cdFx0XHRcdFx0XHRcImV4cGVjdFwiLFxuXHRcdFx0XHRcdFx0XCJob3N0XCIsXG5cdFx0XHRcdFx0XHRcImtlZXAtYWxpdmVcIixcblx0XHRcdFx0XHRcdFwib3JpZ2luXCIsXG5cdFx0XHRcdFx0XHRcInJlZmVyZXJcIixcblx0XHRcdFx0XHRcdFwidGVcIixcblx0XHRcdFx0XHRcdFwidHJhaWxlclwiLFxuXHRcdFx0XHRcdFx0XCJ0cmFuc2Zlci1lbmNvZGluZ1wiLFxuXHRcdFx0XHRcdFx0XCJ1cGdyYWRlXCIsXG5cdFx0XHRcdFx0XHRcInVzZXItYWdlbnRcIixcblx0XHRcdFx0XHRcdFwidmlhXCJcblx0XHRcdFx0XHRdO1xuXG5cdFx0XHRcdC8vIDEtMlxuXHRcdFx0XHRpZiAoX3AoJ3JlYWR5U3RhdGUnKSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEIHx8IF9zZW5kX2ZsYWcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gM1xuXHRcdFx0XHRpZiAoL1tcXHUwMTAwLVxcdWZmZmZdLy50ZXN0KGhlYWRlcikgfHwgRW5jb2RlLnV0ZjhfZW5jb2RlKGhlYWRlcikgIT09IGhlYWRlcikge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5TWU5UQVhfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDRcblx0XHRcdFx0LyogdGhpcyBzdGVwIGlzIHNlZW1pbmdseSBieXBhc3NlZCBpbiBicm93c2VycywgcHJvYmFibHkgdG8gYWxsb3cgdmFyaW91cyB1bmljb2RlIGNoYXJhY3RlcnMgaW4gaGVhZGVyIHZhbHVlc1xuXHRcdFx0XHRpZiAoL1tcXHUwMTAwLVxcdWZmZmZdLy50ZXN0KHZhbHVlKSB8fCBFbmNvZGUudXRmOF9lbmNvZGUodmFsdWUpICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5TWU5UQVhfRVJSKTtcblx0XHRcdFx0fSovXG5cblx0XHRcdFx0aGVhZGVyID0gQmFzaWMudHJpbShoZWFkZXIpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0Ly8gc2V0dGluZyBvZiBwcm94eS0qIGFuZCBzZWMtKiBoZWFkZXJzIGlzIHByb2hpYml0ZWQgYnkgc3BlY1xuXHRcdFx0XHRpZiAoISF+QmFzaWMuaW5BcnJheShoZWFkZXIsIHVhSGVhZGVycykgfHwgL14ocHJveHlcXC18c2VjXFwtKS8udGVzdChoZWFkZXIpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2FtZWxpemVcblx0XHRcdFx0Ly8gYnJvd3NlcnMgbG93ZXJjYXNlIGhlYWRlciBuYW1lcyAoYXQgbGVhc3QgZm9yIGN1c3RvbSBvbmVzKVxuXHRcdFx0XHQvLyBoZWFkZXIgPSBoZWFkZXIucmVwbGFjZSgvXFxiXFx3L2csIGZ1bmN0aW9uKCQxKSB7IHJldHVybiAkMS50b1VwcGVyQ2FzZSgpOyB9KTtcblxuXHRcdFx0XHRpZiAoIV9oZWFkZXJzW2hlYWRlcl0pIHtcblx0XHRcdFx0XHRfaGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNiNzZWN0aW9uLTQuMiAobGFzdCBwYXJhZ3JhcGgpXG5cdFx0XHRcdFx0X2hlYWRlcnNbaGVhZGVyXSArPSAnLCAnICsgdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRlc3QgaWYgdGhlIHNwZWNpZmllZCBoZWFkZXIgaXMgYWxyZWFkeSBzZXQgb24gdGhpcyByZXF1ZXN0LlxuXHRcdFx0ICogUmV0dXJucyBhIGhlYWRlciB2YWx1ZSBvciBib29sZWFuIGZhbHNlIGlmIGl0J3Mgbm90IHlldCBzZXQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBoYXNSZXF1ZXN0SGVhZGVyXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIE5hbWUgb2YgdGhlIGhlYWRlciB0byB0ZXN0XG5cdFx0XHQgKiBAcmV0dXJuIHtCb29sZWFufFN0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0aGFzUmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oaGVhZGVyKSB7XG5cdFx0XHRcdHJldHVybiBoZWFkZXIgJiYgX2hlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldIHx8IGZhbHNlO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRSZXR1cm5zIGFsbCBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhvc2Ugd2hvc2UgZmllbGQgbmFtZSBpcyBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLlxuXG5cdFx0XHRAbWV0aG9kIGdldEFsbFJlc3BvbnNlSGVhZGVyc1xuXHRcdFx0QHJldHVybiB7U3RyaW5nfSByZXBvbnNlIGhlYWRlcnMgb3IgZW1wdHkgc3RyaW5nXG5cdFx0XHQqL1xuXHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9yZXNwb25zZUhlYWRlcnMgfHwgJyc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHVybnMgdGhlIGhlYWRlciBmaWVsZCB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB3aGljaCB0aGUgZmllbGQgbmFtZSBtYXRjaGVzIGhlYWRlcixcblx0XHRcdHVubGVzcyB0aGUgZmllbGQgbmFtZSBpcyBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLlxuXG5cdFx0XHRAbWV0aG9kIGdldFJlc3BvbnNlSGVhZGVyXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gaGVhZGVyXG5cdFx0XHRAcmV0dXJuIHtTdHJpbmd9IHZhbHVlKHMpIGZvciB0aGUgc3BlY2lmaWVkIGhlYWRlciBvciBudWxsXG5cdFx0XHQqL1xuXHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlcikge1xuXHRcdFx0XHRoZWFkZXIgPSBoZWFkZXIudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAoX2Vycm9yX2ZsYWcgfHwgISF+QmFzaWMuaW5BcnJheShoZWFkZXIsIFsnc2V0LWNvb2tpZScsICdzZXQtY29va2llMiddKSkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF9yZXNwb25zZUhlYWRlcnMgJiYgX3Jlc3BvbnNlSGVhZGVycyAhPT0gJycpIHtcblx0XHRcdFx0XHQvLyBpZiB3ZSBkaWRuJ3QgcGFyc2UgcmVzcG9uc2UgaGVhZGVycyB1bnRpbCBub3csIGRvIGl0IGFuZCBrZWVwIGZvciBsYXRlclxuXHRcdFx0XHRcdGlmICghX3Jlc3BvbnNlSGVhZGVyc0JhZykge1xuXHRcdFx0XHRcdFx0X3Jlc3BvbnNlSGVhZGVyc0JhZyA9IHt9O1xuXHRcdFx0XHRcdFx0QmFzaWMuZWFjaChfcmVzcG9uc2VIZWFkZXJzLnNwbGl0KC9cXHJcXG4vKSwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcGFpciA9IGxpbmUuc3BsaXQoLzpcXHMrLyk7XG5cdFx0XHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCA9PT0gMikgeyAvLyBsYXN0IGxpbmUgbWlnaHQgYmUgZW1wdHksIG9taXRcblx0XHRcdFx0XHRcdFx0XHRwYWlyWzBdID0gQmFzaWMudHJpbShwYWlyWzBdKTsgLy8ganVzdCBpbiBjYXNlXG5cdFx0XHRcdFx0XHRcdFx0X3Jlc3BvbnNlSGVhZGVyc0JhZ1twYWlyWzBdLnRvTG93ZXJDYXNlKCldID0geyAvLyBzaW1wbHkgdG8gcmV0YWluIGhlYWRlciBuYW1lIGluIG9yaWdpbmFsIGZvcm1cblx0XHRcdFx0XHRcdFx0XHRcdGhlYWRlcjogcGFpclswXSxcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBCYXNpYy50cmltKHBhaXJbMV0pXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChfcmVzcG9uc2VIZWFkZXJzQmFnLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcblx0XHRcdFx0XHRcdHJldHVybiBfcmVzcG9uc2VIZWFkZXJzQmFnW2hlYWRlcl0uaGVhZGVyICsgJzogJyArIF9yZXNwb25zZUhlYWRlcnNCYWdbaGVhZGVyXS52YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFNldHMgdGhlIENvbnRlbnQtVHlwZSBoZWFkZXIgZm9yIHRoZSByZXNwb25zZSB0byBtaW1lLlxuXHRcdFx0VGhyb3dzIGFuIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBleGNlcHRpb24gaWYgdGhlIHN0YXRlIGlzIExPQURJTkcgb3IgRE9ORS5cblx0XHRcdFRocm93cyBhIFwiU3ludGF4RXJyb3JcIiBleGNlcHRpb24gaWYgbWltZSBpcyBub3QgYSB2YWxpZCBtZWRpYSB0eXBlLlxuXG5cdFx0XHRAbWV0aG9kIG92ZXJyaWRlTWltZVR5cGVcblx0XHRcdEBwYXJhbSBTdHJpbmcgbWltZSBNaW1lIHR5cGUgdG8gc2V0XG5cdFx0XHQqL1xuXHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24obWltZSkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcywgY2hhcnNldDtcblxuXHRcdFx0XHQvLyAxXG5cdFx0XHRcdGlmICghIX5CYXNpYy5pbkFycmF5KF9wKCdyZWFkeVN0YXRlJyksIFtYTUxIdHRwUmVxdWVzdC5MT0FESU5HLCBYTUxIdHRwUmVxdWVzdC5ET05FXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gMlxuXHRcdFx0XHRtaW1lID0gQmFzaWMudHJpbShtaW1lLnRvTG93ZXJDYXNlKCkpO1xuXG5cdFx0XHRcdGlmICgvOy8udGVzdChtaW1lKSAmJiAobWF0Y2hlcyA9IG1pbWUubWF0Y2goL14oW147XSspKD86O1xcc2NoYXJzZXRcXD0pPyguKikkLykpKSB7XG5cdFx0XHRcdFx0bWltZSA9IG1hdGNoZXNbMV07XG5cdFx0XHRcdFx0aWYgKG1hdGNoZXNbMl0pIHtcblx0XHRcdFx0XHRcdGNoYXJzZXQgPSBtYXRjaGVzWzJdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghTWltZS5taW1lc1ttaW1lXSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5TWU5UQVhfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDMtNFxuXHRcdFx0XHRfZmluYWxNaW1lID0gbWltZTtcblx0XHRcdFx0X2ZpbmFsQ2hhcnNldCA9IGNoYXJzZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdEluaXRpYXRlcyB0aGUgcmVxdWVzdC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50IHByb3ZpZGVzIHRoZSByZXF1ZXN0IGVudGl0eSBib2R5LlxuXHRcdFx0VGhlIGFyZ3VtZW50IGlzIGlnbm9yZWQgaWYgcmVxdWVzdCBtZXRob2QgaXMgR0VUIG9yIEhFQUQuXG5cblx0XHRcdFRocm93cyBhbiBcIkludmFsaWRTdGF0ZUVycm9yXCIgZXhjZXB0aW9uIGlmIHRoZSBzdGF0ZSBpcyBub3QgT1BFTkVEIG9yIGlmIHRoZSBzZW5kKCkgZmxhZyBpcyBzZXQuXG5cblx0XHRcdEBtZXRob2Qgc2VuZFxuXHRcdFx0QHBhcmFtIHtCbG9ifERvY3VtZW50fFN0cmluZ3xGb3JtRGF0YX0gW2RhdGFdIFJlcXVlc3QgZW50aXR5IGJvZHlcblx0XHRcdEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2V0IG9mIHJlcXVpcmVtZW50cyBhbmQgcHJlLXJlcXVpc2l0aWVzIGZvciBydW50aW1lIGluaXRpYWxpemF0aW9uXG5cdFx0XHQqL1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdF9vcHRpb25zID0geyBydWlkOiBvcHRpb25zIH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIW9wdGlvbnMpIHtcblx0XHRcdFx0XHRfb3B0aW9ucyA9IHt9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDEtMlxuXHRcdFx0XHRpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5PUEVORUQgfHwgX3NlbmRfZmxhZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAzXG5cdFx0XHRcdC8vIHNlbmRpbmcgQmxvYlxuXHRcdFx0XHRpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRfb3B0aW9ucy5ydWlkID0gZGF0YS5ydWlkO1xuXHRcdFx0XHRcdF9taW1lVHlwZSA9IGRhdGEudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcm1EYXRhXG5cdFx0XHRcdGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRcdGlmIChkYXRhLmhhc0Jsb2IoKSkge1xuXHRcdFx0XHRcdFx0dmFyIGJsb2IgPSBkYXRhLmdldEJsb2IoKTtcblx0XHRcdFx0XHRcdF9vcHRpb25zLnJ1aWQgPSBibG9iLnJ1aWQ7XG5cdFx0XHRcdFx0XHRfbWltZVR5cGUgPSBibG9iLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRE9NU3RyaW5nXG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdF9lbmNvZGluZyA9ICdVVEYtOCc7XG5cdFx0XHRcdFx0X21pbWVUeXBlID0gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG5cblx0XHRcdFx0XHQvLyBkYXRhIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gVW5pY29kZSBhbmQgZW5jb2RlZCBhcyBVVEYtOFxuXHRcdFx0XHRcdGRhdGEgPSBFbmNvZGUudXRmOF9lbmNvZGUoZGF0YSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiB3aXRoQ3JlZGVudGlhbHMgbm90IHNldCwgYnV0IHJlcXVlc3RlZCwgc2V0IGl0IGF1dG9tYXRpY2FsbHlcblx0XHRcdFx0aWYgKCF0aGlzLndpdGhDcmVkZW50aWFscykge1xuXHRcdFx0XHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gKF9vcHRpb25zLnJlcXVpcmVkX2NhcHMgJiYgX29wdGlvbnMucmVxdWlyZWRfY2Fwcy5zZW5kX2Jyb3dzZXJfY29va2llcykgJiYgIV9zYW1lX29yaWdpbl9mbGFnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gNCAtIHN0b3JhZ2UgbXV0ZXhcblx0XHRcdFx0Ly8gNVxuXHRcdFx0XHRfdXBsb2FkX2V2ZW50c19mbGFnID0gKCFfc3luY19mbGFnICYmIHRoaXMudXBsb2FkLmhhc0V2ZW50TGlzdGVuZXIoKSk7IC8vIERTQVBcblx0XHRcdFx0Ly8gNlxuXHRcdFx0XHRfZXJyb3JfZmxhZyA9IGZhbHNlO1xuXHRcdFx0XHQvLyA3XG5cdFx0XHRcdF91cGxvYWRfY29tcGxldGVfZmxhZyA9ICFkYXRhO1xuXHRcdFx0XHQvLyA4IC0gQXN5bmNocm9ub3VzIHN0ZXBzXG5cdFx0XHRcdGlmICghX3N5bmNfZmxhZykge1xuXHRcdFx0XHRcdC8vIDguMVxuXHRcdFx0XHRcdF9zZW5kX2ZsYWcgPSB0cnVlO1xuXHRcdFx0XHRcdC8vIDguMlxuXHRcdFx0XHRcdC8vIHRoaXMuZGlzcGF0Y2hFdmVudCgnbG9hZHN0YXJ0Jyk7IC8vIHdpbGwgYmUgZGlzcGF0Y2hlZCBlaXRoZXIgYnkgbmF0aXZlIG9yIHJ1bnRpbWUgeGhyXG5cdFx0XHRcdFx0Ly8gOC4zXG5cdFx0XHRcdFx0Ly9pZiAoIV91cGxvYWRfY29tcGxldGVfZmxhZykge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcy51cGxvYWQuZGlzcGF0Y2hFdmVudCgnbG9hZHN0YXJ0Jyk7XHQvLyB3aWxsIGJlIGRpc3BhdGNoZWQgZWl0aGVyIGJ5IG5hdGl2ZSBvciBydW50aW1lIHhoclxuXHRcdFx0XHRcdC8vfVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIDguNSAtIFJldHVybiB0aGUgc2VuZCgpIG1ldGhvZCBjYWxsLCBidXQgY29udGludWUgcnVubmluZyB0aGUgc3RlcHMgaW4gdGhpcyBhbGdvcml0aG0uXG5cdFx0XHRcdF9kb1hIUi5jYWxsKHRoaXMsIGRhdGEpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRDYW5jZWxzIGFueSBuZXR3b3JrIGFjdGl2aXR5LlxuXG5cdFx0XHRAbWV0aG9kIGFib3J0XG5cdFx0XHQqL1xuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfZXJyb3JfZmxhZyA9IHRydWU7XG5cdFx0XHRcdF9zeW5jX2ZsYWcgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIX5CYXNpYy5pbkFycmF5KF9wKCdyZWFkeVN0YXRlJyksIFtYTUxIdHRwUmVxdWVzdC5VTlNFTlQsIFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCwgWE1MSHR0cFJlcXVlc3QuRE9ORV0pKSB7XG5cdFx0XHRcdFx0X3AoJ3JlYWR5U3RhdGUnLCBYTUxIdHRwUmVxdWVzdC5ET05FKTtcblx0XHRcdFx0XHRfc2VuZF9mbGFnID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoX3hocikge1xuXHRcdFx0XHRcdFx0X3hoci5nZXRSdW50aW1lKCkuZXhlYy5jYWxsKF94aHIsICdYTUxIdHRwUmVxdWVzdCcsICdhYm9ydCcsIF91cGxvYWRfY29tcGxldGVfZmxhZyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3VwbG9hZF9jb21wbGV0ZV9mbGFnID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfcCgncmVhZHlTdGF0ZScsIFhNTEh0dHBSZXF1ZXN0LlVOU0VOVCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3hocikge1xuXHRcdFx0XHRcdGlmIChCYXNpYy50eXBlT2YoX3hoci5kZXN0cm95KSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0X3hoci5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF94aHIgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy51bmJpbmRBbGwoKTtcblxuXHRcdFx0XHRpZiAodGhpcy51cGxvYWQpIHtcblx0XHRcdFx0XHR0aGlzLnVwbG9hZC51bmJpbmRBbGwoKTtcblx0XHRcdFx0XHR0aGlzLnVwbG9hZCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuaGFuZGxlRXZlbnRQcm9wcyhkaXNwYXRjaGVzLmNvbmNhdChbJ3JlYWR5c3RhdGVjaGFuZ2UnXSkpOyAvLyBmb3IgaGlzdG9yaWNhbCByZWFzb25zXG5cdFx0dGhpcy51cGxvYWQuaGFuZGxlRXZlbnRQcm9wcyhkaXNwYXRjaGVzKTtcblxuXHRcdC8qIHRoaXMgaXMgbmljZSwgYnV0IG1heWJlIHRvbyBsZW5ndGh5XG5cblx0XHQvLyBpZiBzdXBwb3J0ZWQgYnkgSlMgdmVyc2lvbiwgc2V0IGdldHRlcnMvc2V0dGVycyBmb3Igc3BlY2lmaWMgcHJvcGVydGllc1xuXHRcdG8uZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWR5U3RhdGUnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX3AoJ3JlYWR5U3RhdGUnKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG8uZGVmaW5lUHJvcGVydHkodGhpcywgJ3RpbWVvdXQnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX3AoJ3RpbWVvdXQnKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblxuXHRcdFx0XHRpZiAoX3N5bmNfZmxhZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX0FDQ0VTU19FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGltZW91dCBzdGlsbCBzaG91bGQgYmUgbWVhc3VyZWQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IHRpbWUgb2YgcmVxdWVzdFxuXHRcdFx0XHRfdGltZW91dHNldF90aW1lID0gKG5ldyBEYXRlKS5nZXRUaW1lKCk7XG5cblx0XHRcdFx0X3AoJ3RpbWVvdXQnLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyB0aGUgd2l0aENyZWRlbnRpYWxzIGF0dHJpYnV0ZSBoYXMgbm8gZWZmZWN0IHdoZW4gZmV0Y2hpbmcgc2FtZS1vcmlnaW4gcmVzb3VyY2VzXG5cdFx0by5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnd2l0aENyZWRlbnRpYWxzJywge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9wKCd3aXRoQ3JlZGVudGlhbHMnKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0Ly8gMS0yXG5cdFx0XHRcdGlmICghfm8uaW5BcnJheShfcCgncmVhZHlTdGF0ZScpLCBbWE1MSHR0cFJlcXVlc3QuVU5TRU5ULCBYTUxIdHRwUmVxdWVzdC5PUEVORURdKSB8fCBfc2VuZF9mbGFnKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDMtNFxuXHRcdFx0XHRpZiAoX2Fub255bW91c19mbGFnIHx8IF9zeW5jX2ZsYWcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9BQ0NFU1NfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDVcblx0XHRcdFx0X3AoJ3dpdGhDcmVkZW50aWFscycsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG8uZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YXR1cycsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfcCgnc3RhdHVzJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRvLmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGF0dXNUZXh0Jywge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9wKCdzdGF0dXNUZXh0Jyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRvLmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXNwb25zZVR5cGUnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX3AoJ3Jlc3BvbnNlVHlwZScpO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHQvLyAxXG5cdFx0XHRcdGlmICghIX5vLmluQXJyYXkoX3AoJ3JlYWR5U3RhdGUnKSwgW1hNTEh0dHBSZXF1ZXN0LkxPQURJTkcsIFhNTEh0dHBSZXF1ZXN0LkRPTkVdKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAyXG5cdFx0XHRcdGlmIChfc3luY19mbGFnKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfQUNDRVNTX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAzXG5cdFx0XHRcdF9wKCdyZXNwb25zZVR5cGUnLCB2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG8uZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlVGV4dCcsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIDFcblx0XHRcdFx0aWYgKCF+by5pbkFycmF5KF9wKCdyZXNwb25zZVR5cGUnKSwgWycnLCAndGV4dCddKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAyLTNcblx0XHRcdFx0aWYgKF9wKCdyZWFkeVN0YXRlJykgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgX3AoJ3JlYWR5U3RhdGUnKSAhPT0gWE1MSHR0cFJlcXVlc3QuTE9BRElORyB8fCBfZXJyb3JfZmxhZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gX3AoJ3Jlc3BvbnNlVGV4dCcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0by5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2VYTUwnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyAxXG5cdFx0XHRcdGlmICghfm8uaW5BcnJheShfcCgncmVzcG9uc2VUeXBlJyksIFsnJywgJ2RvY3VtZW50J10pKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDItM1xuXHRcdFx0XHRpZiAoX3AoJ3JlYWR5U3RhdGUnKSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSB8fCBfZXJyb3JfZmxhZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gX3AoJ3Jlc3BvbnNlWE1MJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRvLmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXNwb25zZScsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghIX5vLmluQXJyYXkoX3AoJ3Jlc3BvbnNlVHlwZScpLCBbJycsICd0ZXh0J10pKSB7XG5cdFx0XHRcdFx0aWYgKF9wKCdyZWFkeVN0YXRlJykgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgX3AoJ3JlYWR5U3RhdGUnKSAhPT0gWE1MSHR0cFJlcXVlc3QuTE9BRElORyB8fCBfZXJyb3JfZmxhZykge1xuXHRcdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChfcCgncmVhZHlTdGF0ZScpICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FIHx8IF9lcnJvcl9mbGFnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gX3AoJ3Jlc3BvbnNlJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQqL1xuXG5cdFx0ZnVuY3Rpb24gX3AocHJvcCwgdmFsdWUpIHtcblx0XHRcdGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgLy8gZ2V0XG5cdFx0XHRcdHJldHVybiBFbnYuY2FuKCdkZWZpbmVfcHJvcGVydHknKSA/IHByb3BzW3Byb3BdIDogc2VsZltwcm9wXTtcblx0XHRcdH0gZWxzZSB7IC8vIHNldFxuXHRcdFx0XHRpZiAoRW52LmNhbignZGVmaW5lX3Byb3BlcnR5JykpIHtcblx0XHRcdFx0XHRwcm9wc1twcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGZbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qXG5cdFx0ZnVuY3Rpb24gX3RvQVNDSUkoc3RyLCBBbGxvd1VuYXNzaWduZWQsIFVzZVNURDNBU0NJSVJ1bGVzKSB7XG5cdFx0XHQvLyBUT0RPOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkwI3NlY3Rpb24tNC4xXG5cdFx0XHRyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHRcdCovXG5cblxuXHRcdGZ1bmN0aW9uIF9kb1hIUihkYXRhKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdF9zdGFydF90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cblx0XHRcdF94aHIgPSBuZXcgUnVudGltZVRhcmdldCgpO1xuXG5cdFx0XHRmdW5jdGlvbiBsb2FkRW5kKCkge1xuXHRcdFx0XHRpZiAoX3hocikgeyAvLyBpdCBjb3VsZCBoYXZlIGJlZW4gZGVzdHJveWVkIGJ5IG5vd1xuXHRcdFx0XHRcdF94aHIuZGVzdHJveSgpO1xuXHRcdFx0XHRcdF94aHIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudCgnbG9hZGVuZCcpO1xuXHRcdFx0XHRzZWxmID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZXhlYyhydW50aW1lKSB7XG5cdFx0XHRcdF94aHIuYmluZCgnTG9hZFN0YXJ0JywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdF9wKCdyZWFkeVN0YXRlJywgWE1MSHR0cFJlcXVlc3QuTE9BRElORyk7XG5cdFx0XHRcdFx0c2VsZi5kaXNwYXRjaEV2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJyk7XG5cblx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoZSk7XG5cblx0XHRcdFx0XHRpZiAoX3VwbG9hZF9ldmVudHNfZmxhZykge1xuXHRcdFx0XHRcdFx0c2VsZi51cGxvYWQuZGlzcGF0Y2hFdmVudChlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF94aHIuYmluZCgnUHJvZ3Jlc3MnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0aWYgKF9wKCdyZWFkeVN0YXRlJykgIT09IFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcpIHtcblx0XHRcdFx0XHRcdF9wKCdyZWFkeVN0YXRlJywgWE1MSHR0cFJlcXVlc3QuTE9BRElORyk7IC8vIExvYWRTdGFydCB1bnJlbGlhYmxlIChpbiBGbGFzaCBmb3IgZXhhbXBsZSlcblx0XHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF94aHIuYmluZCgnVXBsb2FkUHJvZ3Jlc3MnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0aWYgKF91cGxvYWRfZXZlbnRzX2ZsYWcpIHtcblx0XHRcdFx0XHRcdHNlbGYudXBsb2FkLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAncHJvZ3Jlc3MnLFxuXHRcdFx0XHRcdFx0XHRsZW5ndGhDb21wdXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0dG90YWw6IGUudG90YWwsXG5cdFx0XHRcdFx0XHRcdGxvYWRlZDogZS5sb2FkZWRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X3hoci5iaW5kKCdMb2FkJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdF9wKCdyZWFkeVN0YXRlJywgWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG5cdFx0XHRcdFx0X3AoJ3N0YXR1cycsIE51bWJlcihydW50aW1lLmV4ZWMuY2FsbChfeGhyLCAnWE1MSHR0cFJlcXVlc3QnLCAnZ2V0U3RhdHVzJykgfHwgMCkpO1xuXHRcdFx0XHRcdF9wKCdzdGF0dXNUZXh0JywgaHR0cENvZGVbX3AoJ3N0YXR1cycpXSB8fCBcIlwiKTtcblxuXHRcdFx0XHRcdF9wKCdyZXNwb25zZScsIHJ1bnRpbWUuZXhlYy5jYWxsKF94aHIsICdYTUxIdHRwUmVxdWVzdCcsICdnZXRSZXNwb25zZScsIF9wKCdyZXNwb25zZVR5cGUnKSkpO1xuXG5cdFx0XHRcdFx0aWYgKCEhfkJhc2ljLmluQXJyYXkoX3AoJ3Jlc3BvbnNlVHlwZScpLCBbJ3RleHQnLCAnJ10pKSB7XG5cdFx0XHRcdFx0XHRfcCgncmVzcG9uc2VUZXh0JywgX3AoJ3Jlc3BvbnNlJykpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoX3AoJ3Jlc3BvbnNlVHlwZScpID09PSAnZG9jdW1lbnQnKSB7XG5cdFx0XHRcdFx0XHRfcCgncmVzcG9uc2VYTUwnLCBfcCgncmVzcG9uc2UnKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3Jlc3BvbnNlSGVhZGVycyA9IHJ1bnRpbWUuZXhlYy5jYWxsKF94aHIsICdYTUxIdHRwUmVxdWVzdCcsICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnKTtcblxuXHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpO1xuXG5cdFx0XHRcdFx0aWYgKF9wKCdzdGF0dXMnKSA+IDApIHsgLy8gc3RhdHVzIDAgdXN1YWxseSBtZWFucyB0aGF0IHNlcnZlciBpcyB1bnJlYWNoYWJsZVxuXHRcdFx0XHRcdFx0aWYgKF91cGxvYWRfZXZlbnRzX2ZsYWcpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi51cGxvYWQuZGlzcGF0Y2hFdmVudChlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudChlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X2Vycm9yX2ZsYWcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0c2VsZi5kaXNwYXRjaEV2ZW50KCdlcnJvcicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsb2FkRW5kKCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF94aHIuYmluZCgnQWJvcnQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNwYXRjaEV2ZW50KGUpO1xuXHRcdFx0XHRcdGxvYWRFbmQoKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X3hoci5iaW5kKCdFcnJvcicsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRfZXJyb3JfZmxhZyA9IHRydWU7XG5cdFx0XHRcdFx0X3AoJ3JlYWR5U3RhdGUnLCBYTUxIdHRwUmVxdWVzdC5ET05FKTtcblx0XHRcdFx0XHRzZWxmLmRpc3BhdGNoRXZlbnQoJ3JlYWR5c3RhdGVjaGFuZ2UnKTtcblx0XHRcdFx0XHRfdXBsb2FkX2NvbXBsZXRlX2ZsYWcgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudChlKTtcblx0XHRcdFx0XHRsb2FkRW5kKCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJ1bnRpbWUuZXhlYy5jYWxsKF94aHIsICdYTUxIdHRwUmVxdWVzdCcsICdzZW5kJywge1xuXHRcdFx0XHRcdHVybDogX3VybCxcblx0XHRcdFx0XHRtZXRob2Q6IF9tZXRob2QsXG5cdFx0XHRcdFx0YXN5bmM6IF9hc3luYyxcblx0XHRcdFx0XHR1c2VyOiBfdXNlcixcblx0XHRcdFx0XHRwYXNzd29yZDogX3Bhc3N3b3JkLFxuXHRcdFx0XHRcdGhlYWRlcnM6IF9oZWFkZXJzLFxuXHRcdFx0XHRcdG1pbWVUeXBlOiBfbWltZVR5cGUsXG5cdFx0XHRcdFx0ZW5jb2Rpbmc6IF9lbmNvZGluZyxcblx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IHNlbGYucmVzcG9uc2VUeXBlLFxuXHRcdFx0XHRcdHdpdGhDcmVkZW50aWFsczogc2VsZi53aXRoQ3JlZGVudGlhbHMsXG5cdFx0XHRcdFx0b3B0aW9uczogX29wdGlvbnNcblx0XHRcdFx0fSwgZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsYXJpZnkgb3VyIHJlcXVpcmVtZW50c1xuXHRcdFx0aWYgKHR5cGVvZihfb3B0aW9ucy5yZXF1aXJlZF9jYXBzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0X29wdGlvbnMucmVxdWlyZWRfY2FwcyA9IFJ1bnRpbWUucGFyc2VDYXBzKF9vcHRpb25zLnJlcXVpcmVkX2NhcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRfb3B0aW9ucy5yZXF1aXJlZF9jYXBzID0gQmFzaWMuZXh0ZW5kKHt9LCBfb3B0aW9ucy5yZXF1aXJlZF9jYXBzLCB7XG5cdFx0XHRcdHJldHVybl9yZXNwb25zZV90eXBlOiBzZWxmLnJlc3BvbnNlVHlwZVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdFx0X29wdGlvbnMucmVxdWlyZWRfY2Fwcy5zZW5kX211bHRpcGFydCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghQmFzaWMuaXNFbXB0eU9iaihfaGVhZGVycykpIHtcblx0XHRcdFx0X29wdGlvbnMucmVxdWlyZWRfY2Fwcy5zZW5kX2N1c3RvbV9oZWFkZXJzID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFfc2FtZV9vcmlnaW5fZmxhZykge1xuXHRcdFx0XHRfb3B0aW9ucy5yZXF1aXJlZF9jYXBzLmRvX2NvcnMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmIChfb3B0aW9ucy5ydWlkKSB7IC8vIHdlIGRvIG5vdCBuZWVkIHRvIHdhaXQgaWYgd2UgY2FuIGNvbm5lY3QgZGlyZWN0bHlcblx0XHRcdFx0ZXhlYyhfeGhyLmNvbm5lY3RSdW50aW1lKF9vcHRpb25zKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfeGhyLmJpbmQoJ1J1bnRpbWVJbml0JywgZnVuY3Rpb24oZSwgcnVudGltZSkge1xuXHRcdFx0XHRcdGV4ZWMocnVudGltZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRfeGhyLmJpbmQoJ1J1bnRpbWVFcnJvcicsIGZ1bmN0aW9uKGUsIGVycikge1xuXHRcdFx0XHRcdHNlbGYuZGlzcGF0Y2hFdmVudCgnUnVudGltZUVycm9yJywgZXJyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdF94aHIuY29ubmVjdFJ1bnRpbWUoX29wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3Jlc2V0KCkge1xuXHRcdFx0X3AoJ3Jlc3BvbnNlVGV4dCcsIFwiXCIpO1xuXHRcdFx0X3AoJ3Jlc3BvbnNlWE1MJywgbnVsbCk7XG5cdFx0XHRfcCgncmVzcG9uc2UnLCBudWxsKTtcblx0XHRcdF9wKCdzdGF0dXMnLCAwKTtcblx0XHRcdF9wKCdzdGF0dXNUZXh0JywgXCJcIik7XG5cdFx0XHRfc3RhcnRfdGltZSA9IF90aW1lb3V0c2V0X3RpbWUgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdFhNTEh0dHBSZXF1ZXN0LlVOU0VOVCA9IDA7XG5cdFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCA9IDE7XG5cdFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuXHRYTUxIdHRwUmVxdWVzdC5MT0FESU5HID0gMztcblx0WE1MSHR0cFJlcXVlc3QuRE9ORSA9IDQ7XG5cblx0WE1MSHR0cFJlcXVlc3QucHJvdG90eXBlID0gRXZlbnRUYXJnZXQuaW5zdGFuY2U7XG5cblx0cmV0dXJuIFhNTEh0dHBSZXF1ZXN0O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvVHJhbnNwb3J0ZXIuanNcblxuLyoqXG4gKiBUcmFuc3BvcnRlci5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL1RyYW5zcG9ydGVyXCIsIFtcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbmNvZGVcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVDbGllbnRcIixcblx0XCJtb3hpZS9jb3JlL0V2ZW50VGFyZ2V0XCJcbl0sIGZ1bmN0aW9uKEJhc2ljLCBFbmNvZGUsIFJ1bnRpbWVDbGllbnQsIEV2ZW50VGFyZ2V0KSB7XG5cblx0LyoqXG5cdEBjbGFzcyBtb3hpZS9ydW50aW1lL1RyYW5zcG9ydGVyXG5cdEBjb25zdHJ1Y3RvclxuXHQqL1xuXHRmdW5jdGlvbiBUcmFuc3BvcnRlcigpIHtcblx0XHR2YXIgbW9kLCBfcnVudGltZSwgX2RhdGEsIF9zaXplLCBfcG9zLCBfY2h1bmtfc2l6ZTtcblxuXHRcdFJ1bnRpbWVDbGllbnQuY2FsbCh0aGlzKTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHR1aWQ6IEJhc2ljLmd1aWQoJ3VpZF8nKSxcblxuXHRcdFx0c3RhdGU6IFRyYW5zcG9ydGVyLklETEUsXG5cblx0XHRcdHJlc3VsdDogbnVsbCxcblxuXHRcdFx0dHJhbnNwb3J0OiBmdW5jdGlvbihkYXRhLCB0eXBlLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0XHRvcHRpb25zID0gQmFzaWMuZXh0ZW5kKHtcblx0XHRcdFx0XHRjaHVua19zaXplOiAyMDQ3OThcblx0XHRcdFx0fSwgb3B0aW9ucyk7XG5cblx0XHRcdFx0Ly8gc2hvdWxkIGRpdmlkZSBieSB0aHJlZSwgYmFzZTY0IHJlcXVpcmVzIHRoaXNcblx0XHRcdFx0aWYgKChtb2QgPSBvcHRpb25zLmNodW5rX3NpemUgJSAzKSkge1xuXHRcdFx0XHRcdG9wdGlvbnMuY2h1bmtfc2l6ZSArPSAzIC0gbW9kO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2NodW5rX3NpemUgPSBvcHRpb25zLmNodW5rX3NpemU7XG5cblx0XHRcdFx0X3Jlc2V0LmNhbGwodGhpcyk7XG5cdFx0XHRcdF9kYXRhID0gZGF0YTtcblx0XHRcdFx0X3NpemUgPSBkYXRhLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKG9wdGlvbnMpID09PSAnc3RyaW5nJyB8fCBvcHRpb25zLnJ1aWQpIHtcblx0XHRcdFx0XHRfcnVuLmNhbGwoc2VsZiwgdHlwZSwgdGhpcy5jb25uZWN0UnVudGltZShvcHRpb25zKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gd2UgcmVxdWlyZSB0aGlzIHRvIHJ1biBvbmx5IG9uY2Vcblx0XHRcdFx0XHR2YXIgY2IgPSBmdW5jdGlvbihlLCBydW50aW1lKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnVuYmluZChcIlJ1bnRpbWVJbml0XCIsIGNiKTtcblx0XHRcdFx0XHRcdF9ydW4uY2FsbChzZWxmLCB0eXBlLCBydW50aW1lKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHRoaXMuYmluZChcIlJ1bnRpbWVJbml0XCIsIGNiKTtcblx0XHRcdFx0XHR0aGlzLmNvbm5lY3RSdW50aW1lKG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0XHRzZWxmLnN0YXRlID0gVHJhbnNwb3J0ZXIuSURMRTtcblx0XHRcdFx0aWYgKF9ydW50aW1lKSB7XG5cdFx0XHRcdFx0X3J1bnRpbWUuZXhlYy5jYWxsKHNlbGYsICdUcmFuc3BvcnRlcicsICdjbGVhcicpO1xuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcihcIlRyYW5zcG9ydGluZ0Fib3J0ZWRcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfcmVzZXQuY2FsbChzZWxmKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudW5iaW5kQWxsKCk7XG5cdFx0XHRcdF9ydW50aW1lID0gbnVsbDtcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuXHRcdFx0XHRfcmVzZXQuY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGZ1bmN0aW9uIF9yZXNldCgpIHtcblx0XHRcdF9zaXplID0gX3BvcyA9IDA7XG5cdFx0XHRfZGF0YSA9IHRoaXMucmVzdWx0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfcnVuKHR5cGUsIHJ1bnRpbWUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0X3J1bnRpbWUgPSBydW50aW1lO1xuXG5cdFx0XHQvL3NlbGYudW5iaW5kKFwiUnVudGltZUluaXRcIik7XG5cblx0XHRcdHNlbGYuYmluZChcIlRyYW5zcG9ydGluZ1Byb2dyZXNzXCIsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0X3BvcyA9IGUubG9hZGVkO1xuXG5cdFx0XHRcdGlmIChfcG9zIDwgX3NpemUgJiYgQmFzaWMuaW5BcnJheShzZWxmLnN0YXRlLCBbVHJhbnNwb3J0ZXIuSURMRSwgVHJhbnNwb3J0ZXIuRE9ORV0pID09PSAtMSkge1xuXHRcdFx0XHRcdF90cmFuc3BvcnQuY2FsbChzZWxmKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgOTk5KTtcblxuXHRcdFx0c2VsZi5iaW5kKFwiVHJhbnNwb3J0aW5nQ29tcGxldGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9wb3MgPSBfc2l6ZTtcblx0XHRcdFx0c2VsZi5zdGF0ZSA9IFRyYW5zcG9ydGVyLkRPTkU7XG5cdFx0XHRcdF9kYXRhID0gbnVsbDsgLy8gY2xlYW4gYSBiaXRcblx0XHRcdFx0c2VsZi5yZXN1bHQgPSBfcnVudGltZS5leGVjLmNhbGwoc2VsZiwgJ1RyYW5zcG9ydGVyJywgJ2dldEFzQmxvYicsIHR5cGUgfHwgJycpO1xuXHRcdFx0fSwgOTk5KTtcblxuXHRcdFx0c2VsZi5zdGF0ZSA9IFRyYW5zcG9ydGVyLkJVU1k7XG5cdFx0XHRzZWxmLnRyaWdnZXIoXCJUcmFuc3BvcnRpbmdTdGFydGVkXCIpO1xuXHRcdFx0X3RyYW5zcG9ydC5jYWxsKHNlbGYpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF90cmFuc3BvcnQoKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGNodW5rLFxuXHRcdFx0XHRieXRlc0xlZnQgPSBfc2l6ZSAtIF9wb3M7XG5cblx0XHRcdGlmIChfY2h1bmtfc2l6ZSA+IGJ5dGVzTGVmdCkge1xuXHRcdFx0XHRfY2h1bmtfc2l6ZSA9IGJ5dGVzTGVmdDtcblx0XHRcdH1cblxuXHRcdFx0Y2h1bmsgPSBFbmNvZGUuYnRvYShfZGF0YS5zdWJzdHIoX3BvcywgX2NodW5rX3NpemUpKTtcblx0XHRcdF9ydW50aW1lLmV4ZWMuY2FsbChzZWxmLCAnVHJhbnNwb3J0ZXInLCAncmVjZWl2ZScsIGNodW5rLCBfc2l6ZSk7XG5cdFx0fVxuXHR9XG5cblx0VHJhbnNwb3J0ZXIuSURMRSA9IDA7XG5cdFRyYW5zcG9ydGVyLkJVU1kgPSAxO1xuXHRUcmFuc3BvcnRlci5ET05FID0gMjtcblxuXHRUcmFuc3BvcnRlci5wcm90b3R5cGUgPSBFdmVudFRhcmdldC5pbnN0YW5jZTtcblxuXHRyZXR1cm4gVHJhbnNwb3J0ZXI7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvaW1hZ2UvSW1hZ2UuanNcblxuLyoqXG4gKiBJbWFnZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoXCJtb3hpZS9pbWFnZS9JbWFnZVwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRG9tXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlUmVhZGVyU3luY1wiLFxuXHRcIm1veGllL3hoci9YTUxIdHRwUmVxdWVzdFwiLFxuXHRcIm1veGllL3J1bnRpbWUvUnVudGltZVwiLFxuXHRcIm1veGllL3J1bnRpbWUvUnVudGltZUNsaWVudFwiLFxuXHRcIm1veGllL3J1bnRpbWUvVHJhbnNwb3J0ZXJcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VudlwiLFxuXHRcIm1veGllL2NvcmUvRXZlbnRUYXJnZXRcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VuY29kZVwiXG5dLCBmdW5jdGlvbihCYXNpYywgRG9tLCB4LCBGaWxlUmVhZGVyU3luYywgWE1MSHR0cFJlcXVlc3QsIFJ1bnRpbWUsIFJ1bnRpbWVDbGllbnQsIFRyYW5zcG9ydGVyLCBFbnYsIEV2ZW50VGFyZ2V0LCBCbG9iLCBGaWxlLCBFbmNvZGUpIHtcblx0LyoqXG5cdEltYWdlIHByZWxvYWRpbmcgYW5kIG1hbmlwdWxhdGlvbiB1dGlsaXR5LiBBZGRpdGlvbmFsbHkgaXQgcHJvdmlkZXMgYWNjZXNzIHRvIGltYWdlIG1ldGEgaW5mbyAoRXhpZiwgR1BTKSBhbmQgcmF3IGJpbmFyeSBkYXRhLlxuXG5cdEBjbGFzcyBtb3hpZS9pbWFnZS9JbWFnZVxuXHRAY29uc3RydWN0b3Jcblx0QGV4dGVuZHMgRXZlbnRUYXJnZXRcblx0Ki9cblx0dmFyIGRpc3BhdGNoZXMgPSBbXG5cdFx0J3Byb2dyZXNzJyxcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgd2hlbiBsb2FkaW5nIGlzIGNvbXBsZXRlLlxuXG5cdFx0QGV2ZW50IGxvYWRcblx0XHRAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQqL1xuXHRcdCdsb2FkJyxcblxuXHRcdCdlcnJvcicsXG5cblx0XHQvKipcblx0XHREaXNwYXRjaGVkIHdoZW4gcmVzaXplIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cblx0XHRcblx0XHRAZXZlbnQgcmVzaXplXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQncmVzaXplJyxcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZWQgd2hlbiB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGltYWdlIGlzIHN1Y2Nlc3NmdWxseSBlbWJlZGRlZFxuXHRcdGludG8gdGhlIGNvcnJlc3BvbnNpbmcgY29udGFpbmVyLlxuXG5cdFx0QGV2ZW50IGVtYmVkZGVkXG5cdFx0QHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0Ki9cblx0XHQnZW1iZWRkZWQnXG5cdF07XG5cblx0ZnVuY3Rpb24gSW1hZ2UoKSB7XG5cblx0XHRSdW50aW1lQ2xpZW50LmNhbGwodGhpcyk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0LyoqXG5cdFx0XHRVbmlxdWUgaWQgb2YgdGhlIGNvbXBvbmVudFxuXG5cdFx0XHRAcHJvcGVydHkgdWlkXG5cdFx0XHRAdHlwZSB7U3RyaW5nfVxuXHRcdFx0Ki9cblx0XHRcdHVpZDogQmFzaWMuZ3VpZCgndWlkXycpLFxuXG5cdFx0XHQvKipcblx0XHRcdFVuaXF1ZSBpZCBvZiB0aGUgY29ubmVjdGVkIHJ1bnRpbWUsIGlmIGFueS5cblxuXHRcdFx0QHByb3BlcnR5IHJ1aWRcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQqL1xuXHRcdFx0cnVpZDogbnVsbCxcblxuXHRcdFx0LyoqXG5cdFx0XHROYW1lIG9mIHRoZSBmaWxlLCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBhbiBpbWFnZSwgaWYgYXZhaWxhYmxlLiBJZiBub3QgZXF1YWxzIHRvIGVtcHR5IHN0cmluZy5cblxuXHRcdFx0QHByb3BlcnR5IG5hbWVcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHRAZGVmYXVsdCBcIlwiXG5cdFx0XHQqL1xuXHRcdFx0bmFtZTogXCJcIixcblxuXHRcdFx0LyoqXG5cdFx0XHRTaXplIG9mIHRoZSBpbWFnZSBpbiBieXRlcy4gQWN0dWFsIHZhbHVlIGlzIHNldCBvbmx5IGFmdGVyIGltYWdlIGlzIHByZWxvYWRlZC5cblxuXHRcdFx0QHByb3BlcnR5IHNpemVcblx0XHRcdEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHRAZGVmYXVsdCAwXG5cdFx0XHQqL1xuXHRcdFx0c2l6ZTogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHRXaWR0aCBvZiB0aGUgaW1hZ2UuIEFjdHVhbCB2YWx1ZSBpcyBzZXQgb25seSBhZnRlciBpbWFnZSBpcyBwcmVsb2FkZWQuXG5cblx0XHRcdEBwcm9wZXJ0eSB3aWR0aFxuXHRcdFx0QHR5cGUge051bWJlcn1cblx0XHRcdEBkZWZhdWx0IDBcblx0XHRcdCovXG5cdFx0XHR3aWR0aDogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHRIZWlnaHQgb2YgdGhlIGltYWdlLiBBY3R1YWwgdmFsdWUgaXMgc2V0IG9ubHkgYWZ0ZXIgaW1hZ2UgaXMgcHJlbG9hZGVkLlxuXG5cdFx0XHRAcHJvcGVydHkgaGVpZ2h0XG5cdFx0XHRAdHlwZSB7TnVtYmVyfVxuXHRcdFx0QGRlZmF1bHQgMFxuXHRcdFx0Ki9cblx0XHRcdGhlaWdodDogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHRNaW1lIHR5cGUgb2YgdGhlIGltYWdlLiBDdXJyZW50bHkgb25seSBpbWFnZS9qcGVnIGFuZCBpbWFnZS9wbmcgYXJlIHN1cHBvcnRlZC4gQWN0dWFsIHZhbHVlIGlzIHNldCBvbmx5IGFmdGVyIGltYWdlIGlzIHByZWxvYWRlZC5cblxuXHRcdFx0QHByb3BlcnR5IHR5cGVcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHRAZGVmYXVsdCBcIlwiXG5cdFx0XHQqL1xuXHRcdFx0dHlwZTogXCJcIixcblxuXHRcdFx0LyoqXG5cdFx0XHRIb2xkcyBtZXRhIGluZm8gKEV4aWYsIEdQUykuIElzIHBvcHVsYXRlZCBvbmx5IGZvciBpbWFnZS9qcGVnLiBBY3R1YWwgdmFsdWUgaXMgc2V0IG9ubHkgYWZ0ZXIgaW1hZ2UgaXMgcHJlbG9hZGVkLlxuXG5cdFx0XHRAcHJvcGVydHkgbWV0YVxuXHRcdFx0QHR5cGUge09iamVjdH1cblx0XHRcdEBkZWZhdWx0IHt9XG5cdFx0XHQqL1xuXHRcdFx0bWV0YToge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0QWxpYXMgZm9yIGxvYWQgbWV0aG9kLCB0aGF0IHRha2VzIGFub3RoZXIgbU94aWUuSW1hZ2Ugb2JqZWN0IGFzIGEgc291cmNlIChzZWUgbG9hZCkuXG5cblx0XHRcdEBtZXRob2QgY2xvbmVcblx0XHRcdEBwYXJhbSB7SW1hZ2V9IHNyYyBTb3VyY2UgZm9yIHRoZSBpbWFnZVxuXHRcdFx0QHBhcmFtIHtCb29sZWFufSBbZXhhY3Q9ZmFsc2VdIFdoZXRoZXIgdG8gYWN0aXZhdGUgaW4tZGVwdGggY2xvbmUgbW9kZVxuXHRcdFx0Ki9cblx0XHRcdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5sb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdExvYWRzIGltYWdlIGZyb20gdmFyaW91cyBzb3VyY2VzLiBDdXJyZW50bHkgdGhlIHNvdXJjZSBmb3IgbmV3IGltYWdlIGNhbiBiZTogbU94aWUuSW1hZ2UsIG1PeGllLkJsb2IvbU94aWUuRmlsZSwgXG5cdFx0XHRuYXRpdmUgQmxvYi9GaWxlLCBkYXRhVXJsIG9yIFVSTC4gRGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSBzb3VyY2UsIGFyZ3VtZW50cyAtIGRpZmZlci4gV2hlbiBzb3VyY2UgaXMgVVJMLCBcblx0XHRcdEltYWdlIHdpbGwgYmUgZG93bmxvYWRlZCBmcm9tIHJlbW90ZSBkZXN0aW5hdGlvbiBhbmQgbG9hZGVkIGluIG1lbW9yeS5cblxuXHRcdFx0QGV4YW1wbGVcblx0XHRcdFx0dmFyIGltZyA9IG5ldyBtT3hpZS5JbWFnZSgpO1xuXHRcdFx0XHRpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGJsb2IgPSBpbWcuZ2V0QXNCbG9iKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGZvcm1EYXRhID0gbmV3IG1PeGllLkZvcm1EYXRhKCk7XG5cdFx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdmaWxlJywgYmxvYik7XG5cblx0XHRcdFx0XHR2YXIgeGhyID0gbmV3IG1PeGllLlhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHRcdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Ly8gdXBsb2FkIGNvbXBsZXRlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR4aHIub3BlbigncG9zdCcsICd1cGxvYWQucGhwJyk7XG5cdFx0XHRcdFx0eGhyLnNlbmQoZm9ybURhdGEpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpbWcubG9hZChcImh0dHA6Ly93d3cubW94aWVjb2RlLmNvbS9pbWFnZXMvbW94LWxvZ28uanBnXCIpOyAvLyBub3RpY2UgZmlsZSBleHRlbnNpb24gKC5qcGcpXG5cdFx0XHRcblxuXHRcdFx0QG1ldGhvZCBsb2FkXG5cdFx0XHRAcGFyYW0ge0ltYWdlfEJsb2J8RmlsZXxTdHJpbmd9IHNyYyBTb3VyY2UgZm9yIHRoZSBpbWFnZVxuXHRcdFx0QHBhcmFtIHtCb29sZWFufE9iamVjdH0gW21peGVkXVxuXHRcdFx0Ki9cblx0XHRcdGxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdFJlc2l6ZXMgdGhlIGltYWdlIHRvIGZpdCB0aGUgc3BlY2lmaWVkIHdpZHRoL2hlaWdodC4gSWYgY3JvcCBpcyBzcGVjaWZpZWQsIGltYWdlIHdpbGwgYWxzbyBiZSBcblx0XHRcdGNyb3BwZWQgdG8gdGhlIGV4YWN0IGRpbWVuc2lvbnMuXG5cblx0XHRcdEBtZXRob2QgcmVzaXplXG5cdFx0XHRAc2luY2UgMy4wXG5cdFx0XHRAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdFx0XHRAcGFyYW0ge051bWJlcn0gb3B0aW9ucy53aWR0aCBSZXN1bHRpbmcgd2lkdGhcblx0XHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD13aWR0aF0gUmVzdWx0aW5nIGhlaWdodCAob3B0aW9uYWwsIGlmIG5vdCBzdXBwbGllZCB3aWxsIGRlZmF1bHQgdG8gd2lkdGgpXG5cdFx0XHRcdEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50eXBlPSdpbWFnZS9qcGVnJ10gTUlNRSB0eXBlIG9mIHRoZSByZXN1bHRpbmcgaW1hZ2Vcblx0XHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9OTBdIEluIHRoZSBjYXNlIG9mIEpQRUcsIGNvbnRyb2xzIHRoZSBxdWFsaXR5IG9mIHJlc3VsdGluZyBpbWFnZVxuXHRcdFx0XHRAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNyb3A9J2NjJ10gSWYgbm90IGZhbHN5LCBpbWFnZSB3aWxsIGJlIGNyb3BwZWQsIGJ5IGRlZmF1bHQgZnJvbSBjZW50ZXJcblx0XHRcdFx0QHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maXQ9dHJ1ZV0gSW4gY2FzZSBvZiBjcm9wIHdoZXRoZXIgdG8gdXBzY2FsZSB0aGUgaW1hZ2UgdG8gZml0IHRoZSBleGFjdCBkaW1lbnNpb25zXG5cdFx0XHRcdEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucHJlc2VydmVIZWFkZXJzPXRydWVdIFdoZXRoZXIgdG8gcHJlc2VydmUgbWV0YSBoZWFkZXJzIChvbiBKUEVHcyBhZnRlciByZXNpemUpXG5cdFx0XHRcdEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXNhbXBsZT0nZGVmYXVsdCddIFJlc2FtcGxpbmcgYWxnb3JpdGhtIHRvIHVzZSBkdXJpbmcgcmVzaXplXG5cdFx0XHRcdEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXVsdGlwYXNzPXRydWVdIFdoZXRoZXIgdG8gc2NhbGUgdGhlIGltYWdlIGluIHN0ZXBzIChyZXN1bHRzIGluIGJldHRlciBxdWFsaXR5KVxuXHRcdFx0Ki9cblx0XHRcdHJlc2l6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdHZhciBvcmllbnRhdGlvbjtcblx0XHRcdFx0dmFyIHNjYWxlO1xuXG5cdFx0XHRcdHZhciBzcmNSZWN0ID0ge1xuXHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0eTogMCxcblx0XHRcdFx0XHR3aWR0aDogc2VsZi53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHNlbGYuaGVpZ2h0XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIG9wdHMgPSBCYXNpYy5leHRlbmRJZih7XG5cdFx0XHRcdFx0d2lkdGg6IHNlbGYud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzZWxmLmhlaWdodCxcblx0XHRcdFx0XHR0eXBlOiBzZWxmLnR5cGUgfHwgJ2ltYWdlL2pwZWcnLFxuXHRcdFx0XHRcdHF1YWxpdHk6IDkwLFxuXHRcdFx0XHRcdGNyb3A6IGZhbHNlLFxuXHRcdFx0XHRcdGZpdDogdHJ1ZSxcblx0XHRcdFx0XHRwcmVzZXJ2ZUhlYWRlcnM6IHRydWUsXG5cdFx0XHRcdFx0cmVzYW1wbGU6ICdkZWZhdWx0Jyxcblx0XHRcdFx0XHRtdWx0aXBhc3M6IHRydWVcblx0XHRcdFx0fSwgb3B0aW9ucyk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIXNlbGYuc2l6ZSkgeyAvLyBvbmx5IHByZWxvYWRlZCBpbWFnZSBvYmplY3RzIGNhbiBiZSB1c2VkIGFzIHNvdXJjZVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBubyB3YXkgdG8gcmVsaWFibHkgaW50ZXJjZXB0IHRoZSBjcmFzaCBkdWUgdG8gaGlnaCByZXNvbHV0aW9uLCBzbyB3ZSBzaW1wbHkgYXZvaWQgaXRcblx0XHRcdFx0XHRpZiAoc2VsZi53aWR0aCA+IEltYWdlLk1BWF9SRVNJWkVfV0lEVEggfHwgc2VsZi5oZWlnaHQgPiBJbWFnZS5NQVhfUkVTSVpFX0hFSUdIVCkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkltYWdlRXJyb3IuTUFYX1JFU09MVVRJT05fRVJSKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0YWtlIGludG8gYWNjb3VudCBvcmllbnRhdGlvbiB0YWdcblx0XHRcdFx0XHRvcmllbnRhdGlvbiA9IChzZWxmLm1ldGEgJiYgc2VsZi5tZXRhLnRpZmYgJiYgc2VsZi5tZXRhLnRpZmYuT3JpZW50YXRpb24pIHx8IDE7XG5cblx0XHRcdFx0XHRpZiAoQmFzaWMuaW5BcnJheShvcmllbnRhdGlvbiwgWzUsNiw3LDhdKSAhPT0gLTEpIHsgLy8gdmFsdWVzIHRoYXQgcmVxdWlyZSA5MCBkZWdyZWUgcm90YXRpb25cblx0XHRcdFx0XHRcdHZhciB0bXAgPSBvcHRzLndpZHRoO1xuXHRcdFx0XHRcdFx0b3B0cy53aWR0aCA9IG9wdHMuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0b3B0cy5oZWlnaHQgPSB0bXA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG9wdHMuY3JvcCkge1xuXHRcdFx0XHRcdFx0c2NhbGUgPSBNYXRoLm1heChvcHRzLndpZHRoL3NlbGYud2lkdGgsIG9wdHMuaGVpZ2h0L3NlbGYuaGVpZ2h0KTtcblxuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMuZml0KSB7XG5cdFx0XHRcdFx0XHRcdC8vIGZpcnN0IHNjYWxlIGl0IHVwIG9yIGRvd24gdG8gZml0IHRoZSBvcmlnaW5hbCBpbWFnZVxuXHRcdFx0XHRcdFx0XHRzcmNSZWN0LndpZHRoID0gTWF0aC5taW4oTWF0aC5jZWlsKG9wdHMud2lkdGgvc2NhbGUpLCBzZWxmLndpZHRoKTtcblx0XHRcdFx0XHRcdFx0c3JjUmVjdC5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwob3B0cy5oZWlnaHQvc2NhbGUpLCBzZWxmLmhlaWdodCk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyByZWNhbGN1bGF0ZSB0aGUgc2NhbGUgZm9yIGFkYXB0ZWQgZGltZW5zaW9uc1xuXHRcdFx0XHRcdFx0XHRzY2FsZSA9IG9wdHMud2lkdGgvc3JjUmVjdC53aWR0aDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNyY1JlY3Qud2lkdGggPSBNYXRoLm1pbihvcHRzLndpZHRoLCBzZWxmLndpZHRoKTtcblx0XHRcdFx0XHRcdFx0c3JjUmVjdC5oZWlnaHQgPSBNYXRoLm1pbihvcHRzLmhlaWdodCwgc2VsZi5oZWlnaHQpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG5vdyB3ZSBkbyBub3QgbmVlZCB0byBzY2FsZSBpdCBhbnkgZnVydGhlclxuXHRcdFx0XHRcdFx0XHRzY2FsZSA9IDE7IFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKG9wdHMuY3JvcCkgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdFx0XHRvcHRzLmNyb3AgPSAnY2MnO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKG9wdHMuY3JvcC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18vLCAnLScpKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3JiJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAncmlnaHQtYm90dG9tJzpcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnggPSBzZWxmLndpZHRoIC0gc3JjUmVjdC53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnkgPSBzZWxmLmhlaWdodCAtIHNyY1JlY3QuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NiJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnY2VudGVyLWJvdHRvbSc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gTWF0aC5mbG9vcigoc2VsZi53aWR0aCAtIHNyY1JlY3Qud2lkdGgpIC8gMik7XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gc2VsZi5oZWlnaHQgLSBzcmNSZWN0LmhlaWdodDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdsYic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2xlZnQtYm90dG9tJzpcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueSA9IHNlbGYuaGVpZ2h0IC0gc3JjUmVjdC5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnbHQnOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdsZWZ0LXRvcCc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnkgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2N0Jzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnY2VudGVyLXRvcCc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gTWF0aC5mbG9vcigoc2VsZi53aWR0aCAtIHNyY1JlY3Qud2lkdGgpIC8gMik7XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdydCc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3JpZ2h0LXRvcCc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gc2VsZi53aWR0aCAtIHNyY1JlY3Qud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdyYyc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3JpZ2h0LWNlbnRlcic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3JpZ2h0LW1pZGRsZSc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gc2VsZi53aWR0aCAtIHNyY1JlY3Qud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC55ID0gTWF0aC5mbG9vcigoc2VsZi5oZWlnaHQgLSBzcmNSZWN0LmhlaWdodCkgLyAyKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2xjJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbGVmdC1jZW50ZXInOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdsZWZ0LW1pZGRsZSc6XG5cdFx0XHRcdFx0XHRcdFx0c3JjUmVjdC54ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRzcmNSZWN0LnkgPSBNYXRoLmZsb29yKChzZWxmLmhlaWdodCAtIHNyY1JlY3QuaGVpZ2h0KSAvIDIpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NjJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnY2VudGVyLWNlbnRlcic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NlbnRlci1taWRkbGUnOlxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IE1hdGguZmxvb3IoKHNlbGYud2lkdGggLSBzcmNSZWN0LndpZHRoKSAvIDIpO1xuXHRcdFx0XHRcdFx0XHRcdHNyY1JlY3QueSA9IE1hdGguZmxvb3IoKHNlbGYuaGVpZ2h0IC0gc3JjUmVjdC5oZWlnaHQpIC8gMik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIG9yaWdpbmFsIGltYWdlIG1pZ2h0IGJlIHNtYWxsZXIgdGhhbiByZXF1ZXN0ZWQgY3JvcCwgc28gLSBhdm9pZCBuZWdhdGl2ZSB2YWx1ZXNcblx0XHRcdFx0XHRcdHNyY1JlY3QueCA9IE1hdGgubWF4KHNyY1JlY3QueCwgMCk7XG5cdFx0XHRcdFx0XHRzcmNSZWN0LnkgPSBNYXRoLm1heChzcmNSZWN0LnksIDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzY2FsZSA9IE1hdGgubWluKG9wdHMud2lkdGgvc2VsZi53aWR0aCwgb3B0cy5oZWlnaHQvc2VsZi5oZWlnaHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuZXhlYygnSW1hZ2UnLCAncmVzaXplJywgc3JjUmVjdCwgc2NhbGUsIG9wdHMpO1xuXHRcdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdFx0Ly8gZm9yIG5vdyBzaW1wbHkgdHJpZ2dlciBlcnJvciBldmVudFxuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcignZXJyb3InLCBleC5jb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHREb3duc2l6ZXMgdGhlIGltYWdlIHRvIGZpdCB0aGUgc3BlY2lmaWVkIHdpZHRoL2hlaWdodC4gSWYgY3JvcCBpcyBzdXBwbGllZCwgaW1hZ2Ugd2lsbCBiZSBjcm9wcGVkIHRvIGV4YWN0IGRpbWVuc2lvbnMuXG5cblx0XHRcdEBtZXRob2QgZG93bnNpemVcblx0XHRcdEBkZXByZWNhdGVkIHVzZSByZXNpemUoKVxuXHRcdFx0Ki9cblx0XHRcdGRvd25zaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBkZWZhdWx0cyA9IHtcblx0XHRcdFx0XHR3aWR0aDogdGhpcy53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuXHRcdFx0XHRcdHR5cGU6IHRoaXMudHlwZSB8fCAnaW1hZ2UvanBlZycsXG5cdFx0XHRcdFx0cXVhbGl0eTogOTAsXG5cdFx0XHRcdFx0Y3JvcDogZmFsc2UsXG5cdFx0XHRcdFx0cHJlc2VydmVIZWFkZXJzOiB0cnVlLFxuXHRcdFx0XHRcdHJlc2FtcGxlOiAnZGVmYXVsdCdcblx0XHRcdFx0fSwgb3B0cztcblxuXHRcdFx0XHRpZiAodHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdG9wdHMgPSBCYXNpYy5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0b3B0cyA9IEJhc2ljLmV4dGVuZChkZWZhdWx0cywge1xuXHRcdFx0XHRcdFx0d2lkdGg6IGFyZ3VtZW50c1swXSxcblx0XHRcdFx0XHRcdGhlaWdodDogYXJndW1lbnRzWzFdLFxuXHRcdFx0XHRcdFx0Y3JvcDogYXJndW1lbnRzWzJdLFxuXHRcdFx0XHRcdFx0cHJlc2VydmVIZWFkZXJzOiBhcmd1bWVudHNbM11cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMucmVzaXplKG9wdHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRBbGlhcyBmb3IgZG93bnNpemUod2lkdGgsIGhlaWdodCwgdHJ1ZSkuIChzZWUgZG93bnNpemUpXG5cdFx0XHRcblx0XHRcdEBtZXRob2QgY3JvcFxuXHRcdFx0QHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFJlc3VsdGluZyB3aWR0aFxuXHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9d2lkdGhdIFJlc3VsdGluZyBoZWlnaHQgKG9wdGlvbmFsLCBpZiBub3Qgc3VwcGxpZWQgd2lsbCBkZWZhdWx0IHRvIHdpZHRoKVxuXHRcdFx0QHBhcmFtIHtCb29sZWFufSBbcHJlc2VydmVIZWFkZXJzPXRydWVdIFdoZXRoZXIgdG8gcHJlc2VydmUgbWV0YSBoZWFkZXJzIChvbiBKUEVHcyBhZnRlciByZXNpemUpXG5cdFx0XHQqL1xuXHRcdFx0Y3JvcDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcHJlc2VydmVIZWFkZXJzKSB7XG5cdFx0XHRcdHRoaXMuZG93bnNpemUod2lkdGgsIGhlaWdodCwgdHJ1ZSwgcHJlc2VydmVIZWFkZXJzKTtcblx0XHRcdH0sXG5cblx0XHRcdGdldEFzQ2FudmFzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCFFbnYuY2FuKCdjcmVhdGVfY2FudmFzJykpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5SdW50aW1lRXJyb3IoeC5SdW50aW1lRXJyb3IuTk9UX1NVUFBPUlRFRF9FUlIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4ZWMoJ0ltYWdlJywgJ2dldEFzQ2FudmFzJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHJpZXZlcyBpbWFnZSBpbiBpdCdzIGN1cnJlbnQgc3RhdGUgYXMgbU94aWUuQmxvYiBvYmplY3QuIENhbm5vdCBiZSBydW4gb24gZW1wdHkgb3IgaW1hZ2UgaW4gcHJvZ3Jlc3MgKHRocm93c1xuXHRcdFx0RE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKS5cblxuXHRcdFx0QG1ldGhvZCBnZXRBc0Jsb2Jcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBbdHlwZT1cImltYWdlL2pwZWdcIl0gTWltZSB0eXBlIG9mIHJlc3VsdGluZyBibG9iLiBDYW4gZWl0aGVyIGJlIGltYWdlL2pwZWcgb3IgaW1hZ2UvcG5nXG5cdFx0XHRAcGFyYW0ge051bWJlcn0gW3F1YWxpdHk9OTBdIEFwcGxpY2FibGUgb25seSB0b2dldGhlciB3aXRoIG1pbWUgdHlwZSBpbWFnZS9qcGVnXG5cdFx0XHRAcmV0dXJuIHtCbG9ifSBJbWFnZSBhcyBCbG9iXG5cdFx0XHQqL1xuXHRcdFx0Z2V0QXNCbG9iOiBmdW5jdGlvbih0eXBlLCBxdWFsaXR5KSB7XG5cdFx0XHRcdGlmICghdGhpcy5zaXplKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leGVjKCdJbWFnZScsICdnZXRBc0Jsb2InLCB0eXBlIHx8ICdpbWFnZS9qcGVnJywgcXVhbGl0eSB8fCA5MCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHJpZXZlcyBpbWFnZSBpbiBpdCdzIGN1cnJlbnQgc3RhdGUgYXMgZGF0YVVSTCBzdHJpbmcuIENhbm5vdCBiZSBydW4gb24gZW1wdHkgb3IgaW1hZ2UgaW4gcHJvZ3Jlc3MgKHRocm93c1xuXHRcdFx0RE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKS5cblxuXHRcdFx0QG1ldGhvZCBnZXRBc0RhdGFVUkxcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBbdHlwZT1cImltYWdlL2pwZWdcIl0gTWltZSB0eXBlIG9mIHJlc3VsdGluZyBibG9iLiBDYW4gZWl0aGVyIGJlIGltYWdlL2pwZWcgb3IgaW1hZ2UvcG5nXG5cdFx0XHRAcGFyYW0ge051bWJlcn0gW3F1YWxpdHk9OTBdIEFwcGxpY2FibGUgb25seSB0b2dldGhlciB3aXRoIG1pbWUgdHlwZSBpbWFnZS9qcGVnXG5cdFx0XHRAcmV0dXJuIHtTdHJpbmd9IEltYWdlIGFzIGRhdGFVUkwgc3RyaW5nXG5cdFx0XHQqL1xuXHRcdFx0Z2V0QXNEYXRhVVJMOiBmdW5jdGlvbih0eXBlLCBxdWFsaXR5KSB7XG5cdFx0XHRcdGlmICghdGhpcy5zaXplKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leGVjKCdJbWFnZScsICdnZXRBc0RhdGFVUkwnLCB0eXBlIHx8ICdpbWFnZS9qcGVnJywgcXVhbGl0eSB8fCA5MCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJldHJpZXZlcyBpbWFnZSBpbiBpdCdzIGN1cnJlbnQgc3RhdGUgYXMgYmluYXJ5IHN0cmluZy4gQ2Fubm90IGJlIHJ1biBvbiBlbXB0eSBvciBpbWFnZSBpbiBwcm9ncmVzcyAodGhyb3dzXG5cdFx0XHRET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpLlxuXG5cdFx0XHRAbWV0aG9kIGdldEFzQmluYXJ5U3RyaW5nXG5cdFx0XHRAcGFyYW0ge1N0cmluZ30gW3R5cGU9XCJpbWFnZS9qcGVnXCJdIE1pbWUgdHlwZSBvZiByZXN1bHRpbmcgYmxvYi4gQ2FuIGVpdGhlciBiZSBpbWFnZS9qcGVnIG9yIGltYWdlL3BuZ1xuXHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtxdWFsaXR5PTkwXSBBcHBsaWNhYmxlIG9ubHkgdG9nZXRoZXIgd2l0aCBtaW1lIHR5cGUgaW1hZ2UvanBlZ1xuXHRcdFx0QHJldHVybiB7U3RyaW5nfSBJbWFnZSBhcyBiaW5hcnkgc3RyaW5nXG5cdFx0XHQqL1xuXHRcdFx0Z2V0QXNCaW5hcnlTdHJpbmc6IGZ1bmN0aW9uKHR5cGUsIHF1YWxpdHkpIHtcblx0XHRcdFx0dmFyIGRhdGFVcmwgPSB0aGlzLmdldEFzRGF0YVVSTCh0eXBlLCBxdWFsaXR5KTtcblx0XHRcdFx0cmV0dXJuIEVuY29kZS5hdG9iKGRhdGFVcmwuc3Vic3RyaW5nKGRhdGFVcmwuaW5kZXhPZignYmFzZTY0LCcpICsgNykpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHRFbWJlZHMgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGltYWdlIGludG8gdGhlIHNwZWNpZmllZCBub2RlLiBEZXBlbmRpbmcgb24gdGhlIHJ1bnRpbWUsIFxuXHRcdFx0aXQgbWlnaHQgYmUgYSBjYW52YXMsIGFuIGltZyBub2RlIG9yIGEgdGhyaWQgcGFydHkgc2hpbSBvYmplY3QgKEZsYXNoIG9yIFNpbHZlckxpZ2h0IC0gdmVyeSByYXJlLCBcblx0XHRcdGNhbiBiZSB1c2VkIGluIGxlZ2FjeSBicm93c2VycyB0aGF0IGRvIG5vdCBoYXZlIGNhbnZhcyBvciBwcm9wZXIgZGF0YVVSSSBzdXBwb3J0KS5cblxuXHRcdFx0QG1ldGhvZCBlbWJlZFxuXHRcdFx0QHBhcmFtIHtET01FbGVtZW50fSBlbCBET00gZWxlbWVudCB0byBpbnNlcnQgdGhlIGltYWdlIG9iamVjdCBpbnRvXG5cdFx0XHRAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG5cdFx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gVGhlIHdpZHRoIG9mIGFuIGVtYmVkIChkZWZhdWx0cyB0byB0aGUgaW1hZ2Ugd2lkdGgpXG5cdFx0XHRcdEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIFRoZSBoZWlnaHQgb2YgYW4gZW1iZWQgKGRlZmF1bHRzIHRvIHRoZSBpbWFnZSBoZWlnaHQpXG5cdFx0XHRcdEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50eXBlPVwiaW1hZ2UvanBlZ1wiXSBNaW1lIHR5cGVcblx0XHRcdFx0QHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9OTBdIFF1YWxpdHkgb2YgYW4gZW1iZWQsIGlmIG1pbWUgdHlwZSBpcyBpbWFnZS9qcGVnXG5cdFx0XHRcdEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY3JvcD1mYWxzZV0gV2hldGhlciB0byBjcm9wIGFuIGVtYmVkIHRvIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uc1xuXHRcdFx0Ki9cblx0XHRcdGVtYmVkOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHRcdFx0LCBydW50aW1lIC8vIHRoaXMgaGFzIHRvIGJlIG91dHNpZGUgb2YgYWxsIHRoZSBjbG9zdXJlcyB0byBjb250YWluIHByb3BlciBydW50aW1lXG5cdFx0XHRcdDtcblxuXHRcdFx0XHR2YXIgb3B0cyA9IEJhc2ljLmV4dGVuZCh7XG5cdFx0XHRcdFx0d2lkdGg6IHRoaXMud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGlzLmhlaWdodCxcblx0XHRcdFx0XHR0eXBlOiB0aGlzLnR5cGUgfHwgJ2ltYWdlL2pwZWcnLFxuXHRcdFx0XHRcdHF1YWxpdHk6IDkwXG5cdFx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcblxuXHRcdFx0XHRmdW5jdGlvbiByZW5kZXIodHlwZSwgcXVhbGl0eSkge1xuXHRcdFx0XHRcdHZhciBpbWcgPSB0aGlzO1xuXG5cdFx0XHRcdFx0Ly8gaWYgcG9zc2libGUsIGVtYmVkIGEgY2FudmFzIGVsZW1lbnQgZGlyZWN0bHlcblx0XHRcdFx0XHRpZiAoRW52LmNhbignY3JlYXRlX2NhbnZhcycpKSB7XG5cdFx0XHRcdFx0XHR2YXIgY2FudmFzID0gaW1nLmdldEFzQ2FudmFzKCk7XG5cdFx0XHRcdFx0XHRpZiAoY2FudmFzKSB7XG5cdFx0XHRcdFx0XHRcdGVsLmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cdFx0XHRcdFx0XHRcdGNhbnZhcyA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGltZy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdHNlbGYudHJpZ2dlcignZW1iZWRkZWQnKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBkYXRhVXJsID0gaW1nLmdldEFzRGF0YVVSTCh0eXBlLCBxdWFsaXR5KTtcblx0XHRcdFx0XHRpZiAoIWRhdGFVcmwpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLldST05HX0ZPUk1BVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKEVudi5jYW4oJ3VzZV9kYXRhX3VyaV9vZicsIGRhdGFVcmwubGVuZ3RoKSkge1xuXHRcdFx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gJzxpbWcgc3JjPVwiJyArIGRhdGFVcmwgKyAnXCIgd2lkdGg9XCInICsgaW1nLndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyBpbWcuaGVpZ2h0ICsgJ1wiIC8+Jztcblx0XHRcdFx0XHRcdGltZy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2VtYmVkZGVkJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciB0ciA9IG5ldyBUcmFuc3BvcnRlcigpO1xuXG5cdFx0XHRcdFx0XHR0ci5iaW5kKFwiVHJhbnNwb3J0aW5nQ29tcGxldGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bnRpbWUgPSBzZWxmLmNvbm5lY3RSdW50aW1lKHRoaXMucmVzdWx0LnJ1aWQpO1xuXG5cdFx0XHRcdFx0XHRcdHNlbGYuYmluZChcIkVtYmVkZGVkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHBvc2l0aW9uIGFuZCBzaXplIHByb3Blcmx5XG5cdFx0XHRcdFx0XHRcdFx0QmFzaWMuZXh0ZW5kKHJ1bnRpbWUuZ2V0U2hpbUNvbnRhaW5lcigpLnN0eWxlLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvL3Bvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHRcdFx0XHRcdFx0XHRcdFx0dG9wOiAnMHB4Jyxcblx0XHRcdFx0XHRcdFx0XHRcdGxlZnQ6ICcwcHgnLFxuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGg6IGltZy53aWR0aCArICdweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGltZy5oZWlnaHQgKyAncHgnXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzb21lIHNoaW1zIChGbGFzaC9TaWx2ZXJMaWdodCkgcmVpbml0aWFsaXplLCBpZiBwYXJlbnQgZWxlbWVudCBpcyBoaWRkZW4sIHJlb3JkZXJlZCBvciBpdCdzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcG9zaXRpb24gdHlwZSBjaGFuZ2VzIChpbiBHZWNrbyksIGJ1dCBzaW5jZSB3ZSBiYXNpY2FsbHkgbmVlZCB0aGlzIG9ubHkgaW4gSUVzIDYvNyBhbmRcblx0XHRcdFx0XHRcdFx0XHQvLyBzb21ldGltZXMgOCBhbmQgdGhleSBkbyBub3QgaGF2ZSB0aGlzIHByb2JsZW0sIHdlIGNhbiBjb21tZW50IHRoaXMgZm9yIG5vd1xuXHRcdFx0XHRcdFx0XHRcdC8qdHIuYmluZChcIlJ1bnRpbWVJbml0XCIsIGZ1bmN0aW9uKGUsIHJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJ1bnRpbWUuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZXNpemUuY2FsbChzZWxmKTsgLy8gcmUtZmVlZCBvdXIgaW1hZ2UgZGF0YVxuXHRcdFx0XHRcdFx0XHRcdH0pOyovXG5cblx0XHRcdFx0XHRcdFx0XHRydW50aW1lID0gbnVsbDsgLy8gcmVsZWFzZVxuXHRcdFx0XHRcdFx0XHR9LCA5OTkpO1xuXG5cdFx0XHRcdFx0XHRcdHJ1bnRpbWUuZXhlYy5jYWxsKHNlbGYsIFwiSW1hZ2VWaWV3XCIsIFwiZGlzcGxheVwiLCB0aGlzLnJlc3VsdC51aWQsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0XHRcdFx0XHRpbWcuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHRyLnRyYW5zcG9ydChFbmNvZGUuYXRvYihkYXRhVXJsLnN1YnN0cmluZyhkYXRhVXJsLmluZGV4T2YoJ2Jhc2U2NCwnKSArIDcpKSwgdHlwZSwge1xuXHRcdFx0XHRcdFx0XHRyZXF1aXJlZF9jYXBzOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlzcGxheV9tZWRpYTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRydW50aW1lX29yZGVyOiAnZmxhc2gsc2lsdmVybGlnaHQnLFxuXHRcdFx0XHRcdFx0XHRjb250YWluZXI6IGVsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghKGVsID0gRG9tLmdldChlbCkpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9OT0RFX1RZUEVfRVJSKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRoaXMuc2l6ZSkgeyAvLyBvbmx5IHByZWxvYWRlZCBpbWFnZSBvYmplY3RzIGNhbiBiZSB1c2VkIGFzIHNvdXJjZVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IHguRE9NRXhjZXB0aW9uKHguRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gaGlnaC1yZXNvbHV0aW9uIGltYWdlcyBjYW5ub3QgYmUgY29uc2lzdGVudGx5IGhhbmRsZWQgYWNyb3NzIHRoZSBydW50aW1lc1xuXHRcdFx0XHRcdGlmICh0aGlzLndpZHRoID4gSW1hZ2UuTUFYX1JFU0laRV9XSURUSCB8fCB0aGlzLmhlaWdodCA+IEltYWdlLk1BWF9SRVNJWkVfSEVJR0hUKSB7XG5cdFx0XHRcdFx0XHQvL3Rocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLk1BWF9SRVNPTFVUSU9OX0VSUik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGltZ0NvcHkgPSBuZXcgSW1hZ2UoKTtcblxuXHRcdFx0XHRcdGltZ0NvcHkuYmluZChcIlJlc2l6ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJlbmRlci5jYWxsKHRoaXMsIG9wdHMudHlwZSwgb3B0cy5xdWFsaXR5KTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGltZ0NvcHkuYmluZChcIkxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRvd25zaXplKG9wdHMpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gaWYgZW1iZWRkZWQgdGh1bWIgZGF0YSBpcyBhdmFpbGFibGUgYW5kIGRpbWVuc2lvbnMgYXJlIGJpZyBlbm91Z2gsIHVzZSBpdFxuXHRcdFx0XHRcdGlmICh0aGlzLm1ldGEudGh1bWIgJiYgdGhpcy5tZXRhLnRodW1iLndpZHRoID49IG9wdHMud2lkdGggJiYgdGhpcy5tZXRhLnRodW1iLmhlaWdodCA+PSBvcHRzLmhlaWdodCkge1xuXHRcdFx0XHRcdFx0aW1nQ29weS5sb2FkKHRoaXMubWV0YS50aHVtYi5kYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aW1nQ29weS5jbG9uZSh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGltZ0NvcHk7XG5cdFx0XHRcdH0gY2F0Y2goZXgpIHtcblx0XHRcdFx0XHQvLyBmb3Igbm93IHNpbXBseSB0cmlnZ2VyIGVycm9yIGV2ZW50XG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdlcnJvcicsIGV4LmNvZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdFByb3Blcmx5IGRlc3Ryb3lzIHRoZSBpbWFnZSBhbmQgZnJlZXMgcmVzb3VyY2VzIGluIHVzZS4gSWYgYW55LiBSZWNvbW1lbmRlZCB3YXkgdG8gZGlzcG9zZSBtT3hpZS5JbWFnZSBvYmplY3QuXG5cblx0XHRcdEBtZXRob2QgZGVzdHJveVxuXHRcdFx0Ki9cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodGhpcy5ydWlkKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRSdW50aW1lKCkuZXhlYy5jYWxsKHRoaXMsICdJbWFnZScsICdkZXN0cm95Jyk7XG5cdFx0XHRcdFx0dGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLm1ldGEgJiYgdGhpcy5tZXRhLnRodW1iKSB7XG5cdFx0XHRcdFx0Ly8gdGh1bWIgaXMgYmxvYiwgbWFrZSBzdXJlIHdlIGRlc3Ryb3kgaXQgZmlyc3Rcblx0XHRcdFx0XHR0aGlzLm1ldGEudGh1bWIuZGF0YS5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51bmJpbmRBbGwoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXG5cdFx0Ly8gdGhpcyBpcyBoZXJlLCBiZWNhdXNlIGluIG9yZGVyIHRvIGJpbmQgcHJvcGVybHksIHdlIG5lZWQgdWlkLCB3aGljaCBpcyBjcmVhdGVkIGFib3ZlXG5cdFx0dGhpcy5oYW5kbGVFdmVudFByb3BzKGRpc3BhdGNoZXMpO1xuXG5cdFx0dGhpcy5iaW5kKCdMb2FkIFJlc2l6ZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIF91cGRhdGVJbmZvLmNhbGwodGhpcyk7IC8vIGlmIG9wZXJhdGlvbiBmYWlscyAoZS5nLiBpbWFnZSBpcyBuZWl0aGVyIFBORyBub3IgSlBFRykgY2FuY2VsIGFsbCBwZW5kaW5nIGV2ZW50c1xuXHRcdH0sIDk5OSk7XG5cblxuXHRcdGZ1bmN0aW9uIF91cGRhdGVJbmZvKGluZm8pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghaW5mbykge1xuXHRcdFx0XHRcdGluZm8gPSB0aGlzLmV4ZWMoJ0ltYWdlJywgJ2dldEluZm8nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2l6ZSA9IGluZm8uc2l6ZTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGluZm8ud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gaW5mby5oZWlnaHQ7XG5cdFx0XHRcdHRoaXMudHlwZSA9IGluZm8udHlwZTtcblx0XHRcdFx0dGhpcy5tZXRhID0gaW5mby5tZXRhO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBmaWxlIG5hbWUsIG9ubHkgaWYgZW1wdHlcblx0XHRcdFx0aWYgKHRoaXMubmFtZSA9PT0gJycpIHtcblx0XHRcdFx0XHR0aGlzLm5hbWUgPSBpbmZvLm5hbWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gY2F0Y2goZXgpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdlcnJvcicsIGV4LmNvZGUpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfbG9hZChzcmMpIHtcblx0XHRcdHZhciBzcmNUeXBlID0gQmFzaWMudHlwZU9mKHNyYyk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIGlmIHNvdXJjZSBpcyBJbWFnZVxuXHRcdFx0XHRpZiAoc3JjIGluc3RhbmNlb2YgSW1hZ2UpIHtcblx0XHRcdFx0XHRpZiAoIXNyYy5zaXplKSB7IC8vIG9ubHkgcHJlbG9hZGVkIGltYWdlIG9iamVjdHMgY2FuIGJlIHVzZWQgYXMgc291cmNlXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbG9hZEZyb21JbWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHNvdXJjZSBpcyBvLkJsb2Ivby5GaWxlXG5cdFx0XHRcdGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRpZiAoIX5CYXNpYy5pbkFycmF5KHNyYy50eXBlLCBbJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvcG5nJ10pKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbG9hZEZyb21CbG9iLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgbmF0aXZlIGJsb2IvZmlsZVxuXHRcdFx0XHRlbHNlIGlmIChCYXNpYy5pbkFycmF5KHNyY1R5cGUsIFsnYmxvYicsICdmaWxlJ10pICE9PSAtMSkge1xuXHRcdFx0XHRcdF9sb2FkLmNhbGwodGhpcywgbmV3IEZpbGUobnVsbCwgc3JjKSwgYXJndW1lbnRzWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiBTdHJpbmdcblx0XHRcdFx0ZWxzZSBpZiAoc3JjVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHQvLyBpZiBkYXRhVXJsIFN0cmluZ1xuXHRcdFx0XHRcdGlmIChzcmMuc3Vic3RyKDAsIDUpID09PSAnZGF0YTonKSB7XG5cdFx0XHRcdFx0XHRfbG9hZC5jYWxsKHRoaXMsIG5ldyBCbG9iKG51bGwsIHsgZGF0YTogc3JjIH0pLCBhcmd1bWVudHNbMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlbHNlIGFzc3VtZSBVcmwsIGVpdGhlciByZWxhdGl2ZSBvciBhYnNvbHV0ZVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0X2xvYWRGcm9tVXJsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHNvdXJjZSBzZWVtcyB0byBiZSBhbiBpbWcgbm9kZVxuXHRcdFx0XHRlbHNlIGlmIChzcmNUeXBlID09PSAnbm9kZScgJiYgc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG5cdFx0XHRcdFx0X2xvYWQuY2FsbCh0aGlzLCBzcmMuc3JjLCBhcmd1bWVudHNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkRPTUV4Y2VwdGlvbih4LkRPTUV4Y2VwdGlvbi5UWVBFX01JU01BVENIX0VSUik7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goZXgpIHtcblx0XHRcdFx0Ly8gZm9yIG5vdyBzaW1wbHkgdHJpZ2dlciBlcnJvciBldmVudFxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2Vycm9yJywgZXguY29kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfbG9hZEZyb21JbWFnZShpbWcsIGV4YWN0KSB7XG5cdFx0XHR2YXIgcnVudGltZSA9IHRoaXMuY29ubmVjdFJ1bnRpbWUoaW1nLnJ1aWQpO1xuXHRcdFx0dGhpcy5ydWlkID0gcnVudGltZS51aWQ7XG5cdFx0XHRydW50aW1lLmV4ZWMuY2FsbCh0aGlzLCAnSW1hZ2UnLCAnbG9hZEZyb21JbWFnZScsIGltZywgKEJhc2ljLnR5cGVPZihleGFjdCkgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGV4YWN0KSk7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfbG9hZEZyb21CbG9iKGJsb2IsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0c2VsZi5uYW1lID0gYmxvYi5uYW1lIHx8ICcnO1xuXG5cdFx0XHRmdW5jdGlvbiBleGVjKHJ1bnRpbWUpIHtcblx0XHRcdFx0c2VsZi5ydWlkID0gcnVudGltZS51aWQ7XG5cdFx0XHRcdHJ1bnRpbWUuZXhlYy5jYWxsKHNlbGYsICdJbWFnZScsICdsb2FkRnJvbUJsb2InLCBibG9iKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJsb2IuaXNEZXRhY2hlZCgpKSB7XG5cdFx0XHRcdHRoaXMuYmluZCgnUnVudGltZUluaXQnLCBmdW5jdGlvbihlLCBydW50aW1lKSB7XG5cdFx0XHRcdFx0ZXhlYyhydW50aW1lKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gY29udmVydCB0byBvYmplY3QgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0aWYgKG9wdGlvbnMgJiYgdHlwZW9mKG9wdGlvbnMucmVxdWlyZWRfY2FwcykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5yZXF1aXJlZF9jYXBzID0gUnVudGltZS5wYXJzZUNhcHMob3B0aW9ucy5yZXF1aXJlZF9jYXBzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuY29ubmVjdFJ1bnRpbWUoQmFzaWMuZXh0ZW5kKHtcblx0XHRcdFx0XHRyZXF1aXJlZF9jYXBzOiB7XG5cdFx0XHRcdFx0XHRhY2Nlc3NfaW1hZ2VfYmluYXJ5OiB0cnVlLFxuXHRcdFx0XHRcdFx0cmVzaXplX2ltYWdlOiB0cnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCBvcHRpb25zKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleGVjKHRoaXMuY29ubmVjdFJ1bnRpbWUoYmxvYi5ydWlkKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfbG9hZEZyb21VcmwodXJsLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHhocjtcblxuXHRcdFx0eGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdHhoci5vcGVuKCdnZXQnLCB1cmwpO1xuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcblxuXHRcdFx0eGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcihlKTtcblx0XHRcdH07XG5cblx0XHRcdHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0X2xvYWRGcm9tQmxvYi5jYWxsKHNlbGYsIHhoci5yZXNwb25zZSwgdHJ1ZSk7XG5cdFx0XHR9O1xuXG5cdFx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKGUpO1xuXHRcdFx0fTtcblxuXHRcdFx0eGhyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR4aHIuZGVzdHJveSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0eGhyLmJpbmQoJ1J1bnRpbWVFcnJvcicsIGZ1bmN0aW9uKGUsIGVycikge1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ1J1bnRpbWVFcnJvcicsIGVycik7XG5cdFx0XHR9KTtcblxuXHRcdFx0eGhyLnNlbmQobnVsbCwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gdmlydHVhbCB3b3JsZCB3aWxsIGNyYXNoIG9uIHlvdSBpZiBpbWFnZSBoYXMgYSByZXNvbHV0aW9uIGhpZ2hlciB0aGFuIHRoaXM6XG5cdEltYWdlLk1BWF9SRVNJWkVfV0lEVEggPSA4MTkyO1xuXHRJbWFnZS5NQVhfUkVTSVpFX0hFSUdIVCA9IDgxOTI7IFxuXG5cdEltYWdlLnByb3RvdHlwZSA9IEV2ZW50VGFyZ2V0Lmluc3RhbmNlO1xuXG5cdHJldHVybiBJbWFnZTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L1J1bnRpbWUuanNcblxuLyoqXG4gKiBSdW50aW1lLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qZ2xvYmFsIEZpbGU6dHJ1ZSAqL1xuXG4vKipcbkRlZmluZXMgY29uc3RydWN0b3IgZm9yIEhUTUw1IHJ1bnRpbWUuXG5cbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw1L1J1bnRpbWVcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9SdW50aW1lXCIsIFtcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvcnVudGltZS9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbnZcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIHgsIFJ1bnRpbWUsIEVudikge1xuXHRcblx0dmFyIHR5cGUgPSBcImh0bWw1XCIsIGV4dGVuc2lvbnMgPSB7fTtcblx0XG5cdGZ1bmN0aW9uIEh0bWw1UnVudGltZShvcHRpb25zKSB7XG5cdFx0dmFyIEkgPSB0aGlzXG5cdFx0LCBUZXN0ID0gUnVudGltZS5jYXBUZXN0XG5cdFx0LCBUcnVlID0gUnVudGltZS5jYXBUcnVlXG5cdFx0O1xuXG5cdFx0dmFyIGNhcHMgPSBCYXNpYy5leHRlbmQoe1xuXHRcdFx0XHRhY2Nlc3NfYmluYXJ5OiBUZXN0KHdpbmRvdy5GaWxlUmVhZGVyIHx8IHdpbmRvdy5GaWxlICYmIHdpbmRvdy5GaWxlLmdldEFzRGF0YVVSTCksXG5cdFx0XHRcdGFjY2Vzc19pbWFnZV9iaW5hcnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBJLmNhbignYWNjZXNzX2JpbmFyeScpICYmICEhZXh0ZW5zaW9ucy5JbWFnZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGlzcGxheV9tZWRpYTogVGVzdChcblx0XHRcdFx0XHQoRW52LmNhbignY3JlYXRlX2NhbnZhcycpIHx8IEVudi5jYW4oJ3VzZV9kYXRhX3VyaV9vdmVyMzJrYicpKSAmJiBcblx0XHRcdFx0XHRkZWZpbmVkKCdtb3hpZS9pbWFnZS9JbWFnZScpXG5cdFx0XHRcdCksXG5cdFx0XHRcdGRvX2NvcnM6IFRlc3Qod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKSxcblx0XHRcdFx0ZHJhZ19hbmRfZHJvcDogVGVzdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyB0aGlzIGNvbWVzIGRpcmVjdGx5IGZyb20gTW9kZXJuaXpyOiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vXG5cdFx0XHRcdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHRcdC8vIElFIGhhcyBzdXBwb3J0IGZvciBkcmFnIGFuZCBkcm9wIHNpbmNlIHZlcnNpb24gNSwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCBkcm9wcGluZyBmaWxlcyBmcm9tIGRlc2t0b3Bcblx0XHRcdFx0XHRyZXR1cm4gKCgnZHJhZ2dhYmxlJyBpbiBkaXYpIHx8ICgnb25kcmFnc3RhcnQnIGluIGRpdiAmJiAnb25kcm9wJyBpbiBkaXYpKSAmJiBcblx0XHRcdFx0XHRcdChFbnYuYnJvd3NlciAhPT0gJ0lFJyB8fCBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgOSwgJz4nKSk7XG5cdFx0XHRcdH0oKSksXG5cdFx0XHRcdGZpbHRlcl9ieV9leHRlbnNpb246IFRlc3QoZnVuY3Rpb24oKSB7IC8vIGlmIHlvdSBrbm93IGhvdyB0byBmZWF0dXJlLWRldGVjdCB0aGlzLCBwbGVhc2Ugc3VnZ2VzdFxuXHRcdFx0XHRcdHJldHVybiAhKFxuXHRcdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnQ2hyb21lJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMjgsICc8JykpIHx8IFxuXHRcdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnSUUnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAxMCwgJzwnKSkgfHwgXG5cdFx0XHRcdFx0XHQoRW52LmJyb3dzZXIgPT09ICdTYWZhcmknICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCA3LCAnPCcpKSB8fFxuXHRcdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnRmlyZWZveCcgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDM3LCAnPCcpKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0oKSksXG5cdFx0XHRcdHJldHVybl9yZXNwb25zZV9oZWFkZXJzOiBUcnVlLFxuXHRcdFx0XHRyZXR1cm5fcmVzcG9uc2VfdHlwZTogZnVuY3Rpb24ocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmICEhd2luZG93LkpTT04pIHsgLy8gd2UgY2FuIGZha2UgdGhpcyBvbmUgZXZlbiBpZiBpdCdzIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0cmV0dXJuIEVudi5jYW4oJ3JldHVybl9yZXNwb25zZV90eXBlJywgcmVzcG9uc2VUeXBlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmV0dXJuX3N0YXR1c19jb2RlOiBUcnVlLFxuXHRcdFx0XHRyZXBvcnRfdXBsb2FkX3Byb2dyZXNzOiBUZXN0KHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiBuZXcgWE1MSHR0cFJlcXVlc3QoKS51cGxvYWQpLFxuXHRcdFx0XHRyZXNpemVfaW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBJLmNhbignYWNjZXNzX2JpbmFyeScpICYmIEVudi5jYW4oJ2NyZWF0ZV9jYW52YXMnKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0X2ZpbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBFbnYuY2FuKCd1c2VfZmlsZWlucHV0JykgJiYgd2luZG93LkZpbGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdF9mb2xkZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBJLmNhbignc2VsZWN0X2ZpbGUnKSAmJiAoXG5cdFx0XHRcdFx0XHRFbnYuYnJvd3NlciA9PT0gJ0Nocm9tZScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDIxLCAnPj0nKSB8fFxuXHRcdFx0XHRcdFx0RW52LmJyb3dzZXIgPT09ICdGaXJlZm94JyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgNDIsICc+PScpIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0ZpcmVmb3gvUmVsZWFzZXMvNDJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RfbXVsdGlwbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIGl0IGlzIGJ1Z2d5IG9uIFNhZmFyaSBXaW5kb3dzIGFuZCBpT1Ncblx0XHRcdFx0XHRyZXR1cm4gSS5jYW4oJ3NlbGVjdF9maWxlJykgJiZcblx0XHRcdFx0XHRcdCEoRW52LmJyb3dzZXIgPT09ICdTYWZhcmknICYmIEVudi5vcyA9PT0gJ1dpbmRvd3MnKSAmJlxuXHRcdFx0XHRcdFx0IShFbnYub3MgPT09ICdpT1MnICYmIEVudi52ZXJDb21wKEVudi5vc1ZlcnNpb24sIFwiNy4wLjBcIiwgJz4nKSAmJiBFbnYudmVyQ29tcChFbnYub3NWZXJzaW9uLCBcIjguMC4wXCIsICc8JykpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZW5kX2JpbmFyeV9zdHJpbmc6IFRlc3Qod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmIChuZXcgWE1MSHR0cFJlcXVlc3QoKS5zZW5kQXNCaW5hcnkgfHwgKHdpbmRvdy5VaW50OEFycmF5ICYmIHdpbmRvdy5BcnJheUJ1ZmZlcikpKSxcblx0XHRcdFx0c2VuZF9jdXN0b21faGVhZGVyczogVGVzdCh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpLFxuXHRcdFx0XHRzZW5kX211bHRpcGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiBuZXcgWE1MSHR0cFJlcXVlc3QoKS51cGxvYWQgJiYgd2luZG93LkZvcm1EYXRhKSB8fCBJLmNhbignc2VuZF9iaW5hcnlfc3RyaW5nJyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNsaWNlX2Jsb2I6IFRlc3Qod2luZG93LkZpbGUgJiYgKEZpbGUucHJvdG90eXBlLm1velNsaWNlIHx8IEZpbGUucHJvdG90eXBlLndlYmtpdFNsaWNlIHx8IEZpbGUucHJvdG90eXBlLnNsaWNlKSksXG5cdFx0XHRcdHN0cmVhbV91cGxvYWQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cmV0dXJuIEkuY2FuKCdzbGljZV9ibG9iJykgJiYgSS5jYW4oJ3NlbmRfbXVsdGlwYXJ0Jyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1bW1vbl9maWxlX2RpYWxvZzogZnVuY3Rpb24oKSB7IC8vIHllYWguLi4gc29tZSBkaXJ0eSBzbmlmZmluZyBoZXJlLi4uXG5cdFx0XHRcdFx0cmV0dXJuIEkuY2FuKCdzZWxlY3RfZmlsZScpICYmIChcblx0XHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0ZpcmVmb3gnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCA0LCAnPj0nKSkgfHxcblx0XHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ09wZXJhJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMTIsICc+PScpKSB8fFxuXHRcdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnSUUnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAxMCwgJz49JykpIHx8XG5cdFx0XHRcdFx0XHQhIX5CYXNpYy5pbkFycmF5KEVudi5icm93c2VyLCBbJ0Nocm9tZScsICdTYWZhcmknLCAnRWRnZSddKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVwbG9hZF9maWxlc2l6ZTogVHJ1ZSxcblx0XHRcdFx0dXNlX2h0dHBfbWV0aG9kOiBUcnVlXG5cdFx0XHR9LCBcblx0XHRcdGFyZ3VtZW50c1syXVxuXHRcdCk7XG5cblx0XHRSdW50aW1lLmNhbGwodGhpcywgb3B0aW9ucywgKGFyZ3VtZW50c1sxXSB8fCB0eXBlKSwgY2Fwcyk7XG5cblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cblx0XHRcdGluaXQgOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiSW5pdFwiKTtcblx0XHRcdH0sXG5cblx0XHRcdGRlc3Ryb3k6IChmdW5jdGlvbihkZXN0cm95KSB7IC8vIGV4dGVuZCBkZWZhdWx0IGRlc3Ryb3kgbWV0aG9kXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZXN0cm95LmNhbGwoSSk7XG5cdFx0XHRcdFx0ZGVzdHJveSA9IEkgPSBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSh0aGlzLmRlc3Ryb3kpKVxuXHRcdH0pO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMuZ2V0U2hpbSgpLCBleHRlbnNpb25zKTtcblx0fVxuXG5cdFJ1bnRpbWUuYWRkQ29uc3RydWN0b3IodHlwZSwgSHRtbDVSdW50aW1lKTtcblxuXHRyZXR1cm4gZXh0ZW5zaW9ucztcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ZpbGUvQmxvYi5qc1xuXG4vKipcbiAqIEJsb2IuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9maWxlL0Jsb2JcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9maWxlL0Jsb2JcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvUnVudGltZVwiLFxuXHRcIm1veGllL2ZpbGUvQmxvYlwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCbG9iKSB7XG5cblx0ZnVuY3Rpb24gSFRNTDVCbG9iKCkge1xuXHRcdGZ1bmN0aW9uIHczY0Jsb2JTbGljZShibG9iLCBzdGFydCwgZW5kKSB7XG5cdFx0XHR2YXIgYmxvYlNsaWNlO1xuXG5cdFx0XHRpZiAod2luZG93LkZpbGUucHJvdG90eXBlLnNsaWNlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YmxvYi5zbGljZSgpO1x0Ly8gZGVwcmljYXRlZCB2ZXJzaW9uIHdpbGwgdGhyb3cgV1JPTkdfQVJHVU1FTlRTX0VSUiBleGNlcHRpb25cblx0XHRcdFx0XHRyZXR1cm4gYmxvYi5zbGljZShzdGFydCwgZW5kKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdC8vIGRlcHJpY2F0ZWQgc2xpY2UgbWV0aG9kXG5cdFx0XHRcdFx0cmV0dXJuIGJsb2Iuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHRcdFx0fVxuXHRcdFx0Ly8gc2xpY2UgbWV0aG9kIGdvdCBwcmVmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5NjcyXG5cdFx0XHR9IGVsc2UgaWYgKChibG9iU2xpY2UgPSB3aW5kb3cuRmlsZS5wcm90b3R5cGUud2Via2l0U2xpY2UgfHwgd2luZG93LkZpbGUucHJvdG90eXBlLm1velNsaWNlKSkge1xuXHRcdFx0XHRyZXR1cm4gYmxvYlNsaWNlLmNhbGwoYmxvYiwgc3RhcnQsIGVuZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDsgLy8gb3IgdGhyb3cgc29tZSBleGNlcHRpb25cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNsaWNlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJsb2IodGhpcy5nZXRSdW50aW1lKCkudWlkLCB3M2NCbG9iU2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5CbG9iID0gSFRNTDVCbG9iKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9jb3JlL3V0aWxzL0V2ZW50cy5qc1xuXG4vKipcbiAqIEV2ZW50cy5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG5kZWZpbmUoJ21veGllL2NvcmUvdXRpbHMvRXZlbnRzJywgW1xuXHQnbW94aWUvY29yZS91dGlscy9CYXNpYydcbl0sIGZ1bmN0aW9uKEJhc2ljKSB7XG5cdHZhciBldmVudGhhc2ggPSB7fSwgdWlkID0gJ21veGllXycgKyBCYXNpYy5ndWlkKCk7XG5cdFxuXHQvLyBJRSBXM0MgbGlrZSBldmVudCBmdW5jc1xuXHRmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcblx0XHR0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG5cdFx0dGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgc3BlY2lmaWVkIG9iamVjdCBhbmQgc3RvcmUgcmVmZXJlbmNlIHRvIHRoZSBoYW5kbGVyXG5cdGluIG9iamVjdHMgaW50ZXJuYWwgUGx1cGxvYWQgcmVnaXN0cnkgKEBzZWUgcmVtb3ZlRXZlbnQpLlxuXHRcblx0QG1ldGhvZCBhZGRFdmVudFxuXHRAZm9yIFV0aWxzXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG9iaiBET00gZWxlbWVudCBsaWtlIG9iamVjdCB0byBhZGQgaGFuZGxlciB0by5cblx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG8uXG5cdEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVudCBvY2N1cnMuXG5cdEBwYXJhbSB7U3RyaW5nfSBba2V5XSB0aGF0IG1pZ2h0IGJlIHVzZWQgdG8gYWRkIHNwZWNpZml0eSB0byB0aGUgZXZlbnQgcmVjb3JkLlxuXHQqL1xuXHR2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrLCBrZXkpIHtcblx0XHR2YXIgZnVuYywgZXZlbnRzO1xuXHRcdFx0XHRcdFxuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBBZGQgZXZlbnQgbGlzdGVuZXJcblx0XHRpZiAob2JqLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdGZ1bmMgPSBjYWxsYmFjaztcblx0XHRcdFxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZiAob2JqLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRmdW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBldnQgPSB3aW5kb3cuZXZlbnQ7XG5cblx0XHRcdFx0aWYgKCFldnQudGFyZ2V0KSB7XG5cdFx0XHRcdFx0ZXZ0LnRhcmdldCA9IGV2dC5zcmNFbGVtZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZXZ0LnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG5cdFx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG5cblx0XHRcdFx0Y2FsbGJhY2soZXZ0KTtcblx0XHRcdH07XG5cblx0XHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgZnVuYyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIExvZyBldmVudCBoYW5kbGVyIHRvIG9iamVjdHMgaW50ZXJuYWwgbU94aWUgcmVnaXN0cnlcblx0XHRpZiAoIW9ialt1aWRdKSB7XG5cdFx0XHRvYmpbdWlkXSA9IEJhc2ljLmd1aWQoKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCFldmVudGhhc2guaGFzT3duUHJvcGVydHkob2JqW3VpZF0pKSB7XG5cdFx0XHRldmVudGhhc2hbb2JqW3VpZF1dID0ge307XG5cdFx0fVxuXHRcdFxuXHRcdGV2ZW50cyA9IGV2ZW50aGFzaFtvYmpbdWlkXV07XG5cdFx0XG5cdFx0aWYgKCFldmVudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdGV2ZW50c1tuYW1lXSA9IFtdO1xuXHRcdH1cblx0XHRcdFx0XG5cdFx0ZXZlbnRzW25hbWVdLnB1c2goe1xuXHRcdFx0ZnVuYzogZnVuYyxcblx0XHRcdG9yaWc6IGNhbGxiYWNrLCAvLyBzdG9yZSBvcmlnaW5hbCBjYWxsYmFjayBmb3IgSUVcblx0XHRcdGtleToga2V5XG5cdFx0fSk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdFJlbW92ZSBldmVudCBoYW5kbGVyIGZyb20gdGhlIHNwZWNpZmllZCBvYmplY3QuIElmIHRoaXJkIGFyZ3VtZW50IChjYWxsYmFjaylcblx0aXMgbm90IHNwZWNpZmllZCByZW1vdmUgYWxsIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cblx0XG5cdEBtZXRob2QgcmVtb3ZlRXZlbnRcblx0QHN0YXRpY1xuXHRAcGFyYW0ge09iamVjdH0gb2JqIERPTSBlbGVtZW50IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcihzKSBmcm9tLlxuXHRAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIGV2ZW50IGxpc3RlbmVyIHRvIHJlbW92ZS5cblx0QHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IFtjYWxsYmFja10gbWlnaHQgYmUgYSBjYWxsYmFjayBvciB1bmlxdWUga2V5IHRvIG1hdGNoLlxuXHQqL1xuXHR2YXIgcmVtb3ZlRXZlbnQgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHR5cGUsIHVuZGVmO1xuXHRcdFxuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XG5cdFx0aWYgKG9ialt1aWRdICYmIGV2ZW50aGFzaFtvYmpbdWlkXV0gJiYgZXZlbnRoYXNoW29ialt1aWRdXVtuYW1lXSkge1xuXHRcdFx0dHlwZSA9IGV2ZW50aGFzaFtvYmpbdWlkXV1bbmFtZV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XHRcblx0XHRmb3IgKHZhciBpID0gdHlwZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Ly8gdW5kZWZpbmVkIG9yIG5vdCwga2V5IHNob3VsZCBtYXRjaFxuXHRcdFx0aWYgKHR5cGVbaV0ub3JpZyA9PT0gY2FsbGJhY2sgfHwgdHlwZVtpXS5rZXkgPT09IGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmIChvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHR5cGVbaV0uZnVuYywgZmFsc2UpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9iai5kZXRhY2hFdmVudCkge1xuXHRcdFx0XHRcdG9iai5kZXRhY2hFdmVudCgnb24nK25hbWUsIHR5cGVbaV0uZnVuYyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHR5cGVbaV0ub3JpZyA9IG51bGw7XG5cdFx0XHRcdHR5cGVbaV0uZnVuYyA9IG51bGw7XG5cdFx0XHRcdHR5cGUuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgY2FsbGJhY2sgd2FzIHBhc3NlZCB3ZSBhcmUgZG9uZSBoZXJlLCBvdGhlcndpc2UgcHJvY2VlZFxuXHRcdFx0XHRpZiAoY2FsbGJhY2sgIT09IHVuZGVmKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gSWYgZXZlbnQgYXJyYXkgZ290IGVtcHR5LCByZW1vdmUgaXRcblx0XHRpZiAoIXR5cGUubGVuZ3RoKSB7XG5cdFx0XHRkZWxldGUgZXZlbnRoYXNoW29ialt1aWRdXVtuYW1lXTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gSWYgbU94aWUgcmVnaXN0cnkgaGFzIGJlY29tZSBlbXB0eSwgcmVtb3ZlIGl0XG5cdFx0aWYgKEJhc2ljLmlzRW1wdHlPYmooZXZlbnRoYXNoW29ialt1aWRdXSkpIHtcblx0XHRcdGRlbGV0ZSBldmVudGhhc2hbb2JqW3VpZF1dO1xuXHRcdFx0XG5cdFx0XHQvLyBJRSBkb2Vzbid0IGxldCB5b3UgcmVtb3ZlIERPTSBvYmplY3QgcHJvcGVydHkgd2l0aCAtIGRlbGV0ZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVsZXRlIG9ialt1aWRdO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdG9ialt1aWRdID0gdW5kZWY7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHRSZW1vdmUgYWxsIGtpbmQgb2YgZXZlbnRzIGZyb20gdGhlIHNwZWNpZmllZCBvYmplY3Rcblx0XG5cdEBtZXRob2QgcmVtb3ZlQWxsRXZlbnRzXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtPYmplY3R9IG9iaiBET00gZWxlbWVudCB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZyb20uXG5cdEBwYXJhbSB7U3RyaW5nfSBba2V5XSB1bmlxdWUga2V5IHRvIG1hdGNoLCB3aGVuIHJlbW92aW5nIGV2ZW50cy5cblx0Ki9cblx0dmFyIHJlbW92ZUFsbEV2ZW50cyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XHRcdFxuXHRcdGlmICghb2JqIHx8ICFvYmpbdWlkXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHRCYXNpYy5lYWNoKGV2ZW50aGFzaFtvYmpbdWlkXV0sIGZ1bmN0aW9uKGV2ZW50cywgbmFtZSkge1xuXHRcdFx0cmVtb3ZlRXZlbnQob2JqLCBuYW1lLCBrZXkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0YWRkRXZlbnQ6IGFkZEV2ZW50LFxuXHRcdHJlbW92ZUV2ZW50OiByZW1vdmVFdmVudCxcblx0XHRyZW1vdmVBbGxFdmVudHM6IHJlbW92ZUFsbEV2ZW50c1xuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDUvZmlsZS9GaWxlSW5wdXQuanNcblxuLyoqXG4gKiBGaWxlSW5wdXQuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9maWxlL0ZpbGVJbnB1dFxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw1L2ZpbGUvRmlsZUlucHV0XCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L1J1bnRpbWVcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9Eb21cIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0V2ZW50c1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvTWltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEZpbGUsIEJhc2ljLCBEb20sIEV2ZW50cywgTWltZSwgRW52KSB7XG5cdFxuXHRmdW5jdGlvbiBGaWxlSW5wdXQoKSB7XG5cdFx0dmFyIF9vcHRpb25zLCBfYnJvd3NlQnRuWkluZGV4OyAvLyBzYXZlIG9yaWdpbmFsIHotaW5kZXhcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBjb21wID0gdGhpcywgSSA9IGNvbXAuZ2V0UnVudGltZSgpLCBpbnB1dCwgc2hpbUNvbnRhaW5lciwgbWltZXMsIGJyb3dzZUJ1dHRvbiwgekluZGV4LCB0b3A7XG5cblx0XHRcdFx0X29wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0XHRcdC8vIGZpZ3VyZSBvdXQgYWNjZXB0IHN0cmluZ1xuXHRcdFx0XHRtaW1lcyA9IF9vcHRpb25zLmFjY2VwdC5taW1lcyB8fCBNaW1lLmV4dExpc3QybWltZXMoX29wdGlvbnMuYWNjZXB0LCBJLmNhbignZmlsdGVyX2J5X2V4dGVuc2lvbicpKTtcblxuXHRcdFx0XHRzaGltQ29udGFpbmVyID0gSS5nZXRTaGltQ29udGFpbmVyKCk7XG5cblx0XHRcdFx0c2hpbUNvbnRhaW5lci5pbm5lckhUTUwgPSAnPGlucHV0IGlkPVwiJyArIEkudWlkICsnXCIgdHlwZT1cImZpbGVcIiBzdHlsZT1cImZvbnQtc2l6ZTo5OTlweDtvcGFjaXR5OjA7XCInICtcblx0XHRcdFx0XHQoX29wdGlvbnMubXVsdGlwbGUgJiYgSS5jYW4oJ3NlbGVjdF9tdWx0aXBsZScpID8gJ211bHRpcGxlJyA6ICcnKSArIFxuXHRcdFx0XHRcdChfb3B0aW9ucy5kaXJlY3RvcnkgJiYgSS5jYW4oJ3NlbGVjdF9mb2xkZXInKSA/ICd3ZWJraXRkaXJlY3RvcnkgZGlyZWN0b3J5JyA6ICcnKSArIC8vIENocm9tZSAxMStcblx0XHRcdFx0XHQobWltZXMgPyAnIGFjY2VwdD1cIicgKyBtaW1lcy5qb2luKCcsJykgKyAnXCInIDogJycpICsgJyAvPic7XG5cblx0XHRcdFx0aW5wdXQgPSBEb20uZ2V0KEkudWlkKTtcblxuXHRcdFx0XHQvLyBwcmVwYXJlIGZpbGUgaW5wdXQgdG8gYmUgcGxhY2VkIHVuZGVybmVhdGggdGhlIGJyb3dzZV9idXR0b24gZWxlbWVudFxuXHRcdFx0XHRCYXNpYy5leHRlbmQoaW5wdXQuc3R5bGUsIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0XHRcdGhlaWdodDogJzEwMCUnXG5cdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0YnJvd3NlQnV0dG9uID0gRG9tLmdldChfb3B0aW9ucy5icm93c2VfYnV0dG9uKTtcblx0XHRcdFx0X2Jyb3dzZUJ0blpJbmRleCA9IERvbS5nZXRTdHlsZShicm93c2VCdXR0b24sICd6LWluZGV4JykgfHwgJ2F1dG8nO1xuXG5cdFx0XHRcdC8vIFJvdXRlIGNsaWNrIGV2ZW50IHRvIHRoZSBpbnB1dFt0eXBlPWZpbGVdIGVsZW1lbnQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBzdWNoIGJlaGF2aW9yXG5cdFx0XHRcdGlmIChJLmNhbignc3VtbW9uX2ZpbGVfZGlhbG9nJykpIHtcblx0XHRcdFx0XHRpZiAoRG9tLmdldFN0eWxlKGJyb3dzZUJ1dHRvbiwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG5cdFx0XHRcdFx0XHRicm93c2VCdXR0b24uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdEV2ZW50cy5hZGRFdmVudChicm93c2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdHZhciBpbnB1dCA9IERvbS5nZXQoSS51aWQpO1xuXHRcdFx0XHRcdFx0aWYgKGlucHV0ICYmICFpbnB1dC5kaXNhYmxlZCkgeyAvLyBmb3Igc29tZSByZWFzb24gRkYgKHVwIHRvIDguMC4xIHNvIGZhcikgbGV0cyB0byBjbGljayBkaXNhYmxlZCBpbnB1dFt0eXBlPWZpbGVdXG5cdFx0XHRcdFx0XHRcdGlucHV0LmNsaWNrKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRcdFx0Y29tcC5iaW5kKCdSZWZyZXNoJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR6SW5kZXggPSBwYXJzZUludChfYnJvd3NlQnRuWkluZGV4LCAxMCkgfHwgMTtcblxuXHRcdFx0XHRcdFx0RG9tLmdldChfb3B0aW9ucy5icm93c2VfYnV0dG9uKS5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG5cdFx0XHRcdFx0XHR0aGlzLmdldFJ1bnRpbWUoKS5nZXRTaGltQ29udGFpbmVyKCkuc3R5bGUuekluZGV4ID0gekluZGV4IC0gMTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIFNpbmNlIHdlIGhhdmUgdG8gcGxhY2UgaW5wdXRbdHlwZT1maWxlXSBvbiB0b3Agb2YgdGhlIGJyb3dzZV9idXR0b24gZm9yIHNvbWUgYnJvd3NlcnMsXG5cdFx0XHRcdGJyb3dzZV9idXR0b24gbG9zZXMgaW50ZXJhY3Rpdml0eSwgc28gd2UgcmVzdG9yZSBpdCBoZXJlICovXG5cdFx0XHRcdHRvcCA9IEkuY2FuKCdzdW1tb25fZmlsZV9kaWFsb2cnKSA/IGJyb3dzZUJ1dHRvbiA6IHNoaW1Db250YWluZXI7XG5cblx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KHRvcCwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbXAudHJpZ2dlcignbW91c2VlbnRlcicpO1xuXHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KHRvcCwgJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdtb3VzZWxlYXZlJyk7XG5cdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRFdmVudHMuYWRkRXZlbnQodG9wLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdtb3VzZWRvd24nKTtcblx0XHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRcdEV2ZW50cy5hZGRFdmVudChEb20uZ2V0KF9vcHRpb25zLmNvbnRhaW5lciksICdtb3VzZXVwJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdtb3VzZXVwJyk7XG5cdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXG5cdFx0XHRcdGlucHV0Lm9uY2hhbmdlID0gZnVuY3Rpb24gb25DaGFuZ2UoZSkgeyAvLyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgaGFuZGxlciBmb3IgdGhpc1xuXHRcdFx0XHRcdGNvbXAuZmlsZXMgPSBbXTtcblxuXHRcdFx0XHRcdEJhc2ljLmVhY2godGhpcy5maWxlcywgZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRcdFx0dmFyIHJlbGF0aXZlUGF0aCA9ICcnO1xuXG5cdFx0XHRcdFx0XHRpZiAoX29wdGlvbnMuZGlyZWN0b3J5KSB7XG5cdFx0XHRcdFx0XHRcdC8vIGZvbGRlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IGRvdHMsIGZpbHRlciB0aGVtIG91dCAoQ2hyb21lIDExKylcblx0XHRcdFx0XHRcdFx0aWYgKGZpbGUubmFtZSA9PSBcIi5cIikge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIGl0IGxvb2tzIGxpa2UgYSBmb2xkZXIuLi5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGgpIHtcblx0XHRcdFx0XHRcdFx0cmVsYXRpdmVQYXRoID0gJy8nICsgZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGgucmVwbGFjZSgvXlxcLy8sICcnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ZmlsZSA9IG5ldyBGaWxlKEkudWlkLCBmaWxlKTtcblx0XHRcdFx0XHRcdGZpbGUucmVsYXRpdmVQYXRoID0gcmVsYXRpdmVQYXRoO1xuXG5cdFx0XHRcdFx0XHRjb21wLmZpbGVzLnB1c2goZmlsZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBjbGVhcmluZyB0aGUgdmFsdWUgZW5hYmxlcyB0aGUgdXNlciB0byBzZWxlY3QgdGhlIHNhbWUgZmlsZSBhZ2FpbiBpZiB0aGV5IHdhbnQgdG9cblx0XHRcdFx0XHRpZiAoRW52LmJyb3dzZXIgIT09ICdJRScgJiYgRW52LmJyb3dzZXIgIT09ICdJRU1vYmlsZScpIHtcblx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSAnJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gaW4gSUUgaW5wdXRbdHlwZT1cImZpbGVcIl0gaXMgcmVhZC1vbmx5IHNvIHRoZSBvbmx5IHdheSB0byByZXNldCBpdCBpcyB0byByZS1pbnNlcnQgaXRcblx0XHRcdFx0XHRcdHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpO1xuXHRcdFx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZSwgdGhpcyk7XG5cdFx0XHRcdFx0XHRjbG9uZS5vbmNoYW5nZSA9IG9uQ2hhbmdlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChjb21wLmZpbGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gcmVhZHkgZXZlbnQgaXMgcGVyZmVjdGx5IGFzeW5jaHJvbm91c1xuXHRcdFx0XHRjb21wLnRyaWdnZXIoe1xuXHRcdFx0XHRcdHR5cGU6ICdyZWFkeScsXG5cdFx0XHRcdFx0YXN5bmM6IHRydWVcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2hpbUNvbnRhaW5lciA9IG51bGw7XG5cdFx0XHR9LFxuXG5cblx0XHRcdHNldE9wdGlvbjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHRcdFx0dmFyIEkgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblx0XHRcdFx0dmFyIGlucHV0ID0gRG9tLmdldChJLnVpZCk7XG5cblx0XHRcdFx0c3dpdGNoIChuYW1lKSB7XG5cdFx0XHRcdFx0Y2FzZSAnYWNjZXB0Jzpcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbWltZXMgPSB2YWx1ZS5taW1lcyB8fCBNaW1lLmV4dExpc3QybWltZXModmFsdWUsIEkuY2FuKCdmaWx0ZXJfYnlfZXh0ZW5zaW9uJykpO1xuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsIG1pbWVzLmpvaW4oJywnKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FjY2VwdCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdkaXJlY3RvcnknOlxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIEkuY2FuKCdzZWxlY3RfZm9sZGVyJykpIHtcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCdkaXJlY3RvcnknLCAnJyk7XG5cdFx0XHRcdFx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSgnd2Via2l0ZGlyZWN0b3J5JywgJycpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKCdkaXJlY3RvcnknKTtcblx0XHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKCd3ZWJraXRkaXJlY3RvcnknKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbXVsdGlwbGUnOlxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIEkuY2FuKCdzZWxlY3RfbXVsdGlwbGUnKSkge1xuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJycpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKCdtdWx0aXBsZScpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblxuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRcdFx0dmFyIEkgPSB0aGlzLmdldFJ1bnRpbWUoKSwgaW5wdXQ7XG5cblx0XHRcdFx0aWYgKChpbnB1dCA9IERvbS5nZXQoSS51aWQpKSkge1xuXHRcdFx0XHRcdGlucHV0LmRpc2FibGVkID0gISFzdGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBJID0gdGhpcy5nZXRSdW50aW1lKClcblx0XHRcdFx0LCBzaGltID0gSS5nZXRTaGltKClcblx0XHRcdFx0LCBzaGltQ29udGFpbmVyID0gSS5nZXRTaGltQ29udGFpbmVyKClcblx0XHRcdFx0LCBjb250YWluZXIgPSBfb3B0aW9ucyAmJiBEb20uZ2V0KF9vcHRpb25zLmNvbnRhaW5lcilcblx0XHRcdFx0LCBicm93c2VCdXR0b24gPSBfb3B0aW9ucyAmJiBEb20uZ2V0KF9vcHRpb25zLmJyb3dzZV9idXR0b24pXG5cdFx0XHRcdDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdFx0XHRFdmVudHMucmVtb3ZlQWxsRXZlbnRzKGNvbnRhaW5lciwgdGhpcy51aWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYnJvd3NlQnV0dG9uKSB7XG5cdFx0XHRcdFx0RXZlbnRzLnJlbW92ZUFsbEV2ZW50cyhicm93c2VCdXR0b24sIHRoaXMudWlkKTtcblx0XHRcdFx0XHRicm93c2VCdXR0b24uc3R5bGUuekluZGV4ID0gX2Jyb3dzZUJ0blpJbmRleDsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgdmFsdWVcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNoaW1Db250YWluZXIpIHtcblx0XHRcdFx0XHRFdmVudHMucmVtb3ZlQWxsRXZlbnRzKHNoaW1Db250YWluZXIsIHRoaXMudWlkKTtcblx0XHRcdFx0XHRzaGltQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2hpbS5yZW1vdmVJbnN0YW5jZSh0aGlzLnVpZCk7XG5cblx0XHRcdFx0X29wdGlvbnMgPSBzaGltQ29udGFpbmVyID0gY29udGFpbmVyID0gYnJvd3NlQnV0dG9uID0gc2hpbSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZUlucHV0ID0gRmlsZUlucHV0KTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ZpbGUvRmlsZURyb3AuanNcblxuLyoqXG4gKiBGaWxlRHJvcC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw1L2ZpbGUvRmlsZURyb3BcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9maWxlL0ZpbGVEcm9wXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L1J1bnRpbWVcIixcblx0J21veGllL2ZpbGUvRmlsZScsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRG9tXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FdmVudHNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL01pbWVcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgRmlsZSwgQmFzaWMsIERvbSwgRXZlbnRzLCBNaW1lKSB7XG5cdFxuXHRmdW5jdGlvbiBGaWxlRHJvcCgpIHtcblx0XHR2YXIgX2ZpbGVzID0gW10sIF9hbGxvd2VkRXh0cyA9IFtdLCBfb3B0aW9ucywgX3J1aWQ7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgY29tcCA9IHRoaXMsIGRyb3Bab25lO1xuXG5cdFx0XHRcdF9vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdFx0X3J1aWQgPSBjb21wLnJ1aWQ7IC8vIGV2ZXJ5IGRyb3BwZWQtaW4gZmlsZSBzaG91bGQgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgcnVudGltZVxuXHRcdFx0XHRfYWxsb3dlZEV4dHMgPSBfZXh0cmFjdEV4dHMoX29wdGlvbnMuYWNjZXB0KTtcblx0XHRcdFx0ZHJvcFpvbmUgPSBfb3B0aW9ucy5jb250YWluZXI7XG5cblx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KGRyb3Bab25lLCAnZHJhZ292ZXInLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0aWYgKCFfaGFzRmlsZXMoZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG5cdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoZHJvcFpvbmUsICdkcm9wJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGlmICghX2hhc0ZpbGVzKGUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdF9maWxlcyA9IFtdO1xuXG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDIxKyBhY2NlcHRzIGZvbGRlcnMgdmlhIERyYWcnbidEcm9wXG5cdFx0XHRcdFx0aWYgKGUuZGF0YVRyYW5zZmVyLml0ZW1zICYmIGUuZGF0YVRyYW5zZmVyLml0ZW1zWzBdLndlYmtpdEdldEFzRW50cnkpIHtcblx0XHRcdFx0XHRcdF9yZWFkSXRlbXMoZS5kYXRhVHJhbnNmZXIuaXRlbXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRjb21wLmZpbGVzID0gX2ZpbGVzO1xuXHRcdFx0XHRcdFx0XHRjb21wLnRyaWdnZXIoXCJkcm9wXCIpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdEJhc2ljLmVhY2goZS5kYXRhVHJhbnNmZXIuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRcdFx0X2FkZEZpbGUoZmlsZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGNvbXAuZmlsZXMgPSBfZmlsZXM7XG5cdFx0XHRcdFx0XHRjb21wLnRyaWdnZXIoXCJkcm9wXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRcdEV2ZW50cy5hZGRFdmVudChkcm9wWm9uZSwgJ2RyYWdlbnRlcicsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wLnRyaWdnZXIoXCJkcmFnZW50ZXJcIik7XG5cdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoZHJvcFpvbmUsICdkcmFnbGVhdmUnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKFwiZHJhZ2xlYXZlXCIpO1xuXHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0RXZlbnRzLnJlbW92ZUFsbEV2ZW50cyhfb3B0aW9ucyAmJiBEb20uZ2V0KF9vcHRpb25zLmNvbnRhaW5lciksIHRoaXMudWlkKTtcblx0XHRcdFx0X3J1aWQgPSBfZmlsZXMgPSBfYWxsb3dlZEV4dHMgPSBfb3B0aW9ucyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHRcdGZ1bmN0aW9uIF9oYXNGaWxlcyhlKSB7XG5cdFx0XHRpZiAoIWUuZGF0YVRyYW5zZmVyIHx8ICFlLmRhdGFUcmFuc2Zlci50eXBlcykgeyAvLyBlLmRhdGFUcmFuc2Zlci5maWxlcyBpcyBub3QgYXZhaWxhYmxlIGluIEdlY2tvIGR1cmluZyBkcmFnb3ZlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0eXBlcyA9IEJhc2ljLnRvQXJyYXkoZS5kYXRhVHJhbnNmZXIudHlwZXMgfHwgW10pO1xuXG5cdFx0XHRyZXR1cm4gQmFzaWMuaW5BcnJheShcIkZpbGVzXCIsIHR5cGVzKSAhPT0gLTEgfHxcblx0XHRcdFx0QmFzaWMuaW5BcnJheShcInB1YmxpYy5maWxlLXVybFwiLCB0eXBlcykgIT09IC0xIHx8IC8vIFNhZmFyaSA8IDVcblx0XHRcdFx0QmFzaWMuaW5BcnJheShcImFwcGxpY2F0aW9uL3gtbW96LWZpbGVcIiwgdHlwZXMpICE9PSAtMSAvLyBHZWNrbyA8IDEuOS4yICg8IEZpcmVmb3ggMy42KVxuXHRcdFx0XHQ7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfYWRkRmlsZShmaWxlLCByZWxhdGl2ZVBhdGgpIHtcblx0XHRcdGlmIChfaXNBY2NlcHRhYmxlKGZpbGUpKSB7XG5cdFx0XHRcdHZhciBmaWxlT2JqID0gbmV3IEZpbGUoX3J1aWQsIGZpbGUpO1xuXHRcdFx0XHRmaWxlT2JqLnJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlUGF0aCB8fCAnJztcblx0XHRcdFx0X2ZpbGVzLnB1c2goZmlsZU9iaik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0XG5cdFx0ZnVuY3Rpb24gX2V4dHJhY3RFeHRzKGFjY2VwdCkge1xuXHRcdFx0dmFyIGV4dHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYWNjZXB0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFtdLnB1c2guYXBwbHkoZXh0cywgYWNjZXB0W2ldLmV4dGVuc2lvbnMuc3BsaXQoL1xccyosXFxzKi8pKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBCYXNpYy5pbkFycmF5KCcqJywgZXh0cykgPT09IC0xID8gZXh0cyA6IFtdO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2lzQWNjZXB0YWJsZShmaWxlKSB7XG5cdFx0XHRpZiAoIV9hbGxvd2VkRXh0cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXh0ID0gTWltZS5nZXRGaWxlRXh0ZW5zaW9uKGZpbGUubmFtZSk7XG5cdFx0XHRyZXR1cm4gIWV4dCB8fCBCYXNpYy5pbkFycmF5KGV4dCwgX2FsbG93ZWRFeHRzKSAhPT0gLTE7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfcmVhZEl0ZW1zKGl0ZW1zLCBjYikge1xuXHRcdFx0dmFyIGVudHJpZXMgPSBbXTtcblx0XHRcdEJhc2ljLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG5cdFx0XHRcdC8vIEFkZHJlc3MgIzk5OCAoaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTMzMjU3OSlcblx0XHRcdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRcdFx0Ly8gZmlsZSgpIGZhaWxzIG9uIE9TWCB3aGVuIHRoZSBmaWxlbmFtZSBjb250YWlucyBhIHNwZWNpYWwgY2hhcmFjdGVyIChlLmcuIHVtbGF1dCk6IHNlZSAjNjFcblx0XHRcdFx0XHRpZiAoZW50cnkuaXNGaWxlKSB7XG5cdFx0XHRcdFx0XHRfYWRkRmlsZShpdGVtLmdldEFzRmlsZSgpLCBlbnRyeS5mdWxsUGF0aCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVudHJpZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGVudHJpZXMubGVuZ3RoKSB7XG5cdFx0XHRcdF9yZWFkRW50cmllcyhlbnRyaWVzLCBjYik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3JlYWRFbnRyaWVzKGVudHJpZXMsIGNiKSB7XG5cdFx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHRcdEJhc2ljLmVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHRcdFx0cXVldWUucHVzaChmdW5jdGlvbihjYmNiKSB7XG5cdFx0XHRcdFx0X3JlYWRFbnRyeShlbnRyeSwgY2JjYik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRCYXNpYy5pblNlcmllcyhxdWV1ZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9yZWFkRW50cnkoZW50cnksIGNiKSB7XG5cdFx0XHRpZiAoZW50cnkuaXNGaWxlKSB7XG5cdFx0XHRcdGVudHJ5LmZpbGUoZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRcdF9hZGRGaWxlKGZpbGUsIGVudHJ5LmZ1bGxQYXRoKTtcblx0XHRcdFx0XHRjYigpO1xuXHRcdFx0XHR9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBmaXJlIGFuIGVycm9yIGV2ZW50IG1heWJlXG5cdFx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG5cdFx0XHRcdF9yZWFkRGlyRW50cnkoZW50cnksIGNiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNiKCk7IC8vIG5vdCBmaWxlLCBub3QgZGlyZWN0b3J5PyB3aGF0IHRoZW4/Li5cblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9yZWFkRGlyRW50cnkoZGlyRW50cnksIGNiKSB7XG5cdFx0XHR2YXIgZW50cmllcyA9IFtdLCBkaXJSZWFkZXIgPSBkaXJFbnRyeS5jcmVhdGVSZWFkZXIoKTtcblxuXHRcdFx0Ly8ga2VlcCBxdWVyaW5nIHJlY3Vyc2l2ZWx5IHRpbGwgbm8gbW9yZSBlbnRyaWVzXG5cdFx0XHRmdW5jdGlvbiBnZXRFbnRyaWVzKGNiY2IpIHtcblx0XHRcdFx0ZGlyUmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKG1vcmVFbnRyaWVzKSB7XG5cdFx0XHRcdFx0aWYgKG1vcmVFbnRyaWVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0W10ucHVzaC5hcHBseShlbnRyaWVzLCBtb3JlRW50cmllcyk7XG5cdFx0XHRcdFx0XHRnZXRFbnRyaWVzKGNiY2IpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjYmNiKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCBjYmNiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gLi4uYW5kIHlvdSB0aG91Z2h0IEZpbGVSZWFkZXIgd2FzIGNyYXp5Li4uXG5cdFx0XHRnZXRFbnRyaWVzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfcmVhZEVudHJpZXMoZW50cmllcywgY2IpO1xuXHRcdFx0fSk7IFxuXHRcdH1cblx0fVxuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5GaWxlRHJvcCA9IEZpbGVEcm9wKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ZpbGUvRmlsZVJlYWRlci5qc1xuXG4vKipcbiAqIEZpbGVSZWFkZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9maWxlL0ZpbGVSZWFkZXJcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9maWxlL0ZpbGVSZWFkZXJcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW5jb2RlXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBFbmNvZGUsIEJhc2ljKSB7XG5cdFxuXHRmdW5jdGlvbiBGaWxlUmVhZGVyKCkge1xuXHRcdHZhciBfZnIsIF9jb252ZXJ0VG9CaW5hcnkgPSBmYWxzZTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cblx0XHRcdHJlYWQ6IGZ1bmN0aW9uKG9wLCBibG9iKSB7XG5cdFx0XHRcdHZhciBjb21wID0gdGhpcztcblxuXHRcdFx0XHRjb21wLnJlc3VsdCA9ICcnO1xuXG5cdFx0XHRcdF9mciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpO1xuXG5cdFx0XHRcdF9mci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wLnRyaWdnZXIoZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF9mci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGNvbXAucmVzdWx0ID0gX2NvbnZlcnRUb0JpbmFyeSA/IF90b0JpbmFyeShfZnIucmVzdWx0KSA6IF9mci5yZXN1bHQ7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKGUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfZnIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKGUsIF9mci5lcnJvcik7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF9mci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdF9mciA9IG51bGw7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKGUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoQmFzaWMudHlwZU9mKF9mcltvcF0pID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0X2NvbnZlcnRUb0JpbmFyeSA9IGZhbHNlO1xuXHRcdFx0XHRcdF9mcltvcF0oYmxvYi5nZXRTb3VyY2UoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAob3AgPT09ICdyZWFkQXNCaW5hcnlTdHJpbmcnKSB7IC8vIHJlYWRBc0JpbmFyeVN0cmluZyBpcyBkZXByaWNhdGVkIGluIGdlbmVyYWwgYW5kIG5ldmVyIGV4aXN0ZWQgaW4gSUUxMCtcblx0XHRcdFx0XHRfY29udmVydFRvQmluYXJ5ID0gdHJ1ZTtcblx0XHRcdFx0XHRfZnIucmVhZEFzRGF0YVVSTChibG9iLmdldFNvdXJjZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX2ZyKSB7XG5cdFx0XHRcdFx0X2ZyLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfZnIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZnVuY3Rpb24gX3RvQmluYXJ5KHN0cikge1xuXHRcdFx0cmV0dXJuIEVuY29kZS5hdG9iKHN0ci5zdWJzdHJpbmcoc3RyLmluZGV4T2YoJ2Jhc2U2NCwnKSArIDcpKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZVJlYWRlciA9IEZpbGVSZWFkZXIpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDUveGhyL1hNTEh0dHBSZXF1ZXN0LmpzXG5cbi8qKlxuICogWE1MSHR0cFJlcXVlc3QuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLypnbG9iYWwgQWN0aXZlWE9iamVjdDp0cnVlICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUveGhyL1hNTEh0dHBSZXF1ZXN0XG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUveGhyL1hNTEh0dHBSZXF1ZXN0XCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9NaW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9VcmxcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIixcblx0XCJtb3hpZS94aHIvRm9ybURhdGFcIixcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0VudlwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgTWltZSwgVXJsLCBGaWxlLCBCbG9iLCBGb3JtRGF0YSwgeCwgRW52KSB7XG5cdFxuXHRmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdCgpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHQsIF94aHJcblx0XHQsIF9maWxlbmFtZVxuXHRcdDtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbihtZXRhLCBkYXRhKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSB0aGlzXG5cdFx0XHRcdCwgaXNHZWNrbzJfNV82ID0gKEVudi5icm93c2VyID09PSAnTW96aWxsYScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDQsICc+PScpICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCA3LCAnPCcpKVxuXHRcdFx0XHQsIGlzQW5kcm9pZEJyb3dzZXIgPSBFbnYuYnJvd3NlciA9PT0gJ0FuZHJvaWQgQnJvd3Nlcidcblx0XHRcdFx0LCBtdXN0U2VuZEFzQmluYXJ5ID0gZmFsc2Vcblx0XHRcdFx0O1xuXG5cdFx0XHRcdC8vIGV4dHJhY3QgZmlsZSBuYW1lXG5cdFx0XHRcdF9maWxlbmFtZSA9IG1ldGEudXJsLnJlcGxhY2UoL14uKz9cXC8oW1xcd1xcLVxcLl0rKSQvLCAnJDEnKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdF94aHIgPSBfZ2V0TmF0aXZlWEhSKCk7XG5cdFx0XHRcdF94aHIub3BlbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIG1ldGEuYXN5bmMsIG1ldGEudXNlciwgbWV0YS5wYXNzd29yZCk7XG5cblxuXHRcdFx0XHQvLyBwcmVwYXJlIGRhdGEgdG8gYmUgc2VudFxuXHRcdFx0XHRpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRpZiAoZGF0YS5pc0RldGFjaGVkKCkpIHtcblx0XHRcdFx0XHRcdG11c3RTZW5kQXNCaW5hcnkgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhID0gZGF0YS5nZXRTb3VyY2UoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblxuXHRcdFx0XHRcdGlmIChkYXRhLmhhc0Jsb2IoKSkge1xuXHRcdFx0XHRcdFx0aWYgKGRhdGEuZ2V0QmxvYigpLmlzRGV0YWNoZWQoKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gX3ByZXBhcmVNdWx0aXBhcnQuY2FsbCh0YXJnZXQsIGRhdGEpOyAvLyBfeGhyIG11c3QgYmUgaW5zdGFudGlhdGVkIGFuZCBiZSBpbiBPUEVORUQgc3RhdGVcblx0XHRcdFx0XHRcdFx0bXVzdFNlbmRBc0JpbmFyeSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChpc0dlY2tvMl81XzYgfHwgaXNBbmRyb2lkQnJvd3NlcikgJiYgQmFzaWMudHlwZU9mKGRhdGEuZ2V0QmxvYigpLmdldFNvdXJjZSgpKSA9PT0gJ2Jsb2InICYmIHdpbmRvdy5GaWxlUmVhZGVyKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEdlY2tvIDIvNS82IGNhbid0IHNlbmQgYmxvYiBpbiBGb3JtRGF0YTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5MTUwXG5cdFx0XHRcdFx0XHRcdC8vIEFuZHJvaWQgYnJvd3NlcnMgKGRlZmF1bHQgb25lIGFuZCBEb2xwaGluKSBzZWVtIHRvIGhhdmUgdGhlIHNhbWUgaXNzdWUsIHNlZTogIzYxM1xuXHRcdFx0XHRcdFx0XHRfcHJlbG9hZEFuZFNlbmQuY2FsbCh0YXJnZXQsIG1ldGEsIGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47IC8vIF9wcmVsb2FkQW5kU2VuZCB3aWxsIHJlaW52b2tlIHNlbmQoKSB3aXRoIHRyYW5zbXV0YXRlZCBGb3JtRGF0YSA9JURcblx0XHRcdFx0XHRcdH1cdFxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRyYW5zZmVyIGZpZWxkcyB0byByZWFsIEZvcm1EYXRhXG5cdFx0XHRcdFx0aWYgKGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkgeyAvLyBpZiBzdGlsbCBhIEZvcm1EYXRhLCBlLmcuIG5vdCBtYW5nbGVkIGJ5IF9wcmVwYXJlTXVsdGlwYXJ0KClcblx0XHRcdFx0XHRcdHZhciBmZCA9IG5ldyB3aW5kb3cuRm9ybURhdGEoKTtcblx0XHRcdFx0XHRcdGRhdGEuZWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmQuYXBwZW5kKG5hbWUsIHZhbHVlLmdldFNvdXJjZSgpKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRmZC5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGRhdGEgPSBmZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vIGlmIFhIUiBMMlxuXHRcdFx0XHRpZiAoX3hoci51cGxvYWQpIHtcblx0XHRcdFx0XHRpZiAobWV0YS53aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRcdFx0XHRcdF94aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcihlKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdF94aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcihlKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIGFkZGl0aW9uYWxseSBsaXN0ZW4gdG8gcHJvZ3Jlc3MgZXZlbnRzXG5cdFx0XHRcdFx0X3hoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdHRhcmdldC50cmlnZ2VyKGUpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0X3hoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcih7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdVcGxvYWRQcm9ncmVzcycsXG5cdFx0XHRcdFx0XHRcdGxvYWRlZDogZS5sb2FkZWQsXG5cdFx0XHRcdFx0XHRcdHRvdGFsOiBlLnRvdGFsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gLi4uIG90aGVyd2lzZSBzaW11bGF0ZSBYSFIgTDJcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9uUmVhZHlTdGF0ZUNoYW5nZSgpIHtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gZmFrZSBMZXZlbCAyIGV2ZW50c1xuXHRcdFx0XHRcdFx0c3dpdGNoIChfeGhyLnJlYWR5U3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNhc2UgMTogLy8gWE1MSHR0cFJlcXVlc3QuT1BFTkVEXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmVhZHlzdGF0ZWNoYW5nZWQgaXMgZmlyZWQgdHdpY2UgZm9yIE9QRU5FRCBzdGF0ZSAoaW4gSUUgYW5kIE1vemlsbGEpIC0gbmV1XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBsb29rcyBsaWtlIEhFQURFUlNfUkVDRUlWRUQgKHN0YXRlIDIpIGlzIG5vdCByZXBvcnRlZCBpbiBPcGVyYSAob3IgaXQncyBvbGQgdmVyc2lvbnMpIC0gbmV1XG5cdFx0XHRcdFx0XHRcdGNhc2UgMjogLy8gWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjYXNlIDM6IC8vIFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdHJ5IHRvIGZpcmUgcHJvZ3Jlc3MgZXZlbnQgZm9yIG5vdCBYSFIgTDJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdG90YWwsIGxvYWRlZDtcblx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKFVybC5oYXNTYW1lT3JpZ2luKG1ldGEudXJsKSkgeyAvLyBDb250ZW50LUxlbmd0aCBub3QgYWNjZXNzaWJsZSBmb3IgY3Jvc3MtZG9tYWluIG9uIHNvbWUgYnJvd3NlcnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG90YWwgPSBfeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LUxlbmd0aCcpIHx8IDA7IC8vIG9sZCBTYWZhcmkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBoZXJlXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfeGhyLnJlc3BvbnNlVGV4dCkgeyAvLyByZXNwb25zZVRleHQgd2FzIGludHJvZHVjZWQgaW4gSUU3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxvYWRlZCA9IF94aHIucmVzcG9uc2VUZXh0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0b3RhbCA9IGxvYWRlZCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogJ3Byb2dyZXNzJyxcblx0XHRcdFx0XHRcdFx0XHRcdGxlbmd0aENvbXB1dGFibGU6ICEhdG90YWwsXG5cdFx0XHRcdFx0XHRcdFx0XHR0b3RhbDogcGFyc2VJbnQodG90YWwsIDEwKSxcblx0XHRcdFx0XHRcdFx0XHRcdGxvYWRlZDogbG9hZGVkXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNhc2UgNDogLy8gWE1MSHR0cFJlcXVlc3QuRE9ORVxuXHRcdFx0XHRcdFx0XHRcdC8vIHJlbGVhc2UgcmVhZHlzdGF0ZWNoYW5nZSBoYW5kbGVyIChtb3N0bHkgZm9yIElFKVxuXHRcdFx0XHRcdFx0XHRcdF94aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHVzdWFsbHkgc3RhdHVzIDAgaXMgcmV0dXJuZWQgd2hlbiBzZXJ2ZXIgaXMgdW5yZWFjaGFibGUsIGJ1dCBGRiBhbHNvIGZhaWxzIHRvIHN0YXR1cyAwIGZvciA0MDggdGltZW91dFxuXHRcdFx0XHRcdFx0XHRcdGlmIChfeGhyLnN0YXR1cyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoJ2Vycm9yJyk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldC50cmlnZ2VyKCdsb2FkJyk7XG5cdFx0XHRcdFx0XHRcdFx0fVx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblxuXHRcdFx0XHQvLyBzZXQgcmVxdWVzdCBoZWFkZXJzXG5cdFx0XHRcdGlmICghQmFzaWMuaXNFbXB0eU9iaihtZXRhLmhlYWRlcnMpKSB7XG5cdFx0XHRcdFx0QmFzaWMuZWFjaChtZXRhLmhlYWRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBoZWFkZXIpIHtcblx0XHRcdFx0XHRcdF94aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlcXVlc3QgcmVzcG9uc2UgdHlwZVxuXHRcdFx0XHRpZiAoXCJcIiAhPT0gbWV0YS5yZXNwb25zZVR5cGUgJiYgJ3Jlc3BvbnNlVHlwZScgaW4gX3hocikge1xuXHRcdFx0XHRcdGlmICgnanNvbicgPT09IG1ldGEucmVzcG9uc2VUeXBlICYmICFFbnYuY2FuKCdyZXR1cm5fcmVzcG9uc2VfdHlwZScsICdqc29uJykpIHsgLy8gd2UgY2FuIGZha2UgdGhpcyBvbmVcblx0XHRcdFx0XHRcdF94aHIucmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfeGhyLnJlc3BvbnNlVHlwZSA9IG1ldGEucmVzcG9uc2VUeXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlbmQgLi4uXG5cdFx0XHRcdGlmICghbXVzdFNlbmRBc0JpbmFyeSkge1xuXHRcdFx0XHRcdF94aHIuc2VuZChkYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoX3hoci5zZW5kQXNCaW5hcnkpIHsgLy8gR2Vja29cblx0XHRcdFx0XHRcdF94aHIuc2VuZEFzQmluYXJ5KGRhdGEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vIG90aGVyIGJyb3dzZXJzIGhhdmluZyBzdXBwb3J0IGZvciB0eXBlZCBhcnJheXNcblx0XHRcdFx0XHRcdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbWltaWMgR2Vja28ncyBzZW5kQXNCaW5hcnlcblx0XHRcdFx0XHRcdFx0dmFyIHVpOGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHVpOGFbaV0gPSAoZGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0X3hoci5zZW5kKHVpOGEuYnVmZmVyKTtcblx0XHRcdFx0XHRcdH0oKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0U3RhdHVzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gYWNjb3JkaW5nIHRvIFczQyBzcGVjIGl0IHNob3VsZCByZXR1cm4gMCBmb3IgcmVhZHlTdGF0ZSA8IDMsIGJ1dCBpbnN0ZWFkIGl0IHRocm93cyBhbiBleGNlcHRpb25cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoX3hocikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF94aHIuc3RhdHVzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaChleCkge31cblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdHZhciBJID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnYmxvYic6XG5cdFx0XHRcdFx0XHRcdHZhciBmaWxlID0gbmV3IEZpbGUoSS51aWQsIF94aHIucmVzcG9uc2UpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gdHJ5IHRvIGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gY29udGVudC1kaXNwb3NpdGlvbiBpZiBwb3NzaWJsZSAobWlnaHQgYmUgLSBub3QsIGlmIENPUlMgZm9yIGV4YW1wbGUpXHRcblx0XHRcdFx0XHRcdFx0dmFyIGRpc3Bvc2l0aW9uID0gX3hoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1EaXNwb3NpdGlvbicpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlzcG9zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBleHRyYWN0IGZpbGVuYW1lIGZyb20gcmVzcG9uc2UgaGVhZGVyIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXRjaCA9IGRpc3Bvc2l0aW9uLm1hdGNoKC9maWxlbmFtZT0oW1xcJ1xcXCInXSkoW15cXDFdKylcXDEvKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRcdF9maWxlbmFtZSA9IG1hdGNoWzJdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRmaWxlLm5hbWUgPSBfZmlsZW5hbWU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcHJlLXdlYmtpdCBPcGVyYSBkb2Vzbid0IHNldCB0eXBlIHByb3BlcnR5IG9uIHRoZSBibG9iIHJlc3BvbnNlXG5cdFx0XHRcdFx0XHRcdGlmICghZmlsZS50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmlsZS50eXBlID0gTWltZS5nZXRGaWxlTWltZShfZmlsZW5hbWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmaWxlO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdqc29uJzpcblx0XHRcdFx0XHRcdFx0aWYgKCFFbnYuY2FuKCdyZXR1cm5fcmVzcG9uc2VfdHlwZScsICdqc29uJykpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gX3hoci5zdGF0dXMgPT09IDIwMCAmJiAhIXdpbmRvdy5KU09OID8gSlNPTi5wYXJzZShfeGhyLnJlc3BvbnNlVGV4dCkgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBfeGhyLnJlc3BvbnNlO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdkb2N1bWVudCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBfZ2V0RG9jdW1lbnQoX3hocik7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBfeGhyLnJlc3BvbnNlVGV4dCAhPT0gJycgPyBfeGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7IC8vIGFnYWluc3QgdGhlIHNwZWNzLCBidXQgZm9yIGNvbnNpc3RlbmN5IGFjcm9zcyB0aGUgcnVudGltZXNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2goZXgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVx0XHRcdFx0XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBfeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXHRcdFx0XHR9IGNhdGNoKGV4KSB7fVxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfeGhyKSB7XG5cdFx0XHRcdFx0X3hoci5hYm9ydCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZiA9IF9maWxlbmFtZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHRcdC8vIGhlcmUgd2UgZ28uLi4gdWdseSBmaXggZm9yIHVnbHkgYnVnXG5cdFx0ZnVuY3Rpb24gX3ByZWxvYWRBbmRTZW5kKG1ldGEsIGRhdGEpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLCBibG9iLCBmcjtcblx0XHRcdFx0XG5cdFx0XHQvLyBnZXQgb3JpZ2luYWwgYmxvYlxuXHRcdFx0YmxvYiA9IGRhdGEuZ2V0QmxvYigpLmdldFNvdXJjZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBwcmVsb2FkIGJsb2IgaW4gbWVtb3J5IHRvIGJlIHNlbnQgYXMgYmluYXJ5IHN0cmluZ1xuXHRcdFx0ZnIgPSBuZXcgd2luZG93LkZpbGVSZWFkZXIoKTtcblx0XHRcdGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBvdmVyd3JpdGUgb3JpZ2luYWwgYmxvYlxuXHRcdFx0XHRkYXRhLmFwcGVuZChkYXRhLmdldEJsb2JOYW1lKCksIG5ldyBCbG9iKG51bGwsIHtcblx0XHRcdFx0XHR0eXBlOiBibG9iLnR5cGUsXG5cdFx0XHRcdFx0ZGF0YTogZnIucmVzdWx0XG5cdFx0XHRcdH0pKTtcblx0XHRcdFx0Ly8gaW52b2tlIHNlbmQgb3BlcmF0aW9uIGFnYWluXG5cdFx0XHRcdHNlbGYuc2VuZC5jYWxsKHRhcmdldCwgbWV0YSwgZGF0YSk7XG5cdFx0XHR9O1xuXHRcdFx0ZnIucmVhZEFzQmluYXJ5U3RyaW5nKGJsb2IpO1xuXHRcdH1cblxuXHRcdFxuXHRcdGZ1bmN0aW9uIF9nZXROYXRpdmVYSFIoKSB7XG5cdFx0XHRpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmICEoRW52LmJyb3dzZXIgPT09ICdJRScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDgsICc8JykpKSB7IC8vIElFNyBoYXMgbmF0aXZlIFhIUiBidXQgaXQncyBidWdneVxuXHRcdFx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgcHJvZ0lEcyA9IFsnTXN4bWwyLlhNTEhUVFAuNi4wJywgJ01pY3Jvc29mdC5YTUxIVFRQJ107IC8vIGlmIDYuMCBhdmFpbGFibGUsIHVzZSBpdCwgb3RoZXJ3aXNlIGZhaWxiYWNrIHRvIGRlZmF1bHQgMy4wXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9nSURzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QocHJvZ0lEc1tpXSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChleCkge31cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEBjcmVkaXRzIFNlcmdleSBJbGluc2t5XHQoaHR0cDovL3d3dy5pbGluc2t5LmNvbS8pXG5cdFx0ZnVuY3Rpb24gX2dldERvY3VtZW50KHhocikge1xuXHRcdFx0dmFyIHJYTUwgPSB4aHIucmVzcG9uc2VYTUw7XG5cdFx0XHR2YXIgclRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0XG5cdFx0XHQvLyBUcnkgcGFyc2luZyByZXNwb25zZVRleHQgKEBzZWU6IGh0dHA6Ly93d3cuaWxpbnNreS5jb20vYXJ0aWNsZXMvWE1MSHR0cFJlcXVlc3QvI2J1Z3MtaWUtcmVzcG9uc2VYTUwtY29udGVudC10eXBlKVxuXHRcdFx0aWYgKEVudi5icm93c2VyID09PSAnSUUnICYmIHJUZXh0ICYmIHJYTUwgJiYgIXJYTUwuZG9jdW1lbnRFbGVtZW50ICYmIC9bXlxcL10rXFwvW15cXCtdK1xcK3htbC8udGVzdCh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpKSB7XG5cdFx0XHRcdHJYTUwgPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuXHRcdFx0XHRyWE1MLmFzeW5jID0gZmFsc2U7XG5cdFx0XHRcdHJYTUwudmFsaWRhdGVPblBhcnNlID0gZmFsc2U7XG5cdFx0XHRcdHJYTUwubG9hZFhNTChyVGV4dCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlcmUgaXMgbm8gZXJyb3IgaW4gZG9jdW1lbnRcblx0XHRcdGlmIChyWE1MKSB7XG5cdFx0XHRcdGlmICgoRW52LmJyb3dzZXIgPT09ICdJRScgJiYgclhNTC5wYXJzZUVycm9yICE9PSAwKSB8fCAhclhNTC5kb2N1bWVudEVsZW1lbnQgfHwgclhNTC5kb2N1bWVudEVsZW1lbnQudGFnTmFtZSA9PT0gXCJwYXJzZXJlcnJvclwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByWE1MO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3ByZXBhcmVNdWx0aXBhcnQoZmQpIHtcblx0XHRcdHZhciBib3VuZGFyeSA9ICctLS0tbW94aWVib3VuZGFyeScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuXHRcdFx0LCBkYXNoZGFzaCA9ICctLSdcblx0XHRcdCwgY3JsZiA9ICdcXHJcXG4nXG5cdFx0XHQsIG11bHRpcGFydCA9ICcnXG5cdFx0XHQsIEkgPSB0aGlzLmdldFJ1bnRpbWUoKVxuXHRcdFx0O1xuXG5cdFx0XHRpZiAoIUkuY2FuKCdzZW5kX2JpbmFyeV9zdHJpbmcnKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgeC5SdW50aW1lRXJyb3IoeC5SdW50aW1lRXJyb3IuTk9UX1NVUFBPUlRFRF9FUlIpO1xuXHRcdFx0fVxuXG5cdFx0XHRfeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0nICsgYm91bmRhcnkpO1xuXG5cdFx0XHQvLyBhcHBlbmQgbXVsdGlwYXJ0IHBhcmFtZXRlcnNcblx0XHRcdGZkLmVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdFx0Ly8gRmlyZWZveCAzLjYgZmFpbGVkIHRvIGNvbnZlcnQgbXVsdGlieXRlIGNoYXJhY3RlcnMgdG8gVVRGLTggaW4gc2VuZEFzQmluYXJ5KCksIFxuXHRcdFx0XHQvLyBzbyB3ZSB0cnkgaXQgaGVyZSBvdXJzZWx2ZXMgd2l0aDogdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcblx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdC8vIEJ1aWxkIFJGQzIzODggYmxvYlxuXHRcdFx0XHRcdG11bHRpcGFydCArPSBkYXNoZGFzaCArIGJvdW5kYXJ5ICsgY3JsZiArXG5cdFx0XHRcdFx0XHQnQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJyArIG5hbWUgKyAnXCI7IGZpbGVuYW1lPVwiJyArIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZS5uYW1lIHx8ICdibG9iJykpICsgJ1wiJyArIGNybGYgK1xuXHRcdFx0XHRcdFx0J0NvbnRlbnQtVHlwZTogJyArICh2YWx1ZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSArIGNybGYgKyBjcmxmICtcblx0XHRcdFx0XHRcdHZhbHVlLmdldFNvdXJjZSgpICsgY3JsZjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtdWx0aXBhcnQgKz0gZGFzaGRhc2ggKyBib3VuZGFyeSArIGNybGYgK1xuXHRcdFx0XHRcdFx0J0NvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIicgKyBuYW1lICsgJ1wiJyArIGNybGYgKyBjcmxmICtcblx0XHRcdFx0XHRcdHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpICsgY3JsZjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG11bHRpcGFydCArPSBkYXNoZGFzaCArIGJvdW5kYXJ5ICsgZGFzaGRhc2ggKyBjcmxmO1xuXG5cdFx0XHRyZXR1cm4gbXVsdGlwYXJ0O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5YTUxIdHRwUmVxdWVzdCA9IFhNTEh0dHBSZXF1ZXN0KTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L3V0aWxzL0JpbmFyeVJlYWRlci5qc1xuXG4vKipcbiAqIEJpbmFyeVJlYWRlci5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw1L3V0aWxzL0JpbmFyeVJlYWRlclxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw1L3V0aWxzL0JpbmFyeVJlYWRlclwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiXG5dLCBmdW5jdGlvbihCYXNpYykge1xuXG5cdFxuXHRmdW5jdGlvbiBCaW5hcnlSZWFkZXIoZGF0YSkge1xuXHRcdGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdEFycmF5QnVmZmVyUmVhZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFVURjE2U3RyaW5nUmVhZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9XG5cblx0QmFzaWMuZXh0ZW5kKEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIHtcblx0XHRcblx0XHRsaXR0bGVFbmRpYW46IGZhbHNlLFxuXG5cblx0XHRyZWFkOiBmdW5jdGlvbihpZHgsIHNpemUpIHtcblx0XHRcdHZhciBzdW0sIG12LCBpO1xuXG5cdFx0XHRpZiAoaWR4ICsgc2l6ZSA+IHRoaXMubGVuZ3RoKCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSB0cnlpbmcgdG8gcmVhZCBvdXRzaWRlIHRoZSBzb3VyY2UgYm91bmRhcmllcy5cIik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdG12ID0gdGhpcy5saXR0bGVFbmRpYW4gXG5cdFx0XHRcdD8gMCBcblx0XHRcdFx0OiAtOCAqIChzaXplIC0gMSlcblx0XHRcdDtcblxuXHRcdFx0Zm9yIChpID0gMCwgc3VtID0gMDsgaSA8IHNpemU7IGkrKykge1xuXHRcdFx0XHRzdW0gfD0gKHRoaXMucmVhZEJ5dGVBdChpZHggKyBpKSA8PCBNYXRoLmFicyhtdiArIGkqOCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN1bTtcblx0XHR9LFxuXG5cblx0XHR3cml0ZTogZnVuY3Rpb24oaWR4LCBudW0sIHNpemUpIHtcblx0XHRcdHZhciBtdiwgaSwgc3RyID0gJyc7XG5cblx0XHRcdGlmIChpZHggPiB0aGlzLmxlbmd0aCgpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgdHJ5aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhlIHNvdXJjZSBib3VuZGFyaWVzLlwiKTtcblx0XHRcdH1cblxuXHRcdFx0bXYgPSB0aGlzLmxpdHRsZUVuZGlhbiBcblx0XHRcdFx0PyAwIFxuXHRcdFx0XHQ6IC04ICogKHNpemUgLSAxKVxuXHRcdFx0O1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG5cdFx0XHRcdHRoaXMud3JpdGVCeXRlQXQoaWR4ICsgaSwgKG51bSA+PiBNYXRoLmFicyhtdiArIGkqOCkpICYgMjU1KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHRCWVRFOiBmdW5jdGlvbihpZHgpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlYWQoaWR4LCAxKTtcblx0XHR9LFxuXG5cblx0XHRTSE9SVDogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkKGlkeCwgMik7XG5cdFx0fSxcblxuXG5cdFx0TE9ORzogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkKGlkeCwgNCk7XG5cdFx0fSxcblxuXG5cdFx0U0xPTkc6IGZ1bmN0aW9uKGlkeCkgeyAvLyAyJ3MgY29tcGxlbWVudCBub3RhdGlvblxuXHRcdFx0dmFyIG51bSA9IHRoaXMucmVhZChpZHgsIDQpO1xuXHRcdFx0cmV0dXJuIChudW0gPiAyMTQ3NDgzNjQ3ID8gbnVtIC0gNDI5NDk2NzI5NiA6IG51bSk7XG5cdFx0fSxcblxuXG5cdFx0Q0hBUjogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWQoaWR4LCAxKSk7XG5cdFx0fSxcblxuXG5cdFx0U1RSSU5HOiBmdW5jdGlvbihpZHgsIGNvdW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hc0FycmF5KCdDSEFSJywgaWR4LCBjb3VudCkuam9pbignJyk7XG5cdFx0fSxcblxuXG5cdFx0YXNBcnJheTogZnVuY3Rpb24odHlwZSwgaWR4LCBjb3VudCkge1xuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dmFsdWVzW2ldID0gdGhpc1t0eXBlXShpZHggKyBpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0fVxuXHR9KTtcblxuXG5cdGZ1bmN0aW9uIEFycmF5QnVmZmVyUmVhZGVyKGRhdGEpIHtcblx0XHR2YXIgX2R2ID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuXG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdFxuXHRcdFx0cmVhZEJ5dGVBdDogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRcdHJldHVybiBfZHYuZ2V0VWludDgoaWR4KTtcblx0XHRcdH0sXG5cblxuXHRcdFx0d3JpdGVCeXRlQXQ6IGZ1bmN0aW9uKGlkeCwgdmFsdWUpIHtcblx0XHRcdFx0X2R2LnNldFVpbnQ4KGlkeCwgdmFsdWUpO1xuXHRcdFx0fSxcblx0XHRcdFxuXG5cdFx0XHRTRUdNRU5UOiBmdW5jdGlvbihpZHgsIHNpemUsIHZhbHVlKSB7XG5cdFx0XHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdHJldHVybiBkYXRhLnNsaWNlKGlkeCwgaWR4ICsgc2l6ZSk7XG5cblx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YS5zbGljZShpZHgpO1xuXG5cdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IEFycmF5QnVmZmVyKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAtIHNpemUgKyB2YWx1ZS5ieXRlTGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0aWYgKGlkeCA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRhcnIuc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgaWR4KSksIDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGFyci5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBpZHgpO1xuXHRcdFx0XHRcdFx0XHRhcnIuc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoaWR4ICsgc2l6ZSkpLCBpZHggKyB2YWx1ZS5ieXRlTGVuZ3RoKTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBhcnIuYnVmZmVyO1xuXHRcdFx0XHRcdFx0XHRfZHYgPSBuZXcgRGF0YVZpZXcoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblxuXHRcdFx0bGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGEgPyBkYXRhLmJ5dGVMZW5ndGggOiAwO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9kdiA9IGRhdGEgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBVVEYxNlN0cmluZ1JlYWRlcihkYXRhKSB7XG5cdFx0QmFzaWMuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdFxuXHRcdFx0cmVhZEJ5dGVBdDogZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRcdHJldHVybiBkYXRhLmNoYXJDb2RlQXQoaWR4KTtcblx0XHRcdH0sXG5cblxuXHRcdFx0d3JpdGVCeXRlQXQ6IGZ1bmN0aW9uKGlkeCwgdmFsdWUpIHtcblx0XHRcdFx0cHV0c3RyKFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUpLCBpZHgsIDEpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRTRUdNRU5UOiBmdW5jdGlvbihpZHgsIGxlbmd0aCwgc2VnbWVudCkge1xuXHRcdFx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YS5zdWJzdHIoaWR4KTtcblx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YS5zdWJzdHIoaWR4LCBsZW5ndGgpO1xuXHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdHB1dHN0cihzZWdtZW50ICE9PSBudWxsID8gc2VnbWVudCA6ICcnLCBpZHgsIGxlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXG5cdFx0XHRsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YSA/IGRhdGEubGVuZ3RoIDogMDtcblx0XHRcdH0sIFxuXG5cdFx0XHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHRmdW5jdGlvbiBwdXRzdHIoc2VnbWVudCwgaWR4LCBsZW5ndGgpIHtcblx0XHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBsZW5ndGggOiBkYXRhLmxlbmd0aCAtIGlkeCAtIDE7XG5cdFx0XHRkYXRhID0gZGF0YS5zdWJzdHIoMCwgaWR4KSArIHNlZ21lbnQgKyBkYXRhLnN1YnN0cihsZW5ndGggKyBpZHgpO1xuXHRcdH1cblx0fVxuXG5cblx0cmV0dXJuIEJpbmFyeVJlYWRlcjtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ltYWdlL0pQRUdIZWFkZXJzLmpzXG5cbi8qKlxuICogSlBFR0hlYWRlcnMuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cbiBcbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSlBFR0hlYWRlcnNcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9KUEVHSGVhZGVyc1wiLCBbXG5cdFwibW94aWUvcnVudGltZS9odG1sNS91dGlscy9CaW5hcnlSZWFkZXJcIixcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIlxuXSwgZnVuY3Rpb24oQmluYXJ5UmVhZGVyLCB4KSB7XG5cdFxuXHRyZXR1cm4gZnVuY3Rpb24gSlBFR0hlYWRlcnMoZGF0YSkge1xuXHRcdHZhciBoZWFkZXJzID0gW10sIF9iciwgaWR4LCBtYXJrZXIsIGxlbmd0aCA9IDA7XG5cblx0XHRfYnIgPSBuZXcgQmluYXJ5UmVhZGVyKGRhdGEpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgZGF0YSBpcyBqcGVnXG5cdFx0aWYgKF9ici5TSE9SVCgwKSAhPT0gMHhGRkQ4KSB7XG5cdFx0XHRfYnIuY2xlYXIoKTtcblx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLldST05HX0ZPUk1BVCk7XG5cdFx0fVxuXG5cdFx0aWR4ID0gMjtcblxuXHRcdHdoaWxlIChpZHggPD0gX2JyLmxlbmd0aCgpKSB7XG5cdFx0XHRtYXJrZXIgPSBfYnIuU0hPUlQoaWR4KTtcblxuXHRcdFx0Ly8gb21pdCBSU1QgKHJlc3RhcnQpIG1hcmtlcnNcblx0XHRcdGlmIChtYXJrZXIgPj0gMHhGRkQwICYmIG1hcmtlciA8PSAweEZGRDcpIHtcblx0XHRcdFx0aWR4ICs9IDI7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBubyBoZWFkZXJzIGFsbG93ZWQgYWZ0ZXIgU09TIG1hcmtlclxuXHRcdFx0aWYgKG1hcmtlciA9PT0gMHhGRkRBIHx8IG1hcmtlciA9PT0gMHhGRkQ5KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRsZW5ndGggPSBfYnIuU0hPUlQoaWR4ICsgMikgKyAyO1xuXG5cdFx0XHQvLyBBUFBuIG1hcmtlciBkZXRlY3RlZFxuXHRcdFx0aWYgKG1hcmtlciA+PSAweEZGRTEgJiYgbWFya2VyIDw9IDB4RkZFRikge1xuXHRcdFx0XHRoZWFkZXJzLnB1c2goe1xuXHRcdFx0XHRcdGhleDogbWFya2VyLFxuXHRcdFx0XHRcdG5hbWU6ICdBUFAnICsgKG1hcmtlciAmIDB4MDAwRiksXG5cdFx0XHRcdFx0c3RhcnQ6IGlkeCxcblx0XHRcdFx0XHRsZW5ndGg6IGxlbmd0aCxcblx0XHRcdFx0XHRzZWdtZW50OiBfYnIuU0VHTUVOVChpZHgsIGxlbmd0aClcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlkeCArPSBsZW5ndGg7XG5cdFx0fVxuXG5cdFx0X2JyLmNsZWFyKCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVhZGVyczogaGVhZGVycyxcblxuXHRcdFx0cmVzdG9yZTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHR2YXIgbWF4LCBpLCBicjtcblxuXHRcdFx0XHRiciA9IG5ldyBCaW5hcnlSZWFkZXIoZGF0YSk7XG5cblx0XHRcdFx0aWR4ID0gYnIuU0hPUlQoMikgPT0gMHhGRkUwID8gNCArIGJyLlNIT1JUKDQpIDogMjtcblxuXHRcdFx0XHRmb3IgKGkgPSAwLCBtYXggPSBoZWFkZXJzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdFx0YnIuU0VHTUVOVChpZHgsIDAsIGhlYWRlcnNbaV0uc2VnbWVudCk7XG5cdFx0XHRcdFx0aWR4ICs9IGhlYWRlcnNbaV0ubGVuZ3RoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGF0YSA9IGJyLlNFR01FTlQoKTtcblx0XHRcdFx0YnIuY2xlYXIoKTtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9LFxuXG5cdFx0XHRzdHJpcDogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHR2YXIgYnIsIGhlYWRlcnMsIGpwZWdIZWFkZXJzLCBpO1xuXG5cdFx0XHRcdGpwZWdIZWFkZXJzID0gbmV3IEpQRUdIZWFkZXJzKGRhdGEpO1xuXHRcdFx0XHRoZWFkZXJzID0ganBlZ0hlYWRlcnMuaGVhZGVycztcblx0XHRcdFx0anBlZ0hlYWRlcnMucHVyZ2UoKTtcblxuXHRcdFx0XHRiciA9IG5ldyBCaW5hcnlSZWFkZXIoZGF0YSk7XG5cblx0XHRcdFx0aSA9IGhlYWRlcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0YnIuU0VHTUVOVChoZWFkZXJzW2ldLnN0YXJ0LCBoZWFkZXJzW2ldLmxlbmd0aCwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRkYXRhID0gYnIuU0VHTUVOVCgpO1xuXHRcdFx0XHRici5jbGVhcigpO1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH0sXG5cblx0XHRcdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbWF4ID0gaGVhZGVycy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJzW2ldLm5hbWUgPT09IG5hbWUudG9VcHBlckNhc2UoKSkge1xuXHRcdFx0XHRcdFx0YXJyYXkucHVzaChoZWFkZXJzW2ldLnNlZ21lbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKG5hbWUsIHNlZ21lbnQpIHtcblx0XHRcdFx0dmFyIGFycmF5ID0gW10sIGksIGlpLCBtYXg7XG5cblx0XHRcdFx0aWYgKHR5cGVvZihzZWdtZW50KSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRhcnJheS5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFycmF5ID0gc2VnbWVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoaSA9IGlpID0gMCwgbWF4ID0gaGVhZGVycy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJzW2ldLm5hbWUgPT09IG5hbWUudG9VcHBlckNhc2UoKSkge1xuXHRcdFx0XHRcdFx0aGVhZGVyc1tpXS5zZWdtZW50ID0gYXJyYXlbaWldO1xuXHRcdFx0XHRcdFx0aGVhZGVyc1tpXS5sZW5ndGggPSBhcnJheVtpaV0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWkrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGlpID49IGFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRwdXJnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVycyA9IGhlYWRlcnMgPSBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDUvaW1hZ2UvRXhpZlBhcnNlci5qc1xuXG4vKipcbiAqIEV4aWZQYXJzZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9FeGlmUGFyc2VyXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvRXhpZlBhcnNlclwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvdXRpbHMvQmluYXJ5UmVhZGVyXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCJcbl0sIGZ1bmN0aW9uKEJhc2ljLCBCaW5hcnlSZWFkZXIsIHgpIHtcblx0XG5cdGZ1bmN0aW9uIEV4aWZQYXJzZXIoZGF0YSkge1xuXHRcdHZhciBfX3N1cGVyX18sIHRhZ3MsIHRhZ0Rlc2NzLCBvZmZzZXRzLCBpZHgsIFRpZmY7XG5cdFx0XG5cdFx0QmluYXJ5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cblx0XHR0YWdzID0ge1xuXHRcdFx0dGlmZjoge1xuXHRcdFx0XHQvKlxuXHRcdFx0XHRUaGUgaW1hZ2Ugb3JpZW50YXRpb24gdmlld2VkIGluIHRlcm1zIG9mIHJvd3MgYW5kIGNvbHVtbnMuXG5cblx0XHRcdFx0MSA9IFRoZSAwdGggcm93IGlzIGF0IHRoZSB2aXN1YWwgdG9wIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgbGVmdC1oYW5kIHNpZGUuXG5cdFx0XHRcdDIgPSBUaGUgMHRoIHJvdyBpcyBhdCB0aGUgdmlzdWFsIHRvcCBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIHJpZ2h0LWhhbmQgc2lkZS5cblx0XHRcdFx0MyA9IFRoZSAwdGggcm93IGlzIGF0IHRoZSB2aXN1YWwgYm90dG9tIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgcmlnaHQtaGFuZCBzaWRlLlxuXHRcdFx0XHQ0ID0gVGhlIDB0aCByb3cgaXMgYXQgdGhlIHZpc3VhbCBib3R0b20gb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCBsZWZ0LWhhbmQgc2lkZS5cblx0XHRcdFx0NSA9IFRoZSAwdGggcm93IGlzIHRoZSB2aXN1YWwgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCB0b3AuXG5cdFx0XHRcdDYgPSBUaGUgMHRoIHJvdyBpcyB0aGUgdmlzdWFsIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIHRvcC5cblx0XHRcdFx0NyA9IFRoZSAwdGggcm93IGlzIHRoZSB2aXN1YWwgcmlnaHQtaGFuZCBzaWRlIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgYm90dG9tLlxuXHRcdFx0XHQ4ID0gVGhlIDB0aCByb3cgaXMgdGhlIHZpc3VhbCBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgaW1hZ2UsIGFuZCB0aGUgMHRoIGNvbHVtbiBpcyB0aGUgdmlzdWFsIGJvdHRvbS5cblx0XHRcdFx0Ki9cblx0XHRcdFx0MHgwMTEyOiAnT3JpZW50YXRpb24nLFxuXHRcdFx0XHQweDAxMEU6ICdJbWFnZURlc2NyaXB0aW9uJyxcblx0XHRcdFx0MHgwMTBGOiAnTWFrZScsXG5cdFx0XHRcdDB4MDExMDogJ01vZGVsJyxcblx0XHRcdFx0MHgwMTMxOiAnU29mdHdhcmUnLFxuXHRcdFx0XHQweDg3Njk6ICdFeGlmSUZEUG9pbnRlcicsXG5cdFx0XHRcdDB4ODgyNTpcdCdHUFNJbmZvSUZEUG9pbnRlcidcblx0XHRcdH0sXG5cdFx0XHRleGlmOiB7XG5cdFx0XHRcdDB4OTAwMDogJ0V4aWZWZXJzaW9uJyxcblx0XHRcdFx0MHhBMDAxOiAnQ29sb3JTcGFjZScsXG5cdFx0XHRcdDB4QTAwMjogJ1BpeGVsWERpbWVuc2lvbicsXG5cdFx0XHRcdDB4QTAwMzogJ1BpeGVsWURpbWVuc2lvbicsXG5cdFx0XHRcdDB4OTAwMzogJ0RhdGVUaW1lT3JpZ2luYWwnLFxuXHRcdFx0XHQweDgyOUE6ICdFeHBvc3VyZVRpbWUnLFxuXHRcdFx0XHQweDgyOUQ6ICdGTnVtYmVyJyxcblx0XHRcdFx0MHg4ODI3OiAnSVNPU3BlZWRSYXRpbmdzJyxcblx0XHRcdFx0MHg5MjAxOiAnU2h1dHRlclNwZWVkVmFsdWUnLFxuXHRcdFx0XHQweDkyMDI6ICdBcGVydHVyZVZhbHVlJ1x0LFxuXHRcdFx0XHQweDkyMDc6ICdNZXRlcmluZ01vZGUnLFxuXHRcdFx0XHQweDkyMDg6ICdMaWdodFNvdXJjZScsXG5cdFx0XHRcdDB4OTIwOTogJ0ZsYXNoJyxcblx0XHRcdFx0MHg5MjBBOiAnRm9jYWxMZW5ndGgnLFxuXHRcdFx0XHQweEE0MDI6ICdFeHBvc3VyZU1vZGUnLFxuXHRcdFx0XHQweEE0MDM6ICdXaGl0ZUJhbGFuY2UnLFxuXHRcdFx0XHQweEE0MDY6ICdTY2VuZUNhcHR1cmVUeXBlJyxcblx0XHRcdFx0MHhBNDA0OiAnRGlnaXRhbFpvb21SYXRpbycsXG5cdFx0XHRcdDB4QTQwODogJ0NvbnRyYXN0Jyxcblx0XHRcdFx0MHhBNDA5OiAnU2F0dXJhdGlvbicsXG5cdFx0XHRcdDB4QTQwQTogJ1NoYXJwbmVzcydcblx0XHRcdH0sXG5cdFx0XHRncHM6IHtcblx0XHRcdFx0MHgwMDAwOiAnR1BTVmVyc2lvbklEJyxcblx0XHRcdFx0MHgwMDAxOiAnR1BTTGF0aXR1ZGVSZWYnLFxuXHRcdFx0XHQweDAwMDI6ICdHUFNMYXRpdHVkZScsXG5cdFx0XHRcdDB4MDAwMzogJ0dQU0xvbmdpdHVkZVJlZicsXG5cdFx0XHRcdDB4MDAwNDogJ0dQU0xvbmdpdHVkZSdcblx0XHRcdH0sXG5cblx0XHRcdHRodW1iOiB7XG5cdFx0XHRcdDB4MDIwMTogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdCcsXG5cdFx0XHRcdDB4MDIwMjogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aCdcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGFnRGVzY3MgPSB7XG5cdFx0XHQnQ29sb3JTcGFjZSc6IHtcblx0XHRcdFx0MTogJ3NSR0InLFxuXHRcdFx0XHQwOiAnVW5jYWxpYnJhdGVkJ1xuXHRcdFx0fSxcblxuXHRcdFx0J01ldGVyaW5nTW9kZSc6IHtcblx0XHRcdFx0MDogJ1Vua25vd24nLFxuXHRcdFx0XHQxOiAnQXZlcmFnZScsXG5cdFx0XHRcdDI6ICdDZW50ZXJXZWlnaHRlZEF2ZXJhZ2UnLFxuXHRcdFx0XHQzOiAnU3BvdCcsXG5cdFx0XHRcdDQ6ICdNdWx0aVNwb3QnLFxuXHRcdFx0XHQ1OiAnUGF0dGVybicsXG5cdFx0XHRcdDY6ICdQYXJ0aWFsJyxcblx0XHRcdFx0MjU1OiAnT3RoZXInXG5cdFx0XHR9LFxuXG5cdFx0XHQnTGlnaHRTb3VyY2UnOiB7XG5cdFx0XHRcdDE6ICdEYXlsaWdodCcsXG5cdFx0XHRcdDI6ICdGbGlvcmVzY2VudCcsXG5cdFx0XHRcdDM6ICdUdW5nc3RlbicsXG5cdFx0XHRcdDQ6ICdGbGFzaCcsXG5cdFx0XHRcdDk6ICdGaW5lIHdlYXRoZXInLFxuXHRcdFx0XHQxMDogJ0Nsb3VkeSB3ZWF0aGVyJyxcblx0XHRcdFx0MTE6ICdTaGFkZScsXG5cdFx0XHRcdDEyOiAnRGF5bGlnaHQgZmx1b3Jlc2NlbnQgKEQgNTcwMCAtIDcxMDBLKScsXG5cdFx0XHRcdDEzOiAnRGF5IHdoaXRlIGZsdW9yZXNjZW50IChOIDQ2MDAgLTU0MDBLKScsXG5cdFx0XHRcdDE0OiAnQ29vbCB3aGl0ZSBmbHVvcmVzY2VudCAoVyAzOTAwIC0gNDUwMEspJyxcblx0XHRcdFx0MTU6ICdXaGl0ZSBmbHVvcmVzY2VudCAoV1cgMzIwMCAtIDM3MDBLKScsXG5cdFx0XHRcdDE3OiAnU3RhbmRhcmQgbGlnaHQgQScsXG5cdFx0XHRcdDE4OiAnU3RhbmRhcmQgbGlnaHQgQicsXG5cdFx0XHRcdDE5OiAnU3RhbmRhcmQgbGlnaHQgQycsXG5cdFx0XHRcdDIwOiAnRDU1Jyxcblx0XHRcdFx0MjE6ICdENjUnLFxuXHRcdFx0XHQyMjogJ0Q3NScsXG5cdFx0XHRcdDIzOiAnRDUwJyxcblx0XHRcdFx0MjQ6ICdJU08gc3R1ZGlvIHR1bmdzdGVuJyxcblx0XHRcdFx0MjU1OiAnT3RoZXInXG5cdFx0XHR9LFxuXG5cdFx0XHQnRmxhc2gnOiB7XG5cdFx0XHRcdDB4MDAwMDogJ0ZsYXNoIGRpZCBub3QgZmlyZScsXG5cdFx0XHRcdDB4MDAwMTogJ0ZsYXNoIGZpcmVkJyxcblx0XHRcdFx0MHgwMDA1OiAnU3Ryb2JlIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwMDc6ICdTdHJvYmUgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDA5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG5cdFx0XHRcdDB4MDAwRDogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwMEY6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwMTA6ICdGbGFzaCBkaWQgbm90IGZpcmUsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG5cdFx0XHRcdDB4MDAxODogJ0ZsYXNoIGRpZCBub3QgZmlyZSwgYXV0byBtb2RlJyxcblx0XHRcdFx0MHgwMDE5OiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZScsXG5cdFx0XHRcdDB4MDAxRDogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwMUY6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwMjA6ICdObyBmbGFzaCBmdW5jdGlvbicsXG5cdFx0XHRcdDB4MDA0MTogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcblx0XHRcdFx0MHgwMDQ1OiAnRmxhc2ggZmlyZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwNDc6ICdGbGFzaCBmaXJlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcblx0XHRcdFx0MHgwMDQ5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG5cdFx0XHRcdDB4MDA0RDogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwNEY6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuXHRcdFx0XHQweDAwNTk6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcblx0XHRcdFx0MHgwMDVEOiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG5cdFx0XHRcdDB4MDA1RjogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSdcblx0XHRcdH0sXG5cblx0XHRcdCdFeHBvc3VyZU1vZGUnOiB7XG5cdFx0XHRcdDA6ICdBdXRvIGV4cG9zdXJlJyxcblx0XHRcdFx0MTogJ01hbnVhbCBleHBvc3VyZScsXG5cdFx0XHRcdDI6ICdBdXRvIGJyYWNrZXQnXG5cdFx0XHR9LFxuXG5cdFx0XHQnV2hpdGVCYWxhbmNlJzoge1xuXHRcdFx0XHQwOiAnQXV0byB3aGl0ZSBiYWxhbmNlJyxcblx0XHRcdFx0MTogJ01hbnVhbCB3aGl0ZSBiYWxhbmNlJ1xuXHRcdFx0fSxcblxuXHRcdFx0J1NjZW5lQ2FwdHVyZVR5cGUnOiB7XG5cdFx0XHRcdDA6ICdTdGFuZGFyZCcsXG5cdFx0XHRcdDE6ICdMYW5kc2NhcGUnLFxuXHRcdFx0XHQyOiAnUG9ydHJhaXQnLFxuXHRcdFx0XHQzOiAnTmlnaHQgc2NlbmUnXG5cdFx0XHR9LFxuXG5cdFx0XHQnQ29udHJhc3QnOiB7XG5cdFx0XHRcdDA6ICdOb3JtYWwnLFxuXHRcdFx0XHQxOiAnU29mdCcsXG5cdFx0XHRcdDI6ICdIYXJkJ1xuXHRcdFx0fSxcblxuXHRcdFx0J1NhdHVyYXRpb24nOiB7XG5cdFx0XHRcdDA6ICdOb3JtYWwnLFxuXHRcdFx0XHQxOiAnTG93IHNhdHVyYXRpb24nLFxuXHRcdFx0XHQyOiAnSGlnaCBzYXR1cmF0aW9uJ1xuXHRcdFx0fSxcblxuXHRcdFx0J1NoYXJwbmVzcyc6IHtcblx0XHRcdFx0MDogJ05vcm1hbCcsXG5cdFx0XHRcdDE6ICdTb2Z0Jyxcblx0XHRcdFx0MjogJ0hhcmQnXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBHUFMgcmVsYXRlZFxuXHRcdFx0J0dQU0xhdGl0dWRlUmVmJzoge1xuXHRcdFx0XHROOiAnTm9ydGggbGF0aXR1ZGUnLFxuXHRcdFx0XHRTOiAnU291dGggbGF0aXR1ZGUnXG5cdFx0XHR9LFxuXG5cdFx0XHQnR1BTTG9uZ2l0dWRlUmVmJzoge1xuXHRcdFx0XHRFOiAnRWFzdCBsb25naXR1ZGUnLFxuXHRcdFx0XHRXOiAnV2VzdCBsb25naXR1ZGUnXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdG9mZnNldHMgPSB7XG5cdFx0XHR0aWZmSGVhZGVyOiAxMFxuXHRcdH07XG5cdFx0XG5cdFx0aWR4ID0gb2Zmc2V0cy50aWZmSGVhZGVyO1xuXG5cdFx0X19zdXBlcl9fID0ge1xuXHRcdFx0Y2xlYXI6IHRoaXMuY2xlYXJcblx0XHR9O1xuXG5cdFx0Ly8gUHVibGljIGZ1bmN0aW9uc1xuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBFeGlmUGFyc2VyLnByb3RvdHlwZS5yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkltYWdlRXJyb3IuSU5WQUxJRF9NRVRBX0VSUik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBFeGlmUGFyc2VyLnByb3RvdHlwZS53cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLklOVkFMSURfTUVUQV9FUlIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdFVOREVGSU5FRDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLkJZVEUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0UkFUSU9OQUw6IGZ1bmN0aW9uKGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5MT05HKGlkeCkgLyB0aGlzLkxPTkcoaWR4ICsgNClcblx0XHRcdH0sXG5cblxuXHRcdFx0U1JBVElPTkFMOiBmdW5jdGlvbihpZHgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuU0xPTkcoaWR4KSAvIHRoaXMuU0xPTkcoaWR4ICsgNClcblx0XHRcdH0sXG5cblx0XHRcdEFTQ0lJOiBmdW5jdGlvbihpZHgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuQ0hBUihpZHgpO1xuXHRcdFx0fSxcblxuXHRcdFx0VElGRjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBUaWZmIHx8IG51bGw7XG5cdFx0XHR9LFxuXG5cblx0XHRcdEVYSUY6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgRXhpZiA9IG51bGw7XG5cblx0XHRcdFx0aWYgKG9mZnNldHMuZXhpZklGRCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRFeGlmID0gZXh0cmFjdFRhZ3MuY2FsbCh0aGlzLCBvZmZzZXRzLmV4aWZJRkQsIHRhZ3MuZXhpZik7XG5cdFx0XHRcdFx0fSBjYXRjaChleCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRml4IGZvcm1hdHRpbmcgb2Ygc29tZSB0YWdzXG5cdFx0XHRcdFx0aWYgKEV4aWYuRXhpZlZlcnNpb24gJiYgQmFzaWMudHlwZU9mKEV4aWYuRXhpZlZlcnNpb24pID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgZXhpZlZlcnNpb24gPSAnJzsgaSA8IEV4aWYuRXhpZlZlcnNpb24ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0ZXhpZlZlcnNpb24gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShFeGlmLkV4aWZWZXJzaW9uW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdEV4aWYuRXhpZlZlcnNpb24gPSBleGlmVmVyc2lvbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gRXhpZjtcblx0XHRcdH0sXG5cblxuXHRcdFx0R1BTOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIEdQUyA9IG51bGw7XG5cblx0XHRcdFx0aWYgKG9mZnNldHMuZ3BzSUZEKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdEdQUyA9IGV4dHJhY3RUYWdzLmNhbGwodGhpcywgb2Zmc2V0cy5ncHNJRkQsIHRhZ3MuZ3BzKTtcblx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaU9TIGRldmljZXMgKGFuZCBwcm9iYWJseSBzb21lIG90aGVycykgZG8gbm90IHB1dCBpbiBHUFNWZXJzaW9uSUQgdGFnICh3aHk/Li4pXG5cdFx0XHRcdFx0aWYgKEdQUy5HUFNWZXJzaW9uSUQgJiYgQmFzaWMudHlwZU9mKEdQUy5HUFNWZXJzaW9uSUQpID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0XHRHUFMuR1BTVmVyc2lvbklEID0gR1BTLkdQU1ZlcnNpb25JRC5qb2luKCcuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIEdQUztcblx0XHRcdH0sXG5cblxuXHRcdFx0dGh1bWI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAob2Zmc2V0cy5JRkQxKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhciBJRkQxVGFncyA9IGV4dHJhY3RUYWdzLmNhbGwodGhpcywgb2Zmc2V0cy5JRkQxLCB0YWdzLnRodW1iKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCdKUEVHSW50ZXJjaGFuZ2VGb3JtYXQnIGluIElGRDFUYWdzKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLlNFR01FTlQob2Zmc2V0cy50aWZmSGVhZGVyICsgSUZEMVRhZ3MuSlBFR0ludGVyY2hhbmdlRm9ybWF0LCBJRkQxVGFncy5KUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4KSB7fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRzZXRFeGlmOiBmdW5jdGlvbih0YWcsIHZhbHVlKSB7XG5cdFx0XHRcdC8vIFJpZ2h0IG5vdyBvbmx5IHNldHRpbmcgb2Ygd2lkdGgvaGVpZ2h0IGlzIHBvc3NpYmxlXG5cdFx0XHRcdGlmICh0YWcgIT09ICdQaXhlbFhEaW1lbnNpb24nICYmIHRhZyAhPT0gJ1BpeGVsWURpbWVuc2lvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRcdFx0cmV0dXJuIHNldFRhZy5jYWxsKHRoaXMsICdleGlmJywgdGFnLCB2YWx1ZSk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X19zdXBlcl9fLmNsZWFyKCk7XG5cdFx0XHRcdGRhdGEgPSB0YWdzID0gdGFnRGVzY3MgPSBUaWZmID0gb2Zmc2V0cyA9IF9fc3VwZXJfXyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHRcdC8vIENoZWNrIGlmIHRoYXQncyBBUFAxIGFuZCB0aGF0IGl0IGhhcyBFWElGXG5cdFx0aWYgKHRoaXMuU0hPUlQoMCkgIT09IDB4RkZFMSB8fCB0aGlzLlNUUklORyg0LCA1KS50b1VwcGVyQ2FzZSgpICE9PSBcIkVYSUZcXDBcIikge1xuXHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkltYWdlRXJyb3IuSU5WQUxJRF9NRVRBX0VSUik7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHJlYWQgb3JkZXIgb2YgbXVsdGktYnl0ZSBkYXRhXG5cdFx0dGhpcy5saXR0bGVFbmRpYW4gPSAodGhpcy5TSE9SVChpZHgpID09IDB4NDk0OSk7XG5cblx0XHQvLyBDaGVjayBpZiBhbHdheXMgcHJlc2VudCBieXRlcyBhcmUgaW5kZWVkIHByZXNlbnRcblx0XHRpZiAodGhpcy5TSE9SVChpZHgrPTIpICE9PSAweDAwMkEpIHtcblx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLklOVkFMSURfTUVUQV9FUlIpO1xuXHRcdH1cblxuXHRcdG9mZnNldHMuSUZEMCA9IG9mZnNldHMudGlmZkhlYWRlciArIHRoaXMuTE9ORyhpZHggKz0gMik7XG5cdFx0VGlmZiA9IGV4dHJhY3RUYWdzLmNhbGwodGhpcywgb2Zmc2V0cy5JRkQwLCB0YWdzLnRpZmYpO1xuXG5cdFx0aWYgKCdFeGlmSUZEUG9pbnRlcicgaW4gVGlmZikge1xuXHRcdFx0b2Zmc2V0cy5leGlmSUZEID0gb2Zmc2V0cy50aWZmSGVhZGVyICsgVGlmZi5FeGlmSUZEUG9pbnRlcjtcblx0XHRcdGRlbGV0ZSBUaWZmLkV4aWZJRkRQb2ludGVyO1xuXHRcdH1cblxuXHRcdGlmICgnR1BTSW5mb0lGRFBvaW50ZXInIGluIFRpZmYpIHtcblx0XHRcdG9mZnNldHMuZ3BzSUZEID0gb2Zmc2V0cy50aWZmSGVhZGVyICsgVGlmZi5HUFNJbmZvSUZEUG9pbnRlcjtcblx0XHRcdGRlbGV0ZSBUaWZmLkdQU0luZm9JRkRQb2ludGVyO1xuXHRcdH1cblxuXHRcdGlmIChCYXNpYy5pc0VtcHR5T2JqKFRpZmYpKSB7XG5cdFx0XHRUaWZmID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBjaGVjayBpZiB3ZSBoYXZlIGEgdGh1bWIgYXMgd2VsbFxuXHRcdHZhciBJRkQxT2Zmc2V0ID0gdGhpcy5MT05HKG9mZnNldHMuSUZEMCArIHRoaXMuU0hPUlQob2Zmc2V0cy5JRkQwKSAqIDEyICsgMik7XG5cdFx0aWYgKElGRDFPZmZzZXQpIHtcblx0XHRcdG9mZnNldHMuSUZEMSA9IG9mZnNldHMudGlmZkhlYWRlciArIElGRDFPZmZzZXQ7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBleHRyYWN0VGFncyhJRkRfb2Zmc2V0LCB0YWdzMmV4dHJhY3QpIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcztcblx0XHRcdHZhciBsZW5ndGgsIGksIHRhZywgdHlwZSwgY291bnQsIHNpemUsIG9mZnNldCwgdmFsdWUsIHZhbHVlcyA9IFtdLCBoYXNoID0ge307XG5cdFx0XHRcblx0XHRcdHZhciB0eXBlcyA9IHtcblx0XHRcdFx0MSA6ICdCWVRFJyxcblx0XHRcdFx0NyA6ICdVTkRFRklORUQnLFxuXHRcdFx0XHQyIDogJ0FTQ0lJJyxcblx0XHRcdFx0MyA6ICdTSE9SVCcsXG5cdFx0XHRcdDQgOiAnTE9ORycsXG5cdFx0XHRcdDUgOiAnUkFUSU9OQUwnLFxuXHRcdFx0XHQ5IDogJ1NMT05HJyxcblx0XHRcdFx0MTA6ICdTUkFUSU9OQUwnXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgc2l6ZXMgPSB7XG5cdFx0XHRcdCdCWVRFJyBcdFx0OiAxLFxuXHRcdFx0XHQnVU5ERUZJTkVEJ1x0OiAxLFxuXHRcdFx0XHQnQVNDSUknXHRcdDogMSxcblx0XHRcdFx0J1NIT1JUJ1x0XHQ6IDIsXG5cdFx0XHRcdCdMT05HJyBcdFx0OiA0LFxuXHRcdFx0XHQnUkFUSU9OQUwnIFx0OiA4LFxuXHRcdFx0XHQnU0xPTkcnXHRcdDogNCxcblx0XHRcdFx0J1NSQVRJT05BTCdcdDogOFxuXHRcdFx0fTtcblxuXHRcdFx0bGVuZ3RoID0gZGF0YS5TSE9SVChJRkRfb2Zmc2V0KTtcblxuXHRcdFx0Ly8gVGhlIHNpemUgb2YgQVBQMSBpbmNsdWRpbmcgYWxsIHRoZXNlIGVsZW1lbnRzIHNoYWxsIG5vdCBleGNlZWQgdGhlIDY0IEtieXRlcyBzcGVjaWZpZWQgaW4gdGhlIEpQRUcgc3RhbmRhcmQuXG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHQvLyBTZXQgYmluYXJ5IHJlYWRlciBwb2ludGVyIHRvIGJlZ2lubmluZyBvZiB0aGUgbmV4dCB0YWdcblx0XHRcdFx0b2Zmc2V0ID0gSUZEX29mZnNldCArIDIgKyBpKjEyO1xuXG5cdFx0XHRcdHRhZyA9IHRhZ3MyZXh0cmFjdFtkYXRhLlNIT1JUKG9mZnNldCldO1xuXG5cdFx0XHRcdGlmICh0YWcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlOyAvLyBOb3QgdGhlIHRhZyB3ZSByZXF1ZXN0ZWRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR5cGUgPSB0eXBlc1tkYXRhLlNIT1JUKG9mZnNldCs9MildO1xuXHRcdFx0XHRjb3VudCA9IGRhdGEuTE9ORyhvZmZzZXQrPTIpO1xuXHRcdFx0XHRzaXplID0gc2l6ZXNbdHlwZV07XG5cblx0XHRcdFx0aWYgKCFzaXplKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkltYWdlRXJyb3IuSU5WQUxJRF9NRVRBX0VSUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdFx0XHQvLyB0YWcgY2FuIG9ubHkgZml0IDQgYnl0ZXMgb2YgZGF0YSwgaWYgZGF0YSBpcyBsYXJnZXIgd2Ugc2hvdWxkIGxvb2sgb3V0c2lkZVxuXHRcdFx0XHRpZiAoc2l6ZSAqIGNvdW50ID4gNCkge1xuXHRcdFx0XHRcdC8vIGluc3RlYWQgb2YgZGF0YSB0YWcgY29udGFpbnMgYW4gb2Zmc2V0IG9mIHRoZSBkYXRhXG5cdFx0XHRcdFx0b2Zmc2V0ID0gZGF0YS5MT05HKG9mZnNldCkgKyBvZmZzZXRzLnRpZmZIZWFkZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpbiBjYXNlIHdlIGxlZnQgdGhlIGJvdW5kYXJpZXMgb2YgZGF0YSB0aHJvdyBhbiBlYXJseSBleGNlcHRpb25cblx0XHRcdFx0aWYgKG9mZnNldCArIHNpemUgKiBjb3VudCA+PSB0aGlzLmxlbmd0aCgpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkltYWdlRXJyb3IuSU5WQUxJRF9NRVRBX0VSUik7XG5cdFx0XHRcdH0gXG5cblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXJlIGZvciB0aGUgc3RyaW5nXG5cdFx0XHRcdGlmICh0eXBlID09PSAnQVNDSUknKSB7XG5cdFx0XHRcdFx0aGFzaFt0YWddID0gQmFzaWMudHJpbShkYXRhLlNUUklORyhvZmZzZXQsIGNvdW50KS5yZXBsYWNlKC9cXDAkLywgJycpKTsgLy8gc3RyaXAgdHJhaWxpbmcgTlVMTFxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlcyA9IGRhdGEuYXNBcnJheSh0eXBlLCBvZmZzZXQsIGNvdW50KTtcblx0XHRcdFx0XHR2YWx1ZSA9IChjb3VudCA9PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzKTtcblxuXHRcdFx0XHRcdGlmICh0YWdEZXNjcy5oYXNPd25Qcm9wZXJ0eSh0YWcpICYmIHR5cGVvZiB2YWx1ZSAhPSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0aGFzaFt0YWddID0gdGFnRGVzY3NbdGFnXVt2YWx1ZV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhhc2hbdGFnXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9XG5cblx0XHQvLyBBdCB0aGUgbW9tZW50IG9ubHkgc2V0dGluZyBvZiBzaW1wbGUgKExPTkcpIHZhbHVlcywgdGhhdCBkbyBub3QgcmVxdWlyZSBvZmZzZXQgcmVjYWxjdWxhdGlvbiwgaXMgc3VwcG9ydGVkXG5cdFx0ZnVuY3Rpb24gc2V0VGFnKGlmZCwgdGFnLCB2YWx1ZSkge1xuXHRcdFx0dmFyIG9mZnNldCwgbGVuZ3RoLCB0YWdPZmZzZXQsIHZhbHVlT2Zmc2V0ID0gMDtcblxuXHRcdFx0Ly8gSWYgdGFnIG5hbWUgcGFzc2VkIHRyYW5zbGF0ZSBpbnRvIGhleCBrZXlcblx0XHRcdGlmICh0eXBlb2YodGFnKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmFyIHRtcFRhZ3MgPSB0YWdzW2lmZC50b0xvd2VyQ2FzZSgpXTtcblx0XHRcdFx0Zm9yICh2YXIgaGV4IGluIHRtcFRhZ3MpIHtcblx0XHRcdFx0XHRpZiAodG1wVGFnc1toZXhdID09PSB0YWcpIHtcblx0XHRcdFx0XHRcdHRhZyA9IGhleDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0c1tpZmQudG9Mb3dlckNhc2UoKSArICdJRkQnXTtcblx0XHRcdGxlbmd0aCA9IHRoaXMuU0hPUlQob2Zmc2V0KTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0YWdPZmZzZXQgPSBvZmZzZXQgKyAxMiAqIGkgKyAyO1xuXG5cdFx0XHRcdGlmICh0aGlzLlNIT1JUKHRhZ09mZnNldCkgPT0gdGFnKSB7XG5cdFx0XHRcdFx0dmFsdWVPZmZzZXQgPSB0YWdPZmZzZXQgKyA4O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdmFsdWVPZmZzZXQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLndyaXRlKHZhbHVlT2Zmc2V0LCB2YWx1ZSwgNCk7XG5cdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0RXhpZlBhcnNlci5wcm90b3R5cGUgPSBCaW5hcnlSZWFkZXIucHJvdG90eXBlO1xuXG5cdHJldHVybiBFeGlmUGFyc2VyO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDUvaW1hZ2UvSlBFRy5qc1xuXG4vKipcbiAqIEpQRUcuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9KUEVHXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSlBFR1wiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSlBFR0hlYWRlcnNcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L3V0aWxzL0JpbmFyeVJlYWRlclwiLFxuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvRXhpZlBhcnNlclwiXG5dLCBmdW5jdGlvbihCYXNpYywgeCwgSlBFR0hlYWRlcnMsIEJpbmFyeVJlYWRlciwgRXhpZlBhcnNlcikge1xuXHRcblx0ZnVuY3Rpb24gSlBFRyhkYXRhKSB7XG5cdFx0dmFyIF9iciwgX2htLCBfZXAsIF9pbmZvO1xuXG5cdFx0X2JyID0gbmV3IEJpbmFyeVJlYWRlcihkYXRhKTtcblxuXHRcdC8vIGNoZWNrIGlmIGl0IGlzIGpwZWdcblx0XHRpZiAoX2JyLlNIT1JUKDApICE9PSAweEZGRDgpIHtcblx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLldST05HX0ZPUk1BVCk7XG5cdFx0fVxuXG5cdFx0Ly8gYmFja3VwIGhlYWRlcnNcblx0XHRfaG0gPSBuZXcgSlBFR0hlYWRlcnMoZGF0YSk7XG5cblx0XHQvLyBleHRyYWN0IGV4aWYgaW5mb1xuXHRcdHRyeSB7XG5cdFx0XHRfZXAgPSBuZXcgRXhpZlBhcnNlcihfaG0uZ2V0KCdhcHAxJylbMF0pO1xuXHRcdH0gY2F0Y2goZXgpIHt9XG5cblx0XHQvLyBnZXQgZGltZW5zaW9uc1xuXHRcdF9pbmZvID0gX2dldERpbWVuc2lvbnMuY2FsbCh0aGlzKTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHR0eXBlOiAnaW1hZ2UvanBlZycsXG5cblx0XHRcdHNpemU6IF9ici5sZW5ndGgoKSxcblxuXHRcdFx0d2lkdGg6IF9pbmZvICYmIF9pbmZvLndpZHRoIHx8IDAsXG5cblx0XHRcdGhlaWdodDogX2luZm8gJiYgX2luZm8uaGVpZ2h0IHx8IDAsXG5cblx0XHRcdHNldEV4aWY6IGZ1bmN0aW9uKHRhZywgdmFsdWUpIHtcblx0XHRcdFx0aWYgKCFfZXApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIG9yIHRocm93IGFuIGV4Y2VwdGlvblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKEJhc2ljLnR5cGVPZih0YWcpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdEJhc2ljLmVhY2godGFnLCBmdW5jdGlvbih2YWx1ZSwgdGFnKSB7XG5cdFx0XHRcdFx0XHRfZXAuc2V0RXhpZih0YWcsIHZhbHVlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZXAuc2V0RXhpZih0YWcsIHZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSBpbnRlcm5hbCBoZWFkZXJzXG5cdFx0XHRcdF9obS5zZXQoJ2FwcDEnLCBfZXAuU0VHTUVOVCgpKTtcblx0XHRcdH0sXG5cblx0XHRcdHdyaXRlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdC8vIGlmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIHVwZGF0ZSBoZWFkZXJzIGludGVybmFsbHlcblx0XHRcdFx0XHRyZXR1cm4gX2htLnJlc3RvcmUoZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIF9obS5yZXN0b3JlKGFyZ3VtZW50c1swXSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzdHJpcEhlYWRlcnM6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIF9obS5zdHJpcChkYXRhKTtcblx0XHRcdH0sXG5cblx0XHRcdHB1cmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X3B1cmdlLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoX2VwKSB7XG5cdFx0XHR0aGlzLm1ldGEgPSB7XG5cdFx0XHRcdHRpZmY6IF9lcC5USUZGKCksXG5cdFx0XHRcdGV4aWY6IF9lcC5FWElGKCksXG5cdFx0XHRcdGdwczogX2VwLkdQUygpLFxuXHRcdFx0XHR0aHVtYjogX2dldFRodW1iKClcblx0XHRcdH07XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfZ2V0RGltZW5zaW9ucyhicikge1xuXHRcdFx0dmFyIGlkeCA9IDBcblx0XHRcdCwgbWFya2VyXG5cdFx0XHQsIGxlbmd0aFxuXHRcdFx0O1xuXG5cdFx0XHRpZiAoIWJyKSB7XG5cdFx0XHRcdGJyID0gX2JyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBleGFtaW5lIGFsbCB0aHJvdWdoIHRoZSBlbmQsIHNpbmNlIHNvbWUgaW1hZ2VzIG1pZ2h0IGhhdmUgdmVyeSBsYXJnZSBBUFAgc2VnbWVudHNcblx0XHRcdHdoaWxlIChpZHggPD0gYnIubGVuZ3RoKCkpIHtcblx0XHRcdFx0bWFya2VyID0gYnIuU0hPUlQoaWR4ICs9IDIpO1xuXG5cdFx0XHRcdGlmIChtYXJrZXIgPj0gMHhGRkMwICYmIG1hcmtlciA8PSAweEZGQzMpIHsgLy8gU09GblxuXHRcdFx0XHRcdGlkeCArPSA1OyAvLyBtYXJrZXIgKDIgYnl0ZXMpICsgbGVuZ3RoICgyIGJ5dGVzKSArIFNhbXBsZSBwcmVjaXNpb24gKDEgYnl0ZSlcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0aGVpZ2h0OiBici5TSE9SVChpZHgpLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGJyLlNIT1JUKGlkeCArPSAyKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVuZ3RoID0gYnIuU0hPUlQoaWR4ICs9IDIpO1xuXHRcdFx0XHRpZHggKz0gbGVuZ3RoIC0gMjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2dldFRodW1iKCkge1xuXHRcdFx0dmFyIGRhdGEgPSAgX2VwLnRodW1iKClcblx0XHRcdCwgYnJcblx0XHRcdCwgaW5mb1xuXHRcdFx0O1xuXG5cdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRiciA9IG5ldyBCaW5hcnlSZWFkZXIoZGF0YSk7XG5cdFx0XHRcdGluZm8gPSBfZ2V0RGltZW5zaW9ucyhicik7XG5cdFx0XHRcdGJyLmNsZWFyKCk7XG5cblx0XHRcdFx0aWYgKGluZm8pIHtcblx0XHRcdFx0XHRpbmZvLmRhdGEgPSBkYXRhO1xuXHRcdFx0XHRcdHJldHVybiBpbmZvO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9wdXJnZSgpIHtcblx0XHRcdGlmICghX2VwIHx8ICFfaG0gfHwgIV9icikgeyBcblx0XHRcdFx0cmV0dXJuOyAvLyBpZ25vcmUgYW55IHJlcGVhdGluZyBwdXJnZSByZXF1ZXN0c1xuXHRcdFx0fVxuXHRcdFx0X2VwLmNsZWFyKCk7XG5cdFx0XHRfaG0ucHVyZ2UoKTtcblx0XHRcdF9ici5jbGVhcigpO1xuXHRcdFx0X2luZm8gPSBfaG0gPSBfZXAgPSBfYnIgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBKUEVHO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDUvaW1hZ2UvUE5HLmpzXG5cbi8qKlxuICogUE5HLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvUE5HXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvUE5HXCIsIFtcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvcnVudGltZS9odG1sNS91dGlscy9CaW5hcnlSZWFkZXJcIlxuXSwgZnVuY3Rpb24oeCwgQmFzaWMsIEJpbmFyeVJlYWRlcikge1xuXHRcblx0ZnVuY3Rpb24gUE5HKGRhdGEpIHtcblx0XHR2YXIgX2JyLCBfaG0sIF9lcCwgX2luZm87XG5cblx0XHRfYnIgPSBuZXcgQmluYXJ5UmVhZGVyKGRhdGEpO1xuXG5cdFx0Ly8gY2hlY2sgaWYgaXQncyBwbmdcblx0XHQoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaWR4ID0gMCwgaSA9IDBcblx0XHRcdCwgc2lnbmF0dXJlID0gWzB4ODk1MCwgMHg0RTQ3LCAweDBEMEEsIDB4MUEwQV1cblx0XHRcdDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7IGkrKywgaWR4ICs9IDIpIHtcblx0XHRcdFx0aWYgKHNpZ25hdHVyZVtpXSAhPSBfYnIuU0hPUlQoaWR4KSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyB4LkltYWdlRXJyb3IoeC5JbWFnZUVycm9yLldST05HX0ZPUk1BVCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KCkpO1xuXG5cdFx0ZnVuY3Rpb24gX2dldERpbWVuc2lvbnMoKSB7XG5cdFx0XHR2YXIgY2h1bmssIGlkeDtcblxuXHRcdFx0Y2h1bmsgPSBfZ2V0Q2h1bmtBdC5jYWxsKHRoaXMsIDgpO1xuXG5cdFx0XHRpZiAoY2h1bmsudHlwZSA9PSAnSUhEUicpIHtcblx0XHRcdFx0aWR4ID0gY2h1bmsuc3RhcnQ7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0d2lkdGg6IF9ici5MT05HKGlkeCksXG5cdFx0XHRcdFx0aGVpZ2h0OiBfYnIuTE9ORyhpZHggKz0gNClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF9wdXJnZSgpIHtcblx0XHRcdGlmICghX2JyKSB7XG5cdFx0XHRcdHJldHVybjsgLy8gaWdub3JlIGFueSByZXBlYXRpbmcgcHVyZ2UgcmVxdWVzdHNcblx0XHRcdH1cblx0XHRcdF9ici5jbGVhcigpO1xuXHRcdFx0ZGF0YSA9IF9pbmZvID0gX2htID0gX2VwID0gX2JyID0gbnVsbDtcblx0XHR9XG5cblx0XHRfaW5mbyA9IF9nZXREaW1lbnNpb25zLmNhbGwodGhpcyk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0dHlwZTogJ2ltYWdlL3BuZycsXG5cblx0XHRcdHNpemU6IF9ici5sZW5ndGgoKSxcblxuXHRcdFx0d2lkdGg6IF9pbmZvLndpZHRoLFxuXG5cdFx0XHRoZWlnaHQ6IF9pbmZvLmhlaWdodCxcblxuXHRcdFx0cHVyZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfcHVyZ2UuY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGZvciBQTkcgd2UgY2FuIHNhZmVseSB0cmlnZ2VyIHB1cmdlIGF1dG9tYXRpY2FsbHksIGFzIHdlIGRvIG5vdCBrZWVwIGFueSBkYXRhIGZvciBsYXRlclxuXHRcdF9wdXJnZS5jYWxsKHRoaXMpO1xuXG5cdFx0ZnVuY3Rpb24gX2dldENodW5rQXQoaWR4KSB7XG5cdFx0XHR2YXIgbGVuZ3RoLCB0eXBlLCBzdGFydCwgQ1JDO1xuXG5cdFx0XHRsZW5ndGggPSBfYnIuTE9ORyhpZHgpO1xuXHRcdFx0dHlwZSA9IF9ici5TVFJJTkcoaWR4ICs9IDQsIDQpO1xuXHRcdFx0c3RhcnQgPSBpZHggKz0gNDtcblx0XHRcdENSQyA9IF9ici5MT05HKGlkeCArIGxlbmd0aCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGxlbmd0aDogbGVuZ3RoLFxuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRcdENSQzogQ1JDXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBQTkc7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNS9pbWFnZS9JbWFnZUluZm8uanNcblxuLyoqXG4gKiBJbWFnZUluZm8uanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9JbWFnZUluZm9cbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9JbWFnZUluZm9cIiwgW1xuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0pQRUdcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL1BOR1wiXG5dLCBmdW5jdGlvbihCYXNpYywgeCwgSlBFRywgUE5HKSB7XG5cdC8qKlxuXHRPcHRpb25hbCBpbWFnZSBpbnZlc3RpZ2F0aW9uIHRvb2wgZm9yIEhUTUw1IHJ1bnRpbWUuIFByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXM6XG5cdC0gYWJpbGl0eSB0byBkaXN0aW5ndWlzaCBpbWFnZSB0eXBlIChKUEVHIG9yIFBORykgYnkgc2lnbmF0dXJlXG5cdC0gYWJpbGl0eSB0byBleHRyYWN0IGltYWdlIHdpZHRoL2hlaWdodCBkaXJlY3RseSBmcm9tIGl0J3MgaW50ZXJuYWxzLCB3aXRob3V0IHByZWxvYWRpbmcgaW4gbWVtb3J5IChmYXN0KVxuXHQtIGFiaWxpdHkgdG8gZXh0cmFjdCBBUFAgaGVhZGVycyBmcm9tIEpQRUdzIChFeGlmLCBHUFMsIGV0Yylcblx0LSBhYmlsaXR5IHRvIHJlcGxhY2Ugd2lkdGgvaGVpZ2h0IHRhZ3MgaW4gZXh0cmFjdGVkIEpQRUcgaGVhZGVyc1xuXHQtIGFiaWxpdHkgdG8gcmVzdG9yZSBBUFAgaGVhZGVycywgdGhhdCB3ZXJlIGZvciBleGFtcGxlIHN0cmlwcGVkIGR1cmluZyBpbWFnZSBtYW5pcHVsYXRpb25cblxuXHRAY2xhc3MgSW1hZ2VJbmZvXG5cdEBjb25zdHJ1Y3RvclxuXHRAcGFyYW0ge1N0cmluZ30gZGF0YSBJbWFnZSBzb3VyY2UgYXMgYmluYXJ5IHN0cmluZ1xuXHQqL1xuXHRyZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuXHRcdHZhciBfY3MgPSBbSlBFRywgUE5HXSwgX2ltZztcblxuXHRcdC8vIGZpZ3VyZSBvdXQgdGhlIGZvcm1hdCwgdGhyb3c6IEltYWdlRXJyb3IuV1JPTkdfRk9STUFUIGlmIG5vdCBzdXBwb3J0ZWRcblx0XHRfaW1nID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBfY3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IF9jc1tpXShkYXRhKTtcblx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmluZm8oZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgeC5JbWFnZUVycm9yKHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdH0oKSk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0LyoqXG5cdFx0XHRJbWFnZSBNaW1lIFR5cGUgZXh0cmFjdGVkIGZyb20gaXQncyBkZXB0aHNcblxuXHRcdFx0QHByb3BlcnR5IHR5cGVcblx0XHRcdEB0eXBlIHtTdHJpbmd9XG5cdFx0XHRAZGVmYXVsdCAnJ1xuXHRcdFx0Ki9cblx0XHRcdHR5cGU6ICcnLFxuXG5cdFx0XHQvKipcblx0XHRcdEltYWdlIHNpemUgaW4gYnl0ZXNcblxuXHRcdFx0QHByb3BlcnR5IHNpemVcblx0XHRcdEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHRAZGVmYXVsdCAwXG5cdFx0XHQqL1xuXHRcdFx0c2l6ZTogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHRJbWFnZSB3aWR0aCBleHRyYWN0ZWQgZnJvbSBpbWFnZSBzb3VyY2VcblxuXHRcdFx0QHByb3BlcnR5IHdpZHRoXG5cdFx0XHRAdHlwZSB7TnVtYmVyfVxuXHRcdFx0QGRlZmF1bHQgMFxuXHRcdFx0Ki9cblx0XHRcdHdpZHRoOiAwLFxuXG5cdFx0XHQvKipcblx0XHRcdEltYWdlIGhlaWdodCBleHRyYWN0ZWQgZnJvbSBpbWFnZSBzb3VyY2VcblxuXHRcdFx0QHByb3BlcnR5IGhlaWdodFxuXHRcdFx0QHR5cGUge051bWJlcn1cblx0XHRcdEBkZWZhdWx0IDBcblx0XHRcdCovXG5cdFx0XHRoZWlnaHQ6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0U2V0cyBFeGlmIHRhZy4gQ3VycmVudGx5IGFwcGxpY2FibGUgb25seSBmb3Igd2lkdGggYW5kIGhlaWdodCB0YWdzLiBPYnZpb3VzbHkgd29ya3Mgb25seSB3aXRoIEpQRUdzLlxuXG5cdFx0XHRAbWV0aG9kIHNldEV4aWZcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSB0YWcgVGFnIHRvIHNldFxuXHRcdFx0QHBhcmFtIHtNaXhlZH0gdmFsdWUgVmFsdWUgdG8gYXNzaWduIHRvIHRoZSB0YWdcblx0XHRcdCovXG5cdFx0XHRzZXRFeGlmOiBmdW5jdGlvbigpIHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdFJlc3RvcmVzIGhlYWRlcnMgdG8gdGhlIHNvdXJjZS5cblxuXHRcdFx0QG1ldGhvZCB3cml0ZUhlYWRlcnNcblx0XHRcdEBwYXJhbSB7U3RyaW5nfSBkYXRhIEltYWdlIHNvdXJjZSBhcyBiaW5hcnkgc3RyaW5nXG5cdFx0XHRAcmV0dXJuIHtTdHJpbmd9IFVwZGF0ZWQgYmluYXJ5IHN0cmluZ1xuXHRcdFx0Ki9cblx0XHRcdHdyaXRlSGVhZGVyczogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0U3RyaXAgYWxsIGhlYWRlcnMgZnJvbSB0aGUgc291cmNlLlxuXG5cdFx0XHRAbWV0aG9kIHN0cmlwSGVhZGVyc1xuXHRcdFx0QHBhcmFtIHtTdHJpbmd9IGRhdGEgSW1hZ2Ugc291cmNlIGFzIGJpbmFyeSBzdHJpbmdcblx0XHRcdEByZXR1cm4ge1N0cmluZ30gVXBkYXRlZCBiaW5hcnkgc3RyaW5nXG5cdFx0XHQqL1xuXHRcdFx0c3RyaXBIZWFkZXJzOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHREaXNwb3NlIHJlc291cmNlcy5cblxuXHRcdFx0QG1ldGhvZCBwdXJnZVxuXHRcdFx0Ki9cblx0XHRcdHB1cmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywgX2ltZyk7XG5cblx0XHR0aGlzLnB1cmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRfaW1nLnB1cmdlKCk7XG5cdFx0XHRfaW1nID0gbnVsbDtcblx0XHR9O1xuXHR9O1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDUvaW1hZ2UvUmVzaXplckNhbnZhcy5qc1xuXG4vKipcbiAqIFJlc2l6ZXJDYW52YXMuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG4gKiBSZXNpemVzIGltYWdlL2NhbnZhcyB1c2luZyBjYW52YXNcbiAqL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9SZXNpemVyQ2FudmFzXCIsIFtdLCBmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIHNjYWxlKGltYWdlLCByYXRpbykge1xuICAgICAgICB2YXIgc1cgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGRXID0gTWF0aC5mbG9vcihzVyAqIHJhdGlvKTtcbiAgICAgICAgdmFyIHNjYWxlQ2FwcGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHJhdGlvIDwgMC41IHx8IHJhdGlvID4gMikge1xuICAgICAgICAgICAgcmF0aW8gPSByYXRpbyA8IDAuNSA/IDAuNSA6IDI7XG4gICAgICAgICAgICBzY2FsZUNhcHBlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdENhbnZhcyA9IF9zY2FsZShpbWFnZSwgcmF0aW8pO1xuXG4gICAgICAgIGlmIChzY2FsZUNhcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlKHRDYW52YXMsIGRXIC8gdENhbnZhcy53aWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdENhbnZhcztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gX3NjYWxlKGltYWdlLCByYXRpbykge1xuICAgICAgICB2YXIgc1cgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIHNIID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB2YXIgZFcgPSBNYXRoLmZsb29yKHNXICogcmF0aW8pO1xuICAgICAgICB2YXIgZEggPSBNYXRoLmZsb29yKHNIICogcmF0aW8pO1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gZFc7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkSDtcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHNXLCBzSCwgMCwgMCwgZFcsIGRIKTtcblxuICAgICAgICBpbWFnZSA9IG51bGw7IC8vIGp1c3QgaW4gY2FzZVxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlOiBzY2FsZVxuICAgIH07XG5cbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2h0bWw1L2ltYWdlL0ltYWdlLmpzXG5cbi8qKlxuICogSW1hZ2UuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNS9pbWFnZS9JbWFnZVxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0ltYWdlXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbmNvZGVcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVcIixcblx0XCJtb3hpZS9ydW50aW1lL2h0bWw1L2ltYWdlL0ltYWdlSW5mb1wiLFxuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvUmVzaXplckNhbnZhc1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvTWltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJhc2ljLCB4LCBFbmNvZGUsIEJsb2IsIEZpbGUsIEltYWdlSW5mbywgUmVzaXplckNhbnZhcywgTWltZSwgRW52KSB7XG5cblx0ZnVuY3Rpb24gSFRNTDVJbWFnZSgpIHtcblx0XHR2YXIgbWUgPSB0aGlzXG5cdFx0LCBfaW1nLCBfaW1nSW5mbywgX2NhbnZhcywgX2JpblN0ciwgX2Jsb2Jcblx0XHQsIF9tb2RpZmllZCA9IGZhbHNlIC8vIGlzIHNldCB0cnVlIHdoZW5ldmVyIGltYWdlIGlzIG1vZGlmaWVkXG5cdFx0LCBfcHJlc2VydmVIZWFkZXJzID0gdHJ1ZVxuXHRcdDtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRsb2FkRnJvbUJsb2I6IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdFx0dmFyIEkgPSB0aGlzLmdldFJ1bnRpbWUoKVxuXHRcdFx0XHQsIGFzQmluYXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB0cnVlXG5cdFx0XHRcdDtcblxuXHRcdFx0XHRpZiAoIUkuY2FuKCdhY2Nlc3NfYmluYXJ5JykpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgeC5SdW50aW1lRXJyb3IoeC5SdW50aW1lRXJyb3IuTk9UX1NVUFBPUlRFRF9FUlIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2Jsb2IgPSBibG9iO1xuXG5cdFx0XHRcdGlmIChibG9iLmlzRGV0YWNoZWQoKSkge1xuXHRcdFx0XHRcdF9iaW5TdHIgPSBibG9iLmdldFNvdXJjZSgpO1xuXHRcdFx0XHRcdF9wcmVsb2FkLmNhbGwodGhpcywgX2JpblN0cik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9yZWFkQXNEYXRhVXJsLmNhbGwodGhpcywgYmxvYi5nZXRTb3VyY2UoKSwgZnVuY3Rpb24oZGF0YVVybCkge1xuXHRcdFx0XHRcdFx0aWYgKGFzQmluYXJ5KSB7XG5cdFx0XHRcdFx0XHRcdF9iaW5TdHIgPSBfdG9CaW5hcnkoZGF0YVVybCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfcHJlbG9hZC5jYWxsKHRoaXMsIGRhdGFVcmwpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRsb2FkRnJvbUltYWdlOiBmdW5jdGlvbihpbWcsIGV4YWN0KSB7XG5cdFx0XHRcdHRoaXMubWV0YSA9IGltZy5tZXRhO1xuXG5cdFx0XHRcdF9ibG9iID0gbmV3IEZpbGUobnVsbCwge1xuXHRcdFx0XHRcdG5hbWU6IGltZy5uYW1lLFxuXHRcdFx0XHRcdHNpemU6IGltZy5zaXplLFxuXHRcdFx0XHRcdHR5cGU6IGltZy50eXBlXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF9wcmVsb2FkLmNhbGwodGhpcywgZXhhY3QgPyAoX2JpblN0ciA9IGltZy5nZXRBc0JpbmFyeVN0cmluZygpKSA6IGltZy5nZXRBc0RhdGFVUkwoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRJbmZvOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIEkgPSB0aGlzLmdldFJ1bnRpbWUoKSwgaW5mbztcblxuXHRcdFx0XHRpZiAoIV9pbWdJbmZvICYmIF9iaW5TdHIgJiYgSS5jYW4oJ2FjY2Vzc19pbWFnZV9iaW5hcnknKSkge1xuXHRcdFx0XHRcdF9pbWdJbmZvID0gbmV3IEltYWdlSW5mbyhfYmluU3RyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRoaXMgc3R1ZmYgYmVsb3cgaXMgZGVmaW5pdGVseSBoYXZpbmcgZnVuIHdpdGggaXRzZWxmXG5cdFx0XHRcdGluZm8gPSB7XG5cdFx0XHRcdFx0d2lkdGg6IF9nZXRJbWcoKS53aWR0aCB8fCAwLFxuXHRcdFx0XHRcdGhlaWdodDogX2dldEltZygpLmhlaWdodCB8fCAwLFxuXHRcdFx0XHRcdHR5cGU6IF9ibG9iLnR5cGUgfHwgTWltZS5nZXRGaWxlTWltZShfYmxvYi5uYW1lKSxcblx0XHRcdFx0XHRzaXplOiBfYmluU3RyICYmIF9iaW5TdHIubGVuZ3RoIHx8IF9ibG9iLnNpemUgfHwgMCxcblx0XHRcdFx0XHRuYW1lOiBfYmxvYi5uYW1lIHx8ICcnLFxuXHRcdFx0XHRcdG1ldGE6IG51bGxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoX3ByZXNlcnZlSGVhZGVycykge1xuXHRcdFx0XHRcdGluZm8ubWV0YSA9IF9pbWdJbmZvICYmIF9pbWdJbmZvLm1ldGEgfHwgdGhpcy5tZXRhIHx8IHt9O1xuXG5cdFx0XHRcdFx0Ly8gaWYgZGF0YSB3YXMgdGFrZW4gZnJvbSBJbWFnZUluZm8gaXQgd2lsbCBiZSBhIGJpbmFyeSBzdHJpbmcsIHNvIHdlIGNvbnZlcnQgaXQgdG8gYmxvYlxuXHRcdFx0XHRcdGlmIChpbmZvLm1ldGEgJiYgaW5mby5tZXRhLnRodW1iICYmICEoaW5mby5tZXRhLnRodW1iLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSkge1xuXHRcdFx0XHRcdFx0aW5mby5tZXRhLnRodW1iLmRhdGEgPSBuZXcgQmxvYihudWxsLCB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdpbWFnZS9qcGVnJyxcblx0XHRcdFx0XHRcdFx0ZGF0YTogaW5mby5tZXRhLnRodW1iLmRhdGFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbmZvO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRyZXNpemU6IGZ1bmN0aW9uKHJlY3QsIHJhdGlvLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gcmVjdC53aWR0aDtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG5cdFx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKF9nZXRJbWcoKSwgcmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0XHRcdF9jYW52YXMgPSBSZXNpemVyQ2FudmFzLnNjYWxlKGNhbnZhcywgcmF0aW8pO1xuXG5cdFx0XHRcdF9wcmVzZXJ2ZUhlYWRlcnMgPSBvcHRpb25zLnByZXNlcnZlSGVhZGVycztcblxuXHRcdFx0XHQvLyByb3RhdGUgaWYgcmVxdWlyZWQsIGFjY29yZGluZyB0byBvcmllbnRhdGlvbiB0YWdcblx0XHRcdFx0aWYgKCFfcHJlc2VydmVIZWFkZXJzKSB7XG5cdFx0XHRcdFx0dmFyIG9yaWVudGF0aW9uID0gKHRoaXMubWV0YSAmJiB0aGlzLm1ldGEudGlmZiAmJiB0aGlzLm1ldGEudGlmZi5PcmllbnRhdGlvbikgfHwgMTtcblx0XHRcdFx0XHRfY2FudmFzID0gX3JvdGF0ZVRvT3JpZW50YWlvbihfY2FudmFzLCBvcmllbnRhdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLndpZHRoID0gX2NhbnZhcy53aWR0aDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBfY2FudmFzLmhlaWdodDtcblxuXHRcdFx0XHRfbW9kaWZpZWQgPSB0cnVlO1xuXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignUmVzaXplJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBc0NhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghX2NhbnZhcykge1xuXHRcdFx0XHRcdF9jYW52YXMgPSBfZ2V0Q2FudmFzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2NhbnZhcy5pZCA9IHRoaXMudWlkICsgJ19jYW52YXMnO1xuXHRcdFx0XHRyZXR1cm4gX2NhbnZhcztcblx0XHRcdH0sXG5cblx0XHRcdGdldEFzQmxvYjogZnVuY3Rpb24odHlwZSwgcXVhbGl0eSkge1xuXHRcdFx0XHRpZiAodHlwZSAhPT0gdGhpcy50eXBlKSB7XG5cdFx0XHRcdFx0X21vZGlmaWVkID0gdHJ1ZTsgLy8gcmVjb25zaWRlciB0aGUgc3RhdGVcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEZpbGUobnVsbCwge1xuXHRcdFx0XHRcdFx0bmFtZTogX2Jsb2IubmFtZSB8fCAnJyxcblx0XHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0XHRkYXRhOiBtZS5nZXRBc0RhdGFVUkwodHlwZSwgcXVhbGl0eSlcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmV3IEZpbGUobnVsbCwge1xuXHRcdFx0XHRcdG5hbWU6IF9ibG9iLm5hbWUgfHwgJycsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRkYXRhOiBtZS5nZXRBc0JpbmFyeVN0cmluZyh0eXBlLCBxdWFsaXR5KVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdGdldEFzRGF0YVVSTDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHR2YXIgcXVhbGl0eSA9IGFyZ3VtZW50c1sxXSB8fCA5MDtcblxuXHRcdFx0XHQvLyBpZiBpbWFnZSBoYXMgbm90IGJlZW4gbW9kaWZpZWQsIHJldHVybiB0aGUgc291cmNlIHJpZ2h0IGF3YXlcblx0XHRcdFx0aWYgKCFfbW9kaWZpZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2ltZy5zcmM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhIGNhbnZhcyB0byB3b3JrIHdpdGhcblx0XHRcdFx0X2dldENhbnZhcygpO1xuXG5cdFx0XHRcdGlmICgnaW1hZ2UvanBlZycgIT09IHR5cGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2NhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHQvLyBvbGRlciBHZWNrb3MgdXNlZCB0byByZXN1bHQgaW4gYW4gZXhjZXB0aW9uIG9uIHF1YWxpdHkgYXJndW1lbnRcblx0XHRcdFx0XHRcdHJldHVybiBfY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkvMTAwKTtcblx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9jYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBc0JpbmFyeVN0cmluZzogZnVuY3Rpb24odHlwZSwgcXVhbGl0eSkge1xuXHRcdFx0XHQvLyBpZiBpbWFnZSBoYXMgbm90IGJlZW4gbW9kaWZpZWQsIHJldHVybiB0aGUgc291cmNlIHJpZ2h0IGF3YXlcblx0XHRcdFx0aWYgKCFfbW9kaWZpZWQpIHtcblx0XHRcdFx0XHQvLyBpZiBpbWFnZSB3YXMgbm90IGxvYWRlZCBmcm9tIGJpbmFyeSBzdHJpbmdcblx0XHRcdFx0XHRpZiAoIV9iaW5TdHIpIHtcblx0XHRcdFx0XHRcdF9iaW5TdHIgPSBfdG9CaW5hcnkobWUuZ2V0QXNEYXRhVVJMKHR5cGUsIHF1YWxpdHkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIF9iaW5TdHI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoJ2ltYWdlL2pwZWcnICE9PSB0eXBlKSB7XG5cdFx0XHRcdFx0X2JpblN0ciA9IF90b0JpbmFyeShtZS5nZXRBc0RhdGFVUkwodHlwZSwgcXVhbGl0eSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBkYXRhVXJsO1xuXG5cdFx0XHRcdFx0Ly8gaWYganBlZ1xuXHRcdFx0XHRcdGlmICghcXVhbGl0eSkge1xuXHRcdFx0XHRcdFx0cXVhbGl0eSA9IDkwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2FudmFzIHRvIHdvcmsgd2l0aFxuXHRcdFx0XHRcdF9nZXRDYW52YXMoKTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHQvLyBvbGRlciBHZWNrb3MgdXNlZCB0byByZXN1bHQgaW4gYW4gZXhjZXB0aW9uIG9uIHF1YWxpdHkgYXJndW1lbnRcblx0XHRcdFx0XHRcdGRhdGFVcmwgPSBfY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkvMTAwKTtcblx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0ZGF0YVVybCA9IF9jYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2JpblN0ciA9IF90b0JpbmFyeShkYXRhVXJsKTtcblxuXHRcdFx0XHRcdGlmIChfaW1nSW5mbykge1xuXHRcdFx0XHRcdFx0X2JpblN0ciA9IF9pbWdJbmZvLnN0cmlwSGVhZGVycyhfYmluU3RyKTtcblxuXHRcdFx0XHRcdFx0aWYgKF9wcmVzZXJ2ZUhlYWRlcnMpIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXBkYXRlIGRpbWVuc2lvbnMgaW5mbyBpbiBleGlmXG5cdFx0XHRcdFx0XHRcdGlmIChfaW1nSW5mby5tZXRhICYmIF9pbWdJbmZvLm1ldGEuZXhpZikge1xuXHRcdFx0XHRcdFx0XHRcdF9pbWdJbmZvLnNldEV4aWYoe1xuXHRcdFx0XHRcdFx0XHRcdFx0UGl4ZWxYRGltZW5zaW9uOiB0aGlzLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdFx0UGl4ZWxZRGltZW5zaW9uOiB0aGlzLmhlaWdodFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmUtaW5qZWN0IHRoZSBoZWFkZXJzXG5cdFx0XHRcdFx0XHRcdF9iaW5TdHIgPSBfaW1nSW5mby53cml0ZUhlYWRlcnMoX2JpblN0cik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHdpbGwgYmUgcmUtY3JlYXRlZCBmcm9tIGZyZXNoIG9uIG5leHQgZ2V0SW5mbyBjYWxsXG5cdFx0XHRcdFx0XHRfaW1nSW5mby5wdXJnZSgpO1xuXHRcdFx0XHRcdFx0X2ltZ0luZm8gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9tb2RpZmllZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHJldHVybiBfYmluU3RyO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1lID0gbnVsbDtcblx0XHRcdFx0X3B1cmdlLmNhbGwodGhpcyk7XG5cdFx0XHRcdHRoaXMuZ2V0UnVudGltZSgpLmdldFNoaW0oKS5yZW1vdmVJbnN0YW5jZSh0aGlzLnVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHRcdGZ1bmN0aW9uIF9nZXRJbWcoKSB7XG5cdFx0XHRpZiAoIV9jYW52YXMgJiYgIV9pbWcpIHtcblx0XHRcdFx0dGhyb3cgbmV3IHguSW1hZ2VFcnJvcih4LkRPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX2NhbnZhcyB8fCBfaW1nO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2dldENhbnZhcygpIHtcblx0XHRcdHZhciBjYW52YXMgPSBfZ2V0SW1nKCk7XG5cdFx0XHRpZiAoY2FudmFzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2NhbnZhcycpIHtcblx0XHRcdFx0cmV0dXJuIGNhbnZhcztcblx0XHRcdH1cblx0XHRcdF9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdF9jYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cdFx0XHRfY2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cdFx0XHRfY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblx0XHRcdHJldHVybiBfY2FudmFzO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3RvQmluYXJ5KHN0cikge1xuXHRcdFx0cmV0dXJuIEVuY29kZS5hdG9iKHN0ci5zdWJzdHJpbmcoc3RyLmluZGV4T2YoJ2Jhc2U2NCwnKSArIDcpKTtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF90b0RhdGFVcmwoc3RyLCB0eXBlKSB7XG5cdFx0XHRyZXR1cm4gJ2RhdGE6JyArICh0eXBlIHx8ICcnKSArICc7YmFzZTY0LCcgKyBFbmNvZGUuYnRvYShzdHIpO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3ByZWxvYWQoc3RyKSB7XG5cdFx0XHR2YXIgY29tcCA9IHRoaXM7XG5cblx0XHRcdF9pbWcgPSBuZXcgSW1hZ2UoKTtcblx0XHRcdF9pbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfcHVyZ2UuY2FsbCh0aGlzKTtcblx0XHRcdFx0Y29tcC50cmlnZ2VyKCdlcnJvcicsIHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdFx0fTtcblx0XHRcdF9pbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbXAudHJpZ2dlcignbG9hZCcpO1xuXHRcdFx0fTtcblxuXHRcdFx0X2ltZy5zcmMgPSBzdHIuc3Vic3RyKDAsIDUpID09ICdkYXRhOicgPyBzdHIgOiBfdG9EYXRhVXJsKHN0ciwgX2Jsb2IudHlwZSk7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfcmVhZEFzRGF0YVVybChmaWxlLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGNvbXAgPSB0aGlzLCBmcjtcblxuXHRcdFx0Ly8gdXNlIEZpbGVSZWFkZXIgaWYgaXQncyBhdmFpbGFibGVcblx0XHRcdGlmICh3aW5kb3cuRmlsZVJlYWRlcikge1xuXHRcdFx0XHRmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoY29tcCwgdGhpcy5yZXN1bHQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdlcnJvcicsIHguSW1hZ2VFcnJvci5XUk9OR19GT1JNQVQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmlsZS5nZXRBc0RhdGFVUkwoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0KiBUcmFuc2Zvcm0gY2FudmFzIGNvb3JkaW5hdGlvbiBhY2NvcmRpbmcgdG8gc3BlY2lmaWVkIGZyYW1lIHNpemUgYW5kIG9yaWVudGF0aW9uXG5cdFx0KiBPcmllbnRhdGlvbiB2YWx1ZSBpcyBmcm9tIEVYSUYgdGFnXG5cdFx0KiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cblx0XHQqL1xuXHRcdGZ1bmN0aW9uIF9yb3RhdGVUb09yaWVudGFpb24oaW1nLCBvcmllbnRhdGlvbikge1xuXHRcdFx0dmFyIFJBRElBTlMgPSBNYXRoLlBJLzE4MDtcblx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRcdHZhciB3aWR0aCA9IGltZy53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG5cdFx0XHRpZiAoQmFzaWMuaW5BcnJheShvcmllbnRhdGlvbiwgWzUsNiw3LDhdKSA+IC0xKSB7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IGhlaWdodDtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IHdpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0MSA9IFRoZSAwdGggcm93IGlzIGF0IHRoZSB2aXN1YWwgdG9wIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgbGVmdC1oYW5kIHNpZGUuXG5cdFx0XHQyID0gVGhlIDB0aCByb3cgaXMgYXQgdGhlIHZpc3VhbCB0b3Agb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCByaWdodC1oYW5kIHNpZGUuXG5cdFx0XHQzID0gVGhlIDB0aCByb3cgaXMgYXQgdGhlIHZpc3VhbCBib3R0b20gb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCByaWdodC1oYW5kIHNpZGUuXG5cdFx0XHQ0ID0gVGhlIDB0aCByb3cgaXMgYXQgdGhlIHZpc3VhbCBib3R0b20gb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCBsZWZ0LWhhbmQgc2lkZS5cblx0XHRcdDUgPSBUaGUgMHRoIHJvdyBpcyB0aGUgdmlzdWFsIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgdG9wLlxuXHRcdFx0NiA9IFRoZSAwdGggcm93IGlzIHRoZSB2aXN1YWwgcmlnaHQtaGFuZCBzaWRlIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgdG9wLlxuXHRcdFx0NyA9IFRoZSAwdGggcm93IGlzIHRoZSB2aXN1YWwgcmlnaHQtaGFuZCBzaWRlIG9mIHRoZSBpbWFnZSwgYW5kIHRoZSAwdGggY29sdW1uIGlzIHRoZSB2aXN1YWwgYm90dG9tLlxuXHRcdFx0OCA9IFRoZSAwdGggcm93IGlzIHRoZSB2aXN1YWwgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIGltYWdlLCBhbmQgdGhlIDB0aCBjb2x1bW4gaXMgdGhlIHZpc3VhbCBib3R0b20uXG5cdFx0XHQqL1xuXHRcdFx0c3dpdGNoIChvcmllbnRhdGlvbikge1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0Ly8gaG9yaXpvbnRhbCBmbGlwXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG5cdFx0XHRcdFx0Y3R4LnNjYWxlKC0xLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdC8vIDE4MCByb3RhdGUgbGVmdFxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUod2lkdGgsIGhlaWdodCk7XG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSgxODAgKiBSQURJQU5TKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdC8vIHZlcnRpY2FsIGZsaXBcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKDAsIGhlaWdodCk7XG5cdFx0XHRcdFx0Y3R4LnNjYWxlKDEsIC0xKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA1OlxuXHRcdFx0XHRcdC8vIHZlcnRpY2FsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcblx0XHRcdFx0XHRjdHgucm90YXRlKDkwICogUkFESUFOUyk7XG5cdFx0XHRcdFx0Y3R4LnNjYWxlKDEsIC0xKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA2OlxuXHRcdFx0XHRcdC8vIDkwIHJvdGF0ZSByaWdodFxuXHRcdFx0XHRcdGN0eC5yb3RhdGUoOTAgKiBSQURJQU5TKTtcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKDAsIC1oZWlnaHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDc6XG5cdFx0XHRcdFx0Ly8gaG9yaXpvbnRhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSg5MCAqIFJBRElBTlMpO1xuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUod2lkdGgsIC1oZWlnaHQpO1xuXHRcdFx0XHRcdGN0eC5zY2FsZSgtMSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHQvLyA5MCByb3RhdGUgbGVmdFxuXHRcdFx0XHRcdGN0eC5yb3RhdGUoLTkwICogUkFESUFOUyk7XG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtd2lkdGgsIDApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRyZXR1cm4gY2FudmFzO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX3B1cmdlKCkge1xuXHRcdFx0aWYgKF9pbWdJbmZvKSB7XG5cdFx0XHRcdF9pbWdJbmZvLnB1cmdlKCk7XG5cdFx0XHRcdF9pbWdJbmZvID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0X2JpblN0ciA9IF9pbWcgPSBfY2FudmFzID0gX2Jsb2IgPSBudWxsO1xuXHRcdFx0X21vZGlmaWVkID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChleHRlbnNpb25zLkltYWdlID0gSFRNTDVJbWFnZSk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9mbGFzaC9SdW50aW1lLmpzXG5cbi8qKlxuICogUnVudGltZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKmdsb2JhbCBBY3RpdmVYT2JqZWN0OnRydWUgKi9cblxuLyoqXG5EZWZpbmVzIGNvbnN0cnVjdG9yIGZvciBGbGFzaCBydW50aW1lLlxuXG5AY2xhc3MgbW94aWUvcnVudGltZS9mbGFzaC9SdW50aW1lXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvZmxhc2gvUnVudGltZVwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCIsXG5cdFwibW94aWUvY29yZS91dGlscy9Eb21cIixcblx0XCJtb3hpZS9jb3JlL0V4Y2VwdGlvbnNcIixcblx0XCJtb3hpZS9ydW50aW1lL1J1bnRpbWVcIlxuXSwgZnVuY3Rpb24oQmFzaWMsIEVudiwgRG9tLCB4LCBSdW50aW1lKSB7XG5cdFxuXHR2YXIgdHlwZSA9ICdmbGFzaCcsIGV4dGVuc2lvbnMgPSB7fTtcblxuXHQvKipcblx0R2V0IHRoZSB2ZXJzaW9uIG9mIHRoZSBGbGFzaCBQbGF5ZXJcblxuXHRAbWV0aG9kIGdldFNoaW1WZXJzaW9uXG5cdEBwcml2YXRlXG5cdEByZXR1cm4ge051bWJlcn0gRmxhc2ggUGxheWVyIHZlcnNpb25cblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U2hpbVZlcnNpb24oKSB7XG5cdFx0dmFyIHZlcnNpb247XG5cblx0XHR0cnkge1xuXHRcdFx0dmVyc2lvbiA9IG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2gnXTtcblx0XHRcdHZlcnNpb24gPSB2ZXJzaW9uLmRlc2NyaXB0aW9uO1xuXHRcdH0gY2F0Y2ggKGUxKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2ZXJzaW9uID0gbmV3IEFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykuR2V0VmFyaWFibGUoJyR2ZXJzaW9uJyk7XG5cdFx0XHR9IGNhdGNoIChlMikge1xuXHRcdFx0XHR2ZXJzaW9uID0gJzAuMCc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZlcnNpb24gPSB2ZXJzaW9uLm1hdGNoKC9cXGQrL2cpO1xuXHRcdHJldHVybiBwYXJzZUZsb2F0KHZlcnNpb25bMF0gKyAnLicgKyB2ZXJzaW9uWzFdKTtcblx0fVxuXG5cblx0LyoqXG5cdENyb3NzLWJyb3dzZXIgU1dGIHJlbW92YWxcbiAgICBcdC0gRXNwZWNpYWxseSBuZWVkZWQgdG8gc2FmZWx5IGFuZCBjb21wbGV0ZWx5IHJlbW92ZSBhIFNXRiBpbiBJbnRlcm5ldCBFeHBsb3JlclxuXG4gICBcdE9yaWdpbmF0ZWQgZnJvbSBTV0ZPYmplY3QgdjIuMiA8aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3N3Zm9iamVjdC8+IFxuXHQqL1xuXHRmdW5jdGlvbiByZW1vdmVTV0YoaWQpIHtcbiAgICAgICAgdmFyIG9iaiA9IERvbS5nZXQoaWQpO1xuICAgICAgICBpZiAob2JqICYmIG9iai5ub2RlTmFtZSA9PSBcIk9CSkVDVFwiKSB7XG4gICAgICAgICAgICBpZiAoRW52LmJyb3dzZXIgPT09ICdJRScpIHtcbiAgICAgICAgICAgICAgICBvYmouc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiBvbkluaXQoKXtcbiAgICAgICAgICAgICAgICBcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNDM2MCh2PXZzLjg1KS5hc3B4XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVPYmplY3RJbklFKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQob25Jbml0LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG5cdGZ1bmN0aW9uIHJlbW92ZU9iamVjdEluSUUoaWQpIHtcbiAgICAgICAgdmFyIG9iaiA9IERvbS5nZXQoaWQpO1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2ldID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvYmpbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdENvbnN0cnVjdG9yIGZvciB0aGUgRmxhc2ggUnVudGltZVxuXG5cdEBjbGFzcyBGbGFzaFJ1bnRpbWVcblx0QGV4dGVuZHMgUnVudGltZVxuXHQqL1xuXHRmdW5jdGlvbiBGbGFzaFJ1bnRpbWUob3B0aW9ucykge1xuXHRcdHZhciBJID0gdGhpcywgaW5pdFRpbWVyO1xuXG5cdFx0b3B0aW9ucyA9IEJhc2ljLmV4dGVuZCh7IHN3Zl91cmw6IEVudi5zd2ZfdXJsIH0sIG9wdGlvbnMpO1xuXG5cdFx0UnVudGltZS5jYWxsKHRoaXMsIG9wdGlvbnMsIHR5cGUsIHtcblx0XHRcdGFjY2Vzc19iaW5hcnk6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBJLm1vZGUgPT09ICdicm93c2VyJztcblx0XHRcdH0sXG5cdFx0XHRhY2Nlc3NfaW1hZ2VfYmluYXJ5OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzcGxheV9tZWRpYTogUnVudGltZS5jYXBUZXN0KGRlZmluZWQoJ21veGllL2ltYWdlL0ltYWdlJykpLFxuXHRcdFx0ZG9fY29yczogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0ZHJhZ19hbmRfZHJvcDogZmFsc2UsXG5cdFx0XHRyZXBvcnRfdXBsb2FkX3Byb2dyZXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIEkubW9kZSA9PT0gJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0cmVzaXplX2ltYWdlOiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRyZXR1cm5fcmVzcG9uc2VfaGVhZGVyczogZmFsc2UsXG5cdFx0XHRyZXR1cm5fcmVzcG9uc2VfdHlwZTogZnVuY3Rpb24ocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdGlmIChyZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiAhIXdpbmRvdy5KU09OKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gXG5cdFx0XHRcdHJldHVybiAhQmFzaWMuYXJyYXlEaWZmKHJlc3BvbnNlVHlwZSwgWycnLCAndGV4dCcsICdkb2N1bWVudCddKSB8fCBJLm1vZGUgPT09ICdicm93c2VyJztcblx0XHRcdH0sXG5cdFx0XHRyZXR1cm5fc3RhdHVzX2NvZGU6IGZ1bmN0aW9uKGNvZGUpIHtcblx0XHRcdFx0cmV0dXJuIEkubW9kZSA9PT0gJ2Jyb3dzZXInIHx8ICFCYXNpYy5hcnJheURpZmYoY29kZSwgWzIwMCwgNDA0XSk7XG5cdFx0XHR9LFxuXHRcdFx0c2VsZWN0X2ZpbGU6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdHNlbGVjdF9tdWx0aXBsZTogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0c2VuZF9iaW5hcnlfc3RyaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9icm93c2VyX2Nvb2tpZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBJLm1vZGUgPT09ICdicm93c2VyJztcblx0XHRcdH0sXG5cdFx0XHRzZW5kX2N1c3RvbV9oZWFkZXJzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9tdWx0aXBhcnQ6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdHNsaWNlX2Jsb2I6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBJLm1vZGUgPT09ICdicm93c2VyJztcblx0XHRcdH0sXG5cdFx0XHRzdHJlYW1fdXBsb2FkOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0c3VtbW9uX2ZpbGVfZGlhbG9nOiBmYWxzZSxcblx0XHRcdHVwbG9hZF9maWxlc2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gQmFzaWMucGFyc2VTaXplU3RyKHNpemUpIDw9IDIwOTcxNTIgfHwgSS5tb2RlID09PSAnY2xpZW50Jztcblx0XHRcdH0sXG5cdFx0XHR1c2VfaHR0cF9tZXRob2Q6IGZ1bmN0aW9uKG1ldGhvZHMpIHtcblx0XHRcdFx0cmV0dXJuICFCYXNpYy5hcnJheURpZmYobWV0aG9kcywgWydHRVQnLCAnUE9TVCddKTtcblx0XHRcdH1cblx0XHR9LCB7IFxuXHRcdFx0Ly8gY2FwYWJpbGl0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWZpYyBtb2RlXG5cdFx0XHRhY2Nlc3NfYmluYXJ5OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnYnJvd3NlcicgOiAnY2xpZW50Jztcblx0XHRcdH0sXG5cdFx0XHRhY2Nlc3NfaW1hZ2VfYmluYXJ5OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnYnJvd3NlcicgOiAnY2xpZW50Jztcblx0XHRcdH0sXG5cdFx0XHRyZXBvcnRfdXBsb2FkX3Byb2dyZXNzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnYnJvd3NlcicgOiAnY2xpZW50Jztcblx0XHRcdH0sXG5cdFx0XHRyZXR1cm5fcmVzcG9uc2VfdHlwZTogZnVuY3Rpb24ocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdHJldHVybiBCYXNpYy5hcnJheURpZmYocmVzcG9uc2VUeXBlLCBbJycsICd0ZXh0JywgJ2pzb24nLCAnZG9jdW1lbnQnXSkgPyAnYnJvd3NlcicgOiBbJ2NsaWVudCcsICdicm93c2VyJ107XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuX3N0YXR1c19jb2RlOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdHJldHVybiBCYXNpYy5hcnJheURpZmYoY29kZSwgWzIwMCwgNDA0XSkgPyAnYnJvd3NlcicgOiBbJ2NsaWVudCcsICdicm93c2VyJ107XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9iaW5hcnlfc3RyaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnYnJvd3NlcicgOiAnY2xpZW50Jztcblx0XHRcdH0sXG5cdFx0XHRzZW5kX2Jyb3dzZXJfY29va2llczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9jdXN0b21faGVhZGVyczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0c2xpY2VfYmxvYjogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0c3RyZWFtX3VwbG9hZDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2NsaWVudCcgOiAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0dXBsb2FkX2ZpbGVzaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0XHRcdHJldHVybiBCYXNpYy5wYXJzZVNpemVTdHIoc2l6ZSkgPj0gMjA5NzE1MiA/ICdjbGllbnQnIDogJ2Jyb3dzZXInO1xuXHRcdFx0fVxuXHRcdH0sICdjbGllbnQnKTtcblxuXG5cdFx0Ly8gbWluaW1hbCByZXF1aXJlbWVudCBmb3IgRmxhc2ggUGxheWVyIHZlcnNpb25cblx0XHRpZiAoZ2V0U2hpbVZlcnNpb24oKSA8IDExLjMpIHtcblx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0RW52LmxvZyhcIlxcdEZsYXNoIGRpZG4ndCBtZWV0IG1pbmltYWwgdmVyc2lvbiByZXF1aXJlbWVudCAoMTEuMykuXCIpO1x0XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9kZSA9IGZhbHNlOyAvLyB3aXRoIGZhbHN5IG1vZGUsIHJ1bnRpbWUgd29uJ3Qgb3BlcmFibGUsIG5vIG1hdHRlciB3aGF0IHRoZSBtb2RlIHdhcyBiZWZvcmVcblx0XHR9XG5cblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cblx0XHRcdGdldFNoaW06IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gRG9tLmdldCh0aGlzLnVpZCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzaGltRXhlYzogZnVuY3Rpb24oY29tcG9uZW50LCBhY3Rpb24pIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdFx0XHRcdHJldHVybiBJLmdldFNoaW0oKS5leGVjKHRoaXMudWlkLCBjb21wb25lbnQsIGFjdGlvbiwgYXJncyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGh0bWwsIGVsLCBjb250YWluZXI7XG5cblx0XHRcdFx0Y29udGFpbmVyID0gdGhpcy5nZXRTaGltQ29udGFpbmVyKCk7XG5cblx0XHRcdFx0Ly8gaWYgbm90IHRoZSBtaW5pbWFsIGhlaWdodCwgc2hpbXMgYXJlIG5vdCBpbml0aWFsaXplZCBpbiBvbGRlciBicm93c2VycyAoZS5nIEZGMy42LCBJRTYsNyw4LCBTYWZhcmkgNC4wLDUuMCwgZXRjKVxuXHRcdFx0XHRCYXNpYy5leHRlbmQoY29udGFpbmVyLnN0eWxlLCB7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0dG9wOiAnLThweCcsXG5cdFx0XHRcdFx0bGVmdDogJy04cHgnLFxuXHRcdFx0XHRcdHdpZHRoOiAnOXB4Jyxcblx0XHRcdFx0XHRoZWlnaHQ6ICc5cHgnLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBpbnNlcnQgZmxhc2ggb2JqZWN0XG5cdFx0XHRcdGh0bWwgPSAnPG9iamVjdCBpZD1cIicgKyB0aGlzLnVpZCArICdcIiB0eXBlPVwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIiBkYXRhPVwiJyArICBvcHRpb25zLnN3Zl91cmwgKyAnXCIgJztcblxuXHRcdFx0XHRpZiAoRW52LmJyb3dzZXIgPT09ICdJRScpIHtcblx0XHRcdFx0XHRodG1sICs9ICdjbGFzc2lkPVwiY2xzaWQ6ZDI3Y2RiNmUtYWU2ZC0xMWNmLTk2YjgtNDQ0NTUzNTQwMDAwXCIgJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGh0bWwgKz0gJ3dpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBzdHlsZT1cIm91dGxpbmU6MFwiPicgICtcblx0XHRcdFx0XHQnPHBhcmFtIG5hbWU9XCJtb3ZpZVwiIHZhbHVlPVwiJyArIG9wdGlvbnMuc3dmX3VybCArICdcIiAvPicgK1xuXHRcdFx0XHRcdCc8cGFyYW0gbmFtZT1cImZsYXNodmFyc1wiIHZhbHVlPVwidWlkPScgKyBlc2NhcGUodGhpcy51aWQpICsgJyZ0YXJnZXQ9JyArIEVudi5nbG9iYWxfZXZlbnRfZGlzcGF0Y2hlciArICdcIiAvPicgK1xuXHRcdFx0XHRcdCc8cGFyYW0gbmFtZT1cIndtb2RlXCIgdmFsdWU9XCJ0cmFuc3BhcmVudFwiIC8+JyArXG5cdFx0XHRcdFx0JzxwYXJhbSBuYW1lPVwiYWxsb3dzY3JpcHRhY2Nlc3NcIiB2YWx1ZT1cImFsd2F5c1wiIC8+JyArXG5cdFx0XHRcdCc8L29iamVjdD4nO1xuXG5cdFx0XHRcdGlmIChFbnYuYnJvd3NlciA9PT0gJ0lFJykge1xuXHRcdFx0XHRcdGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdFx0XHRlbC5vdXRlckhUTUwgPSBodG1sO1xuXHRcdFx0XHRcdGVsID0gY29udGFpbmVyID0gbnVsbDsgLy8ganVzdCBpbiBjYXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJbml0IGlzIGRpc3BhdGNoZWQgYnkgdGhlIHNoaW1cblx0XHRcdFx0aW5pdFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoSSAmJiAhSS5pbml0aWFsaXplZCkgeyAvLyBydW50aW1lIG1pZ2h0IGJlIGFscmVhZHkgZGVzdHJveWVkIGJ5IHRoaXMgbW9tZW50XG5cdFx0XHRcdFx0XHRJLnRyaWdnZXIoXCJFcnJvclwiLCBuZXcgeC5SdW50aW1lRXJyb3IoeC5SdW50aW1lRXJyb3IuTk9UX0lOSVRfRVJSKSk7XG5cblx0XHRcdFx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdFx0RW52LmxvZyhcIlxcdEZsYXNoIGZhaWxlZCB0byBpbml0aWFsaXplIHdpdGhpbiBhIHNwZWNpZmllZCBwZXJpb2Qgb2YgdGltZSAodHlwaWNhbGx5IDVzKS5cIik7XHRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDUwMDApO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGVzdHJveTogKGZ1bmN0aW9uKGRlc3Ryb3kpIHsgLy8gZXh0ZW5kIGRlZmF1bHQgZGVzdHJveSBtZXRob2Rcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJlbW92ZVNXRihJLnVpZCk7IC8vIFNXRiByZW1vdmFsIHJlcXVpcmVzIHNwZWNpYWwgY2FyZSBpbiBJRVxuXG5cdFx0XHRcdFx0ZGVzdHJveS5jYWxsKEkpO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChpbml0VGltZXIpOyAvLyBpbml0aWFsaXphdGlvbiBjaGVjayBtaWdodCBiZSBzdGlsbCBvbndhaXRcblx0XHRcdFx0XHRvcHRpb25zID0gaW5pdFRpbWVyID0gZGVzdHJveSA9IEkgPSBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSh0aGlzLmRlc3Ryb3kpKVxuXG5cdFx0fSwgZXh0ZW5zaW9ucyk7XG5cdH1cblxuXHRSdW50aW1lLmFkZENvbnN0cnVjdG9yKHR5cGUsIEZsYXNoUnVudGltZSk7XG5cblx0cmV0dXJuIGV4dGVuc2lvbnM7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9mbGFzaC9maWxlL0Jsb2IuanNcblxuLyoqXG4gKiBCbG9iLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9CbG9iXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9CbG9iXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL1J1bnRpbWVcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmxvYikge1xuXG5cdHZhciBGbGFzaEJsb2IgPSB7XG5cdFx0c2xpY2U6IGZ1bmN0aW9uKGJsb2IsIHN0YXJ0LCBlbmQsIHR5cGUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cblx0XHRcdGlmIChzdGFydCA8IDApIHtcblx0XHRcdFx0c3RhcnQgPSBNYXRoLm1heChibG9iLnNpemUgKyBzdGFydCwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKHN0YXJ0ID4gMCkge1xuXHRcdFx0XHRzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBibG9iLnNpemUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZW5kIDwgMCkge1xuXHRcdFx0XHRlbmQgPSBNYXRoLm1heChibG9iLnNpemUgKyBlbmQsIDApO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPiAwKSB7XG5cdFx0XHRcdGVuZCA9IE1hdGgubWluKGVuZCwgYmxvYi5zaXplKTtcblx0XHRcdH1cblxuXHRcdFx0YmxvYiA9IHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnQmxvYicsICdzbGljZScsIHN0YXJ0LCBlbmQsIHR5cGUgfHwgJycpO1xuXG5cdFx0XHRpZiAoYmxvYikge1xuXHRcdFx0XHRibG9iID0gbmV3IEJsb2Ioc2VsZi51aWQsIGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJsb2I7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5CbG9iID0gRmxhc2hCbG9iKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2ZsYXNoL2ZpbGUvRmlsZUlucHV0LmpzXG5cbi8qKlxuICogRmlsZUlucHV0LmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlSW5wdXRcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVJbnB1dFwiLCBbXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9SdW50aW1lXCIsXG5cdFwibW94aWUvZmlsZS9GaWxlXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBGaWxlLCBCYXNpYykge1xuXHRcblx0dmFyIEZpbGVJbnB1dCA9IHtcdFx0XG5cdFx0aW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0dmFyIGNvbXAgPSB0aGlzLCBJID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cblx0XHRcdHRoaXMuYmluZChcIkNoYW5nZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGZpbGVzID0gSS5zaGltRXhlYy5jYWxsKGNvbXAsICdGaWxlSW5wdXQnLCAnZ2V0RmlsZXMnKTtcblx0XHRcdFx0Y29tcC5maWxlcyA9IFtdO1xuXHRcdFx0XHRCYXNpYy5lYWNoKGZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHRcdFx0Y29tcC5maWxlcy5wdXNoKG5ldyBGaWxlKEkudWlkLCBmaWxlKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgOTk5KTtcblxuXHRcdFx0dGhpcy5nZXRSdW50aW1lKCkuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnRmlsZUlucHV0JywgJ2luaXQnLCB7XG5cdFx0XHRcdGFjY2VwdDogb3B0aW9ucy5hY2NlcHQsXG5cdFx0XHRcdG11bHRpcGxlOiBvcHRpb25zLm11bHRpcGxlXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy50cmlnZ2VyKCdyZWFkeScpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZUlucHV0ID0gRmlsZUlucHV0KTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2ZsYXNoL2ZpbGUvRmlsZVJlYWRlci5qc1xuXG4vKipcbiAqIEZpbGVSZWFkZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVSZWFkZXJcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVSZWFkZXJcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW5jb2RlXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEVuY29kZSkge1xuXG5cdGZ1bmN0aW9uIF9mb3JtYXREYXRhKGRhdGEsIG9wKSB7XG5cdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0Y2FzZSAncmVhZEFzVGV4dCc6XG5cdFx0XHRcdHJldHVybiBFbmNvZGUuYXRvYihkYXRhLCAndXRmOCcpO1xuXHRcdFx0Y2FzZSAncmVhZEFzQmluYXJ5U3RyaW5nJzpcblx0XHRcdFx0cmV0dXJuIEVuY29kZS5hdG9iKGRhdGEpO1xuXHRcdFx0Y2FzZSAncmVhZEFzRGF0YVVSTCc6XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBGaWxlUmVhZGVyID0ge1xuXHRcdHJlYWQ6IGZ1bmN0aW9uKG9wLCBibG9iKSB7XG5cdFx0XHR2YXIgY29tcCA9IHRoaXM7XG5cblx0XHRcdGNvbXAucmVzdWx0ID0gJyc7XG5cblx0XHRcdC8vIHNwZWNpYWwgcHJlZml4IGZvciBEYXRhVVJMIHJlYWQgbW9kZVxuXHRcdFx0aWYgKG9wID09PSAncmVhZEFzRGF0YVVSTCcpIHtcblx0XHRcdFx0Y29tcC5yZXN1bHQgPSAnZGF0YTonICsgKGJsb2IudHlwZSB8fCAnJykgKyAnO2Jhc2U2NCwnO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wLmJpbmQoJ1Byb2dyZXNzJywgZnVuY3Rpb24oZSwgZGF0YSkge1xuXHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdGNvbXAucmVzdWx0ICs9IF9mb3JtYXREYXRhKGRhdGEsIG9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgOTk5KTtcblxuXHRcdFx0cmV0dXJuIGNvbXAuZ2V0UnVudGltZSgpLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ZpbGVSZWFkZXInLCAncmVhZEFzQmFzZTY0JywgYmxvYi51aWQpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZVJlYWRlciA9IEZpbGVSZWFkZXIpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlUmVhZGVyU3luYy5qc1xuXG4vKipcbiAqIEZpbGVSZWFkZXJTeW5jLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9GaWxlUmVhZGVyU3luY1xuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2ZsYXNoL2ZpbGUvRmlsZVJlYWRlclN5bmNcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW5jb2RlXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEVuY29kZSkge1xuXHRcblx0ZnVuY3Rpb24gX2Zvcm1hdERhdGEoZGF0YSwgb3ApIHtcblx0XHRzd2l0Y2ggKG9wKSB7XG5cdFx0XHRjYXNlICdyZWFkQXNUZXh0Jzpcblx0XHRcdFx0cmV0dXJuIEVuY29kZS5hdG9iKGRhdGEsICd1dGY4Jyk7XG5cdFx0XHRjYXNlICdyZWFkQXNCaW5hcnlTdHJpbmcnOlxuXHRcdFx0XHRyZXR1cm4gRW5jb2RlLmF0b2IoZGF0YSk7XG5cdFx0XHRjYXNlICdyZWFkQXNEYXRhVVJMJzpcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIEZpbGVSZWFkZXJTeW5jID0ge1xuXHRcdHJlYWQ6IGZ1bmN0aW9uKG9wLCBibG9iKSB7XG5cdFx0XHR2YXIgcmVzdWx0LCBzZWxmID0gdGhpcy5nZXRSdW50aW1lKCk7XG5cblx0XHRcdHJlc3VsdCA9IHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnRmlsZVJlYWRlclN5bmMnLCAncmVhZEFzQmFzZTY0JywgYmxvYi51aWQpO1xuXHRcdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIG9yIHRocm93IGV4XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNwZWNpYWwgcHJlZml4IGZvciBEYXRhVVJMIHJlYWQgbW9kZVxuXHRcdFx0aWYgKG9wID09PSAncmVhZEFzRGF0YVVSTCcpIHtcblx0XHRcdFx0cmVzdWx0ID0gJ2RhdGE6JyArIChibG9iLnR5cGUgfHwgJycpICsgJztiYXNlNjQsJyArIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIF9mb3JtYXREYXRhKHJlc3VsdCwgb3AsIGJsb2IudHlwZSk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5GaWxlUmVhZGVyU3luYyA9IEZpbGVSZWFkZXJTeW5jKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL2ZsYXNoL3J1bnRpbWUvVHJhbnNwb3J0ZXIuanNcblxuLyoqXG4gKiBUcmFuc3BvcnRlci5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2ZsYXNoL3J1bnRpbWUvVHJhbnNwb3J0ZXJcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9mbGFzaC9ydW50aW1lL1RyYW5zcG9ydGVyXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL1J1bnRpbWVcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmxvYikge1xuXG5cdHZhciBUcmFuc3BvcnRlciA9IHtcblx0XHRnZXRBc0Jsb2I6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcy5nZXRSdW50aW1lKClcblx0XHRcdCwgYmxvYiA9IHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnVHJhbnNwb3J0ZXInLCAnZ2V0QXNCbG9iJywgdHlwZSlcblx0XHRcdDtcblx0XHRcdGlmIChibG9iKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQmxvYihzZWxmLnVpZCwgYmxvYik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIChleHRlbnNpb25zLlRyYW5zcG9ydGVyID0gVHJhbnNwb3J0ZXIpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvZmxhc2gveGhyL1hNTEh0dHBSZXF1ZXN0LmpzXG5cbi8qKlxuICogWE1MSHR0cFJlcXVlc3QuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9mbGFzaC94aHIvWE1MSHR0cFJlcXVlc3RcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9mbGFzaC94aHIvWE1MSHR0cFJlcXVlc3RcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVSZWFkZXJTeW5jXCIsXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVSZWFkZXJTeW5jXCIsXG5cdFwibW94aWUveGhyL0Zvcm1EYXRhXCIsXG5cdFwibW94aWUvcnVudGltZS9UcmFuc3BvcnRlclwiLFxuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvcnVudGltZS9UcmFuc3BvcnRlclwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgQmxvYiwgRmlsZSwgRmlsZVJlYWRlclN5bmMsIEZpbGVSZWFkZXJTeW5jRmxhc2gsIEZvcm1EYXRhLCBUcmFuc3BvcnRlciwgVHJhbnNwb3J0ZXJGbGFzaCkge1xuXHRcblx0dmFyIFhNTEh0dHBSZXF1ZXN0ID0ge1xuXG5cdFx0c2VuZDogZnVuY3Rpb24obWV0YSwgZGF0YSkge1xuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMsIHNlbGYgPSB0YXJnZXQuZ2V0UnVudGltZSgpO1xuXG5cdFx0XHRmdW5jdGlvbiBzZW5kKCkge1xuXHRcdFx0XHRtZXRhLnRyYW5zcG9ydCA9IHNlbGYubW9kZTtcblx0XHRcdFx0c2VsZi5zaGltRXhlYy5jYWxsKHRhcmdldCwgJ1hNTEh0dHBSZXF1ZXN0JywgJ3NlbmQnLCBtZXRhLCBkYXRhKTtcblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBhcHBlbmRCbG9iKG5hbWUsIGJsb2IpIHtcblx0XHRcdFx0c2VsZi5zaGltRXhlYy5jYWxsKHRhcmdldCwgJ1hNTEh0dHBSZXF1ZXN0JywgJ2FwcGVuZEJsb2InLCBuYW1lLCBibG9iLnVpZCk7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0XHRzZW5kKCk7XG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gYXR0YWNoQmxvYihibG9iLCBjYikge1xuXHRcdFx0XHR2YXIgdHIgPSBuZXcgVHJhbnNwb3J0ZXIoKTtcblxuXHRcdFx0XHR0ci5iaW5kKFwiVHJhbnNwb3J0aW5nQ29tcGxldGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y2IodGhpcy5yZXN1bHQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0ci50cmFuc3BvcnQoYmxvYi5nZXRTb3VyY2UoKSwgYmxvYi50eXBlLCB7XG5cdFx0XHRcdFx0cnVpZDogc2VsZi51aWRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgb3ZlciB0aGUgaGVhZGVycyBpZiBhbnlcblx0XHRcdGlmICghQmFzaWMuaXNFbXB0eU9iaihtZXRhLmhlYWRlcnMpKSB7XG5cdFx0XHRcdEJhc2ljLmVhY2gobWV0YS5oZWFkZXJzLCBmdW5jdGlvbih2YWx1ZSwgaGVhZGVyKSB7XG5cdFx0XHRcdFx0c2VsZi5zaGltRXhlYy5jYWxsKHRhcmdldCwgJ1hNTEh0dHBSZXF1ZXN0JywgJ3NldFJlcXVlc3RIZWFkZXInLCBoZWFkZXIsIHZhbHVlLnRvU3RyaW5nKCkpOyAvLyBTaWx2ZXJsaWdodCBkb2Vzbid0IGFjY2VwdCBpbnRlZ2VycyBpbnRvIHRoZSBhcmd1bWVudHMgb2YgdHlwZSBvYmplY3Rcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRyYW5zZmVyIG92ZXIgbXVsdGlwYXJ0IHBhcmFtcyBhbmQgYmxvYiBpdHNlbGZcblx0XHRcdGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdFx0dmFyIGJsb2JGaWVsZDtcblx0XHRcdFx0ZGF0YS5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdFx0YmxvYkZpZWxkID0gbmFtZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5zaGltRXhlYy5jYWxsKHRhcmdldCwgJ1hNTEh0dHBSZXF1ZXN0JywgJ2FwcGVuZCcsIG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICghZGF0YS5oYXNCbG9iKCkpIHtcblx0XHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdFx0XHRzZW5kKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGJsb2IgPSBkYXRhLmdldEJsb2IoKTtcblx0XHRcdFx0XHRpZiAoYmxvYi5pc0RldGFjaGVkKCkpIHtcblx0XHRcdFx0XHRcdGF0dGFjaEJsb2IoYmxvYiwgZnVuY3Rpb24oYXR0YWNoZWRCbG9iKSB7XG5cdFx0XHRcdFx0XHRcdGJsb2IuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRhcHBlbmRCbG9iKGJsb2JGaWVsZCwgYXR0YWNoZWRCbG9iKTtcdFx0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YXBwZW5kQmxvYihibG9iRmllbGQsIGJsb2IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRpZiAoZGF0YS5pc0RldGFjaGVkKCkpIHtcblx0XHRcdFx0XHRhdHRhY2hCbG9iKGRhdGEsIGZ1bmN0aW9uKGF0dGFjaGVkQmxvYikge1xuXHRcdFx0XHRcdFx0ZGF0YS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRkYXRhID0gYXR0YWNoZWRCbG9iLnVpZDtcblx0XHRcdFx0XHRcdHNlbmQoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YS51aWQ7XG5cdFx0XHRcdFx0c2VuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZW5kKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZVR5cGUpIHtcblx0XHRcdHZhciBmcnMsIGJsb2IsIHNlbGYgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblxuXHRcdFx0YmxvYiA9IHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnWE1MSHR0cFJlcXVlc3QnLCAnZ2V0UmVzcG9uc2VBc0Jsb2InKTtcblxuXHRcdFx0aWYgKGJsb2IpIHtcblx0XHRcdFx0YmxvYiA9IG5ldyBGaWxlKHNlbGYudWlkLCBibG9iKTtcblxuXHRcdFx0XHRpZiAoJ2Jsb2InID09PSByZXNwb25zZVR5cGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gYmxvYjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7IFxuXHRcdFx0XHRcdGZycyA9IG5ldyBGaWxlUmVhZGVyU3luYygpO1xuXG5cdFx0XHRcdFx0aWYgKCEhfkJhc2ljLmluQXJyYXkocmVzcG9uc2VUeXBlLCBbXCJcIiwgXCJ0ZXh0XCJdKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZycy5yZWFkQXNUZXh0KGJsb2IpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoJ2pzb24nID09PSByZXNwb25zZVR5cGUgJiYgISF3aW5kb3cuSlNPTikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoZnJzLnJlYWRBc1RleHQoYmxvYikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRibG9iLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblxuXHRcdGFib3J0OiBmdW5jdGlvbih1cGxvYWRfY29tcGxldGVfZmxhZykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblxuXHRcdFx0c2VsZi5zaGltRXhlYy5jYWxsKHRoaXMsICdYTUxIdHRwUmVxdWVzdCcsICdhYm9ydCcpO1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlYWR5c3RhdGVjaGFuZ2UnKTtcblx0XHRcdC8vIHRoaXMuZGlzcGF0Y2hFdmVudCgncHJvZ3Jlc3MnKTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCgnYWJvcnQnKTtcblxuXHRcdFx0Ly9pZiAoIXVwbG9hZF9jb21wbGV0ZV9mbGFnKSB7XG5cdFx0XHRcdC8vIHRoaXMuZGlzcGF0Y2hFdmVudCgndXBsb2FkcHJvZ3Jlc3MnKTtcblx0XHRcdC8vfVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdCk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9mbGFzaC9pbWFnZS9JbWFnZS5qc1xuXG4vKipcbiAqIEltYWdlLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvZmxhc2gvaW1hZ2UvSW1hZ2VcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9mbGFzaC9pbWFnZS9JbWFnZVwiLCBbXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvVHJhbnNwb3J0ZXJcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIixcblx0XCJtb3hpZS9maWxlL0ZpbGVSZWFkZXJTeW5jXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJhc2ljLCBUcmFuc3BvcnRlciwgQmxvYiwgRmlsZVJlYWRlclN5bmMpIHtcblx0XG5cdHZhciBJbWFnZSA9IHtcblx0XHRsb2FkRnJvbUJsb2I6IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdHZhciBjb21wID0gdGhpcywgc2VsZiA9IGNvbXAuZ2V0UnVudGltZSgpO1xuXG5cdFx0XHRmdW5jdGlvbiBleGVjKHNyY0Jsb2IpIHtcblx0XHRcdFx0c2VsZi5zaGltRXhlYy5jYWxsKGNvbXAsICdJbWFnZScsICdsb2FkRnJvbUJsb2InLCBzcmNCbG9iLnVpZCk7XG5cdFx0XHRcdGNvbXAgPSBzZWxmID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJsb2IuaXNEZXRhY2hlZCgpKSB7IC8vIGJpbmFyeSBzdHJpbmdcblx0XHRcdFx0dmFyIHRyID0gbmV3IFRyYW5zcG9ydGVyKCk7XG5cdFx0XHRcdHRyLmJpbmQoXCJUcmFuc3BvcnRpbmdDb21wbGV0ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRleGVjKHRyLnJlc3VsdC5nZXRTb3VyY2UoKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0ci50cmFuc3BvcnQoYmxvYi5nZXRTb3VyY2UoKSwgYmxvYi50eXBlLCB7IHJ1aWQ6IHNlbGYudWlkIH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXhlYyhibG9iLmdldFNvdXJjZSgpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bG9hZEZyb21JbWFnZTogZnVuY3Rpb24oaW1nKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpO1xuXHRcdFx0cmV0dXJuIHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnSW1hZ2UnLCAnbG9hZEZyb21JbWFnZScsIGltZy51aWQpO1xuXHRcdH0sXG5cblx0XHRnZXRJbmZvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcy5nZXRSdW50aW1lKClcblx0XHRcdCwgaW5mbyA9IHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnSW1hZ2UnLCAnZ2V0SW5mbycpXG5cdFx0XHQ7XG5cblx0XHRcdGlmIChpbmZvLm1ldGEgJiYgaW5mby5tZXRhLnRodW1iICYmIGluZm8ubWV0YS50aHVtYi5kYXRhICYmICEoc2VsZi5tZXRhLnRodW1iLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSkge1xuXHRcdFx0XHRpbmZvLm1ldGEudGh1bWIuZGF0YSA9IG5ldyBCbG9iKHNlbGYudWlkLCBpbmZvLm1ldGEudGh1bWIuZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5mbztcblx0XHR9LFxuXG5cdFx0Z2V0QXNCbG9iOiBmdW5jdGlvbih0eXBlLCBxdWFsaXR5KSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpXG5cdFx0XHQsIGJsb2IgPSBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ltYWdlJywgJ2dldEFzQmxvYicsIHR5cGUsIHF1YWxpdHkpXG5cdFx0XHQ7XG5cdFx0XHRpZiAoYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJsb2Ioc2VsZi51aWQsIGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblxuXHRcdGdldEFzRGF0YVVSTDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpXG5cdFx0XHQsIGJsb2IgPSBzZWxmLkltYWdlLmdldEFzQmxvYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cdFx0XHQsIGZyc1xuXHRcdFx0O1xuXHRcdFx0aWYgKCFibG9iKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZnJzID0gbmV3IEZpbGVSZWFkZXJTeW5jKCk7XG5cdFx0XHRyZXR1cm4gZnJzLnJlYWRBc0RhdGFVUkwoYmxvYik7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5JbWFnZSA9IEltYWdlKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL3NpbHZlcmxpZ2h0L1J1bnRpbWUuanNcblxuLyoqXG4gKiBSdW5UaW1lLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qZ2xvYmFsIEFjdGl2ZVhPYmplY3Q6dHJ1ZSAqL1xuXG4vKipcbkRlZmluZXMgY29uc3RydWN0b3IgZm9yIFNpbHZlcmxpZ2h0IHJ1bnRpbWUuXG5cbkBjbGFzcyBtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L1J1bnRpbWVcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXCIsIFtcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbnZcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0RvbVwiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL3J1bnRpbWUvUnVudGltZVwiXG5dLCBmdW5jdGlvbihCYXNpYywgRW52LCBEb20sIHgsIFJ1bnRpbWUpIHtcblx0XG5cdHZhciB0eXBlID0gXCJzaWx2ZXJsaWdodFwiLCBleHRlbnNpb25zID0ge307XG5cblx0ZnVuY3Rpb24gaXNJbnN0YWxsZWQodmVyc2lvbikge1xuXHRcdHZhciBpc1ZlcnNpb25TdXBwb3J0ZWQgPSBmYWxzZSwgY29udHJvbCA9IG51bGwsIGFjdHVhbFZlcixcblx0XHRcdGFjdHVhbFZlckFycmF5LCByZXFWZXJBcnJheSwgcmVxdWlyZWRWZXJzaW9uUGFydCwgYWN0dWFsVmVyc2lvblBhcnQsIGluZGV4ID0gMDtcblxuXHRcdHRyeSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb250cm9sID0gbmV3IEFjdGl2ZVhPYmplY3QoJ0FnQ29udHJvbC5BZ0NvbnRyb2wnKTtcblxuXHRcdFx0XHRpZiAoY29udHJvbC5Jc1ZlcnNpb25TdXBwb3J0ZWQodmVyc2lvbikpIHtcblx0XHRcdFx0XHRpc1ZlcnNpb25TdXBwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udHJvbCA9IG51bGw7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHZhciBwbHVnaW4gPSBuYXZpZ2F0b3IucGx1Z2luc1tcIlNpbHZlcmxpZ2h0IFBsdWctSW5cIl07XG5cblx0XHRcdFx0aWYgKHBsdWdpbikge1xuXHRcdFx0XHRcdGFjdHVhbFZlciA9IHBsdWdpbi5kZXNjcmlwdGlvbjtcblxuXHRcdFx0XHRcdGlmIChhY3R1YWxWZXIgPT09IFwiMS4wLjMwMjI2LjJcIikge1xuXHRcdFx0XHRcdFx0YWN0dWFsVmVyID0gXCIyLjAuMzAyMjYuMlwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFjdHVhbFZlckFycmF5ID0gYWN0dWFsVmVyLnNwbGl0KFwiLlwiKTtcblxuXHRcdFx0XHRcdHdoaWxlIChhY3R1YWxWZXJBcnJheS5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0XHRhY3R1YWxWZXJBcnJheS5wb3AoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aGlsZSAoIGFjdHVhbFZlckFycmF5Lmxlbmd0aCA8IDQpIHtcblx0XHRcdFx0XHRcdGFjdHVhbFZlckFycmF5LnB1c2goMCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVxVmVyQXJyYXkgPSB2ZXJzaW9uLnNwbGl0KFwiLlwiKTtcblxuXHRcdFx0XHRcdHdoaWxlIChyZXFWZXJBcnJheS5sZW5ndGggPiA0KSB7XG5cdFx0XHRcdFx0XHRyZXFWZXJBcnJheS5wb3AoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRyZXF1aXJlZFZlcnNpb25QYXJ0ID0gcGFyc2VJbnQocmVxVmVyQXJyYXlbaW5kZXhdLCAxMCk7XG5cdFx0XHRcdFx0XHRhY3R1YWxWZXJzaW9uUGFydCA9IHBhcnNlSW50KGFjdHVhbFZlckFycmF5W2luZGV4XSwgMTApO1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHR9IHdoaWxlIChpbmRleCA8IHJlcVZlckFycmF5Lmxlbmd0aCAmJiByZXF1aXJlZFZlcnNpb25QYXJ0ID09PSBhY3R1YWxWZXJzaW9uUGFydCk7XG5cblx0XHRcdFx0XHRpZiAocmVxdWlyZWRWZXJzaW9uUGFydCA8PSBhY3R1YWxWZXJzaW9uUGFydCAmJiAhaXNOYU4ocmVxdWlyZWRWZXJzaW9uUGFydCkpIHtcblx0XHRcdFx0XHRcdGlzVmVyc2lvblN1cHBvcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZTIpIHtcblx0XHRcdGlzVmVyc2lvblN1cHBvcnRlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBpc1ZlcnNpb25TdXBwb3J0ZWQ7XG5cdH1cblxuXHQvKipcblx0Q29uc3RydWN0b3IgZm9yIHRoZSBTaWx2ZXJsaWdodCBSdW50aW1lXG5cblx0QGNsYXNzIFNpbHZlcmxpZ2h0UnVudGltZVxuXHRAZXh0ZW5kcyBSdW50aW1lXG5cdCovXG5cdGZ1bmN0aW9uIFNpbHZlcmxpZ2h0UnVudGltZShvcHRpb25zKSB7XG5cdFx0dmFyIEkgPSB0aGlzLCBpbml0VGltZXI7XG5cblx0XHRvcHRpb25zID0gQmFzaWMuZXh0ZW5kKHsgeGFwX3VybDogRW52LnhhcF91cmwgfSwgb3B0aW9ucyk7XG5cblx0XHRSdW50aW1lLmNhbGwodGhpcywgb3B0aW9ucywgdHlwZSwge1xuXHRcdFx0YWNjZXNzX2JpbmFyeTogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0YWNjZXNzX2ltYWdlX2JpbmFyeTogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0ZGlzcGxheV9tZWRpYTogUnVudGltZS5jYXBUZXN0KGRlZmluZWQoJ21veGllL2ltYWdlL0ltYWdlJykpLFxuXHRcdFx0ZG9fY29yczogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0ZHJhZ19hbmRfZHJvcDogZmFsc2UsXG5cdFx0XHRyZXBvcnRfdXBsb2FkX3Byb2dyZXNzOiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRyZXNpemVfaW1hZ2U6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdHJldHVybl9yZXNwb25zZV9oZWFkZXJzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSS5tb2RlID09PSAnY2xpZW50Jztcblx0XHRcdH0sXG5cdFx0XHRyZXR1cm5fcmVzcG9uc2VfdHlwZTogZnVuY3Rpb24ocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRcdGlmIChyZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiAhIXdpbmRvdy5KU09OO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuX3N0YXR1c19jb2RlOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdHJldHVybiBJLm1vZGUgPT09ICdjbGllbnQnIHx8ICFCYXNpYy5hcnJheURpZmYoY29kZSwgWzIwMCwgNDA0XSk7XG5cdFx0XHR9LFxuXHRcdFx0c2VsZWN0X2ZpbGU6IFJ1bnRpbWUuY2FwVHJ1ZSxcblx0XHRcdHNlbGVjdF9tdWx0aXBsZTogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0c2VuZF9iaW5hcnlfc3RyaW5nOiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRzZW5kX2Jyb3dzZXJfY29va2llczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEkubW9kZSA9PT0gJ2Jyb3dzZXInO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRfY3VzdG9tX2hlYWRlcnM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBJLm1vZGUgPT09ICdjbGllbnQnO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRfbXVsdGlwYXJ0OiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRzbGljZV9ibG9iOiBSdW50aW1lLmNhcFRydWUsXG5cdFx0XHRzdHJlYW1fdXBsb2FkOiB0cnVlLFxuXHRcdFx0c3VtbW9uX2ZpbGVfZGlhbG9nOiBmYWxzZSxcblx0XHRcdHVwbG9hZF9maWxlc2l6ZTogUnVudGltZS5jYXBUcnVlLFxuXHRcdFx0dXNlX2h0dHBfbWV0aG9kOiBmdW5jdGlvbihtZXRob2RzKSB7XG5cdFx0XHRcdHJldHVybiBJLm1vZGUgPT09ICdjbGllbnQnIHx8ICFCYXNpYy5hcnJheURpZmYobWV0aG9kcywgWydHRVQnLCAnUE9TVCddKTtcblx0XHRcdH1cblx0XHR9LCB7IFxuXHRcdFx0Ly8gY2FwYWJpbGl0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWZpYyBtb2RlXG5cdFx0XHRyZXR1cm5fcmVzcG9uc2VfaGVhZGVyczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2NsaWVudCcgOiAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuX3N0YXR1c19jb2RlOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdHJldHVybiBCYXNpYy5hcnJheURpZmYoY29kZSwgWzIwMCwgNDA0XSkgPyAnY2xpZW50JyA6IFsnY2xpZW50JywgJ2Jyb3dzZXInXTtcblx0XHRcdH0sXG5cdFx0XHRzZW5kX2Jyb3dzZXJfY29va2llczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2Jyb3dzZXInIDogJ2NsaWVudCc7XG5cdFx0XHR9LFxuXHRcdFx0c2VuZF9jdXN0b21faGVhZGVyczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJ2NsaWVudCcgOiAnYnJvd3Nlcic7XG5cdFx0XHR9LFxuXHRcdFx0dXNlX2h0dHBfbWV0aG9kOiBmdW5jdGlvbihtZXRob2RzKSB7XG5cdFx0XHRcdHJldHVybiBCYXNpYy5hcnJheURpZmYobWV0aG9kcywgWydHRVQnLCAnUE9TVCddKSA/ICdjbGllbnQnIDogWydjbGllbnQnLCAnYnJvd3NlciddO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHQvLyBtaW5pbWFsIHJlcXVpcmVtZW50XG5cdFx0aWYgKCFpc0luc3RhbGxlZCgnMi4wLjMxMDA1LjAnKSB8fCBFbnYuYnJvd3NlciA9PT0gJ09wZXJhJykge1xuXHRcdFx0aWYgKE1YSV9ERUJVRyAmJiBFbnYuZGVidWcucnVudGltZSkge1xuXHRcdFx0XHRFbnYubG9nKFwiXFx0U2lsdmVybGlnaHQgaXMgbm90IGluc3RhbGxlZCBvciBtaW5pbWFsIHZlcnNpb24gKDIuMC4zMTAwNS4wKSByZXF1aXJlbWVudCBub3QgbWV0IChub3QgbGlrZWx5KS5cIik7XHRcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb2RlID0gZmFsc2U7XG5cdFx0fVxuXG5cblx0XHRCYXNpYy5leHRlbmQodGhpcywge1xuXHRcdFx0Z2V0U2hpbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBEb20uZ2V0KHRoaXMudWlkKS5jb250ZW50Lk1veGllO1xuXHRcdFx0fSxcblxuXHRcdFx0c2hpbUV4ZWM6IGZ1bmN0aW9uKGNvbXBvbmVudCwgYWN0aW9uKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdFx0XHRyZXR1cm4gSS5nZXRTaGltKCkuZXhlYyh0aGlzLnVpZCwgY29tcG9uZW50LCBhY3Rpb24sIGFyZ3MpO1xuXHRcdFx0fSxcblxuXHRcdFx0aW5pdCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY29udGFpbmVyO1xuXG5cdFx0XHRcdGNvbnRhaW5lciA9IHRoaXMuZ2V0U2hpbUNvbnRhaW5lcigpO1xuXG5cdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPG9iamVjdCBpZD1cIicgKyB0aGlzLnVpZCArICdcIiBkYXRhPVwiZGF0YTphcHBsaWNhdGlvbi94LXNpbHZlcmxpZ2h0LFwiIHR5cGU9XCJhcHBsaWNhdGlvbi94LXNpbHZlcmxpZ2h0LTJcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7XCI+JyArXG5cdFx0XHRcdFx0JzxwYXJhbSBuYW1lPVwic291cmNlXCIgdmFsdWU9XCInICsgb3B0aW9ucy54YXBfdXJsICsgJ1wiLz4nICtcblx0XHRcdFx0XHQnPHBhcmFtIG5hbWU9XCJiYWNrZ3JvdW5kXCIgdmFsdWU9XCJUcmFuc3BhcmVudFwiLz4nICtcblx0XHRcdFx0XHQnPHBhcmFtIG5hbWU9XCJ3aW5kb3dsZXNzXCIgdmFsdWU9XCJ0cnVlXCIvPicgK1xuXHRcdFx0XHRcdCc8cGFyYW0gbmFtZT1cImVuYWJsZWh0bWxhY2Nlc3NcIiB2YWx1ZT1cInRydWVcIi8+JyArXG5cdFx0XHRcdFx0JzxwYXJhbSBuYW1lPVwiaW5pdFBhcmFtc1wiIHZhbHVlPVwidWlkPScgKyB0aGlzLnVpZCArICcsdGFyZ2V0PScgKyBFbnYuZ2xvYmFsX2V2ZW50X2Rpc3BhdGNoZXIgKyAnXCIvPicgK1xuXHRcdFx0XHQnPC9vYmplY3Q+JztcblxuXHRcdFx0XHQvLyBJbml0IGlzIGRpc3BhdGNoZWQgYnkgdGhlIHNoaW1cblx0XHRcdFx0aW5pdFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoSSAmJiAhSS5pbml0aWFsaXplZCkgeyAvLyBydW50aW1lIG1pZ2h0IGJlIGFscmVhZHkgZGVzdHJveWVkIGJ5IHRoaXMgbW9tZW50XG5cdFx0XHRcdFx0XHRJLnRyaWdnZXIoXCJFcnJvclwiLCBuZXcgeC5SdW50aW1lRXJyb3IoeC5SdW50aW1lRXJyb3IuTk9UX0lOSVRfRVJSKSk7XG5cblx0XHRcdFx0XHRcdGlmIChNWElfREVCVUcgJiYgRW52LmRlYnVnLnJ1bnRpbWUpIHtcblx0XHRcdFx0XHRcdFx0RW52LmxvZyhcIlxcU2lsdmVybGlnaHQgZmFpbGVkIHRvIGluaXRpYWxpemUgd2l0aGluIGEgc3BlY2lmaWVkIHBlcmlvZCBvZiB0aW1lICg1LTEwcykuXCIpO1x0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCBFbnYuT1MgIT09ICdXaW5kb3dzJz8gMTAwMDAgOiA1MDAwKTsgLy8gZ2l2ZSBpdCBtb3JlIHRpbWUgdG8gaW5pdGlhbGl6ZSBpbiBub24gV2luZG93cyBPUyAobGlrZSBNYWMpXG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiAoZnVuY3Rpb24oZGVzdHJveSkgeyAvLyBleHRlbmQgZGVmYXVsdCBkZXN0cm95IG1ldGhvZFxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVzdHJveS5jYWxsKEkpO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChpbml0VGltZXIpOyAvLyBpbml0aWFsaXphdGlvbiBjaGVjayBtaWdodCBiZSBzdGlsbCBvbndhaXRcblx0XHRcdFx0XHRvcHRpb25zID0gaW5pdFRpbWVyID0gZGVzdHJveSA9IEkgPSBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSh0aGlzLmRlc3Ryb3kpKVxuXG5cdFx0fSwgZXh0ZW5zaW9ucyk7XG5cdH1cblxuXHRSdW50aW1lLmFkZENvbnN0cnVjdG9yKHR5cGUsIFNpbHZlcmxpZ2h0UnVudGltZSk7IFxuXG5cdHJldHVybiBleHRlbnNpb25zO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9CbG9iLmpzXG5cbi8qKlxuICogQmxvYi5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvQmxvYlxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvQmxvYlwiLCBbXG5cdFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvZmlsZS9CbG9iXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJhc2ljLCBCbG9iKSB7XG5cdHJldHVybiAoZXh0ZW5zaW9ucy5CbG9iID0gQmFzaWMuZXh0ZW5kKHt9LCBCbG9iKSk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVJbnB1dC5qc1xuXG4vKipcbiAqIEZpbGVJbnB1dC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZUlucHV0XG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlSW5wdXRcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvUnVudGltZVwiLFxuXHRcIm1veGllL2ZpbGUvRmlsZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgRmlsZSwgQmFzaWMpIHtcblxuXHRmdW5jdGlvbiB0b0ZpbHRlcnMoYWNjZXB0KSB7XG5cdFx0dmFyIGZpbHRlciA9ICcnO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYWNjZXB0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRmaWx0ZXIgKz0gKGZpbHRlciAhPT0gJycgPyAnfCcgOiAnJykgKyBhY2NlcHRbaV0udGl0bGUgKyBcIiB8ICouXCIgKyBhY2NlcHRbaV0uZXh0ZW5zaW9ucy5yZXBsYWNlKC8sL2csICc7Ki4nKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZpbHRlcjtcblx0fVxuXG5cdFxuXHR2YXIgRmlsZUlucHV0ID0ge1xuXHRcdGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdHZhciBjb21wID0gdGhpcywgSSA9IHRoaXMuZ2V0UnVudGltZSgpO1xuXG5cdFx0XHR0aGlzLmJpbmQoXCJDaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBmaWxlcyA9IEkuc2hpbUV4ZWMuY2FsbChjb21wLCAnRmlsZUlucHV0JywgJ2dldEZpbGVzJyk7XG5cdFx0XHRcdGNvbXAuZmlsZXMgPSBbXTtcblx0XHRcdFx0QmFzaWMuZWFjaChmaWxlcywgZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRcdGNvbXAuZmlsZXMucHVzaChuZXcgRmlsZShJLnVpZCwgZmlsZSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sIDk5OSk7XG5cdFx0XHRcblx0XHRcdEkuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnRmlsZUlucHV0JywgJ2luaXQnLCB0b0ZpbHRlcnMob3B0aW9ucy5hY2NlcHQpLCBvcHRpb25zLm11bHRpcGxlKTtcblx0XHRcdHRoaXMudHJpZ2dlcigncmVhZHknKTtcblx0XHR9LFxuXG5cdFx0c2V0T3B0aW9uOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKG5hbWUgPT0gJ2FjY2VwdCcpIHtcblx0XHRcdFx0dmFsdWUgPSB0b0ZpbHRlcnModmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5nZXRSdW50aW1lKCkuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnRmlsZUlucHV0JywgJ3NldE9wdGlvbicsIG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVJbnB1dCA9IEZpbGVJbnB1dCk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVEcm9wLmpzXG5cbi8qKlxuICogRmlsZURyb3AuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVEcm9wXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlRHJvcFwiLCBbXG5cdFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9Eb21cIiwgXG5cdFwibW94aWUvY29yZS91dGlscy9FdmVudHNcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgRG9tLCBFdmVudHMpIHtcblxuXHQvLyBub3QgZXhhY3RseSB1c2VmdWwsIHNpbmNlIHdvcmtzIG9ubHkgaW4gc2FmYXJpICguLi5jcmlja2V0cy4uLilcblx0dmFyIEZpbGVEcm9wID0ge1xuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbXAgPSB0aGlzLCBzZWxmID0gY29tcC5nZXRSdW50aW1lKCksIGRyb3Bab25lO1xuXG5cdFx0XHRkcm9wWm9uZSA9IHNlbGYuZ2V0U2hpbUNvbnRhaW5lcigpO1xuXG5cdFx0XHRFdmVudHMuYWRkRXZlbnQoZHJvcFpvbmUsICdkcmFnb3ZlcicsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xuXHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRFdmVudHMuYWRkRXZlbnQoZHJvcFpvbmUsICdkcmFnZW50ZXInLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0dmFyIGZsYWcgPSBEb20uZ2V0KHNlbGYudWlkKS5kcmFnRW50ZXIoZSk7XG5cdFx0XHRcdC8vIElmIGhhbmRsZWQsIHRoZW4gc3RvcCBwcm9wYWdhdGlvbiBvZiBldmVudCBpbiBET01cblx0XHRcdFx0aWYgKGZsYWcpIHtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdEV2ZW50cy5hZGRFdmVudChkcm9wWm9uZSwgJ2Ryb3AnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0dmFyIGZsYWcgPSBEb20uZ2V0KHNlbGYudWlkKS5kcmFnRHJvcChlKTtcblx0XHRcdFx0Ly8gSWYgaGFuZGxlZCwgdGhlbiBzdG9wIHByb3BhZ2F0aW9uIG9mIGV2ZW50IGluIERPTVxuXHRcdFx0XHRpZiAoZmxhZykge1xuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0cmV0dXJuIHNlbGYuc2hpbUV4ZWMuY2FsbCh0aGlzLCAnRmlsZURyb3AnLCAnaW5pdCcpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZURyb3AgPSBGaWxlRHJvcCk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVSZWFkZXIuanNcblxuLyoqXG4gKiBGaWxlUmVhZGVyLmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIE1veGllY29kZSBTeXN0ZW1zIEFCXG4gKiBSZWxlYXNlZCB1bmRlciBHUEwgTGljZW5zZS5cbiAqXG4gKiBMaWNlbnNlOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9saWNlbnNlXG4gKiBDb250cmlidXRpbmc6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2NvbnRyaWJ1dGluZ1xuICovXG5cbi8qKlxuQGNsYXNzIG1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlUmVhZGVyXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlUmVhZGVyXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVSZWFkZXJcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmFzaWMsIEZpbGVSZWFkZXIpIHtcblx0cmV0dXJuIChleHRlbnNpb25zLkZpbGVSZWFkZXIgPSBCYXNpYy5leHRlbmQoe30sIEZpbGVSZWFkZXIpKTtcbn0pO1xuXG4vLyBJbmNsdWRlZCBmcm9tOiBzcmMvamF2YXNjcmlwdC9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZVJlYWRlclN5bmMuanNcblxuLyoqXG4gKiBGaWxlUmVhZGVyU3luYy5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ZpbGUvRmlsZVJlYWRlclN5bmNcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9maWxlL0ZpbGVSZWFkZXJTeW5jXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9maWxlL0ZpbGVSZWFkZXJTeW5jXCJcbl0sIGZ1bmN0aW9uKGV4dGVuc2lvbnMsIEJhc2ljLCBGaWxlUmVhZGVyU3luYykge1xuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZVJlYWRlclN5bmMgPSBCYXNpYy5leHRlbmQoe30sIEZpbGVSZWFkZXJTeW5jKSk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9zaWx2ZXJsaWdodC9ydW50aW1lL1RyYW5zcG9ydGVyLmpzXG5cbi8qKlxuICogVHJhbnNwb3J0ZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9ydW50aW1lL1RyYW5zcG9ydGVyXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvcnVudGltZS9UcmFuc3BvcnRlclwiLCBbXG5cdFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9SdW50aW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvZmxhc2gvcnVudGltZS9UcmFuc3BvcnRlclwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgVHJhbnNwb3J0ZXIpIHtcblx0cmV0dXJuIChleHRlbnNpb25zLlRyYW5zcG9ydGVyID0gQmFzaWMuZXh0ZW5kKHt9LCBUcmFuc3BvcnRlcikpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvc2lsdmVybGlnaHQveGhyL1hNTEh0dHBSZXF1ZXN0LmpzXG5cbi8qKlxuICogWE1MSHR0cFJlcXVlc3QuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC94aHIvWE1MSHR0cFJlcXVlc3RcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC94aHIvWE1MSHR0cFJlcXVlc3RcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9ydW50aW1lL2ZsYXNoL3hoci9YTUxIdHRwUmVxdWVzdFwiLFxuXHRcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvZmlsZS9GaWxlUmVhZGVyU3luY1wiLFxuXHRcIm1veGllL3J1bnRpbWUvc2lsdmVybGlnaHQvcnVudGltZS9UcmFuc3BvcnRlclwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgWE1MSHR0cFJlcXVlc3QsIEZpbGVSZWFkZXJTeW5jU2lsdmVybGlnaHQsIFRyYW5zcG9ydGVyU2lsdmVybGlnaHQpIHtcblx0cmV0dXJuIChleHRlbnNpb25zLlhNTEh0dHBSZXF1ZXN0ID0gQmFzaWMuZXh0ZW5kKHt9LCBYTUxIdHRwUmVxdWVzdCkpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvc2lsdmVybGlnaHQvaW1hZ2UvSW1hZ2UuanNcblxuLyoqXG4gKiBJbWFnZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuIFxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9zaWx2ZXJsaWdodC9pbWFnZS9JbWFnZVxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L2ltYWdlL0ltYWdlXCIsIFtcblx0XCJtb3hpZS9ydW50aW1lL3NpbHZlcmxpZ2h0L1J1bnRpbWVcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXG5cdFwibW94aWUvZmlsZS9CbG9iXCIsXG5cdFwibW94aWUvcnVudGltZS9mbGFzaC9pbWFnZS9JbWFnZVwiXG5dLCBmdW5jdGlvbihleHRlbnNpb25zLCBCYXNpYywgQmxvYiwgSW1hZ2UpIHtcblx0cmV0dXJuIChleHRlbnNpb25zLkltYWdlID0gQmFzaWMuZXh0ZW5kKHt9LCBJbWFnZSwge1xuXG5cdFx0Z2V0SW5mbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMuZ2V0UnVudGltZSgpXG5cdFx0XHQsIGdycHMgPSBbJ3RpZmYnLCAnZXhpZicsICdncHMnLCAndGh1bWInXVxuXHRcdFx0LCBpbmZvID0geyBtZXRhOiB7fSB9XG5cdFx0XHQsIHJhd0luZm8gPSBzZWxmLnNoaW1FeGVjLmNhbGwodGhpcywgJ0ltYWdlJywgJ2dldEluZm8nKVxuXHRcdFx0O1xuXG5cdFx0XHRpZiAocmF3SW5mby5tZXRhKSB7XG5cdFx0XHRcdEJhc2ljLmVhY2goZ3JwcywgZnVuY3Rpb24oZ3JwKSB7XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSByYXdJbmZvLm1ldGFbZ3JwXVxuXHRcdFx0XHRcdCwgdGFnXG5cdFx0XHRcdFx0LCBpXG5cdFx0XHRcdFx0LCBsZW5ndGhcblx0XHRcdFx0XHQsIHZhbHVlXG5cdFx0XHRcdFx0O1xuXHRcdFx0XHRcdGlmIChtZXRhICYmIG1ldGEua2V5cykge1xuXHRcdFx0XHRcdFx0aW5mby5tZXRhW2dycF0gPSB7fTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IG1ldGEua2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0YWcgPSBtZXRhLmtleXNbaV07XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbWV0YVt0YWddO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjb252ZXJ0IG51bWJlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoL14oXFxkfFsxLTldXFxkKykkLy50ZXN0KHZhbHVlKSkgeyAvLyBpbnRlZ2VyIChtYWtlIHN1cmUgZG9lc24ndCBzdGFydCB3aXRoIHplcm8pXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgvXlxcZCpcXC5cXGQrJC8udGVzdCh2YWx1ZSkpIHsgLy8gZG91YmxlXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpbmZvLm1ldGFbZ3JwXVt0YWddID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHNhdmUgdGh1bWIgZGF0YSBhcyBibG9iXG5cdFx0XHRcdGlmIChpbmZvLm1ldGEgJiYgaW5mby5tZXRhLnRodW1iICYmIGluZm8ubWV0YS50aHVtYi5kYXRhICYmICEoc2VsZi5tZXRhLnRodW1iLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSkge1xuXHRcdFx0XHRcdGluZm8ubWV0YS50aHVtYi5kYXRhID0gbmV3IEJsb2Ioc2VsZi51aWQsIGluZm8ubWV0YS50aHVtYi5kYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpbmZvLndpZHRoID0gcGFyc2VJbnQocmF3SW5mby53aWR0aCwgMTApO1xuXHRcdFx0aW5mby5oZWlnaHQgPSBwYXJzZUludChyYXdJbmZvLmhlaWdodCwgMTApO1xuXHRcdFx0aW5mby5zaXplID0gcGFyc2VJbnQocmF3SW5mby5zaXplLCAxMCk7XG5cdFx0XHRpbmZvLnR5cGUgPSByYXdJbmZvLnR5cGU7XG5cdFx0XHRpbmZvLm5hbWUgPSByYXdJbmZvLm5hbWU7XG5cblx0XHRcdHJldHVybiBpbmZvO1xuXHRcdH0sXG5cblx0XHRyZXNpemU6IGZ1bmN0aW9uKHJlY3QsIHJhdGlvLCBvcHRzKSB7XG5cdFx0XHR0aGlzLmdldFJ1bnRpbWUoKS5zaGltRXhlYy5jYWxsKHRoaXMsICdJbWFnZScsICdyZXNpemUnLCByZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIHJhdGlvLCBvcHRzLnByZXNlcnZlSGVhZGVycywgb3B0cy5yZXNhbXBsZSk7XG5cdFx0fVxuXHR9KSk7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNC9SdW50aW1lLmpzXG5cbi8qKlxuICogUnVudGltZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKmdsb2JhbCBGaWxlOnRydWUgKi9cblxuLyoqXG5EZWZpbmVzIGNvbnN0cnVjdG9yIGZvciBIVE1MNCBydW50aW1lLlxuXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNC9SdW50aW1lXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDQvUnVudGltZVwiLCBbXG5cdFwibW94aWUvY29yZS91dGlscy9CYXNpY1wiLFxuXHRcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFxuXHRcIm1veGllL3J1bnRpbWUvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRW52XCJcbl0sIGZ1bmN0aW9uKEJhc2ljLCB4LCBSdW50aW1lLCBFbnYpIHtcblx0XG5cdHZhciB0eXBlID0gJ2h0bWw0JywgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdGZ1bmN0aW9uIEh0bWw0UnVudGltZShvcHRpb25zKSB7XG5cdFx0dmFyIEkgPSB0aGlzXG5cdFx0LCBUZXN0ID0gUnVudGltZS5jYXBUZXN0XG5cdFx0LCBUcnVlID0gUnVudGltZS5jYXBUcnVlXG5cdFx0O1xuXG5cdFx0UnVudGltZS5jYWxsKHRoaXMsIG9wdGlvbnMsIHR5cGUsIHtcblx0XHRcdGFjY2Vzc19iaW5hcnk6IFRlc3Qod2luZG93LkZpbGVSZWFkZXIgfHwgd2luZG93LkZpbGUgJiYgRmlsZS5nZXRBc0RhdGFVUkwpLFxuXHRcdFx0YWNjZXNzX2ltYWdlX2JpbmFyeTogZmFsc2UsXG5cdFx0XHRkaXNwbGF5X21lZGlhOiBUZXN0KFxuXHRcdFx0XHQoRW52LmNhbignY3JlYXRlX2NhbnZhcycpIHx8IEVudi5jYW4oJ3VzZV9kYXRhX3VyaV9vdmVyMzJrYicpKSAmJiBcblx0XHRcdFx0ZGVmaW5lZCgnbW94aWUvaW1hZ2UvSW1hZ2UnKVxuXHRcdFx0KSxcblx0XHRcdGRvX2NvcnM6IGZhbHNlLFxuXHRcdFx0ZHJhZ19hbmRfZHJvcDogZmFsc2UsXG5cdFx0XHRmaWx0ZXJfYnlfZXh0ZW5zaW9uOiBUZXN0KGZ1bmN0aW9uKCkgeyAvLyBpZiB5b3Uga25vdyBob3cgdG8gZmVhdHVyZS1kZXRlY3QgdGhpcywgcGxlYXNlIHN1Z2dlc3Rcblx0XHRcdFx0cmV0dXJuICEoXG5cdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnQ2hyb21lJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMjgsICc8JykpIHx8IFxuXHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ0lFJyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgMTAsICc8JykpIHx8IFxuXHRcdFx0XHRcdChFbnYuYnJvd3NlciA9PT0gJ1NhZmFyaScgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDcsICc8JykpIHx8XG5cdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnRmlyZWZveCcgJiYgRW52LnZlckNvbXAoRW52LnZlcnNpb24sIDM3LCAnPCcpKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSgpKSxcblx0XHRcdHJlc2l6ZV9pbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBleHRlbnNpb25zLkltYWdlICYmIEkuY2FuKCdhY2Nlc3NfYmluYXJ5JykgJiYgRW52LmNhbignY3JlYXRlX2NhbnZhcycpO1xuXHRcdFx0fSxcblx0XHRcdHJlcG9ydF91cGxvYWRfcHJvZ3Jlc3M6IGZhbHNlLFxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX2hlYWRlcnM6IGZhbHNlLFxuXHRcdFx0cmV0dXJuX3Jlc3BvbnNlX3R5cGU6IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRpZiAocmVzcG9uc2VUeXBlID09PSAnanNvbicgJiYgISF3aW5kb3cuSlNPTikge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IFxuXHRcdFx0XHRyZXR1cm4gISF+QmFzaWMuaW5BcnJheShyZXNwb25zZVR5cGUsIFsndGV4dCcsICdkb2N1bWVudCcsICcnXSk7XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuX3N0YXR1c19jb2RlOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdHJldHVybiAhQmFzaWMuYXJyYXlEaWZmKGNvZGUsIFsyMDAsIDQwNF0pO1xuXHRcdFx0fSxcblx0XHRcdHNlbGVjdF9maWxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIEVudi5jYW4oJ3VzZV9maWxlaW5wdXQnKTtcblx0XHRcdH0sXG5cdFx0XHRzZWxlY3RfbXVsdGlwbGU6IGZhbHNlLFxuXHRcdFx0c2VuZF9iaW5hcnlfc3RyaW5nOiBmYWxzZSxcblx0XHRcdHNlbmRfY3VzdG9tX2hlYWRlcnM6IGZhbHNlLFxuXHRcdFx0c2VuZF9tdWx0aXBhcnQ6IHRydWUsXG5cdFx0XHRzbGljZV9ibG9iOiBmYWxzZSxcblx0XHRcdHN0cmVhbV91cGxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gSS5jYW4oJ3NlbGVjdF9maWxlJyk7XG5cdFx0XHR9LFxuXHRcdFx0c3VtbW9uX2ZpbGVfZGlhbG9nOiBmdW5jdGlvbigpIHsgLy8geWVhaC4uLiBzb21lIGRpcnR5IHNuaWZmaW5nIGhlcmUuLi5cblx0XHRcdFx0cmV0dXJuIEkuY2FuKCdzZWxlY3RfZmlsZScpICYmIChcblx0XHRcdFx0XHQoRW52LmJyb3dzZXIgPT09ICdGaXJlZm94JyAmJiBFbnYudmVyQ29tcChFbnYudmVyc2lvbiwgNCwgJz49JykpIHx8XG5cdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnT3BlcmEnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAxMiwgJz49JykpIHx8XG5cdFx0XHRcdFx0KEVudi5icm93c2VyID09PSAnSUUnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAxMCwgJz49JykpIHx8XG5cdFx0XHRcdFx0ISF+QmFzaWMuaW5BcnJheShFbnYuYnJvd3NlciwgWydDaHJvbWUnLCAnU2FmYXJpJ10pXG5cdFx0XHRcdCk7XG5cdFx0XHR9LFxuXHRcdFx0dXBsb2FkX2ZpbGVzaXplOiBUcnVlLFxuXHRcdFx0dXNlX2h0dHBfbWV0aG9kOiBmdW5jdGlvbihtZXRob2RzKSB7XG5cdFx0XHRcdHJldHVybiAhQmFzaWMuYXJyYXlEaWZmKG1ldGhvZHMsIFsnR0VUJywgJ1BPU1QnXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRpbml0IDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcIkluaXRcIik7XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiAoZnVuY3Rpb24oZGVzdHJveSkgeyAvLyBleHRlbmQgZGVmYXVsdCBkZXN0cm95IG1ldGhvZFxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVzdHJveS5jYWxsKEkpO1xuXHRcdFx0XHRcdGRlc3Ryb3kgPSBJID0gbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdH0odGhpcy5kZXN0cm95KSlcblx0XHR9KTtcblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLmdldFNoaW0oKSwgZXh0ZW5zaW9ucyk7XG5cdH1cblxuXHRSdW50aW1lLmFkZENvbnN0cnVjdG9yKHR5cGUsIEh0bWw0UnVudGltZSk7XG5cblx0cmV0dXJuIGV4dGVuc2lvbnM7XG59KTtcblxuLy8gSW5jbHVkZWQgZnJvbTogc3JjL2phdmFzY3JpcHQvcnVudGltZS9odG1sNC9maWxlL0ZpbGVJbnB1dC5qc1xuXG4vKipcbiAqIEZpbGVJbnB1dC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw0L2ZpbGUvRmlsZUlucHV0XG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDQvZmlsZS9GaWxlSW5wdXRcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvaHRtbDQvUnVudGltZVwiLFxuXHRcIm1veGllL2ZpbGUvRmlsZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0RvbVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvRXZlbnRzXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9NaW1lXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FbnZcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgRmlsZSwgQmFzaWMsIERvbSwgRXZlbnRzLCBNaW1lLCBFbnYpIHtcblx0XG5cdGZ1bmN0aW9uIEZpbGVJbnB1dCgpIHtcblx0XHR2YXIgX3VpZCwgX21pbWVzID0gW10sIF9vcHRpb25zLCBfYnJvd3NlQnRuWkluZGV4OyAvLyBzYXZlIG9yaWdpbmFsIHotaW5kZXg7XG5cblx0XHRmdW5jdGlvbiBhZGRJbnB1dCgpIHtcblx0XHRcdHZhciBjb21wID0gdGhpcywgSSA9IGNvbXAuZ2V0UnVudGltZSgpLCBzaGltQ29udGFpbmVyLCBicm93c2VCdXR0b24sIGN1cnJGb3JtLCBmb3JtLCBpbnB1dCwgdWlkO1xuXG5cdFx0XHR1aWQgPSBCYXNpYy5ndWlkKCd1aWRfJyk7XG5cblx0XHRcdHNoaW1Db250YWluZXIgPSBJLmdldFNoaW1Db250YWluZXIoKTsgLy8gd2UgZ2V0IG5ldyByZWYgZXZlcnkgdGltZSB0byBhdm9pZCBtZW1vcnkgbGVha3MgaW4gSUVcblxuXHRcdFx0aWYgKF91aWQpIHsgLy8gbW92ZSBwcmV2aW91cyBmb3JtIG91dCBvZiB0aGUgdmlld1xuXHRcdFx0XHRjdXJyRm9ybSA9IERvbS5nZXQoX3VpZCArICdfZm9ybScpO1xuXHRcdFx0XHRpZiAoY3VyckZvcm0pIHtcblx0XHRcdFx0XHRCYXNpYy5leHRlbmQoY3VyckZvcm0uc3R5bGUsIHsgdG9wOiAnMTAwJScgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYnVpbGQgZm9ybSBpbiBET00sIHNpbmNlIGlubmVySFRNTCB2ZXJzaW9uIG5vdCBhYmxlIHRvIHN1Ym1pdCBmaWxlIGZvciBzb21lIHJlYXNvblxuXHRcdFx0Zm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdpZCcsIHVpZCArICdfZm9ybScpO1xuXHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsICdwb3N0Jyk7XG5cdFx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnZW5jdHlwZScsICdtdWx0aXBhcnQvZm9ybS1kYXRhJyk7XG5cdFx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnZW5jb2RpbmcnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpO1xuXG5cdFx0XHRCYXNpYy5leHRlbmQoZm9ybS5zdHlsZSwge1xuXHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdGhlaWdodDogJzEwMCUnXG5cdFx0XHR9KTtcblxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCdpZCcsIHVpZCk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCBfbWltZXMuam9pbignLCcpKTtcblxuXHRcdFx0QmFzaWMuZXh0ZW5kKGlucHV0LnN0eWxlLCB7XG5cdFx0XHRcdGZvbnRTaXplOiAnOTk5cHgnLFxuXHRcdFx0XHRvcGFjaXR5OiAwXG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG5cdFx0XHRzaGltQ29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xuXG5cdFx0XHQvLyBwcmVwYXJlIGZpbGUgaW5wdXQgdG8gYmUgcGxhY2VkIHVuZGVybmVhdGggdGhlIGJyb3dzZV9idXR0b24gZWxlbWVudFxuXHRcdFx0QmFzaWMuZXh0ZW5kKGlucHV0LnN0eWxlLCB7XG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdGhlaWdodDogJzEwMCUnXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKEVudi5icm93c2VyID09PSAnSUUnICYmIEVudi52ZXJDb21wKEVudi52ZXJzaW9uLCAxMCwgJzwnKSkge1xuXHRcdFx0XHRCYXNpYy5leHRlbmQoaW5wdXQuc3R5bGUsIHtcblx0XHRcdFx0XHRmaWx0ZXIgOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShvcGFjaXR5PTApXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlucHV0Lm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7IC8vIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBoYW5kbGVyIGZvciB0aGlzXG5cdFx0XHRcdHZhciBmaWxlO1xuXG5cdFx0XHRcdGlmICghdGhpcy52YWx1ZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmZpbGVzKSB7IC8vIGNoZWNrIGlmIGJyb3dzZXIgaXMgZnJlc2ggZW5vdWdoXG5cdFx0XHRcdFx0ZmlsZSA9IHRoaXMuZmlsZXNbMF07XG5cblx0XHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgZmlsZXMgKElFMTAgZm9yIGV4YW1wbGUgaGFuZ3MgaWYgeW91IHRyeSB0byBzZW5kIHRoZW0gdmlhIFhIUilcblx0XHRcdFx0XHRpZiAoZmlsZS5zaXplID09PSAwKSB7XG5cdFx0XHRcdFx0XHRmb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9ybSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbGUgPSB7XG5cdFx0XHRcdFx0XHRuYW1lOiB0aGlzLnZhbHVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpbGUgPSBuZXcgRmlsZShJLnVpZCwgZmlsZSk7XG5cblx0XHRcdFx0Ly8gY2xlYXIgZXZlbnQgaGFuZGxlclxuXHRcdFx0XHR0aGlzLm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7fTsgXG5cdFx0XHRcdGFkZElucHV0LmNhbGwoY29tcCk7IFxuXG5cdFx0XHRcdGNvbXAuZmlsZXMgPSBbZmlsZV07XG5cblx0XHRcdFx0Ly8gc3Vic3RpdHV0ZSBhbGwgaWRzIHdpdGggZmlsZSB1aWRzIChjb25zaWRlciBmaWxlLnVpZCByZWFkLW9ubHkgLSB3ZSBjYW5ub3QgZG8gaXQgdGhlIG90aGVyIHdheSBhcm91bmQpXG5cdFx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCBmaWxlLnVpZCk7XG5cdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdpZCcsIGZpbGUudWlkICsgJ19mb3JtJyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb21wLnRyaWdnZXIoJ2NoYW5nZScpO1xuXG5cdFx0XHRcdGlucHV0ID0gZm9ybSA9IG51bGw7XG5cdFx0XHR9O1xuXG5cblx0XHRcdC8vIHJvdXRlIGNsaWNrIGV2ZW50IHRvIHRoZSBpbnB1dFxuXHRcdFx0aWYgKEkuY2FuKCdzdW1tb25fZmlsZV9kaWFsb2cnKSkge1xuXHRcdFx0XHRicm93c2VCdXR0b24gPSBEb20uZ2V0KF9vcHRpb25zLmJyb3dzZV9idXR0b24pO1xuXHRcdFx0XHRFdmVudHMucmVtb3ZlRXZlbnQoYnJvd3NlQnV0dG9uLCAnY2xpY2snLCBjb21wLnVpZCk7XG5cdFx0XHRcdEV2ZW50cy5hZGRFdmVudChicm93c2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRpZiAoaW5wdXQgJiYgIWlucHV0LmRpc2FibGVkKSB7IC8vIGZvciBzb21lIHJlYXNvbiBGRiAodXAgdG8gOC4wLjEgc28gZmFyKSBsZXRzIHRvIGNsaWNrIGRpc2FibGVkIGlucHV0W3R5cGU9ZmlsZV1cblx0XHRcdFx0XHRcdGlucHV0LmNsaWNrKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSwgY29tcC51aWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdWlkID0gdWlkO1xuXG5cdFx0XHRzaGltQ29udGFpbmVyID0gY3VyckZvcm0gPSBicm93c2VCdXR0b24gPSBudWxsO1xuXHRcdH1cblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBjb21wID0gdGhpcywgSSA9IGNvbXAuZ2V0UnVudGltZSgpLCBzaGltQ29udGFpbmVyO1xuXG5cdFx0XHRcdC8vIGZpZ3VyZSBvdXQgYWNjZXB0IHN0cmluZ1xuXHRcdFx0XHRfb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRcdF9taW1lcyA9IG9wdGlvbnMuYWNjZXB0Lm1pbWVzIHx8IE1pbWUuZXh0TGlzdDJtaW1lcyhvcHRpb25zLmFjY2VwdCwgSS5jYW4oJ2ZpbHRlcl9ieV9leHRlbnNpb24nKSk7XG5cblx0XHRcdFx0c2hpbUNvbnRhaW5lciA9IEkuZ2V0U2hpbUNvbnRhaW5lcigpO1xuXG5cdFx0XHRcdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgYnJvd3NlQnV0dG9uLCB6SW5kZXgsIHRvcDtcblxuXHRcdFx0XHRcdGJyb3dzZUJ1dHRvbiA9IERvbS5nZXQob3B0aW9ucy5icm93c2VfYnV0dG9uKTtcblx0XHRcdFx0XHRfYnJvd3NlQnRuWkluZGV4ID0gRG9tLmdldFN0eWxlKGJyb3dzZUJ1dHRvbiwgJ3otaW5kZXgnKSB8fCAnYXV0byc7XG5cblx0XHRcdFx0XHQvLyBSb3V0ZSBjbGljayBldmVudCB0byB0aGUgaW5wdXRbdHlwZT1maWxlXSBlbGVtZW50IGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgc3VjaCBiZWhhdmlvclxuXHRcdFx0XHRcdGlmIChJLmNhbignc3VtbW9uX2ZpbGVfZGlhbG9nJykpIHtcblx0XHRcdFx0XHRcdGlmIChEb20uZ2V0U3R5bGUoYnJvd3NlQnV0dG9uLCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcblx0XHRcdFx0XHRcdFx0YnJvd3NlQnV0dG9uLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0XHRcdFx0XHRcdH1cdFx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFx0Y29tcC5iaW5kKCdSZWZyZXNoJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHpJbmRleCA9IHBhcnNlSW50KF9icm93c2VCdG5aSW5kZXgsIDEwKSB8fCAxO1xuXG5cdFx0XHRcdFx0XHRcdERvbS5nZXQoX29wdGlvbnMuYnJvd3NlX2J1dHRvbikuc3R5bGUuekluZGV4ID0gekluZGV4O1xuXHRcdFx0XHRcdFx0XHR0aGlzLmdldFJ1bnRpbWUoKS5nZXRTaGltQ29udGFpbmVyKCkuc3R5bGUuekluZGV4ID0gekluZGV4IC0gMTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIFNpbmNlIHdlIGhhdmUgdG8gcGxhY2UgaW5wdXRbdHlwZT1maWxlXSBvbiB0b3Agb2YgdGhlIGJyb3dzZV9idXR0b24gZm9yIHNvbWUgYnJvd3NlcnMsXG5cdFx0XHRcdFx0YnJvd3NlX2J1dHRvbiBsb3NlcyBpbnRlcmFjdGl2aXR5LCBzbyB3ZSByZXN0b3JlIGl0IGhlcmUgKi9cblx0XHRcdFx0XHR0b3AgPSBJLmNhbignc3VtbW9uX2ZpbGVfZGlhbG9nJykgPyBicm93c2VCdXR0b24gOiBzaGltQ29udGFpbmVyO1xuXG5cdFx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KHRvcCwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y29tcC50cmlnZ2VyKCdtb3VzZWVudGVyJyk7XG5cdFx0XHRcdFx0fSwgY29tcC51aWQpO1xuXG5cdFx0XHRcdFx0RXZlbnRzLmFkZEV2ZW50KHRvcCwgJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRjb21wLnRyaWdnZXIoJ21vdXNlbGVhdmUnKTtcblx0XHRcdFx0XHR9LCBjb21wLnVpZCk7XG5cblx0XHRcdFx0XHRFdmVudHMuYWRkRXZlbnQodG9wLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRjb21wLnRyaWdnZXIoJ21vdXNlZG93bicpO1xuXHRcdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRcdEV2ZW50cy5hZGRFdmVudChEb20uZ2V0KG9wdGlvbnMuY29udGFpbmVyKSwgJ21vdXNldXAnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGNvbXAudHJpZ2dlcignbW91c2V1cCcpO1xuXHRcdFx0XHRcdH0sIGNvbXAudWlkKTtcblxuXHRcdFx0XHRcdGJyb3dzZUJ1dHRvbiA9IG51bGw7XG5cdFx0XHRcdH0oKSk7XG5cblx0XHRcdFx0YWRkSW5wdXQuY2FsbCh0aGlzKTtcblxuXHRcdFx0XHRzaGltQ29udGFpbmVyID0gbnVsbDtcblxuXHRcdFx0XHQvLyB0cmlnZ2VyIHJlYWR5IGV2ZW50IGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdGNvbXAudHJpZ2dlcih7XG5cdFx0XHRcdFx0dHlwZTogJ3JlYWR5Jyxcblx0XHRcdFx0XHRhc3luYzogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdHNldE9wdGlvbjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHRcdFx0dmFyIEkgPSB0aGlzLmdldFJ1bnRpbWUoKTtcblx0XHRcdFx0dmFyIGlucHV0O1xuXG5cdFx0XHRcdGlmIChuYW1lID09ICdhY2NlcHQnKSB7XG5cdFx0XHRcdFx0X21pbWVzID0gdmFsdWUubWltZXMgfHwgTWltZS5leHRMaXN0Mm1pbWVzKHZhbHVlLCBJLmNhbignZmlsdGVyX2J5X2V4dGVuc2lvbicpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSBjdXJyZW50IGlucHV0XG5cdFx0XHRcdGlucHV0ID0gRG9tLmdldChfdWlkKVxuXHRcdFx0XHRpZiAoaW5wdXQpIHtcblx0XHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsIF9taW1lcy5qb2luKCcsJykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0XHRcdHZhciBpbnB1dDtcblxuXHRcdFx0XHRpZiAoKGlucHV0ID0gRG9tLmdldChfdWlkKSkpIHtcblx0XHRcdFx0XHRpbnB1dC5kaXNhYmxlZCA9ICEhc3RhdGU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgSSA9IHRoaXMuZ2V0UnVudGltZSgpXG5cdFx0XHRcdCwgc2hpbSA9IEkuZ2V0U2hpbSgpXG5cdFx0XHRcdCwgc2hpbUNvbnRhaW5lciA9IEkuZ2V0U2hpbUNvbnRhaW5lcigpXG5cdFx0XHRcdCwgY29udGFpbmVyID0gX29wdGlvbnMgJiYgRG9tLmdldChfb3B0aW9ucy5jb250YWluZXIpXG5cdFx0XHRcdCwgYnJvd3NlQnV0dG9uID0gX29wdGlvbnMgJiYgRG9tLmdldChfb3B0aW9ucy5icm93c2VfYnV0dG9uKVxuXHRcdFx0XHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY29udGFpbmVyKSB7XG5cdFx0XHRcdFx0RXZlbnRzLnJlbW92ZUFsbEV2ZW50cyhjb250YWluZXIsIHRoaXMudWlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGJyb3dzZUJ1dHRvbikge1xuXHRcdFx0XHRcdEV2ZW50cy5yZW1vdmVBbGxFdmVudHMoYnJvd3NlQnV0dG9uLCB0aGlzLnVpZCk7XG5cdFx0XHRcdFx0YnJvd3NlQnV0dG9uLnN0eWxlLnpJbmRleCA9IF9icm93c2VCdG5aSW5kZXg7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzaGltQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0RXZlbnRzLnJlbW92ZUFsbEV2ZW50cyhzaGltQ29udGFpbmVyLCB0aGlzLnVpZCk7XG5cdFx0XHRcdFx0c2hpbUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoaW0ucmVtb3ZlSW5zdGFuY2UodGhpcy51aWQpO1xuXG5cdFx0XHRcdF91aWQgPSBfbWltZXMgPSBfb3B0aW9ucyA9IHNoaW1Db250YWluZXIgPSBjb250YWluZXIgPSBicm93c2VCdXR0b24gPSBzaGltID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiAoZXh0ZW5zaW9ucy5GaWxlSW5wdXQgPSBGaWxlSW5wdXQpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDQvZmlsZS9GaWxlUmVhZGVyLmpzXG5cbi8qKlxuICogRmlsZVJlYWRlci5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw0L2ZpbGUvRmlsZVJlYWRlclxuQHByaXZhdGVcbiovXG5kZWZpbmUoXCJtb3hpZS9ydW50aW1lL2h0bWw0L2ZpbGUvRmlsZVJlYWRlclwiLCBbXG5cdFwibW94aWUvcnVudGltZS9odG1sNC9SdW50aW1lXCIsXG5cdFwibW94aWUvcnVudGltZS9odG1sNS9maWxlL0ZpbGVSZWFkZXJcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgRmlsZVJlYWRlcikge1xuXHRyZXR1cm4gKGV4dGVuc2lvbnMuRmlsZVJlYWRlciA9IEZpbGVSZWFkZXIpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDQveGhyL1hNTEh0dHBSZXF1ZXN0LmpzXG5cbi8qKlxuICogWE1MSHR0cFJlcXVlc3QuanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKi9cblxuLyoqXG5AY2xhc3MgbW94aWUvcnVudGltZS9odG1sNC94aHIvWE1MSHR0cFJlcXVlc3RcbkBwcml2YXRlXG4qL1xuZGVmaW5lKFwibW94aWUvcnVudGltZS9odG1sNC94aHIvWE1MSHR0cFJlcXVlc3RcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvaHRtbDQvUnVudGltZVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvQmFzaWNcIixcblx0XCJtb3hpZS9jb3JlL3V0aWxzL0RvbVwiLFxuXHRcIm1veGllL2NvcmUvdXRpbHMvVXJsXCIsXG5cdFwibW94aWUvY29yZS9FeGNlcHRpb25zXCIsXG5cdFwibW94aWUvY29yZS91dGlscy9FdmVudHNcIixcblx0XCJtb3hpZS9maWxlL0Jsb2JcIixcblx0XCJtb3hpZS94aHIvRm9ybURhdGFcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgQmFzaWMsIERvbSwgVXJsLCB4LCBFdmVudHMsIEJsb2IsIEZvcm1EYXRhKSB7XG5cdFxuXHRmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdCgpIHtcblx0XHR2YXIgX3N0YXR1cywgX3Jlc3BvbnNlLCBfaWZyYW1lO1xuXG5cdFx0ZnVuY3Rpb24gY2xlYW51cChjYikge1xuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMsIHVpZCwgZm9ybSwgaW5wdXRzLCBpLCBoYXNGaWxlID0gZmFsc2U7XG5cblx0XHRcdGlmICghX2lmcmFtZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVpZCA9IF9pZnJhbWUuaWQucmVwbGFjZSgvX2lmcmFtZSQvLCAnJyk7XG5cblx0XHRcdGZvcm0gPSBEb20uZ2V0KHVpZCArICdfZm9ybScpO1xuXHRcdFx0aWYgKGZvcm0pIHtcblx0XHRcdFx0aW5wdXRzID0gZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcblx0XHRcdFx0aSA9IGlucHV0cy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHN3aXRjaCAoaW5wdXRzW2ldLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdoaWRkZW4nOlxuXHRcdFx0XHRcdFx0XHRpbnB1dHNbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnB1dHNbaV0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2ZpbGUnOlxuXHRcdFx0XHRcdFx0XHRoYXNGaWxlID0gdHJ1ZTsgLy8gZmxhZyB0aGUgY2FzZSBmb3IgbGF0ZXJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlucHV0cyA9IFtdO1xuXG5cdFx0XHRcdGlmICghaGFzRmlsZSkgeyAvLyB3ZSBuZWVkIHRvIGtlZXAgdGhlIGZvcm0gZm9yIHNha2Ugb2YgcG9zc2libGUgcmV0cmllc1xuXHRcdFx0XHRcdGZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmb3JtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3JtID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gd2l0aG91dCB0aW1lb3V0LCByZXF1ZXN0IGlzIG1hcmtlZCBhcyBjYW5jZWxlZCAoaW4gY29uc29sZSlcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdEV2ZW50cy5yZW1vdmVFdmVudChfaWZyYW1lLCAnbG9hZCcsIHRhcmdldC51aWQpO1xuXHRcdFx0XHRpZiAoX2lmcmFtZS5wYXJlbnROb2RlKSB7IC8vICMzODJcblx0XHRcdFx0XHRfaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX2lmcmFtZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBpZiBzaGltIGNvbnRhaW5lciBoYXMgYW55IG90aGVyIGNoaWxkcmVuLCBpZiAtIG5vdCwgcmVtb3ZlIGl0IGFzIHdlbGxcblx0XHRcdFx0dmFyIHNoaW1Db250YWluZXIgPSB0YXJnZXQuZ2V0UnVudGltZSgpLmdldFNoaW1Db250YWluZXIoKTtcblx0XHRcdFx0aWYgKCFzaGltQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdHNoaW1Db250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzaGltQ29udGFpbmVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoaW1Db250YWluZXIgPSBfaWZyYW1lID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdH0sIDEpO1xuXHRcdH1cblxuXHRcdEJhc2ljLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbihtZXRhLCBkYXRhKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLCBJID0gdGFyZ2V0LmdldFJ1bnRpbWUoKSwgdWlkLCBmb3JtLCBpbnB1dCwgYmxvYjtcblxuXHRcdFx0XHRfc3RhdHVzID0gX3Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdFx0XHRmdW5jdGlvbiBjcmVhdGVJZnJhbWUoKSB7XG5cdFx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IEkuZ2V0U2hpbUNvbnRhaW5lcigpIHx8IGRvY3VtZW50LmJvZHlcblx0XHRcdFx0XHQsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHRcdFx0XHRcdDtcblxuXHRcdFx0XHRcdC8vIElFIDYgd29uJ3QgYmUgYWJsZSB0byBzZXQgdGhlIG5hbWUgdXNpbmcgc2V0QXR0cmlidXRlIG9yIGlmcmFtZS5uYW1lXG5cdFx0XHRcdFx0dGVtcC5pbm5lckhUTUwgPSAnPGlmcmFtZSBpZD1cIicgKyB1aWQgKyAnX2lmcmFtZVwiIG5hbWU9XCInICsgdWlkICsgJ19pZnJhbWVcIiBzcmM9XCJqYXZhc2NyaXB0OiZxdW90OyZxdW90O1wiIHN0eWxlPVwiZGlzcGxheTpub25lXCI+PC9pZnJhbWU+Jztcblx0XHRcdFx0XHRfaWZyYW1lID0gdGVtcC5maXJzdENoaWxkO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChfaWZyYW1lKTtcblxuXHRcdFx0XHRcdC8qIF9pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmluZm8oX2lmcmFtZS5yZWFkeVN0YXRlKTtcblx0XHRcdFx0XHR9OyovXG5cblx0XHRcdFx0XHRFdmVudHMuYWRkRXZlbnQoX2lmcmFtZSwgJ2xvYWQnLCBmdW5jdGlvbigpIHsgLy8gX2lmcmFtZS5vbmxvYWQgZG9lc24ndCB3b3JrIGluIElFIGx0ZSA4XG5cdFx0XHRcdFx0XHR2YXIgZWw7XG5cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGVsID0gX2lmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50IHx8IF9pZnJhbWUuY29udGVudERvY3VtZW50IHx8IHdpbmRvdy5mcmFtZXNbX2lmcmFtZS5pZF0uZG9jdW1lbnQ7XG5cblx0XHRcdFx0XHRcdFx0Ly8gdHJ5IHRvIGRldGVjdCBzb21lIHN0YW5kYXJkIGVycm9yIHBhZ2VzXG5cdFx0XHRcdFx0XHRcdGlmICgvXjQoMFswLTldfDFbMC03XXwyWzIzNDZdKVxccy8udGVzdChlbC50aXRsZSkpIHsgLy8gdGVzdCBpZiB0aXRsZSBzdGFydHMgd2l0aCA0eHggSFRUUCBlcnJvclxuXHRcdFx0XHRcdFx0XHRcdF9zdGF0dXMgPSBlbC50aXRsZS5yZXBsYWNlKC9eKFxcZCspLiokLywgJyQxJyk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0X3N0YXR1cyA9IDIwMDtcblx0XHRcdFx0XHRcdFx0XHQvLyBnZXQgcmVzdWx0XG5cdFx0XHRcdFx0XHRcdFx0X3Jlc3BvbnNlID0gQmFzaWMudHJpbShlbC5ib2R5LmlubmVySFRNTCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGZpcmUgdGhlc2UgYXQgbGVhc3Qgb25jZVxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldC50cmlnZ2VyKHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdwcm9ncmVzcycsXG5cdFx0XHRcdFx0XHRcdFx0XHRsb2FkZWQ6IF9yZXNwb25zZS5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0XHR0b3RhbDogX3Jlc3BvbnNlLmxlbmd0aFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGJsb2IpIHsgLy8gaWYgd2Ugd2VyZSB1cGxvYWRpbmcgYSBmaWxlXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcih7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICd1cGxvYWRwcm9ncmVzcycsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxvYWRlZDogYmxvYi5zaXplIHx8IDEwMjUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRvdGFsOiBibG9iLnNpemUgfHwgMTAyNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoVXJsLmhhc1NhbWVPcmlnaW4obWV0YS51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgcmVzcG9uc2UgaXMgc2VudCB3aXRoIGVycm9yIGNvZGUsIGlmcmFtZSBpbiBJRSBnZXRzIHJlZGlyZWN0ZWQgdG8gcmVzOi8vaWVmcmFtZS5kbGwvaHR0cF94Lmh0bVxuXHRcdFx0XHRcdFx0XHRcdC8vIHdoaWNoIG9idmlvdXNseSByZXN1bHRzIHRvIGNyb3NzIGRvbWFpbiBlcnJvciAod3RmPylcblx0XHRcdFx0XHRcdFx0XHRfc3RhdHVzID0gNDA0O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNsZWFudXAuY2FsbCh0YXJnZXQsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnRyaWdnZXIoJ2Vycm9yJyk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNsZWFudXAuY2FsbCh0YXJnZXQsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXQudHJpZ2dlcignbG9hZCcpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSwgdGFyZ2V0LnVpZCk7XG5cdFx0XHRcdH0gLy8gZW5kIGNyZWF0ZUlmcmFtZVxuXG5cdFx0XHRcdC8vIHByZXBhcmUgZGF0YSB0byBiZSBzZW50IGFuZCBjb252ZXJ0IGlmIHJlcXVpcmVkXG5cdFx0XHRcdGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEgJiYgZGF0YS5oYXNCbG9iKCkpIHtcblx0XHRcdFx0XHRibG9iID0gZGF0YS5nZXRCbG9iKCk7XG5cdFx0XHRcdFx0dWlkID0gYmxvYi51aWQ7XG5cdFx0XHRcdFx0aW5wdXQgPSBEb20uZ2V0KHVpZCk7XG5cdFx0XHRcdFx0Zm9ybSA9IERvbS5nZXQodWlkICsgJ19mb3JtJyk7XG5cdFx0XHRcdFx0aWYgKCFmb3JtKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgeC5ET01FeGNlcHRpb24oeC5ET01FeGNlcHRpb24uTk9UX0ZPVU5EX0VSUik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVpZCA9IEJhc2ljLmd1aWQoJ3VpZF8nKTtcblxuXHRcdFx0XHRcdGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cdFx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2lkJywgdWlkICsgJ19mb3JtJyk7XG5cdFx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsIG1ldGEubWV0aG9kKTtcblx0XHRcdFx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnZW5jdHlwZScsICdtdWx0aXBhcnQvZm9ybS1kYXRhJyk7XG5cdFx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2VuY29kaW5nJywgJ211bHRpcGFydC9mb3JtLWRhdGEnKTtcblxuXHRcdFx0XHRcdEkuZ2V0U2hpbUNvbnRhaW5lcigpLmFwcGVuZENoaWxkKGZvcm0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2V0IHVwbG9hZCB0YXJnZXRcblx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsIHVpZCArICdfaWZyYW1lJyk7XG5cblx0XHRcdFx0aWYgKGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRcdGRhdGEuZWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5wdXQpIHtcblx0XHRcdFx0XHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGhpZGRlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cblx0XHRcdFx0XHRcdFx0QmFzaWMuZXh0ZW5kKGhpZGRlbiwge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGUgOiAnaGlkZGVuJyxcblx0XHRcdFx0XHRcdFx0XHRuYW1lIDogbmFtZSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA6IHZhbHVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IGlucHV0W3R5cGU9XCJmaWxlXCJdLCBpZiBpdCdzIHRoZXJlLCBjb21lcyBsYXN0XG5cdFx0XHRcdFx0XHRcdGlmIChpbnB1dCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvcm0uaW5zZXJ0QmVmb3JlKGhpZGRlbiwgaW5wdXQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGZvcm0uYXBwZW5kQ2hpbGQoaGlkZGVuKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2V0IGRlc3RpbmF0aW9uIHVybFxuXHRcdFx0XHRmb3JtLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCBtZXRhLnVybCk7XG5cblx0XHRcdFx0Y3JlYXRlSWZyYW1lKCk7XG5cdFx0XHRcdGZvcm0uc3VibWl0KCk7XG5cdFx0XHRcdHRhcmdldC50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcblx0XHRcdH0sXG5cblx0XHRcdGdldFN0YXR1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfc3RhdHVzO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0UmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRpZiAoJ2pzb24nID09PSByZXNwb25zZVR5cGUpIHtcblx0XHRcdFx0XHQvLyBzdHJpcCBvZmYgPHByZT4uLjwvcHJlPiB0YWdzIHRoYXQgbWlnaHQgYmUgZW5jbG9zaW5nIHRoZSByZXNwb25zZVxuXHRcdFx0XHRcdGlmIChCYXNpYy50eXBlT2YoX3Jlc3BvbnNlKSA9PT0gJ3N0cmluZycgJiYgISF3aW5kb3cuSlNPTikge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoX3Jlc3BvbnNlLnJlcGxhY2UoL15cXHMqPHByZVtePl0qPi8sICcnKS5yZXBsYWNlKC88XFwvcHJlPlxccyokLywgJycpKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdH0gZWxzZSBpZiAoJ2RvY3VtZW50JyA9PT0gcmVzcG9uc2VUeXBlKSB7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gX3Jlc3BvbnNlO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcztcblxuXHRcdFx0XHRpZiAoX2lmcmFtZSAmJiBfaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcblx0XHRcdFx0XHRpZiAoX2lmcmFtZS5jb250ZW50V2luZG93LnN0b3ApIHsgLy8gRmlyZUZveC9TYWZhcmkvQ2hyb21lXG5cdFx0XHRcdFx0XHRfaWZyYW1lLmNvbnRlbnRXaW5kb3cuc3RvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoX2lmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKSB7IC8vIElFXG5cdFx0XHRcdFx0XHRfaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ1N0b3AnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X2lmcmFtZS5zcmMgPSBcImFib3V0OmJsYW5rXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2xlYW51cC5jYWxsKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIHRhcmdldC5kaXNwYXRjaEV2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJyk7XG5cdFx0XHRcdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoJ2Fib3J0Jyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIChleHRlbnNpb25zLlhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3QpO1xufSk7XG5cbi8vIEluY2x1ZGVkIGZyb206IHNyYy9qYXZhc2NyaXB0L3J1bnRpbWUvaHRtbDQvaW1hZ2UvSW1hZ2UuanNcblxuLyoqXG4gKiBJbWFnZS5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG4vKipcbkBjbGFzcyBtb3hpZS9ydW50aW1lL2h0bWw0L2ltYWdlL0ltYWdlXG5AcHJpdmF0ZVxuKi9cbmRlZmluZShcIm1veGllL3J1bnRpbWUvaHRtbDQvaW1hZ2UvSW1hZ2VcIiwgW1xuXHRcIm1veGllL3J1bnRpbWUvaHRtbDQvUnVudGltZVwiLFxuXHRcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvSW1hZ2VcIlxuXSwgZnVuY3Rpb24oZXh0ZW5zaW9ucywgSW1hZ2UpIHtcblx0cmV0dXJuIChleHRlbnNpb25zLkltYWdlID0gSW1hZ2UpO1xufSk7XG5cbmV4cG9zZShbXCJtb3hpZS9jb3JlL3V0aWxzL0Jhc2ljXCIsXCJtb3hpZS9jb3JlL3V0aWxzL0VuY29kZVwiLFwibW94aWUvY29yZS91dGlscy9FbnZcIixcIm1veGllL2NvcmUvRXhjZXB0aW9uc1wiLFwibW94aWUvY29yZS91dGlscy9Eb21cIixcIm1veGllL2NvcmUvRXZlbnRUYXJnZXRcIixcIm1veGllL3J1bnRpbWUvUnVudGltZVwiLFwibW94aWUvcnVudGltZS9SdW50aW1lQ2xpZW50XCIsXCJtb3hpZS9maWxlL0Jsb2JcIixcIm1veGllL2NvcmUvSTE4blwiLFwibW94aWUvY29yZS91dGlscy9NaW1lXCIsXCJtb3hpZS9maWxlL0ZpbGVJbnB1dFwiLFwibW94aWUvZmlsZS9GaWxlXCIsXCJtb3hpZS9maWxlL0ZpbGVEcm9wXCIsXCJtb3hpZS9maWxlL0ZpbGVSZWFkZXJcIixcIm1veGllL2NvcmUvdXRpbHMvVXJsXCIsXCJtb3hpZS9ydW50aW1lL1J1bnRpbWVUYXJnZXRcIixcIm1veGllL3hoci9Gb3JtRGF0YVwiLFwibW94aWUveGhyL1hNTEh0dHBSZXF1ZXN0XCIsXCJtb3hpZS9ydW50aW1lL1RyYW5zcG9ydGVyXCIsXCJtb3hpZS9pbWFnZS9JbWFnZVwiLFwibW94aWUvY29yZS91dGlscy9FdmVudHNcIixcIm1veGllL3J1bnRpbWUvaHRtbDUvaW1hZ2UvUmVzaXplckNhbnZhc1wiXSk7XG59KSh0aGlzKTtcbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wbHVwbG9hZC9tb3hpZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFBsdXBsb2FkIC0gbXVsdGktcnVudGltZSBGaWxlIFVwbG9hZGVyXG4gKiB2Mi4zLjFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgTW94aWVjb2RlIFN5c3RlbXMgQUJcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBMaWNlbnNlLlxuICpcbiAqIExpY2Vuc2U6IGh0dHA6Ly93d3cucGx1cGxvYWQuY29tL2xpY2Vuc2VcbiAqIENvbnRyaWJ1dGluZzogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vY29udHJpYnV0aW5nXG4gKlxuICogRGF0ZTogMjAxNy0wMi0wNlxuICovXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dmFyIGV4dHJhY3QgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0ge307XG5cdFx0ZmFjdG9yeS5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGN0eC5wbHVwbG9hZDtcblx0fTtcblx0XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShcInBsdXBsb2FkXCIsIFsnLi9tb3hpZSddLCBleHRyYWN0KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHRyYWN0KHJlcXVpcmUoJy4uLy4uLy4uL2pzLXNkay1tYXN0ZXIgMi9zcmMvbW94aWUnKSk7XG5cdH0gZWxzZSB7XG5cdFx0Z2xvYmFsLnBsdXBsb2FkID0gZXh0cmFjdChnbG9iYWwubW94aWUpO1xuXHR9XG59KHRoaXMgfHwgd2luZG93LCBmdW5jdGlvbihtb3hpZSkge1xuLyoqXG4gKiBQbHVwbG9hZC5qc1xuICpcbiAqIENvcHlyaWdodCAyMDEzLCBNb3hpZWNvZGUgU3lzdGVtcyBBQlxuICogUmVsZWFzZWQgdW5kZXIgR1BMIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZTogaHR0cDovL3d3dy5wbHVwbG9hZC5jb20vbGljZW5zZVxuICogQ29udHJpYnV0aW5nOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9jb250cmlidXRpbmdcbiAqL1xuXG47KGZ1bmN0aW9uKGV4cG9ydHMsIG8sIHVuZGVmKSB7XG5cbnZhciBkZWxheSA9IHdpbmRvdy5zZXRUaW1lb3V0O1xudmFyIGZpbGVGaWx0ZXJzID0ge307XG52YXIgdSA9IG8uY29yZS51dGlscztcbnZhciBSdW50aW1lID0gby5ydW50aW1lLlJ1bnRpbWU7XG5cbi8vIGNvbnZlcnQgcGx1cGxvYWQgZmVhdHVyZXMgdG8gY2FwcyBhY2NlcHRhYmxlIGJ5IG1PeGllXG5mdW5jdGlvbiBub3JtYWxpemVDYXBzKHNldHRpbmdzKSB7XG5cdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLnJlcXVpcmVkX2ZlYXR1cmVzLCBjYXBzID0ge307XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZShmZWF0dXJlLCB2YWx1ZSwgc3RyaWN0KSB7XG5cdFx0Ly8gRmVhdHVyZSBub3RhdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgY2FwcyAodGhpcyB0aGluZyBoZXJlIGlzIHJlcXVpcmVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuXHRcdHZhciBtYXAgPSB7XG5cdFx0XHRjaHVua3M6ICdzbGljZV9ibG9iJyxcblx0XHRcdGpwZ3Jlc2l6ZTogJ3NlbmRfYmluYXJ5X3N0cmluZycsXG5cdFx0XHRwbmdyZXNpemU6ICdzZW5kX2JpbmFyeV9zdHJpbmcnLFxuXHRcdFx0cHJvZ3Jlc3M6ICdyZXBvcnRfdXBsb2FkX3Byb2dyZXNzJyxcblx0XHRcdG11bHRpX3NlbGVjdGlvbjogJ3NlbGVjdF9tdWx0aXBsZScsXG5cdFx0XHRkcmFnZHJvcDogJ2RyYWdfYW5kX2Ryb3AnLFxuXHRcdFx0ZHJvcF9lbGVtZW50OiAnZHJhZ19hbmRfZHJvcCcsXG5cdFx0XHRoZWFkZXJzOiAnc2VuZF9jdXN0b21faGVhZGVycycsXG5cdFx0XHR1cmxzdHJlYW1fdXBsb2FkOiAnc2VuZF9iaW5hcnlfc3RyaW5nJyxcblx0XHRcdGNhblNlbmRCaW5hcnk6ICdzZW5kX2JpbmFyeScsXG5cdFx0XHR0cmlnZ2VyRGlhbG9nOiAnc3VtbW9uX2ZpbGVfZGlhbG9nJ1xuXHRcdH07XG5cblx0XHRpZiAobWFwW2ZlYXR1cmVdKSB7XG5cdFx0XHRjYXBzW21hcFtmZWF0dXJlXV0gPSB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKCFzdHJpY3QpIHtcblx0XHRcdGNhcHNbZmVhdHVyZV0gPSB2YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRpZiAodHlwZW9mKGZlYXR1cmVzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRwbHVwbG9hZC5lYWNoKGZlYXR1cmVzLnNwbGl0KC9cXHMqLFxccyovKSwgZnVuY3Rpb24oZmVhdHVyZSkge1xuXHRcdFx0cmVzb2x2ZShmZWF0dXJlLCB0cnVlKTtcblx0XHR9KTtcblx0fSBlbHNlIGlmICh0eXBlb2YoZmVhdHVyZXMpID09PSAnb2JqZWN0Jykge1xuXHRcdHBsdXBsb2FkLmVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uKHZhbHVlLCBmZWF0dXJlKSB7XG5cdFx0XHRyZXNvbHZlKGZlYXR1cmUsIHZhbHVlKTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmZWF0dXJlcyA9PT0gdHJ1ZSkge1xuXHRcdC8vIGNoZWNrIHNldHRpbmdzIGZvciByZXF1aXJlZCBmZWF0dXJlc1xuXHRcdGlmIChzZXR0aW5ncy5jaHVua19zaXplICYmIHNldHRpbmdzLmNodW5rX3NpemUgPiAwKSB7XG5cdFx0XHRjYXBzLnNsaWNlX2Jsb2IgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICghcGx1cGxvYWQuaXNFbXB0eU9iaihzZXR0aW5ncy5yZXNpemUpIHx8IHNldHRpbmdzLm11bHRpcGFydCA9PT0gZmFsc2UpIHtcblx0XHRcdGNhcHMuc2VuZF9iaW5hcnlfc3RyaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MuaHR0cF9tZXRob2QpIHtcbiAgICAgICAgICAgIGNhcHMudXNlX2h0dHBfbWV0aG9kID0gc2V0dGluZ3MuaHR0cF9tZXRob2Q7XG4gICAgICAgIH1cblxuXHRcdHBsdXBsb2FkLmVhY2goc2V0dGluZ3MsIGZ1bmN0aW9uKHZhbHVlLCBmZWF0dXJlKSB7XG5cdFx0XHRyZXNvbHZlKGZlYXR1cmUsICEhdmFsdWUsIHRydWUpOyAvLyBzdHJpY3QgY2hlY2tcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBjYXBzO1xufVxuXG4vKipcbiAqIEBtb2R1bGUgcGx1cGxvYWRcbiAqIEBzdGF0aWNcbiAqL1xudmFyIHBsdXBsb2FkID0ge1xuXHQvKipcblx0ICogUGx1cGxvYWQgdmVyc2lvbiB3aWxsIGJlIHJlcGxhY2VkIG9uIGJ1aWxkLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgVkVSU0lPTlxuXHQgKiBAZm9yIFBsdXBsb2FkXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRWRVJTSU9OIDogJzIuMy4xJyxcblxuXHQvKipcblx0ICogVGhlIHN0YXRlIG9mIHRoZSBxdWV1ZSBiZWZvcmUgaXQgaGFzIHN0YXJ0ZWQgYW5kIGFmdGVyIGl0IGhhcyBmaW5pc2hlZFxuXHQgKlxuXHQgKiBAcHJvcGVydHkgU1RPUFBFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0U1RPUFBFRCA6IDEsXG5cblx0LyoqXG5cdCAqIFVwbG9hZCBwcm9jZXNzIGlzIHJ1bm5pbmdcblx0ICpcblx0ICogQHByb3BlcnR5IFNUQVJURURcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdFNUQVJURUQgOiAyLFxuXG5cdC8qKlxuXHQgKiBGaWxlIGlzIHF1ZXVlZCBmb3IgdXBsb2FkXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBRVUVVRURcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdFFVRVVFRCA6IDEsXG5cblx0LyoqXG5cdCAqIEZpbGUgaXMgYmVpbmcgdXBsb2FkZWRcblx0ICpcblx0ICogQHByb3BlcnR5IFVQTE9BRElOR1xuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0VVBMT0FESU5HIDogMixcblxuXHQvKipcblx0ICogRmlsZSBoYXMgZmFpbGVkIHRvIGJlIHVwbG9hZGVkXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBGQUlMRURcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdEZBSUxFRCA6IDQsXG5cblx0LyoqXG5cdCAqIEZpbGUgaGFzIGJlZW4gdXBsb2FkZWQgc3VjY2Vzc2Z1bGx5XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBET05FXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRET05FIDogNSxcblxuXHQvLyBFcnJvciBjb25zdGFudHMgdXNlZCBieSB0aGUgRXJyb3IgZXZlbnRcblxuXHQvKipcblx0ICogR2VuZXJpYyBlcnJvciBmb3IgZXhhbXBsZSBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGluc2lkZSBTaWx2ZXJsaWdodC5cblx0ICpcblx0ICogQHByb3BlcnR5IEdFTkVSSUNfRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdEdFTkVSSUNfRVJST1IgOiAtMTAwLFxuXG5cdC8qKlxuXHQgKiBIVFRQIHRyYW5zcG9ydCBlcnJvci4gRm9yIGV4YW1wbGUgaWYgdGhlIHNlcnZlciBwcm9kdWNlcyBhIEhUVFAgc3RhdHVzIG90aGVyIHRoYW4gMjAwLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgSFRUUF9FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0SFRUUF9FUlJPUiA6IC0yMDAsXG5cblx0LyoqXG5cdCAqIEdlbmVyaWMgSS9PIGVycm9yLiBGb3IgZXhhbXBsZSBpZiBpdCB3YXNuJ3QgcG9zc2libGUgdG8gb3BlbiB0aGUgZmlsZSBzdHJlYW0gb24gbG9jYWwgbWFjaGluZS5cblx0ICpcblx0ICogQHByb3BlcnR5IElPX0VSUk9SXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRJT19FUlJPUiA6IC0zMDAsXG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBTRUNVUklUWV9FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0U0VDVVJJVFlfRVJST1IgOiAtNDAwLFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXphdGlvbiBlcnJvci4gV2lsbCBiZSB0cmlnZ2VyZWQgaWYgbm8gcnVudGltZSB3YXMgaW5pdGlhbGl6ZWQuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBJTklUX0VSUk9SXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRJTklUX0VSUk9SIDogLTUwMCxcblxuXHQvKipcblx0ICogRmlsZSBzaXplIGVycm9yLiBJZiB0aGUgdXNlciBzZWxlY3RzIGEgZmlsZSB0aGF0IGlzIHRvbyBsYXJnZSBpdCB3aWxsIGJlIGJsb2NrZWQgYW5kIGFuIGVycm9yIG9mIHRoaXMgdHlwZSB3aWxsIGJlIHRyaWdnZXJlZC5cblx0ICpcblx0ICogQHByb3BlcnR5IEZJTEVfU0laRV9FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0RklMRV9TSVpFX0VSUk9SIDogLTYwMCxcblxuXHQvKipcblx0ICogRmlsZSBleHRlbnNpb24gZXJyb3IuIElmIHRoZSB1c2VyIHNlbGVjdHMgYSBmaWxlIHRoYXQgaXNuJ3QgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZSBmaWx0ZXJzIHNldHRpbmcuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBGSUxFX0VYVEVOU0lPTl9FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0RklMRV9FWFRFTlNJT05fRVJST1IgOiAtNjAxLFxuXG5cdC8qKlxuXHQgKiBEdXBsaWNhdGUgZmlsZSBlcnJvci4gSWYgcHJldmVudF9kdXBsaWNhdGVzIGlzIHNldCB0byB0cnVlIGFuZCB1c2VyIHNlbGVjdHMgdGhlIHNhbWUgZmlsZSBhZ2Fpbi5cblx0ICpcblx0ICogQHByb3BlcnR5IEZJTEVfRFVQTElDQVRFX0VSUk9SXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqL1xuXHRGSUxFX0RVUExJQ0FURV9FUlJPUiA6IC02MDIsXG5cblx0LyoqXG5cdCAqIFJ1bnRpbWUgd2lsbCB0cnkgdG8gZGV0ZWN0IGlmIGltYWdlIGlzIHByb3BlciBvbmUuIE90aGVyd2lzZSB3aWxsIHRocm93IHRoaXMgZXJyb3IuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBJTUFHRV9GT1JNQVRfRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdElNQUdFX0ZPUk1BVF9FUlJPUiA6IC03MDAsXG5cblx0LyoqXG5cdCAqIFdoaWxlIHdvcmtpbmcgb24gZmlsZXMgcnVudGltZSBtYXkgcnVuIG91dCBvZiBtZW1vcnkgYW5kIHdpbGwgdGhyb3cgdGhpcyBlcnJvci5cblx0ICpcblx0ICogQHNpbmNlIDIuMS4yXG5cdCAqIEBwcm9wZXJ0eSBNRU1PUllfRVJST1Jcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICovXG5cdE1FTU9SWV9FUlJPUiA6IC03MDEsXG5cblx0LyoqXG5cdCAqIEVhY2ggcnVudGltZSBoYXMgYW4gdXBwZXIgbGltaXQgb24gYSBkaW1lbnNpb24gb2YgdGhlIGltYWdlIGl0IGNhbiBoYW5kbGUuIElmIGJpZ2dlciwgd2lsbCB0aHJvdyB0aGlzIGVycm9yLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgSU1BR0VfRElNRU5TSU9OU19FUlJPUlxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0SU1BR0VfRElNRU5TSU9OU19FUlJPUiA6IC03MDIsXG5cblx0LyoqXG5cdCAqIE1pbWUgdHlwZSBsb29rdXAgdGFibGUuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBtaW1lVHlwZXNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBmaW5hbFxuXHQgKi9cblx0bWltZVR5cGVzIDogdS5NaW1lLm1pbWVzLFxuXG5cdC8qKlxuXHQgKiBJbiBzb21lIGNhc2VzIHNuaWZmaW5nIGlzIHRoZSBvbmx5IHdheSBhcm91bmQgOihcblx0ICovXG5cdHVhOiB1LkVudixcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdHJ1ZSB0eXBlIG9mIHRoZSBidWlsdC1pbiBvYmplY3QgKGJldHRlciB2ZXJzaW9uIG9mIHR5cGVvZikuXG5cdCAqIEBjcmVkaXRzIEFuZ3VzIENyb2xsIChodHRwOi8vamF2YXNjcmlwdHdlYmxvZy53b3JkcHJlc3MuY29tLylcblx0ICpcblx0ICogQG1ldGhvZCB0eXBlT2Zcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gbyBPYmplY3QgdG8gY2hlY2suXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gT2JqZWN0IFtbQ2xhc3NdXVxuXHQgKi9cblx0dHlwZU9mOiB1LkJhc2ljLnR5cGVPZixcblxuXHQvKipcblx0ICogRXh0ZW5kcyB0aGUgc3BlY2lmaWVkIG9iamVjdCB3aXRoIGFub3RoZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGV4dGVuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGV4dGVuZC5cblx0ICogQHBhcmFtIHtPYmplY3QuLn0gb2JqIE11bHRpcGxlIG9iamVjdHMgdG8gZXh0ZW5kIHdpdGguXG5cdCAqIEByZXR1cm4ge09iamVjdH0gU2FtZSBhcyB0YXJnZXQsIHRoZSBleHRlbmRlZCBvYmplY3QuXG5cdCAqL1xuXHRleHRlbmQgOiB1LkJhc2ljLmV4dGVuZCxcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGFuIHVuaXF1ZSBJRC4gVGhpcyBpcyA5OS45OSUgdW5pcXVlIHNpbmNlIGl0IHRha2VzIHRoZSBjdXJyZW50IHRpbWUgYW5kIDUgcmFuZG9tIG51bWJlcnMuXG5cdCAqIFRoZSBvbmx5IHdheSBhIHVzZXIgd291bGQgYmUgYWJsZSB0byBnZXQgdGhlIHNhbWUgSUQgaXMgaWYgdGhlIHR3byBwZXJzb25zIGF0IHRoZSBzYW1lIGV4YWN0IG1pbGxpc2Vjb25kIG1hbmFnZXNcblx0ICogdG8gZ2V0IDUgdGhlIHNhbWUgcmFuZG9tIG51bWJlcnMgYmV0d2VlbiAwLTY1NTM1IGl0IGFsc28gdXNlcyBhIGNvdW50ZXIgc28gZWFjaCBjYWxsIHdpbGwgYmUgZ3VhcmFudGVlZCB0byBiZSBwYWdlIHVuaXF1ZS5cblx0ICogSXQncyBtb3JlIHByb2JhYmxlIGZvciB0aGUgZWFydGggdG8gYmUgaGl0IHdpdGggYW4gYXN0ZXJpb2QuIFlvdSBjYW4gYWxzbyBpZiB5b3Ugd2FudCB0byBiZSAxMDAlIHN1cmUgc2V0IHRoZSBwbHVwbG9hZC5ndWlkUHJlZml4IHByb3BlcnR5XG5cdCAqIHRvIGFuIHVzZXIgdW5pcXVlIGtleS5cblx0ICpcblx0ICogQG1ldGhvZCBndWlkXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7U3RyaW5nfSBWaXJ0dWFsbHkgdW5pcXVlIGlkLlxuXHQgKi9cblx0Z3VpZCA6IHUuQmFzaWMuZ3VpZCxcblxuXHQvKipcblx0ICogR2V0IGFycmF5IG9mIERPTSBFbGVtZW50cyBieSB0aGVpciBpZHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBJZGVudGlmaWVyIG9mIHRoZSBET00gRWxlbWVudFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0Ki9cblx0Z2V0QWxsIDogZnVuY3Rpb24gZ2V0KGlkcykge1xuXHRcdHZhciBlbHMgPSBbXSwgZWw7XG5cblx0XHRpZiAocGx1cGxvYWQudHlwZU9mKGlkcykgIT09ICdhcnJheScpIHtcblx0XHRcdGlkcyA9IFtpZHNdO1xuXHRcdH1cblxuXHRcdHZhciBpID0gaWRzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRlbCA9IHBsdXBsb2FkLmdldChpZHNbaV0pO1xuXHRcdFx0aWYgKGVsKSB7XG5cdFx0XHRcdGVscy5wdXNoKGVsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZWxzLmxlbmd0aCA/IGVscyA6IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdEdldCBET00gZWxlbWVudCBieSBpZFxuXG5cdEBtZXRob2QgZ2V0XG5cdEBwYXJhbSB7U3RyaW5nfSBpZCBJZGVudGlmaWVyIG9mIHRoZSBET00gRWxlbWVudFxuXHRAcmV0dXJuIHtOb2RlfVxuXHQqL1xuXHRnZXQ6IHUuRG9tLmdldCxcblxuXHQvKipcblx0ICogRXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0gaW4gYXJyYXkvb2JqZWN0LiBJZiB5b3UgcmV0dXJuIGZhbHNlIGluIHRoZVxuXHQgKiBjYWxsYmFjayBpdCB3aWxsIGJyZWFrIHRoZSBsb29wLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGVhY2hcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byBpdGVyYXRlLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGl0ZW0uXG5cdCAqL1xuXHRlYWNoIDogdS5CYXNpYy5lYWNoLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhYnNvbHV0ZSB4LCB5IHBvc2l0aW9uIG9mIGFuIEVsZW1lbnQuIFRoZSBwb3NpdGlvbiB3aWxsIGJlIHJldHVybmVkIGluIGEgb2JqZWN0IHdpdGggeCwgeSBmaWVsZHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0UG9zXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEhUTUwgZWxlbWVudCBvciBlbGVtZW50IGlkIHRvIGdldCB4LCB5IHBvc2l0aW9uIGZyb20uXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdCBPcHRpb25hbCByb290IGVsZW1lbnQgdG8gc3RvcCBjYWxjdWxhdGlvbnMgYXQuXG5cdCAqIEByZXR1cm4ge29iamVjdH0gQWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IG9iamVjdCB3aXRoIHgsIHkgZmllbGRzLlxuXHQgKi9cblx0Z2V0UG9zIDogdS5Eb20uZ2V0UG9zLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBzcGVjaWZpZWQgbm9kZSBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0U2l6ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGdldCB0aGUgc2l6ZSBvZi5cblx0ICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBhIHcgYW5kIGggcHJvcGVydHkuXG5cdCAqL1xuXHRnZXRTaXplIDogdS5Eb20uZ2V0U2l6ZSxcblxuXHQvKipcblx0ICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIHN0cmluZy5cblx0ICpcblx0ICogQG1ldGhvZCB4bWxFbmNvZGVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gcyBTdHJpbmcgdG8gZW5jb2RlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxuXHQgKi9cblx0eG1sRW5jb2RlIDogZnVuY3Rpb24oc3RyKSB7XG5cdFx0dmFyIHhtbEVuY29kZUNoYXJzID0geyc8JyA6ICdsdCcsICc+JyA6ICdndCcsICcmJyA6ICdhbXAnLCAnXCInIDogJ3F1b3QnLCAnXFwnJyA6ICcjMzknfSwgeG1sRW5jb2RlUmVnRXhwID0gL1s8PiZcXFwiXFwnXS9nO1xuXG5cdFx0cmV0dXJuIHN0ciA/ICgnJyArIHN0cikucmVwbGFjZSh4bWxFbmNvZGVSZWdFeHAsIGZ1bmN0aW9uKGNocikge1xuXHRcdFx0cmV0dXJuIHhtbEVuY29kZUNoYXJzW2Nocl0gPyAnJicgKyB4bWxFbmNvZGVDaGFyc1tjaHJdICsgJzsnIDogY2hyO1xuXHRcdH0pIDogc3RyO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBGb3JjZXMgYW55dGhpbmcgaW50byBhbiBhcnJheS5cblx0ICpcblx0ICogQG1ldGhvZCB0b0FycmF5XG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3Qgd2l0aCBsZW5ndGggZmllbGQuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvYmplY3QgY29udGFpbmluZyBhbGwgaXRlbXMuXG5cdCAqL1xuXHR0b0FycmF5IDogdS5CYXNpYy50b0FycmF5LFxuXG5cdC8qKlxuXHQgKiBGaW5kIGFuIGVsZW1lbnQgaW4gYXJyYXkgYW5kIHJldHVybiBpdHMgaW5kZXggaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHJldHVybiAtMS5cblx0ICpcblx0ICogQG1ldGhvZCBpbkFycmF5XG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHttaXhlZH0gbmVlZGxlIEVsZW1lbnQgdG8gZmluZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuXHQgKiBAcmV0dXJuIHtJbnR9IEluZGV4IG9mIHRoZSBlbGVtZW50LCBvciAtMSBpZiBub3QgZm91bmRcblx0ICovXG5cdGluQXJyYXkgOiB1LkJhc2ljLmluQXJyYXksXG5cblx0LyoqXG5cdFJlY2lldmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zICh1c3VhbGx5IGFzeW5jKSB0byBjYWxsIGluIHNlcXVlbmNlLCBlYWNoICBmdW5jdGlvblxuXHRyZWNlaXZlcyBhIGNhbGxiYWNrIGFzIGZpcnN0IGFyZ3VtZW50IHRoYXQgaXQgc2hvdWxkIGNhbGwsIHdoZW4gaXQgY29tcGxldGVzLiBGaW5hbGx5LFxuXHRhZnRlciBldmVyeXRoaW5nIGlzIGNvbXBsZXRlLCBtYWluIGNhbGxiYWNrIGlzIGNhbGxlZC4gUGFzc2luZyB0cnV0aHkgdmFsdWUgdG8gdGhlXG5cdGNhbGxiYWNrIGFzIGEgZmlyc3QgYXJndW1lbnQgd2lsbCBpbnRlcnJ1cHQgdGhlIHNlcXVlbmNlIGFuZCBpbnZva2UgbWFpbiBjYWxsYmFja1xuXHRpbW1lZGlhdGVseS5cblxuXHRAbWV0aG9kIGluU2VyaWVzXG5cdEBzdGF0aWNcblx0QHBhcmFtIHtBcnJheX0gcXVldWUgQXJyYXkgb2YgZnVuY3Rpb25zIHRvIGNhbGwgaW4gc2VxdWVuY2Vcblx0QHBhcmFtIHtGdW5jdGlvbn0gY2IgTWFpbiBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBpbiB0aGUgZW5kLCBvciBpbiBjYXNlIG9mIGVycm9yXG5cdCovXG5cdGluU2VyaWVzOiB1LkJhc2ljLmluU2VyaWVzLFxuXG5cdC8qKlxuXHQgKiBFeHRlbmRzIHRoZSBsYW5ndWFnZSBwYWNrIG9iamVjdCB3aXRoIG5ldyBpdGVtcy5cblx0ICpcblx0ICogQG1ldGhvZCBhZGRJMThuXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2sgTGFuZ3VhZ2UgcGFjayBpdGVtcyB0byBhZGQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5kZWQgbGFuZ3VhZ2UgcGFjayBvYmplY3QuXG5cdCAqL1xuXHRhZGRJMThuIDogby5jb3JlLkkxOG4uYWRkSTE4bixcblxuXHQvKipcblx0ICogVHJhbnNsYXRlcyB0aGUgc3BlY2lmaWVkIHN0cmluZyBieSBjaGVja2luZyBmb3IgdGhlIGVuZ2xpc2ggc3RyaW5nIGluIHRoZSBsYW5ndWFnZSBwYWNrIGxvb2t1cC5cblx0ICpcblx0ICogQG1ldGhvZCB0cmFuc2xhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBsb29rIGZvci5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUcmFuc2xhdGVkIHN0cmluZyBvciB0aGUgaW5wdXQgc3RyaW5nIGlmIGl0IHdhc24ndCBmb3VuZC5cblx0ICovXG5cdHRyYW5zbGF0ZSA6IG8uY29yZS5JMThuLnRyYW5zbGF0ZSxcblxuXHQvKipcblx0ICogUHNldWRvIHNwcmludGYgaW1wbGVtZW50YXRpb24gLSBzaW1wbGUgd2F5IHRvIHJlcGxhY2UgdG9rZW5zIHdpdGggc3BlY2lmaWVkIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgd2l0aCB0b2tlbnNcblx0ICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgd2l0aCByZXBsYWNlZCB0b2tlbnNcblx0ICovXG5cdHNwcmludGYgOiB1LkJhc2ljLnNwcmludGYsXG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBvYmplY3QgaXMgZW1wdHkuXG5cdCAqXG5cdCAqIEBtZXRob2QgaXNFbXB0eU9ialxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0aXNFbXB0eU9iaiA6IHUuQmFzaWMuaXNFbXB0eU9iaixcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHNwZWNpZmllZCBET00gZWxlbWVudCBoYXMgc3BlY2lmaWVkIGNsYXNzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGhhc0NsYXNzXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiBET00gZWxlbWVudCBsaWtlIG9iamVjdCB0byBhZGQgaGFuZGxlciB0by5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQ2xhc3MgbmFtZVxuXHQgKi9cblx0aGFzQ2xhc3MgOiB1LkRvbS5oYXNDbGFzcyxcblxuXHQvKipcblx0ICogQWRkcyBzcGVjaWZpZWQgY2xhc3NOYW1lIHRvIHNwZWNpZmllZCBET00gZWxlbWVudC5cblx0ICpcblx0ICogQG1ldGhvZCBhZGRDbGFzc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWVcblx0ICovXG5cdGFkZENsYXNzIDogdS5Eb20uYWRkQ2xhc3MsXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgc3BlY2lmaWVkIGNsYXNzTmFtZSBmcm9tIHNwZWNpZmllZCBET00gZWxlbWVudC5cblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVDbGFzc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWVcblx0ICovXG5cdHJlbW92ZUNsYXNzIDogdS5Eb20ucmVtb3ZlQ2xhc3MsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnaXZlbiBjb21wdXRlZCBzdHlsZSBvZiBhIERPTSBlbGVtZW50LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFN0eWxlXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiBET00gZWxlbWVudCBsaWtlIG9iamVjdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgU3R5bGUgeW91IHdhbnQgdG8gZ2V0IGZyb20gdGhlIERPTSBlbGVtZW50XG5cdCAqL1xuXHRnZXRTdHlsZSA6IHUuRG9tLmdldFN0eWxlLFxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIHNwZWNpZmllZCBvYmplY3QgYW5kIHN0b3JlIHJlZmVyZW5jZSB0byB0aGUgaGFuZGxlclxuXHQgKiBpbiBvYmplY3RzIGludGVybmFsIFBsdXBsb2FkIHJlZ2lzdHJ5IChAc2VlIHJlbW92ZUV2ZW50KS5cblx0ICpcblx0ICogQG1ldGhvZCBhZGRFdmVudFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgbGlrZSBvYmplY3QgdG8gYWRkIGhhbmRsZXIgdG8uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlbnQgb2NjdXJzLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gKG9wdGlvbmFsKSBrZXkgdGhhdCBtaWdodCBiZSB1c2VkIHRvIGFkZCBzcGVjaWZpdHkgdG8gdGhlIGV2ZW50IHJlY29yZC5cblx0ICovXG5cdGFkZEV2ZW50IDogdS5FdmVudHMuYWRkRXZlbnQsXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBldmVudCBoYW5kbGVyIGZyb20gdGhlIHNwZWNpZmllZCBvYmplY3QuIElmIHRoaXJkIGFyZ3VtZW50IChjYWxsYmFjaylcblx0ICogaXMgbm90IHNwZWNpZmllZCByZW1vdmUgYWxsIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyKHMpIGZyb20uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgZXZlbnQgbGlzdGVuZXIgdG8gcmVtb3ZlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gKG9wdGlvbmFsKSBtaWdodCBiZSBhIGNhbGxiYWNrIG9yIHVuaXF1ZSBrZXkgdG8gbWF0Y2guXG5cdCAqL1xuXHRyZW1vdmVFdmVudDogdS5FdmVudHMucmVtb3ZlRXZlbnQsXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwga2luZCBvZiBldmVudHMgZnJvbSB0aGUgc3BlY2lmaWVkIG9iamVjdFxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50c1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRE9NIGVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmcm9tLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gKG9wdGlvbmFsKSB1bmlxdWUga2V5IHRvIG1hdGNoLCB3aGVuIHJlbW92aW5nIGV2ZW50cy5cblx0ICovXG5cdHJlbW92ZUFsbEV2ZW50czogdS5FdmVudHMucmVtb3ZlQWxsRXZlbnRzLFxuXG5cdC8qKlxuXHQgKiBDbGVhbnMgdGhlIHNwZWNpZmllZCBuYW1lIGZyb20gbmF0aW9uYWwgY2hhcmFjdGVycyAoZGlhY3JpdGljcykuIFRoZSByZXN1bHQgd2lsbCBiZSBhIG5hbWUgd2l0aCBvbmx5IGEteiwgMC05IGFuZCBfLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGNsZWFuTmFtZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzIFN0cmluZyB0byBjbGVhbiB1cC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBDbGVhbmVkIHN0cmluZy5cblx0ICovXG5cdGNsZWFuTmFtZSA6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgaSwgbG9va3VwO1xuXG5cdFx0Ly8gUmVwbGFjZSBkaWFjcml0aWNzXG5cdFx0bG9va3VwID0gW1xuXHRcdFx0L1tcXDMwMC1cXDMwNl0vZywgJ0EnLCAvW1xcMzQwLVxcMzQ2XS9nLCAnYScsXG5cdFx0XHQvXFwzMDcvZywgJ0MnLCAvXFwzNDcvZywgJ2MnLFxuXHRcdFx0L1tcXDMxMC1cXDMxM10vZywgJ0UnLCAvW1xcMzUwLVxcMzUzXS9nLCAnZScsXG5cdFx0XHQvW1xcMzE0LVxcMzE3XS9nLCAnSScsIC9bXFwzNTQtXFwzNTddL2csICdpJyxcblx0XHRcdC9cXDMyMS9nLCAnTicsIC9cXDM2MS9nLCAnbicsXG5cdFx0XHQvW1xcMzIyLVxcMzMwXS9nLCAnTycsIC9bXFwzNjItXFwzNzBdL2csICdvJyxcblx0XHRcdC9bXFwzMzEtXFwzMzRdL2csICdVJywgL1tcXDM3MS1cXDM3NF0vZywgJ3UnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsb29rdXAubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UobG9va3VwW2ldLCBsb29rdXBbaSArIDFdKTtcblx0XHR9XG5cblx0XHQvLyBSZXBsYWNlIHdoaXRlc3BhY2Vcblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyk7XG5cblx0XHQvLyBSZW1vdmUgYW55dGhpbmcgZWxzZVxuXHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL1teYS16MC05X1xcLVxcLl0rL2dpLCAnJyk7XG5cblx0XHRyZXR1cm4gbmFtZTtcblx0fSxcblxuXHQvKipcblx0ICogQnVpbGRzIGEgZnVsbCB1cmwgb3V0IG9mIGEgYmFzZSBVUkwgYW5kIGFuIG9iamVjdCB3aXRoIGl0ZW1zIHRvIGFwcGVuZCBhcyBxdWVyeSBzdHJpbmcgaXRlbXMuXG5cdCAqXG5cdCAqIEBtZXRob2QgYnVpbGRVcmxcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsIEJhc2UgVVJMIHRvIGFwcGVuZCBxdWVyeSBzdHJpbmcgaXRlbXMgdG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtcyBOYW1lL3ZhbHVlIG9iamVjdCB0byBzZXJpYWxpemUgYXMgYSBxdWVyeXN0cmluZy5cblx0ICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgd2l0aCB1cmwgKyBzZXJpYWxpemVkIHF1ZXJ5IHN0cmluZyBpdGVtcy5cblx0ICovXG5cdGJ1aWxkVXJsOiBmdW5jdGlvbih1cmwsIGl0ZW1zKSB7XG5cdFx0dmFyIHF1ZXJ5ID0gJyc7XG5cblx0XHRwbHVwbG9hZC5lYWNoKGl0ZW1zLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0cXVlcnkgKz0gKHF1ZXJ5ID8gJyYnIDogJycpICsgZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWVyeSkge1xuXHRcdFx0dXJsICs9ICh1cmwuaW5kZXhPZignPycpID4gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBGb3JtYXRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIGFzIGEgc2l6ZSBzdHJpbmcgZm9yIGV4YW1wbGUgMTAyNCBiZWNvbWVzIDEgS0IuXG5cdCAqXG5cdCAqIEBtZXRob2QgZm9ybWF0U2l6ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFNpemUgdG8gZm9ybWF0IGFzIHN0cmluZy5cblx0ICogQHJldHVybiB7U3RyaW5nfSBGb3JtYXR0ZWQgc2l6ZSBzdHJpbmcuXG5cdCAqL1xuXHRmb3JtYXRTaXplIDogZnVuY3Rpb24oc2l6ZSkge1xuXG5cdFx0aWYgKHNpemUgPT09IHVuZGVmIHx8IC9cXEQvLnRlc3Qoc2l6ZSkpIHtcblx0XHRcdHJldHVybiBwbHVwbG9hZC50cmFuc2xhdGUoJ04vQScpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJvdW5kKG51bSwgcHJlY2lzaW9uKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSkgLyBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcblx0XHR9XG5cblx0XHR2YXIgYm91bmRhcnkgPSBNYXRoLnBvdygxMDI0LCA0KTtcblxuXHRcdC8vIFRCXG5cdFx0aWYgKHNpemUgPiBib3VuZGFyeSkge1xuXHRcdFx0cmV0dXJuIHJvdW5kKHNpemUgLyBib3VuZGFyeSwgMSkgKyBcIiBcIiArIHBsdXBsb2FkLnRyYW5zbGF0ZSgndGInKTtcblx0XHR9XG5cblx0XHQvLyBHQlxuXHRcdGlmIChzaXplID4gKGJvdW5kYXJ5Lz0xMDI0KSkge1xuXHRcdFx0cmV0dXJuIHJvdW5kKHNpemUgLyBib3VuZGFyeSwgMSkgKyBcIiBcIiArIHBsdXBsb2FkLnRyYW5zbGF0ZSgnZ2InKTtcblx0XHR9XG5cblx0XHQvLyBNQlxuXHRcdGlmIChzaXplID4gKGJvdW5kYXJ5Lz0xMDI0KSkge1xuXHRcdFx0cmV0dXJuIHJvdW5kKHNpemUgLyBib3VuZGFyeSwgMSkgKyBcIiBcIiArIHBsdXBsb2FkLnRyYW5zbGF0ZSgnbWInKTtcblx0XHR9XG5cblx0XHQvLyBLQlxuXHRcdGlmIChzaXplID4gMTAyNCkge1xuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoc2l6ZSAvIDEwMjQpICsgXCIgXCIgKyBwbHVwbG9hZC50cmFuc2xhdGUoJ2tiJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemUgKyBcIiBcIiArIHBsdXBsb2FkLnRyYW5zbGF0ZSgnYicpO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgc3BlY2lmaWVkIHNpemUgc3RyaW5nIGludG8gYSBieXRlIHZhbHVlLiBGb3IgZXhhbXBsZSAxMGtiIGJlY29tZXMgMTAyNDAuXG5cdCAqXG5cdCAqIEBtZXRob2QgcGFyc2VTaXplXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzaXplIFN0cmluZyB0byBwYXJzZSBvciBudW1iZXIgdG8ganVzdCBwYXNzIHRocm91Z2guXG5cdCAqIEByZXR1cm4ge051bWJlcn0gU2l6ZSBpbiBieXRlcy5cblx0ICovXG5cdHBhcnNlU2l6ZSA6IHUuQmFzaWMucGFyc2VTaXplU3RyLFxuXG5cblx0LyoqXG5cdCAqIEEgd2F5IHRvIHByZWRpY3Qgd2hhdCBydW50aW1lIHdpbGwgYmUgY2hvb3NlbiBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCB3aXRoIHRoZVxuXHQgKiBzcGVjaWZpZWQgc2V0dGluZ3MuXG5cdCAqXG5cdCAqIEBtZXRob2QgcHJlZGljdFJ1bnRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZyBQbHVwbG9hZCBzZXR0aW5ncyB0byBjaGVja1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3J1bnRpbWVzXSBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBydW50aW1lcyB0byBjaGVjayBhZ2FpbnN0XG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVHlwZSBvZiBjb21wYXRpYmxlIHJ1bnRpbWVcblx0ICovXG5cdHByZWRpY3RSdW50aW1lIDogZnVuY3Rpb24oY29uZmlnLCBydW50aW1lcykge1xuXHRcdHZhciB1cCwgcnVudGltZTtcblxuXHRcdHVwID0gbmV3IHBsdXBsb2FkLlVwbG9hZGVyKGNvbmZpZyk7XG5cdFx0cnVudGltZSA9IFJ1bnRpbWUudGhhdENhbih1cC5nZXRPcHRpb24oKS5yZXF1aXJlZF9mZWF0dXJlcywgcnVudGltZXMgfHwgY29uZmlnLnJ1bnRpbWVzKTtcblx0XHR1cC5kZXN0cm95KCk7XG5cdFx0cmV0dXJuIHJ1bnRpbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIGZpbHRlciB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggZmlsZSBhZGRlZCB0byB0aGUgcXVldWUuXG5cdCAqIElmIGNhbGxiYWNrIHJldHVybnMgZmFsc2UsIGZpbGUgd2lsbCBub3QgYmUgYWRkZWQuXG5cdCAqXG5cdCAqIENhbGxiYWNrIHJlY2VpdmVzIHR3byBhcmd1bWVudHM6IGEgdmFsdWUgZm9yIHRoZSBmaWx0ZXIgYXMgaXQgd2FzIHNwZWNpZmllZCBpbiBzZXR0aW5ncy5maWx0ZXJzXG5cdCAqIGFuZCBhIGZpbGUgdG8gYmUgZmlsdGVyZWQuIENhbGxiYWNrIGlzIGV4ZWN1dGVkIGluIHRoZSBjb250ZXh0IG9mIHVwbG9hZGVyIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZEZpbGVGaWx0ZXJcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBmaWx0ZXIgYnkgd2hpY2ggaXQgY2FuIGJlIHJlZmVyZW5jZWQgaW4gc2V0dGluZ3MuZmlsdGVyc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2IgQ2FsbGJhY2sgLSB0aGUgYWN0dWFsIHJvdXRpbmUgdGhhdCBldmVyeSBhZGRlZCBmaWxlIG11c3QgcGFzc1xuXHQgKi9cblx0YWRkRmlsZUZpbHRlcjogZnVuY3Rpb24obmFtZSwgY2IpIHtcblx0XHRmaWxlRmlsdGVyc1tuYW1lXSA9IGNiO1xuXHR9XG59O1xuXG5cbnBsdXBsb2FkLmFkZEZpbGVGaWx0ZXIoJ21pbWVfdHlwZXMnLCBmdW5jdGlvbihmaWx0ZXJzLCBmaWxlLCBjYikge1xuXHRpZiAoZmlsdGVycy5sZW5ndGggJiYgIWZpbHRlcnMucmVnZXhwLnRlc3QoZmlsZS5uYW1lKSkge1xuXHRcdHRoaXMudHJpZ2dlcignRXJyb3InLCB7XG5cdFx0XHRjb2RlIDogcGx1cGxvYWQuRklMRV9FWFRFTlNJT05fRVJST1IsXG5cdFx0XHRtZXNzYWdlIDogcGx1cGxvYWQudHJhbnNsYXRlKCdGaWxlIGV4dGVuc2lvbiBlcnJvci4nKSxcblx0XHRcdGZpbGUgOiBmaWxlXG5cdFx0fSk7XG5cdFx0Y2IoZmFsc2UpO1xuXHR9IGVsc2Uge1xuXHRcdGNiKHRydWUpO1xuXHR9XG59KTtcblxuXG5wbHVwbG9hZC5hZGRGaWxlRmlsdGVyKCdtYXhfZmlsZV9zaXplJywgZnVuY3Rpb24obWF4U2l6ZSwgZmlsZSwgY2IpIHtcblx0dmFyIHVuZGVmO1xuXG5cdG1heFNpemUgPSBwbHVwbG9hZC5wYXJzZVNpemUobWF4U2l6ZSk7XG5cblx0Ly8gSW52YWxpZCBmaWxlIHNpemVcblx0aWYgKGZpbGUuc2l6ZSAhPT0gdW5kZWYgJiYgbWF4U2l6ZSAmJiBmaWxlLnNpemUgPiBtYXhTaXplKSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdFcnJvcicsIHtcblx0XHRcdGNvZGUgOiBwbHVwbG9hZC5GSUxFX1NJWkVfRVJST1IsXG5cdFx0XHRtZXNzYWdlIDogcGx1cGxvYWQudHJhbnNsYXRlKCdGaWxlIHNpemUgZXJyb3IuJyksXG5cdFx0XHRmaWxlIDogZmlsZVxuXHRcdH0pO1xuXHRcdGNiKGZhbHNlKTtcblx0fSBlbHNlIHtcblx0XHRjYih0cnVlKTtcblx0fVxufSk7XG5cblxucGx1cGxvYWQuYWRkRmlsZUZpbHRlcigncHJldmVudF9kdXBsaWNhdGVzJywgZnVuY3Rpb24odmFsdWUsIGZpbGUsIGNiKSB7XG5cdGlmICh2YWx1ZSkge1xuXHRcdHZhciBpaSA9IHRoaXMuZmlsZXMubGVuZ3RoO1xuXHRcdHdoaWxlIChpaS0tKSB7XG5cdFx0XHQvLyBDb21wYXJlIGJ5IG5hbWUgYW5kIHNpemUgKHNpemUgbWlnaHQgYmUgMCBvciB1bmRlZmluZWQsIGJ1dCBzdGlsbCBlcXVpdmFsZW50IGZvciBib3RoKVxuXHRcdFx0aWYgKGZpbGUubmFtZSA9PT0gdGhpcy5maWxlc1tpaV0ubmFtZSAmJiBmaWxlLnNpemUgPT09IHRoaXMuZmlsZXNbaWldLnNpemUpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdFcnJvcicsIHtcblx0XHRcdFx0XHRjb2RlIDogcGx1cGxvYWQuRklMRV9EVVBMSUNBVEVfRVJST1IsXG5cdFx0XHRcdFx0bWVzc2FnZSA6IHBsdXBsb2FkLnRyYW5zbGF0ZSgnRHVwbGljYXRlIGZpbGUgZXJyb3IuJyksXG5cdFx0XHRcdFx0ZmlsZSA6IGZpbGVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNiKGZhbHNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjYih0cnVlKTtcbn0pO1xuXG5cbi8qKlxuQGNsYXNzIFVwbG9hZGVyXG5AY29uc3RydWN0b3JcblxuQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIG9wdGlvbiBjaGVjayBkb2N1bWVudGF0aW9uLlxuXHRAcGFyYW0ge1N0cmluZ3xET01FbGVtZW50fSBzZXR0aW5ncy5icm93c2VfYnV0dG9uIGlkIG9mIHRoZSBET00gZWxlbWVudCBvciBET00gZWxlbWVudCBpdHNlbGYgdG8gdXNlIGFzIGZpbGUgZGlhbG9nIHRyaWdnZXIuXG5cdEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3NldHRpbmdzLmNodW5rX3NpemU9MF0gQ2h1bmsgc2l6ZSBpbiBieXRlcyB0byBzbGljZSB0aGUgZmlsZSBpbnRvLiBTaG9yY3V0cyB3aXRoIGIsIGtiLCBtYiwgZ2IsIHRiIHN1ZmZpeGVzIGFsc28gc3VwcG9ydGVkLiBgZS5nLiAyMDQ4MDAgb3IgXCIyMDQ4MDBiXCIgb3IgXCIyMDBrYlwiYC4gQnkgZGVmYXVsdCAtIGRpc2FibGVkLlxuXHRAcGFyYW0ge1N0cmluZ3xET01FbGVtZW50fSBbc2V0dGluZ3MuY29udGFpbmVyXSBpZCBvZiB0aGUgRE9NIGVsZW1lbnQgb3IgRE9NIGVsZW1lbnQgaXRzZWxmIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHdyYXAgdXBsb2FkZXIgc3RydWN0dXJlcy4gRGVmYXVsdHMgdG8gaW1tZWRpYXRlIHBhcmVudCBvZiB0aGUgYGJyb3dzZV9idXR0b25gIGVsZW1lbnQuXG5cdEBwYXJhbSB7U3RyaW5nfERPTUVsZW1lbnR9IFtzZXR0aW5ncy5kcm9wX2VsZW1lbnRdIGlkIG9mIHRoZSBET00gZWxlbWVudCBvciBET00gZWxlbWVudCBpdHNlbGYgdG8gdXNlIGFzIGEgZHJvcCB6b25lIGZvciBEcmFnLW4tRHJvcC5cblx0QHBhcmFtIHtTdHJpbmd9IFtzZXR0aW5ncy5maWxlX2RhdGFfbmFtZT1cImZpbGVcIl0gTmFtZSBmb3IgdGhlIGZpbGUgZmllbGQgaW4gTXVsdGlwYXJ0IGZvcm1hdGVkIG1lc3NhZ2UuXG5cdEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ3MuZmlsdGVycz17fV0gU2V0IG9mIGZpbGUgdHlwZSBmaWx0ZXJzLlxuXHRcdEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW3NldHRpbmdzLmZpbHRlcnMubWF4X2ZpbGVfc2l6ZT0wXSBNYXhpbXVtIGZpbGUgc2l6ZSB0aGF0IHRoZSB1c2VyIGNhbiBwaWNrLCBpbiBieXRlcy4gT3B0aW9uYWxseSBzdXBwb3J0cyBiLCBrYiwgbWIsIGdiLCB0YiBzdWZmaXhlcy4gYGUuZy4gXCIxMG1iXCIgb3IgXCIxZ2JcImAuIEJ5IGRlZmF1bHQgLSBub3Qgc2V0LiBEaXNwYXRjaGVzIGBwbHVwbG9hZC5GSUxFX1NJWkVfRVJST1JgLlxuXHRcdEBwYXJhbSB7QXJyYXl9IFtzZXR0aW5ncy5maWx0ZXJzLm1pbWVfdHlwZXM9W11dIExpc3Qgb2YgZmlsZSB0eXBlcyB0byBhY2NlcHQsIGVhY2ggb25lIGRlZmluZWQgYnkgdGl0bGUgYW5kIGxpc3Qgb2YgZXh0ZW5zaW9ucy4gYGUuZy4ge3RpdGxlIDogXCJJbWFnZSBmaWxlc1wiLCBleHRlbnNpb25zIDogXCJqcGcsanBlZyxnaWYscG5nXCJ9YC4gRGlzcGF0Y2hlcyBgcGx1cGxvYWQuRklMRV9FWFRFTlNJT05fRVJST1JgXG5cdFx0QHBhcmFtIHtCb29sZWFufSBbc2V0dGluZ3MuZmlsdGVycy5wcmV2ZW50X2R1cGxpY2F0ZXM9ZmFsc2VdIERvIG5vdCBsZXQgZHVwbGljYXRlcyBpbnRvIHRoZSBxdWV1ZS4gRGlzcGF0Y2hlcyBgcGx1cGxvYWQuRklMRV9EVVBMSUNBVEVfRVJST1JgLlxuXHRAcGFyYW0ge1N0cmluZ30gW3NldHRpbmdzLmZsYXNoX3N3Zl91cmxdIFVSTCBvZiB0aGUgRmxhc2ggc3dmLlxuXHRAcGFyYW0ge09iamVjdH0gW3NldHRpbmdzLmhlYWRlcnNdIEN1c3RvbSBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgdXBsb2FkLiBIYXNoIG9mIG5hbWUvdmFsdWUgcGFpcnMuXG5cdEBwYXJhbSB7U3RyaW5nfSBbc2V0dGluZ3MuaHR0cF9tZXRob2Q9XCJQT1NUXCJdIEhUVFAgbWV0aG9kIHRvIHVzZSBkdXJpbmcgdXBsb2FkIChvbmx5IFBVVCBvciBQT1NUIGFsbG93ZWQpLlxuXHRAcGFyYW0ge051bWJlcn0gW3NldHRpbmdzLm1heF9yZXRyaWVzPTBdIEhvdyBtYW55IHRpbWVzIHRvIHJldHJ5IHRoZSBjaHVuayBvciBmaWxlLCBiZWZvcmUgdHJpZ2dlcmluZyBFcnJvciBldmVudC5cblx0QHBhcmFtIHtCb29sZWFufSBbc2V0dGluZ3MubXVsdGlwYXJ0PXRydWVdIFdoZXRoZXIgdG8gc2VuZCBmaWxlIGFuZCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgYXMgTXVsdGlwYXJ0IGZvcm1hdGVkIG1lc3NhZ2UuXG5cdEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ3MubXVsdGlwYXJ0X3BhcmFtc10gSGFzaCBvZiBrZXkvdmFsdWUgcGFpcnMgdG8gc2VuZCB3aXRoIGV2ZXJ5IGZpbGUgdXBsb2FkLlxuXHRAcGFyYW0ge0Jvb2xlYW59IFtzZXR0aW5ncy5tdWx0aV9zZWxlY3Rpb249dHJ1ZV0gRW5hYmxlIGFiaWxpdHkgdG8gc2VsZWN0IG11bHRpcGxlIGZpbGVzIGF0IG9uY2UgaW4gZmlsZSBkaWFsb2cuXG5cdEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gW3NldHRpbmdzLnJlcXVpcmVkX2ZlYXR1cmVzXSBFaXRoZXIgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb3IgaGFzaCBvZiByZXF1aXJlZCBmZWF0dXJlcyB0aGF0IGNob3NlbiBydW50aW1lIHNob3VsZCBhYnNvbHV0ZWx5IHBvc3Nlc3MuXG5cdEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ3MucmVzaXplXSBFbmFibGUgcmVzaXpuZyBvZiBpbWFnZXMgb24gY2xpZW50LXNpZGUuIEFwcGxpZXMgdG8gYGltYWdlL2pwZWdgIGFuZCBgaW1hZ2UvcG5nYCBvbmx5LiBgZS5nLiB7d2lkdGggOiAyMDAsIGhlaWdodCA6IDIwMCwgcXVhbGl0eSA6IDkwLCBjcm9wOiB0cnVlfWBcblx0XHRAcGFyYW0ge051bWJlcn0gW3NldHRpbmdzLnJlc2l6ZS53aWR0aF0gSWYgaW1hZ2UgaXMgYmlnZ2VyLCBpdCB3aWxsIGJlIHJlc2l6ZWQuXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IFtzZXR0aW5ncy5yZXNpemUuaGVpZ2h0XSBJZiBpbWFnZSBpcyBiaWdnZXIsIGl0IHdpbGwgYmUgcmVzaXplZC5cblx0XHRAcGFyYW0ge051bWJlcn0gW3NldHRpbmdzLnJlc2l6ZS5xdWFsaXR5PTkwXSBDb21wcmVzc2lvbiBxdWFsaXR5IGZvciBqcGVncyAoMS0xMDApLlxuXHRcdEBwYXJhbSB7Qm9vbGVhbn0gW3NldHRpbmdzLnJlc2l6ZS5jcm9wPWZhbHNlXSBXaGV0aGVyIHRvIGNyb3AgaW1hZ2VzIHRvIGV4YWN0IGRpbWVuc2lvbnMuIEJ5IGRlZmF1bHQgdGhleSB3aWxsIGJlIHJlc2l6ZWQgcHJvcG9ydGlvbmFsbHkuXG5cdEBwYXJhbSB7U3RyaW5nfSBbc2V0dGluZ3MucnVudGltZXM9XCJodG1sNSxmbGFzaCxzaWx2ZXJsaWdodCxodG1sNFwiXSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBydW50aW1lcywgdGhhdCBQbHVwbG9hZCB3aWxsIHRyeSBpbiB0dXJuLCBtb3ZpbmcgdG8gdGhlIG5leHQgaWYgcHJldmlvdXMgZmFpbHMuXG5cdEBwYXJhbSB7U3RyaW5nfSBbc2V0dGluZ3Muc2lsdmVybGlnaHRfeGFwX3VybF0gVVJMIG9mIHRoZSBTaWx2ZXJsaWdodCB4YXAuXG5cdEBwYXJhbSB7Qm9vbGVhbn0gW3NldHRpbmdzLnNlbmRfY2h1bmtfbnVtYmVyPXRydWVdIFdoZXRoZXIgdG8gc2VuZCBjaHVua3MgYW5kIGNodW5rIG51bWJlcnMsIG9yIHRvdGFsIGFuZCBvZmZzZXQgYnl0ZXMuXG5cdEBwYXJhbSB7Qm9vbGVhbn0gW3NldHRpbmdzLnNlbmRfZmlsZV9uYW1lPXRydWVdIFdoZXRoZXIgdG8gc2VuZCBmaWxlIG5hbWUgYXMgYWRkaXRpb25hbCBhcmd1bWVudCAtICduYW1lJyAocmVxdWlyZWQgZm9yIGNodW5rZWQgdXBsb2FkcyBhbmQgc29tZSBvdGhlciBjYXNlcyB3aGVyZSBmaWxlIG5hbWUgY2Fubm90IGJlIHNlbnQgdmlhIG5vcm1hbCB3YXlzKS5cblx0QHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnVybCBVUkwgb2YgdGhlIHNlcnZlci1zaWRlIHVwbG9hZCBoYW5kbGVyLlxuXHRAcGFyYW0ge0Jvb2xlYW59IFtzZXR0aW5ncy51bmlxdWVfbmFtZXM9ZmFsc2VdIElmIHRydWUgd2lsbCBnZW5lcmF0ZSB1bmlxdWUgZmlsZW5hbWVzIGZvciB1cGxvYWRlZCBmaWxlcy5cblxuKi9cbnBsdXBsb2FkLlVwbG9hZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvKipcblx0RmlyZXMgd2hlbiB0aGUgY3VycmVudCBSdW5UaW1lIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuXG5cdEBldmVudCBJbml0XG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgYWZ0ZXIgdGhlIGluaXQgZXZlbnQgaW5jYXNlIHlvdSBuZWVkIHRvIHBlcmZvcm0gYWN0aW9ucyB0aGVyZS5cblxuXHRAZXZlbnQgUG9zdEluaXRcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIHRoZSBvcHRpb24gaXMgY2hhbmdlZCBpbiB2aWEgdXBsb2FkZXIuc2V0T3B0aW9uKCkuXG5cblx0QGV2ZW50IE9wdGlvbkNoYW5nZWRcblx0QHNpbmNlIDIuMVxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgb3B0aW9uIHRoYXQgd2FzIGNoYW5nZWRcblx0QHBhcmFtIHtNaXhlZH0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIG9wdGlvblxuXHRAcGFyYW0ge01peGVkfSBvbGRWYWx1ZSBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgb3B0aW9uXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIHRoZSBzaWx2ZXJsaWdodC9mbGFzaCBvciBvdGhlciBzaGltIG5lZWRzIHRvIG1vdmUuXG5cblx0QGV2ZW50IFJlZnJlc2hcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIHRoZSBvdmVyYWxsIHN0YXRlIGlzIGJlaW5nIGNoYW5nZWQgZm9yIHRoZSB1cGxvYWQgcXVldWUuXG5cblx0QGV2ZW50IFN0YXRlQ2hhbmdlZFxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIHdoZW4gYnJvd3NlX2J1dHRvbiBpcyBjbGlja2VkIGFuZCBicm93c2UgZGlhbG9nIHNob3dzLlxuXG5cdEBldmVudCBCcm93c2Vcblx0QHNpbmNlIDIuMS4yXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgZm9yIGV2ZXJ5IGZpbHRlcmVkIGZpbGUgYmVmb3JlIGl0IGlzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cblxuXHRAZXZlbnQgRmlsZUZpbHRlcmVkXG5cdEBzaW5jZSAyLjFcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7cGx1cGxvYWQuRmlsZX0gZmlsZSBBbm90aGVyIGZpbGUgdGhhdCBoYXMgdG8gYmUgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hlbiB0aGUgZmlsZSBxdWV1ZSBpcyBjaGFuZ2VkLiBJbiBvdGhlciB3b3JkcyB3aGVuIGZpbGVzIGFyZSBhZGRlZC9yZW1vdmVkIHRvIHRoZSBmaWxlcyBhcnJheSBvZiB0aGUgdXBsb2FkZXIgaW5zdGFuY2UuXG5cblx0QGV2ZW50IFF1ZXVlQ2hhbmdlZFxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIGFmdGVyIGZpbGVzIHdlcmUgZmlsdGVyZWQgYW5kIGFkZGVkIHRvIHRoZSBxdWV1ZS5cblxuXHRAZXZlbnQgRmlsZXNBZGRlZFxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0QHBhcmFtIHtBcnJheX0gZmlsZXMgQXJyYXkgb2YgZmlsZSBvYmplY3RzIHRoYXQgd2VyZSBhZGRlZCB0byBxdWV1ZSBieSB0aGUgdXNlci5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIHdoZW4gZmlsZSBpcyByZW1vdmVkIGZyb20gdGhlIHF1ZXVlLlxuXG5cdEBldmVudCBGaWxlc1JlbW92ZWRcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7QXJyYXl9IGZpbGVzIEFycmF5IG9mIGZpbGVzIHRoYXQgZ290IHJlbW92ZWQuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyBqdXN0IGJlZm9yZSBhIGZpbGUgaXMgdXBsb2FkZWQuIENhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgdXBsb2FkIGZvciB0aGUgc3BlY2lmaWVkIGZpbGVcblx0YnkgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlIGhhbmRsZXIuXG5cblx0QGV2ZW50IEJlZm9yZVVwbG9hZFxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0QHBhcmFtIHtwbHVwbG9hZC5GaWxlfSBmaWxlIEZpbGUgdG8gYmUgdXBsb2FkZWQuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIGEgZmlsZSBpcyB0byBiZSB1cGxvYWRlZCBieSB0aGUgcnVudGltZS5cblxuXHRAZXZlbnQgVXBsb2FkRmlsZVxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0QHBhcmFtIHtwbHVwbG9hZC5GaWxlfSBmaWxlIEZpbGUgdG8gYmUgdXBsb2FkZWQuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGlsZSBhIGZpbGUgaXMgYmVpbmcgdXBsb2FkZWQuIFVzZSB0aGlzIGV2ZW50IHRvIHVwZGF0ZSB0aGUgY3VycmVudCBmaWxlIHVwbG9hZCBwcm9ncmVzcy5cblxuXHRAZXZlbnQgVXBsb2FkUHJvZ3Jlc3Ncblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7cGx1cGxvYWQuRmlsZX0gZmlsZSBGaWxlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHVwbG9hZGVkLlxuXHQgKi9cblxuXHQvKipcblx0KiBGaXJlcyBqdXN0IGJlZm9yZSBhIGNodW5rIGlzIHVwbG9hZGVkLiBUaGlzIGV2ZW50IGVuYWJsZXMgeW91IHRvIG92ZXJyaWRlIHNldHRpbmdzXG5cdCogb24gdGhlIHVwbG9hZGVyIGluc3RhbmNlIGJlZm9yZSB0aGUgY2h1bmsgaXMgdXBsb2FkZWQuXG5cdCpcblx0KiBAZXZlbnQgQmVmb3JlQ2h1bmtVcGxvYWRcblx0KiBAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0KiBAcGFyYW0ge3BsdXBsb2FkLkZpbGV9IGZpbGUgRmlsZSB0byBiZSB1cGxvYWRlZC5cblx0KiBAcGFyYW0ge09iamVjdH0gYXJncyBQT1NUIHBhcmFtcyB0byBiZSBzZW50LlxuXHQqIEBwYXJhbSB7QmxvYn0gY2h1bmtCbG9iIEN1cnJlbnQgYmxvYi5cblx0KiBAcGFyYW0ge29mZnNldH0gb2Zmc2V0IEN1cnJlbnQgb2Zmc2V0LlxuXHQqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIGZpbGUgY2h1bmsgaXMgdXBsb2FkZWQuXG5cblx0QGV2ZW50IENodW5rVXBsb2FkZWRcblx0QHBhcmFtIHtwbHVwbG9hZC5VcGxvYWRlcn0gdXBsb2FkZXIgVXBsb2FkZXIgaW5zdGFuY2Ugc2VuZGluZyB0aGUgZXZlbnQuXG5cdEBwYXJhbSB7cGx1cGxvYWQuRmlsZX0gZmlsZSBGaWxlIHRoYXQgdGhlIGNodW5rIHdhcyB1cGxvYWRlZCBmb3IuXG5cdEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgT2JqZWN0IHdpdGggcmVzcG9uc2UgcHJvcGVydGllcy5cblx0XHRAcGFyYW0ge051bWJlcn0gcmVzdWx0Lm9mZnNldCBUaGUgYW1vdW50IG9mIGJ5dGVzIHRoZSBzZXJ2ZXIgaGFzIHJlY2VpdmVkIHNvIGZhciwgaW5jbHVkaW5nIHRoaXMgY2h1bmsuXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IHJlc3VsdC50b3RhbCBUaGUgc2l6ZSBvZiB0aGUgZmlsZS5cblx0XHRAcGFyYW0ge1N0cmluZ30gcmVzdWx0LnJlc3BvbnNlIFRoZSByZXNwb25zZSBib2R5IHNlbnQgYnkgdGhlIHNlcnZlci5cblx0XHRAcGFyYW0ge051bWJlcn0gcmVzdWx0LnN0YXR1cyBUaGUgSFRUUCBzdGF0dXMgY29kZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG5cdFx0QHBhcmFtIHtTdHJpbmd9IHJlc3VsdC5yZXNwb25zZUhlYWRlcnMgQWxsIHRoZSByZXNwb25zZSBoZWFkZXJzIGFzIGEgc2luZ2xlIHN0cmluZy5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIHdoZW4gYSBmaWxlIGlzIHN1Y2Nlc3NmdWxseSB1cGxvYWRlZC5cblxuXHRAZXZlbnQgRmlsZVVwbG9hZGVkXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHRAcGFyYW0ge3BsdXBsb2FkLkZpbGV9IGZpbGUgRmlsZSB0aGF0IHdhcyB1cGxvYWRlZC5cblx0QHBhcmFtIHtPYmplY3R9IHJlc3VsdCBPYmplY3Qgd2l0aCByZXNwb25zZSBwcm9wZXJ0aWVzLlxuXHRcdEBwYXJhbSB7U3RyaW5nfSByZXN1bHQucmVzcG9uc2UgVGhlIHJlc3BvbnNlIGJvZHkgc2VudCBieSB0aGUgc2VydmVyLlxuXHRcdEBwYXJhbSB7TnVtYmVyfSByZXN1bHQuc3RhdHVzIFRoZSBIVFRQIHN0YXR1cyBjb2RlIHNlbnQgYnkgdGhlIHNlcnZlci5cblx0XHRAcGFyYW0ge1N0cmluZ30gcmVzdWx0LnJlc3BvbnNlSGVhZGVycyBBbGwgdGhlIHJlc3BvbnNlIGhlYWRlcnMgYXMgYSBzaW5nbGUgc3RyaW5nLlxuXHQgKi9cblxuXHQvKipcblx0RmlyZXMgd2hlbiBhbGwgZmlsZXMgaW4gYSBxdWV1ZSBhcmUgdXBsb2FkZWQuXG5cblx0QGV2ZW50IFVwbG9hZENvbXBsZXRlXG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHRAcGFyYW0ge0FycmF5fSBmaWxlcyBBcnJheSBvZiBmaWxlIG9iamVjdHMgdGhhdCB3YXMgYWRkZWQgdG8gcXVldWUvc2VsZWN0ZWQgYnkgdGhlIHVzZXIuXG5cdCAqL1xuXG5cdC8qKlxuXHRGaXJlcyB3aGVuIGEgZXJyb3Igb2NjdXJzLlxuXG5cdEBldmVudCBFcnJvclxuXHRAcGFyYW0ge3BsdXBsb2FkLlVwbG9hZGVyfSB1cGxvYWRlciBVcGxvYWRlciBpbnN0YW5jZSBzZW5kaW5nIHRoZSBldmVudC5cblx0QHBhcmFtIHtPYmplY3R9IGVycm9yIENvbnRhaW5zIGNvZGUsIG1lc3NhZ2UgYW5kIHNvbWV0aW1lcyBmaWxlIGFuZCBvdGhlciBkZXRhaWxzLlxuXHRcdEBwYXJhbSB7TnVtYmVyfSBlcnJvci5jb2RlIFRoZSBwbHVwbG9hZCBlcnJvciBjb2RlLlxuXHRcdEBwYXJhbSB7U3RyaW5nfSBlcnJvci5tZXNzYWdlIERlc2NyaXB0aW9uIG9mIHRoZSBlcnJvciAodXNlcyBpMThuKS5cblx0ICovXG5cblx0LyoqXG5cdEZpcmVzIHdoZW4gZGVzdHJveSBtZXRob2QgaXMgY2FsbGVkLlxuXG5cdEBldmVudCBEZXN0cm95XG5cdEBwYXJhbSB7cGx1cGxvYWQuVXBsb2FkZXJ9IHVwbG9hZGVyIFVwbG9hZGVyIGluc3RhbmNlIHNlbmRpbmcgdGhlIGV2ZW50LlxuXHQgKi9cblx0dmFyIHVpZCA9IHBsdXBsb2FkLmd1aWQoKVxuXHQsIHNldHRpbmdzXG5cdCwgZmlsZXMgPSBbXVxuXHQsIHByZWZlcnJlZF9jYXBzID0ge31cblx0LCBmaWxlSW5wdXRzID0gW11cblx0LCBmaWxlRHJvcHMgPSBbXVxuXHQsIHN0YXJ0VGltZVxuXHQsIHRvdGFsXG5cdCwgZGlzYWJsZWQgPSBmYWxzZVxuXHQsIHhoclxuXHQ7XG5cblxuXHQvLyBQcml2YXRlIG1ldGhvZHNcblx0ZnVuY3Rpb24gdXBsb2FkTmV4dCgpIHtcblx0XHR2YXIgZmlsZSwgY291bnQgPSAwLCBpO1xuXG5cdFx0aWYgKHRoaXMuc3RhdGUgPT0gcGx1cGxvYWQuU1RBUlRFRCkge1xuXHRcdFx0Ly8gRmluZCBmaXJzdCBRVUVVRUQgZmlsZVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICghZmlsZSAmJiBmaWxlc1tpXS5zdGF0dXMgPT0gcGx1cGxvYWQuUVVFVUVEKSB7XG5cdFx0XHRcdFx0ZmlsZSA9IGZpbGVzW2ldO1xuXHRcdFx0XHRcdGlmICh0aGlzLnRyaWdnZXIoXCJCZWZvcmVVcGxvYWRcIiwgZmlsZSkpIHtcblx0XHRcdFx0XHRcdGZpbGUuc3RhdHVzID0gcGx1cGxvYWQuVVBMT0FESU5HO1xuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiVXBsb2FkRmlsZVwiLCBmaWxlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbGwgZmlsZXMgYXJlIERPTkUgb3IgRkFJTEVEXG5cdFx0XHRpZiAoY291bnQgPT0gZmlsZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLnN0YXRlICE9PSBwbHVwbG9hZC5TVE9QUEVEKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IHBsdXBsb2FkLlNUT1BQRUQ7XG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiU3RhdGVDaGFuZ2VkXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcIlVwbG9hZENvbXBsZXRlXCIsIGZpbGVzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGNhbGNGaWxlKGZpbGUpIHtcblx0XHRmaWxlLnBlcmNlbnQgPSBmaWxlLnNpemUgPiAwID8gTWF0aC5jZWlsKGZpbGUubG9hZGVkIC8gZmlsZS5zaXplICogMTAwKSA6IDEwMDtcblx0XHRjYWxjKCk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGNhbGMoKSB7XG5cdFx0dmFyIGksIGZpbGU7XG5cdFx0dmFyIGxvYWRlZDtcblx0XHR2YXIgbG9hZGVkRHVyaW5nQ3VycmVudFNlc3Npb24gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgc3RhdHNcblx0XHR0b3RhbC5yZXNldCgpO1xuXG5cdFx0Ly8gQ2hlY2sgc3RhdHVzLCBzaXplLCBsb2FkZWQgZXRjIG9uIGFsbCBmaWxlc1xuXHRcdGZvciAoaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZmlsZSA9IGZpbGVzW2ldO1xuXG5cdFx0XHRpZiAoZmlsZS5zaXplICE9PSB1bmRlZikge1xuXHRcdFx0XHQvLyBXZSBjYWxjdWxhdGUgdG90YWxzIGJhc2VkIG9uIG9yaWdpbmFsIGZpbGUgc2l6ZVxuXHRcdFx0XHR0b3RhbC5zaXplICs9IGZpbGUub3JpZ1NpemU7XG5cblx0XHRcdFx0Ly8gU2luY2Ugd2UgY2Fubm90IHByZWRpY3QgZmlsZSBzaXplIGFmdGVyIHJlc2l6ZSwgd2UgZG8gb3Bwb3NpdGUgYW5kXG5cdFx0XHRcdC8vIGludGVycG9sYXRlIGxvYWRlZCBhbW91bnQgdG8gbWF0Y2ggbWFnbml0dWRlIG9mIHRvdGFsXG5cdFx0XHRcdGxvYWRlZCA9IGZpbGUubG9hZGVkICogZmlsZS5vcmlnU2l6ZSAvIGZpbGUuc2l6ZTtcblxuXHRcdFx0XHRpZiAoIWZpbGUuY29tcGxldGVUaW1lc3RhbXAgfHwgZmlsZS5jb21wbGV0ZVRpbWVzdGFtcCA+IHN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdGxvYWRlZER1cmluZ0N1cnJlbnRTZXNzaW9uICs9IGxvYWRlZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRvdGFsLmxvYWRlZCArPSBsb2FkZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b3RhbC5zaXplID0gdW5kZWY7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmaWxlLnN0YXR1cyA9PSBwbHVwbG9hZC5ET05FKSB7XG5cdFx0XHRcdHRvdGFsLnVwbG9hZGVkKys7XG5cdFx0XHR9IGVsc2UgaWYgKGZpbGUuc3RhdHVzID09IHBsdXBsb2FkLkZBSUxFRCkge1xuXHRcdFx0XHR0b3RhbC5mYWlsZWQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvdGFsLnF1ZXVlZCsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlIGNvdWxkbid0IGNhbGN1bGF0ZSBhIHRvdGFsIGZpbGUgc2l6ZSB0aGVuIHVzZSB0aGUgbnVtYmVyIG9mIGZpbGVzIHRvIGNhbGMgcGVyY2VudFxuXHRcdGlmICh0b3RhbC5zaXplID09PSB1bmRlZikge1xuXHRcdFx0dG90YWwucGVyY2VudCA9IGZpbGVzLmxlbmd0aCA+IDAgPyBNYXRoLmNlaWwodG90YWwudXBsb2FkZWQgLyBmaWxlcy5sZW5ndGggKiAxMDApIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG90YWwuYnl0ZXNQZXJTZWMgPSBNYXRoLmNlaWwobG9hZGVkRHVyaW5nQ3VycmVudFNlc3Npb24gLyAoKCtuZXcgRGF0ZSgpIC0gc3RhcnRUaW1lIHx8IDEpIC8gMTAwMC4wKSk7XG5cdFx0XHR0b3RhbC5wZXJjZW50ID0gdG90YWwuc2l6ZSA+IDAgPyBNYXRoLmNlaWwodG90YWwubG9hZGVkIC8gdG90YWwuc2l6ZSAqIDEwMCkgOiAwO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0UlVJRCgpIHtcblx0XHR2YXIgY3RybCA9IGZpbGVJbnB1dHNbMF0gfHwgZmlsZURyb3BzWzBdO1xuXHRcdGlmIChjdHJsKSB7XG5cdFx0XHRyZXR1cm4gY3RybC5nZXRSdW50aW1lKCkudWlkO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJ1bnRpbWVDYW4oZmlsZSwgY2FwKSB7XG5cdFx0aWYgKGZpbGUucnVpZCkge1xuXHRcdFx0dmFyIGluZm8gPSBSdW50aW1lLmdldEluZm8oZmlsZS5ydWlkKTtcblx0XHRcdGlmIChpbmZvKSB7XG5cdFx0XHRcdHJldHVybiBpbmZvLmNhbihjYXApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcblx0XHR0aGlzLmJpbmQoJ0ZpbGVzQWRkZWQgRmlsZXNSZW1vdmVkJywgZnVuY3Rpb24odXApIHtcblx0XHRcdHVwLnRyaWdnZXIoJ1F1ZXVlQ2hhbmdlZCcpO1xuXHRcdFx0dXAucmVmcmVzaCgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5iaW5kKCdDYW5jZWxVcGxvYWQnLCBvbkNhbmNlbFVwbG9hZCk7XG5cblx0XHR0aGlzLmJpbmQoJ0JlZm9yZVVwbG9hZCcsIG9uQmVmb3JlVXBsb2FkKTtcblxuXHRcdHRoaXMuYmluZCgnVXBsb2FkRmlsZScsIG9uVXBsb2FkRmlsZSk7XG5cblx0XHR0aGlzLmJpbmQoJ1VwbG9hZFByb2dyZXNzJywgb25VcGxvYWRQcm9ncmVzcyk7XG5cblx0XHR0aGlzLmJpbmQoJ1N0YXRlQ2hhbmdlZCcsIG9uU3RhdGVDaGFuZ2VkKTtcblxuXHRcdHRoaXMuYmluZCgnUXVldWVDaGFuZ2VkJywgY2FsYyk7XG5cblx0XHR0aGlzLmJpbmQoJ0Vycm9yJywgb25FcnJvcik7XG5cblx0XHR0aGlzLmJpbmQoJ0ZpbGVVcGxvYWRlZCcsIG9uRmlsZVVwbG9hZGVkKTtcblxuXHRcdHRoaXMuYmluZCgnRGVzdHJveScsIG9uRGVzdHJveSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGluaXRDb250cm9scyhzZXR0aW5ncywgY2IpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIGluaXRlZCA9IDAsIHF1ZXVlID0gW107XG5cblx0XHQvLyBjb21tb24gc2V0dGluZ3Ncblx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdHJ1bnRpbWVfb3JkZXI6IHNldHRpbmdzLnJ1bnRpbWVzLFxuXHRcdFx0cmVxdWlyZWRfY2Fwczogc2V0dGluZ3MucmVxdWlyZWRfZmVhdHVyZXMsXG5cdFx0XHRwcmVmZXJyZWRfY2FwczogcHJlZmVycmVkX2NhcHMsXG5cdFx0XHRzd2ZfdXJsOiBzZXR0aW5ncy5mbGFzaF9zd2ZfdXJsLFxuXHRcdFx0eGFwX3VybDogc2V0dGluZ3Muc2lsdmVybGlnaHRfeGFwX3VybFxuXHRcdH07XG5cblx0XHQvLyBhZGQgcnVudGltZSBzcGVjaWZpYyBvcHRpb25zIGlmIGFueVxuXHRcdHBsdXBsb2FkLmVhY2goc2V0dGluZ3MucnVudGltZXMuc3BsaXQoL1xccyosXFxzKi8pLCBmdW5jdGlvbihydW50aW1lKSB7XG5cdFx0XHRpZiAoc2V0dGluZ3NbcnVudGltZV0pIHtcblx0XHRcdFx0b3B0aW9uc1tydW50aW1lXSA9IHNldHRpbmdzW3J1bnRpbWVdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gaW5pdGlhbGl6ZSBmaWxlIHBpY2tlcnMgLSB0aGVyZSBjYW4gYmUgbWFueVxuXHRcdGlmIChzZXR0aW5ncy5icm93c2VfYnV0dG9uKSB7XG5cdFx0XHRwbHVwbG9hZC5lYWNoKHNldHRpbmdzLmJyb3dzZV9idXR0b24sIGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRcdHF1ZXVlLnB1c2goZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHR2YXIgZmlsZUlucHV0ID0gbmV3IG8uZmlsZS5GaWxlSW5wdXQocGx1cGxvYWQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG5cdFx0XHRcdFx0XHRhY2NlcHQ6IHNldHRpbmdzLmZpbHRlcnMubWltZV90eXBlcyxcblx0XHRcdFx0XHRcdG5hbWU6IHNldHRpbmdzLmZpbGVfZGF0YV9uYW1lLFxuXHRcdFx0XHRcdFx0bXVsdGlwbGU6IHNldHRpbmdzLm11bHRpX3NlbGVjdGlvbixcblx0XHRcdFx0XHRcdGNvbnRhaW5lcjogc2V0dGluZ3MuY29udGFpbmVyLFxuXHRcdFx0XHRcdFx0YnJvd3NlX2J1dHRvbjogZWxcblx0XHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0XHRmaWxlSW5wdXQub25yZWFkeSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGluZm8gPSBSdW50aW1lLmdldEluZm8odGhpcy5ydWlkKTtcblxuXHRcdFx0XHRcdFx0Ly8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0XHRcdHBsdXBsb2FkLmV4dGVuZChzZWxmLmZlYXR1cmVzLCB7XG5cdFx0XHRcdFx0XHRcdGNodW5rczogaW5mby5jYW4oJ3NsaWNlX2Jsb2InKSxcblx0XHRcdFx0XHRcdFx0bXVsdGlwYXJ0OiBpbmZvLmNhbignc2VuZF9tdWx0aXBhcnQnKSxcblx0XHRcdFx0XHRcdFx0bXVsdGlfc2VsZWN0aW9uOiBpbmZvLmNhbignc2VsZWN0X211bHRpcGxlJylcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpbml0ZWQrKztcblx0XHRcdFx0XHRcdGZpbGVJbnB1dHMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHRcdGNiKCk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGZpbGVJbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRGaWxlKHRoaXMuZmlsZXMpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRmaWxlSW5wdXQuYmluZCgnbW91c2VlbnRlciBtb3VzZWxlYXZlIG1vdXNlZG93biBtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0aWYgKCFkaXNhYmxlZCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2V0dGluZ3MuYnJvd3NlX2J1dHRvbl9ob3Zlcikge1xuXHRcdFx0XHRcdFx0XHRcdGlmICgnbW91c2VlbnRlcicgPT09IGUudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGx1cGxvYWQuYWRkQ2xhc3MoZWwsIHNldHRpbmdzLmJyb3dzZV9idXR0b25faG92ZXIpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoJ21vdXNlbGVhdmUnID09PSBlLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBsdXBsb2FkLnJlbW92ZUNsYXNzKGVsLCBzZXR0aW5ncy5icm93c2VfYnV0dG9uX2hvdmVyKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoc2V0dGluZ3MuYnJvd3NlX2J1dHRvbl9hY3RpdmUpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoJ21vdXNlZG93bicgPT09IGUudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGx1cGxvYWQuYWRkQ2xhc3MoZWwsIHNldHRpbmdzLmJyb3dzZV9idXR0b25fYWN0aXZlKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCdtb3VzZXVwJyA9PT0gZS50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwbHVwbG9hZC5yZW1vdmVDbGFzcyhlbCwgc2V0dGluZ3MuYnJvd3NlX2J1dHRvbl9hY3RpdmUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0ZmlsZUlucHV0LmJpbmQoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdCcm93c2UnKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGZpbGVJbnB1dC5iaW5kKCdlcnJvciBydW50aW1lZXJyb3InLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGZpbGVJbnB1dCA9IG51bGw7XG5cdFx0XHRcdFx0XHRjYigpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0ZmlsZUlucHV0LmluaXQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGRyb3Agem9uZXNcblx0XHRpZiAoc2V0dGluZ3MuZHJvcF9lbGVtZW50KSB7XG5cdFx0XHRwbHVwbG9hZC5lYWNoKHNldHRpbmdzLmRyb3BfZWxlbWVudCwgZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0cXVldWUucHVzaChmdW5jdGlvbihjYikge1xuXHRcdFx0XHRcdHZhciBmaWxlRHJvcCA9IG5ldyBvLmZpbGUuRmlsZURyb3AocGx1cGxvYWQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG5cdFx0XHRcdFx0XHRkcm9wX3pvbmU6IGVsXG5cdFx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdFx0ZmlsZURyb3Aub25yZWFkeSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGluZm8gPSBSdW50aW1lLmdldEluZm8odGhpcy5ydWlkKTtcblxuXHRcdFx0XHRcdFx0Ly8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0XHRcdHBsdXBsb2FkLmV4dGVuZChzZWxmLmZlYXR1cmVzLCB7XG5cdFx0XHRcdFx0XHRcdGNodW5rczogaW5mby5jYW4oJ3NsaWNlX2Jsb2InKSxcblx0XHRcdFx0XHRcdFx0bXVsdGlwYXJ0OiBpbmZvLmNhbignc2VuZF9tdWx0aXBhcnQnKSxcblx0XHRcdFx0XHRcdFx0ZHJhZ2Ryb3A6IGluZm8uY2FuKCdkcmFnX2FuZF9kcm9wJylcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpbml0ZWQrKztcblx0XHRcdFx0XHRcdGZpbGVEcm9wcy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0ZmlsZURyb3Aub25kcm9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZEZpbGUodGhpcy5maWxlcyk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGZpbGVEcm9wLmJpbmQoJ2Vycm9yIHJ1bnRpbWVlcnJvcicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZmlsZURyb3AgPSBudWxsO1xuXHRcdFx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGZpbGVEcm9wLmluaXQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblxuXHRcdHBsdXBsb2FkLmluU2VyaWVzKHF1ZXVlLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0eXBlb2YoY2IpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNiKGluaXRlZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlc2l6ZUltYWdlKGJsb2IsIHBhcmFtcywgY2IpIHtcblx0XHR2YXIgaW1nID0gbmV3IG8uaW1hZ2UuSW1hZ2UoKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIG5vIG1hbmlwdWxhdGlvbiByZXF1aXJlZCBpZi4uLlxuXHRcdFx0XHRpZiAocGFyYW1zLndpZHRoID4gdGhpcy53aWR0aCAmJlxuXHRcdFx0XHRcdHBhcmFtcy5oZWlnaHQgPiB0aGlzLmhlaWdodCAmJlxuXHRcdFx0XHRcdHBhcmFtcy5xdWFsaXR5ID09PSB1bmRlZiAmJlxuXHRcdFx0XHRcdHBhcmFtcy5wcmVzZXJ2ZV9oZWFkZXJzICYmXG5cdFx0XHRcdFx0IXBhcmFtcy5jcm9wXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdHJldHVybiBjYihibG9iKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBvdGhlcndpc2UgZG93bnNpemVcblx0XHRcdFx0aW1nLmRvd25zaXplKHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCwgcGFyYW1zLmNyb3AsIHBhcmFtcy5wcmVzZXJ2ZV9oZWFkZXJzKTtcblx0XHRcdH07XG5cblx0XHRcdGltZy5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYih0aGlzLmdldEFzQmxvYihibG9iLnR5cGUsIHBhcmFtcy5xdWFsaXR5KSk7XG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0aW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2IoYmxvYik7XG5cdFx0XHR9O1xuXG5cdFx0XHRpbWcubG9hZChibG9iKTtcblx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRjYihibG9iKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHNldE9wdGlvbihvcHRpb24sIHZhbHVlLCBpbml0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCByZWluaXRSZXF1aXJlZCA9IGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gX3NldE9wdGlvbihvcHRpb24sIHZhbHVlLCBpbml0KSB7XG5cdFx0XHR2YXIgb2xkVmFsdWUgPSBzZXR0aW5nc1tvcHRpb25dO1xuXG5cdFx0XHRzd2l0Y2ggKG9wdGlvbikge1xuXHRcdFx0XHRjYXNlICdtYXhfZmlsZV9zaXplJzpcblx0XHRcdFx0XHRpZiAob3B0aW9uID09PSAnbWF4X2ZpbGVfc2l6ZScpIHtcblx0XHRcdFx0XHRcdHNldHRpbmdzLm1heF9maWxlX3NpemUgPSBzZXR0aW5ncy5maWx0ZXJzLm1heF9maWxlX3NpemUgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnY2h1bmtfc2l6ZSc6XG5cdFx0XHRcdFx0aWYgKHZhbHVlID0gcGx1cGxvYWQucGFyc2VTaXplKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0dGluZ3Nbb3B0aW9uXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0c2V0dGluZ3Muc2VuZF9maWxlX25hbWUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtdWx0aXBhcnQnOlxuXHRcdFx0XHRcdHNldHRpbmdzW29wdGlvbl0gPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5zZW5kX2ZpbGVfbmFtZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2h0dHBfbWV0aG9kJzpcblx0XHRcdFx0XHRzZXR0aW5nc1tvcHRpb25dID0gdmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ1BVVCcgPyAnUFVUJyA6ICdQT1NUJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd1bmlxdWVfbmFtZXMnOlxuXHRcdFx0XHRcdHNldHRpbmdzW29wdGlvbl0gPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdHNldHRpbmdzLnNlbmRfZmlsZV9uYW1lID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZmlsdGVycyc6XG5cdFx0XHRcdFx0Ly8gZm9yIHNha2Ugb2YgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdGlmIChwbHVwbG9hZC50eXBlT2YodmFsdWUpID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHtcblx0XHRcdFx0XHRcdFx0bWltZV90eXBlczogdmFsdWVcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGluaXQpIHtcblx0XHRcdFx0XHRcdHBsdXBsb2FkLmV4dGVuZChzZXR0aW5ncy5maWx0ZXJzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldHRpbmdzLmZpbHRlcnMgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpZiBmaWxlIGZvcm1hdCBmaWx0ZXJzIGFyZSBiZWluZyB1cGRhdGVkLCByZWdlbmVyYXRlIHRoZSBtYXRjaGluZyBleHByZXNzaW9uc1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5taW1lX3R5cGVzKSB7XG5cdFx0XHRcdFx0XHRpZiAocGx1cGxvYWQudHlwZU9mKHZhbHVlLm1pbWVfdHlwZXMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZS5taW1lX3R5cGVzID0gby5jb3JlLnV0aWxzLk1pbWUubWltZXMyZXh0TGlzdCh2YWx1ZS5taW1lX3R5cGVzKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFsdWUubWltZV90eXBlcy5yZWdleHAgPSAoZnVuY3Rpb24oZmlsdGVycykge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXh0ZW5zaW9uc1JlZ0V4cCA9IFtdO1xuXG5cdFx0XHRcdFx0XHRcdHBsdXBsb2FkLmVhY2goZmlsdGVycywgZnVuY3Rpb24oZmlsdGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGx1cGxvYWQuZWFjaChmaWx0ZXIuZXh0ZW5zaW9ucy5zcGxpdCgvLC8pLCBmdW5jdGlvbihleHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICgvXlxccypcXCpcXHMqJC8udGVzdChleHQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNSZWdFeHAucHVzaCgnXFxcXC4qJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRleHRlbnNpb25zUmVnRXhwLnB1c2goJ1xcXFwuJyArIGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1snICsgKCcvXiQuKis/fCgpW117fVxcXFwnLnJlcGxhY2UoLy4vZywgJ1xcXFwkJicpKSArICddJywgJ2cnKSwgJ1xcXFwkJicpKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAoJygnICsgZXh0ZW5zaW9uc1JlZ0V4cC5qb2luKCd8JykgKyAnKSQnLCAnaScpO1xuXHRcdFx0XHRcdFx0fSh2YWx1ZS5taW1lX3R5cGVzKSk7XG5cblx0XHRcdFx0XHRcdHNldHRpbmdzLmZpbHRlcnMubWltZV90eXBlcyA9IHZhbHVlLm1pbWVfdHlwZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Jlc2l6ZSc6XG5cdFx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5yZXNpemUgPSBwbHVwbG9hZC5leHRlbmQoe1xuXHRcdFx0XHRcdFx0XHRwcmVzZXJ2ZV9oZWFkZXJzOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjcm9wOiBmYWxzZVxuXHRcdFx0XHRcdFx0fSwgdmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5yZXNpemUgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncHJldmVudF9kdXBsaWNhdGVzJzpcblx0XHRcdFx0XHRzZXR0aW5ncy5wcmV2ZW50X2R1cGxpY2F0ZXMgPSBzZXR0aW5ncy5maWx0ZXJzLnByZXZlbnRfZHVwbGljYXRlcyA9ICEhdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgcmVpbml0aWFsaXNhdGlvblxuXHRcdFx0XHRjYXNlICdjb250YWluZXInOlxuXHRcdFx0XHRjYXNlICdicm93c2VfYnV0dG9uJzpcblx0XHRcdFx0Y2FzZSAnZHJvcF9lbGVtZW50Jzpcblx0XHRcdFx0XHRcdHZhbHVlID0gJ2NvbnRhaW5lcicgPT09IG9wdGlvblxuXHRcdFx0XHRcdFx0XHQ/IHBsdXBsb2FkLmdldCh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0OiBwbHVwbG9hZC5nZXRBbGwodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDtcblxuXHRcdFx0XHRjYXNlICdydW50aW1lcyc6XG5cdFx0XHRcdGNhc2UgJ211bHRpX3NlbGVjdGlvbic6XG5cdFx0XHRcdGNhc2UgJ2ZsYXNoX3N3Zl91cmwnOlxuXHRcdFx0XHRjYXNlICdzaWx2ZXJsaWdodF94YXBfdXJsJzpcblx0XHRcdFx0XHRzZXR0aW5nc1tvcHRpb25dID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCFpbml0KSB7XG5cdFx0XHRcdFx0XHRyZWluaXRSZXF1aXJlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0c2V0dGluZ3Nbb3B0aW9uXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWluaXQpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdPcHRpb25DaGFuZ2VkJywgb3B0aW9uLCB2YWx1ZSwgb2xkVmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Yob3B0aW9uKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHBsdXBsb2FkLmVhY2gob3B0aW9uLCBmdW5jdGlvbih2YWx1ZSwgb3B0aW9uKSB7XG5cdFx0XHRcdF9zZXRPcHRpb24ob3B0aW9uLCB2YWx1ZSwgaW5pdCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X3NldE9wdGlvbihvcHRpb24sIHZhbHVlLCBpbml0KTtcblx0XHR9XG5cblx0XHRpZiAoaW5pdCkge1xuXHRcdFx0Ly8gTm9ybWFsaXplIHRoZSBsaXN0IG9mIHJlcXVpcmVkIGNhcGFiaWxpdGllc1xuXHRcdFx0c2V0dGluZ3MucmVxdWlyZWRfZmVhdHVyZXMgPSBub3JtYWxpemVDYXBzKHBsdXBsb2FkLmV4dGVuZCh7fSwgc2V0dGluZ3MpKTtcblxuXHRcdFx0Ly8gQ29tZSB1cCB3aXRoIHRoZSBsaXN0IG9mIGNhcGFiaWxpdGllcyB0aGF0IGNhbiBhZmZlY3QgZGVmYXVsdCBtb2RlIGluIGEgbXVsdGktbW9kZSBydW50aW1lc1xuXHRcdFx0cHJlZmVycmVkX2NhcHMgPSBub3JtYWxpemVDYXBzKHBsdXBsb2FkLmV4dGVuZCh7fSwgc2V0dGluZ3MsIHtcblx0XHRcdFx0cmVxdWlyZWRfZmVhdHVyZXM6IHRydWVcblx0XHRcdH0pKTtcblx0XHR9IGVsc2UgaWYgKHJlaW5pdFJlcXVpcmVkKSB7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ0Rlc3Ryb3knKTtcblxuXHRcdFx0aW5pdENvbnRyb2xzLmNhbGwoc2VsZiwgc2V0dGluZ3MsIGZ1bmN0aW9uKGluaXRlZCkge1xuXHRcdFx0XHRpZiAoaW5pdGVkKSB7XG5cdFx0XHRcdFx0c2VsZi5ydW50aW1lID0gUnVudGltZS5nZXRJbmZvKGdldFJVSUQoKSkudHlwZTtcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ0luaXQnLCB7IHJ1bnRpbWU6IHNlbGYucnVudGltZSB9KTtcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ1Bvc3RJbml0Jyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdFcnJvcicsIHtcblx0XHRcdFx0XHRcdGNvZGUgOiBwbHVwbG9hZC5JTklUX0VSUk9SLFxuXHRcdFx0XHRcdFx0bWVzc2FnZSA6IHBsdXBsb2FkLnRyYW5zbGF0ZSgnSW5pdCBlcnJvci4nKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXG5cdC8vIEludGVybmFsIGV2ZW50IGhhbmRsZXJzXG5cdGZ1bmN0aW9uIG9uQmVmb3JlVXBsb2FkKHVwLCBmaWxlKSB7XG5cdFx0Ly8gR2VuZXJhdGUgdW5pcXVlIHRhcmdldCBmaWxlbmFtZXNcblx0XHRpZiAodXAuc2V0dGluZ3MudW5pcXVlX25hbWVzKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IGZpbGUubmFtZS5tYXRjaCgvXFwuKFteLl0rKSQvKSwgZXh0ID0gXCJwYXJ0XCI7XG5cdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHRleHQgPSBtYXRjaGVzWzFdO1xuXHRcdFx0fVxuXHRcdFx0ZmlsZS50YXJnZXRfbmFtZSA9IGZpbGUuaWQgKyAnLicgKyBleHQ7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBvblVwbG9hZEZpbGUodXAsIGZpbGUpIHtcblx0XHR2YXIgdXJsID0gdXAuc2V0dGluZ3MudXJsXG5cdFx0LCBjaHVua1NpemUgPSB1cC5zZXR0aW5ncy5jaHVua19zaXplXG5cdFx0LCByZXRyaWVzID0gdXAuc2V0dGluZ3MubWF4X3JldHJpZXNcblx0XHQsIGZlYXR1cmVzID0gdXAuZmVhdHVyZXNcblx0XHQsIG9mZnNldCA9IDBcblx0XHQsIGJsb2Jcblx0XHQ7XG5cblx0XHQvLyBtYWtlIHN1cmUgd2Ugc3RhcnQgYXQgYSBwcmVkaWN0YWJsZSBvZmZzZXRcblx0XHRpZiAoZmlsZS5sb2FkZWQpIHtcblx0XHRcdG9mZnNldCA9IGZpbGUubG9hZGVkID0gY2h1bmtTaXplID8gY2h1bmtTaXplICogTWF0aC5mbG9vcihmaWxlLmxvYWRlZCAvIGNodW5rU2l6ZSkgOiAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuXHRcdFx0aWYgKHJldHJpZXMtLSA+IDApIHtcblx0XHRcdFx0ZGVsYXkodXBsb2FkTmV4dENodW5rLCAxMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpbGUubG9hZGVkID0gb2Zmc2V0OyAvLyByZXNldCBhbGwgcHJvZ3Jlc3NcblxuXHRcdFx0XHR1cC50cmlnZ2VyKCdFcnJvcicsIHtcblx0XHRcdFx0XHRjb2RlIDogcGx1cGxvYWQuSFRUUF9FUlJPUixcblx0XHRcdFx0XHRtZXNzYWdlIDogcGx1cGxvYWQudHJhbnNsYXRlKCdIVFRQIEVycm9yLicpLFxuXHRcdFx0XHRcdGZpbGUgOiBmaWxlLFxuXHRcdFx0XHRcdHJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dCxcblx0XHRcdFx0XHRzdGF0dXMgOiB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyczogeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwbG9hZE5leHRDaHVuaygpIHtcblx0XHRcdHZhciBjaHVua0Jsb2IsIGFyZ3MgPSB7fSwgY3VyQ2h1bmtTaXplO1xuXG5cdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCBmaWxlIHdhc24ndCBjYW5jZWxsZWQgYW5kIHVwbG9hZCBpcyBub3Qgc3RvcHBlZCBpbiBnZW5lcmFsXG5cdFx0XHRpZiAoZmlsZS5zdGF0dXMgIT09IHBsdXBsb2FkLlVQTE9BRElORyB8fCB1cC5zdGF0ZSA9PT0gcGx1cGxvYWQuU1RPUFBFRCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNlbmQgYWRkaXRpb25hbCAnbmFtZScgcGFyYW1ldGVyIG9ubHkgaWYgcmVxdWlyZWRcblx0XHRcdGlmICh1cC5zZXR0aW5ncy5zZW5kX2ZpbGVfbmFtZSkge1xuXHRcdFx0XHRhcmdzLm5hbWUgPSBmaWxlLnRhcmdldF9uYW1lIHx8IGZpbGUubmFtZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNodW5rU2l6ZSAmJiBmZWF0dXJlcy5jaHVua3MgJiYgYmxvYi5zaXplID4gY2h1bmtTaXplKSB7IC8vIGJsb2Igd2lsbCBiZSBvZiB0eXBlIHN0cmluZyBpZiBpdCB3YXMgbG9hZGVkIGluIG1lbW9yeVxuXHRcdFx0XHRjdXJDaHVua1NpemUgPSBNYXRoLm1pbihjaHVua1NpemUsIGJsb2Iuc2l6ZSAtIG9mZnNldCk7XG5cdFx0XHRcdGNodW5rQmxvYiA9IGJsb2Iuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjdXJDaHVua1NpemUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VyQ2h1bmtTaXplID0gYmxvYi5zaXplO1xuXHRcdFx0XHRjaHVua0Jsb2IgPSBibG9iO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBjaHVua2luZyBpcyBlbmFibGVkIGFkZCBjb3JyZXNwb25kaW5nIGFyZ3MsIG5vIG1hdHRlciBpZiBmaWxlIGlzIGJpZ2dlciB0aGFuIGNodW5rIG9yIHNtYWxsZXJcblx0XHRcdGlmIChjaHVua1NpemUgJiYgZmVhdHVyZXMuY2h1bmtzKSB7XG5cdFx0XHRcdC8vIFNldHVwIHF1ZXJ5IHN0cmluZyBhcmd1bWVudHNcblx0XHRcdFx0aWYgKHVwLnNldHRpbmdzLnNlbmRfY2h1bmtfbnVtYmVyKSB7XG5cdFx0XHRcdFx0YXJncy5jaHVuayA9IE1hdGguY2VpbChvZmZzZXQgLyBjaHVua1NpemUpO1xuXHRcdFx0XHRcdGFyZ3MuY2h1bmtzID0gTWF0aC5jZWlsKGJsb2Iuc2l6ZSAvIGNodW5rU2l6ZSk7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGtlZXAgc3VwcG9ydCBmb3IgZXhwZXJpbWVudGFsIGNodW5rIGZvcm1hdCwganVzdCBpbiBjYXNlXG5cdFx0XHRcdFx0YXJncy5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRcdFx0YXJncy50b3RhbCA9IGJsb2Iuc2l6ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodXAudHJpZ2dlcignQmVmb3JlQ2h1bmtVcGxvYWQnLCBmaWxlLCBhcmdzLCBjaHVua0Jsb2IsIG9mZnNldCkpIHtcblx0XHRcdFx0dXBsb2FkQ2h1bmsoYXJncywgY2h1bmtCbG9iLCBjdXJDaHVua1NpemUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwbG9hZENodW5rKGFyZ3MsIGNodW5rQmxvYiwgY3VyQ2h1bmtTaXplKSB7XG5cdFx0XHR2YXIgZm9ybURhdGE7XG5cblx0XHRcdHhociA9IG5ldyBvLnhoci5YTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0XHQvLyBEbyB3ZSBoYXZlIHVwbG9hZCBwcm9ncmVzcyBzdXBwb3J0XG5cdFx0XHRpZiAoeGhyLnVwbG9hZCkge1xuXHRcdFx0XHR4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0ZmlsZS5sb2FkZWQgPSBNYXRoLm1pbihmaWxlLnNpemUsIG9mZnNldCArIGUubG9hZGVkKTtcblx0XHRcdFx0XHR1cC50cmlnZ2VyKCdVcGxvYWRQcm9ncmVzcycsIGZpbGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIHVwbG9hZCBtYWRlIGl0c2VsZiB0aHJvdWdoXG5cdFx0XHRcdGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuXHRcdFx0XHRcdGhhbmRsZUVycm9yKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0cmllcyA9IHVwLnNldHRpbmdzLm1heF9yZXRyaWVzOyAvLyByZXNldCB0aGUgY291bnRlclxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjaHVuayByZXNwb25zZVxuXHRcdFx0XHRpZiAoY3VyQ2h1bmtTaXplIDwgYmxvYi5zaXplKSB7XG5cdFx0XHRcdFx0Y2h1bmtCbG9iLmRlc3Ryb3koKTtcblxuXHRcdFx0XHRcdG9mZnNldCArPSBjdXJDaHVua1NpemU7XG5cdFx0XHRcdFx0ZmlsZS5sb2FkZWQgPSBNYXRoLm1pbihvZmZzZXQsIGJsb2Iuc2l6ZSk7XG5cblx0XHRcdFx0XHR1cC50cmlnZ2VyKCdDaHVua1VwbG9hZGVkJywgZmlsZSwge1xuXHRcdFx0XHRcdFx0b2Zmc2V0IDogZmlsZS5sb2FkZWQsXG5cdFx0XHRcdFx0XHR0b3RhbCA6IGJsb2Iuc2l6ZSxcblx0XHRcdFx0XHRcdHJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dCxcblx0XHRcdFx0XHRcdHN0YXR1cyA6IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnM6IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gc3RvY2sgQW5kcm9pZCBicm93c2VyIGRvZXNuJ3QgZmlyZSB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnRzLCBidXQgaW4gY2h1bmtpbmcgbW9kZSB3ZSBjYW4gZmFrZSB0aGVtXG5cdFx0XHRcdFx0aWYgKHBsdXBsb2FkLnVhLmJyb3dzZXIgPT09ICdBbmRyb2lkIEJyb3dzZXInKSB7XG5cdFx0XHRcdFx0XHQvLyBkb2Vzbid0IGhhcm0gaW4gZ2VuZXJhbCwgYnV0IGlzIG5vdCByZXF1aXJlZCBhbnl3aGVyZSBlbHNlXG5cdFx0XHRcdFx0XHR1cC50cmlnZ2VyKCdVcGxvYWRQcm9ncmVzcycsIGZpbGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaWxlLmxvYWRlZCA9IGZpbGUuc2l6ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNodW5rQmxvYiA9IGZvcm1EYXRhID0gbnVsbDsgLy8gRnJlZSBtZW1vcnlcblxuXHRcdFx0XHQvLyBDaGVjayBpZiBmaWxlIGlzIHVwbG9hZGVkXG5cdFx0XHRcdGlmICghb2Zmc2V0IHx8IG9mZnNldCA+PSBibG9iLnNpemUpIHtcblx0XHRcdFx0XHQvLyBJZiBmaWxlIHdhcyBtb2RpZmllZCwgZGVzdG9yeSB0aGUgY29weVxuXHRcdFx0XHRcdGlmIChmaWxlLnNpemUgIT0gZmlsZS5vcmlnU2l6ZSkge1xuXHRcdFx0XHRcdFx0YmxvYi5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRibG9iID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR1cC50cmlnZ2VyKCdVcGxvYWRQcm9ncmVzcycsIGZpbGUpO1xuXG5cdFx0XHRcdFx0ZmlsZS5zdGF0dXMgPSBwbHVwbG9hZC5ET05FO1xuXHRcdFx0XHRcdGZpbGUuY29tcGxldGVUaW1lc3RhbXAgPSArbmV3IERhdGUoKTtcblxuXHRcdFx0XHRcdHVwLnRyaWdnZXIoJ0ZpbGVVcGxvYWRlZCcsIGZpbGUsIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dCxcblx0XHRcdFx0XHRcdHN0YXR1cyA6IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnM6IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFN0aWxsIGNodW5rcyBsZWZ0XG5cdFx0XHRcdFx0ZGVsYXkodXBsb2FkTmV4dENodW5rLCAxKTsgLy8gcnVuIGRldGFjaGVkLCBvdGhlcndpc2UgZXZlbnQgaGFuZGxlcnMgaW50ZXJmZXJlXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhhbmRsZUVycm9yKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHR4aHIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHR4aHIgPSBudWxsO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQnVpbGQgbXVsdGlwYXJ0IHJlcXVlc3Rcblx0XHRcdGlmICh1cC5zZXR0aW5ncy5tdWx0aXBhcnQgJiYgZmVhdHVyZXMubXVsdGlwYXJ0KSB7XG5cdFx0XHRcdHhoci5vcGVuKHVwLnNldHRpbmdzLmh0dHBfbWV0aG9kLCB1cmwsIHRydWUpO1xuXG5cdFx0XHRcdC8vIFNldCBjdXN0b20gaGVhZGVyc1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKHVwLnNldHRpbmdzLmhlYWRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRmb3JtRGF0YSA9IG5ldyBvLnhoci5Gb3JtRGF0YSgpO1xuXG5cdFx0XHRcdC8vIEFkZCBtdWx0aXBhcnQgcGFyYW1zXG5cdFx0XHRcdHBsdXBsb2FkLmVhY2gocGx1cGxvYWQuZXh0ZW5kKGFyZ3MsIHVwLnNldHRpbmdzLm11bHRpcGFydF9wYXJhbXMpLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEFkZCBmaWxlIGFuZCBzZW5kIGl0XG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCh1cC5zZXR0aW5ncy5maWxlX2RhdGFfbmFtZSwgY2h1bmtCbG9iKTtcblx0XHRcdFx0eGhyLnNlbmQoZm9ybURhdGEsIHtcblx0XHRcdFx0XHRydW50aW1lX29yZGVyOiB1cC5zZXR0aW5ncy5ydW50aW1lcyxcblx0XHRcdFx0XHRyZXF1aXJlZF9jYXBzOiB1cC5zZXR0aW5ncy5yZXF1aXJlZF9mZWF0dXJlcyxcblx0XHRcdFx0XHRwcmVmZXJyZWRfY2FwczogcHJlZmVycmVkX2NhcHMsXG5cdFx0XHRcdFx0c3dmX3VybDogdXAuc2V0dGluZ3MuZmxhc2hfc3dmX3VybCxcblx0XHRcdFx0XHR4YXBfdXJsOiB1cC5zZXR0aW5ncy5zaWx2ZXJsaWdodF94YXBfdXJsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaWYgbm8gbXVsdGlwYXJ0LCBzZW5kIGFzIGJpbmFyeSBzdHJlYW1cblx0XHRcdFx0dXJsID0gcGx1cGxvYWQuYnVpbGRVcmwodXAuc2V0dGluZ3MudXJsLCBwbHVwbG9hZC5leHRlbmQoYXJncywgdXAuc2V0dGluZ3MubXVsdGlwYXJ0X3BhcmFtcykpO1xuXG5cdFx0XHRcdHhoci5vcGVuKHVwLnNldHRpbmdzLmh0dHBfbWV0aG9kLCB1cmwsIHRydWUpO1xuXG5cdFx0XHRcdC8vIFNldCBjdXN0b20gaGVhZGVyc1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKHVwLnNldHRpbmdzLmhlYWRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBkbyBub3Qgc2V0IENvbnRlbnQtVHlwZSwgaWYgaXQgd2FzIGRlZmluZWQgcHJldmlvdXNseSAoc2VlICMxMjAzKVxuXHRcdFx0XHRpZiAoIXhoci5oYXNSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnKSkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7IC8vIEJpbmFyeSBzdHJlYW0gaGVhZGVyXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR4aHIuc2VuZChjaHVua0Jsb2IsIHtcblx0XHRcdFx0XHRydW50aW1lX29yZGVyOiB1cC5zZXR0aW5ncy5ydW50aW1lcyxcblx0XHRcdFx0XHRyZXF1aXJlZF9jYXBzOiB1cC5zZXR0aW5ncy5yZXF1aXJlZF9mZWF0dXJlcyxcblx0XHRcdFx0XHRwcmVmZXJyZWRfY2FwczogcHJlZmVycmVkX2NhcHMsXG5cdFx0XHRcdFx0c3dmX3VybDogdXAuc2V0dGluZ3MuZmxhc2hfc3dmX3VybCxcblx0XHRcdFx0XHR4YXBfdXJsOiB1cC5zZXR0aW5ncy5zaWx2ZXJsaWdodF94YXBfdXJsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0YmxvYiA9IGZpbGUuZ2V0U291cmNlKCk7XG5cblx0XHQvLyBTdGFydCB1cGxvYWRpbmcgY2h1bmtzXG5cdFx0aWYgKCFwbHVwbG9hZC5pc0VtcHR5T2JqKHVwLnNldHRpbmdzLnJlc2l6ZSkgJiYgcnVudGltZUNhbihibG9iLCAnc2VuZF9iaW5hcnlfc3RyaW5nJykgJiYgcGx1cGxvYWQuaW5BcnJheShibG9iLnR5cGUsIFsnaW1hZ2UvanBlZycsICdpbWFnZS9wbmcnXSkgIT09IC0xKSB7XG5cdFx0XHQvLyBSZXNpemUgaWYgcmVxdWlyZWRcblx0XHRcdHJlc2l6ZUltYWdlLmNhbGwodGhpcywgYmxvYiwgdXAuc2V0dGluZ3MucmVzaXplLCBmdW5jdGlvbihyZXNpemVkQmxvYikge1xuXHRcdFx0XHRibG9iID0gcmVzaXplZEJsb2I7XG5cdFx0XHRcdGZpbGUuc2l6ZSA9IHJlc2l6ZWRCbG9iLnNpemU7XG5cdFx0XHRcdHVwbG9hZE5leHRDaHVuaygpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVwbG9hZE5leHRDaHVuaygpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gb25VcGxvYWRQcm9ncmVzcyh1cCwgZmlsZSkge1xuXHRcdGNhbGNGaWxlKGZpbGUpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBvblN0YXRlQ2hhbmdlZCh1cCkge1xuXHRcdGlmICh1cC5zdGF0ZSA9PSBwbHVwbG9hZC5TVEFSVEVEKSB7XG5cdFx0XHQvLyBHZXQgc3RhcnQgdGltZSB0byBjYWxjdWxhdGUgYnBzXG5cdFx0XHRzdGFydFRpbWUgPSAoK25ldyBEYXRlKCkpO1xuXHRcdH0gZWxzZSBpZiAodXAuc3RhdGUgPT0gcGx1cGxvYWQuU1RPUFBFRCkge1xuXHRcdFx0Ly8gUmVzZXQgY3VycmVudGx5IHVwbG9hZGluZyBmaWxlc1xuXHRcdFx0Zm9yICh2YXIgaSA9IHVwLmZpbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmICh1cC5maWxlc1tpXS5zdGF0dXMgPT0gcGx1cGxvYWQuVVBMT0FESU5HKSB7XG5cdFx0XHRcdFx0dXAuZmlsZXNbaV0uc3RhdHVzID0gcGx1cGxvYWQuUVVFVUVEO1xuXHRcdFx0XHRcdGNhbGMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gb25DYW5jZWxVcGxvYWQoKSB7XG5cdFx0aWYgKHhocikge1xuXHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBvbkZpbGVVcGxvYWRlZCh1cCkge1xuXHRcdGNhbGMoKTtcblxuXHRcdC8vIFVwbG9hZCBuZXh0IGZpbGUgYnV0IGRldGFjaCBpdCBmcm9tIHRoZSBlcnJvciBldmVudFxuXHRcdC8vIHNpbmNlIG90aGVyIGN1c3RvbSBsaXN0ZW5lcnMgbWlnaHQgd2FudCB0byBzdG9wIHRoZSBxdWV1ZVxuXHRcdGRlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dXBsb2FkTmV4dC5jYWxsKHVwKTtcblx0XHR9LCAxKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gb25FcnJvcih1cCwgZXJyKSB7XG5cdFx0aWYgKGVyci5jb2RlID09PSBwbHVwbG9hZC5JTklUX0VSUk9SKSB7XG5cdFx0XHR1cC5kZXN0cm95KCk7XG5cdFx0fVxuXHRcdC8vIFNldCBmYWlsZWQgc3RhdHVzIGlmIGFuIGVycm9yIG9jY3VyZWQgb24gYSBmaWxlXG5cdFx0ZWxzZSBpZiAoZXJyLmNvZGUgPT09IHBsdXBsb2FkLkhUVFBfRVJST1IpIHtcblx0XHRcdGVyci5maWxlLnN0YXR1cyA9IHBsdXBsb2FkLkZBSUxFRDtcblx0XHRcdGVyci5maWxlLmNvbXBsZXRlVGltZXN0YW1wID0gK25ldyBEYXRlKCk7XG5cdFx0XHRjYWxjRmlsZShlcnIuZmlsZSk7XG5cblx0XHRcdC8vIFVwbG9hZCBuZXh0IGZpbGUgYnV0IGRldGFjaCBpdCBmcm9tIHRoZSBlcnJvciBldmVudFxuXHRcdFx0Ly8gc2luY2Ugb3RoZXIgY3VzdG9tIGxpc3RlbmVycyBtaWdodCB3YW50IHRvIHN0b3AgdGhlIHF1ZXVlXG5cdFx0XHRpZiAodXAuc3RhdGUgPT0gcGx1cGxvYWQuU1RBUlRFRCkgeyAvLyB1cGxvYWQgaW4gcHJvZ3Jlc3Ncblx0XHRcdFx0dXAudHJpZ2dlcignQ2FuY2VsVXBsb2FkJyk7XG5cdFx0XHRcdGRlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHVwbG9hZE5leHQuY2FsbCh1cCk7XG5cdFx0XHRcdH0sIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gb25EZXN0cm95KHVwKSB7XG5cdFx0dXAuc3RvcCgpO1xuXG5cdFx0Ly8gUHVyZ2UgdGhlIHF1ZXVlXG5cdFx0cGx1cGxvYWQuZWFjaChmaWxlcywgZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0ZmlsZS5kZXN0cm95KCk7XG5cdFx0fSk7XG5cdFx0ZmlsZXMgPSBbXTtcblxuXHRcdGlmIChmaWxlSW5wdXRzLmxlbmd0aCkge1xuXHRcdFx0cGx1cGxvYWQuZWFjaChmaWxlSW5wdXRzLCBmdW5jdGlvbihmaWxlSW5wdXQpIHtcblx0XHRcdFx0ZmlsZUlucHV0LmRlc3Ryb3koKTtcblx0XHRcdH0pO1xuXHRcdFx0ZmlsZUlucHV0cyA9IFtdO1xuXHRcdH1cblxuXHRcdGlmIChmaWxlRHJvcHMubGVuZ3RoKSB7XG5cdFx0XHRwbHVwbG9hZC5lYWNoKGZpbGVEcm9wcywgZnVuY3Rpb24oZmlsZURyb3ApIHtcblx0XHRcdFx0ZmlsZURyb3AuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cdFx0XHRmaWxlRHJvcHMgPSBbXTtcblx0XHR9XG5cblx0XHRwcmVmZXJyZWRfY2FwcyA9IHt9O1xuXHRcdGRpc2FibGVkID0gZmFsc2U7XG5cdFx0c3RhcnRUaW1lID0geGhyID0gbnVsbDtcblx0XHR0b3RhbC5yZXNldCgpO1xuXHR9XG5cblxuXHQvLyBEZWZhdWx0IHNldHRpbmdzXG5cdHNldHRpbmdzID0ge1xuXHRcdGNodW5rX3NpemU6IDAsXG5cdFx0ZmlsZV9kYXRhX25hbWU6ICdmaWxlJyxcblx0XHRmaWx0ZXJzOiB7XG5cdFx0XHRtaW1lX3R5cGVzOiBbXSxcblx0XHRcdHByZXZlbnRfZHVwbGljYXRlczogZmFsc2UsXG5cdFx0XHRtYXhfZmlsZV9zaXplOiAwXG5cdFx0fSxcblx0XHRmbGFzaF9zd2ZfdXJsOiAnanMvTW94aWUuc3dmJyxcblx0XHRodHRwX21ldGhvZDogJ1BPU1QnLFxuXHRcdG1heF9yZXRyaWVzOiAwLFxuXHRcdG11bHRpcGFydDogdHJ1ZSxcblx0XHRtdWx0aV9zZWxlY3Rpb246IHRydWUsXG5cdFx0cmVzaXplOiBmYWxzZSxcblx0XHRydW50aW1lczogUnVudGltZS5vcmRlcixcblx0XHRzZW5kX2ZpbGVfbmFtZTogdHJ1ZSxcblx0XHRzZW5kX2NodW5rX251bWJlcjogdHJ1ZSxcblx0XHRzaWx2ZXJsaWdodF94YXBfdXJsOiAnanMvTW94aWUueGFwJ1xuXHR9O1xuXG5cblx0c2V0T3B0aW9uLmNhbGwodGhpcywgb3B0aW9ucywgbnVsbCwgdHJ1ZSk7XG5cblx0Ly8gSW5pdGFsIHRvdGFsIHN0YXRlXG5cdHRvdGFsID0gbmV3IHBsdXBsb2FkLlF1ZXVlUHJvZ3Jlc3MoKTtcblxuXHQvLyBBZGQgcHVibGljIG1ldGhvZHNcblx0cGx1cGxvYWQuZXh0ZW5kKHRoaXMsIHtcblxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBpZCBmb3IgdGhlIFVwbG9hZGVyIGluc3RhbmNlLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGlkXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0aWQgOiB1aWQsXG5cdFx0dWlkIDogdWlkLCAvLyBtT3hpZSB1c2VzIHRoaXMgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGV2ZW50IHRhcmdldHNcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIHRvdGFsIHVwbG9hZGluZyBwcm9ncmVzcy4gVGhpcyBvbmUgY2FuIGVpdGhlciBiZSBwbHVwbG9hZC5TVEFSVEVEIG9yIHBsdXBsb2FkLlNUT1BQRUQuXG5cdFx0ICogVGhlc2Ugc3RhdGVzIGFyZSBjb250cm9sbGVkIGJ5IHRoZSBzdG9wL3N0YXJ0IG1ldGhvZHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFNUT1BQRUQuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgc3RhdGVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKi9cblx0XHRzdGF0ZSA6IHBsdXBsb2FkLlNUT1BQRUQsXG5cblx0XHQvKipcblx0XHQgKiBNYXAgb2YgZmVhdHVyZXMgdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGUgdXBsb2FkZXIgcnVudGltZS4gRmVhdHVyZXMgd2lsbCBiZSBmaWxsZWRcblx0XHQgKiBiZWZvcmUgdGhlIGluaXQgZXZlbnQgaXMgY2FsbGVkLCB0aGVzZSBmZWF0dXJlcyBjYW4gdGhlbiBiZSB1c2VkIHRvIGFsdGVyIHRoZSBVSSBmb3IgdGhlIGVuZCB1c2VyLlxuXHRcdCAqIFNvbWUgb2YgdGhlIGN1cnJlbnQgZmVhdHVyZXMgdGhhdCBtaWdodCBiZSBpbiB0aGlzIG1hcCBpczogZHJhZ2Ryb3AsIGNodW5rcywganBncmVzaXplLCBwbmdyZXNpemUuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgZmVhdHVyZXNcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHRmZWF0dXJlcyA6IHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBydW50aW1lIG5hbWUuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcnVudGltZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHJ1bnRpbWUgOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCB1cGxvYWQgcXVldWUsIGFuIGFycmF5IG9mIEZpbGUgaW5zdGFuY2VzLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGZpbGVzXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiBAc2VlIHBsdXBsb2FkLkZpbGVcblx0XHQgKi9cblx0XHRmaWxlcyA6IGZpbGVzLFxuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IHdpdGggbmFtZS92YWx1ZSBzZXR0aW5ncy5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBzZXR0aW5nc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdHNldHRpbmdzIDogc2V0dGluZ3MsXG5cblx0XHQvKipcblx0XHQgKiBUb3RhbCBwcm9nZXNzIGluZm9ybWF0aW9uLiBIb3cgbWFueSBmaWxlcyBoYXMgYmVlbiB1cGxvYWRlZCwgdG90YWwgcGVyY2VudCBldGMuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgdG90YWxcblx0XHQgKiBAdHlwZSBwbHVwbG9hZC5RdWV1ZVByb2dyZXNzXG5cdFx0ICovXG5cdFx0dG90YWwgOiB0b3RhbCxcblxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXMgdGhlIFVwbG9hZGVyIGluc3RhbmNlIGFuZCBhZGRzIGludGVybmFsIGV2ZW50IGxpc3RlbmVycy5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqL1xuXHRcdGluaXQgOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgb3B0LCBwcmVpbml0T3B0LCBlcnI7XG5cblx0XHRcdHByZWluaXRPcHQgPSBzZWxmLmdldE9wdGlvbigncHJlaW5pdCcpO1xuXHRcdFx0aWYgKHR5cGVvZihwcmVpbml0T3B0KSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cHJlaW5pdE9wdChzZWxmKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBsdXBsb2FkLmVhY2gocHJlaW5pdE9wdCwgZnVuY3Rpb24oZnVuYywgbmFtZSkge1xuXHRcdFx0XHRcdHNlbGYuYmluZChuYW1lLCBmdW5jKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGJpbmRFdmVudExpc3RlbmVycy5jYWxsKHNlbGYpO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgcmVxdWlyZWQgb3B0aW9uc1xuXHRcdFx0cGx1cGxvYWQuZWFjaChbJ2NvbnRhaW5lcicsICdicm93c2VfYnV0dG9uJywgJ2Ryb3BfZWxlbWVudCddLCBmdW5jdGlvbihlbCkge1xuXHRcdFx0XHRpZiAoc2VsZi5nZXRPcHRpb24oZWwpID09PSBudWxsKSB7XG5cdFx0XHRcdFx0ZXJyID0ge1xuXHRcdFx0XHRcdFx0Y29kZSA6IHBsdXBsb2FkLklOSVRfRVJST1IsXG5cdFx0XHRcdFx0XHRtZXNzYWdlIDogcGx1cGxvYWQuc3ByaW50ZihwbHVwbG9hZC50cmFuc2xhdGUoXCIlcyBzcGVjaWZpZWQsIGJ1dCBjYW5ub3QgYmUgZm91bmQuXCIpLCBlbClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRyZXR1cm4gc2VsZi50cmlnZ2VyKCdFcnJvcicsIGVycik7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKCFzZXR0aW5ncy5icm93c2VfYnV0dG9uICYmICFzZXR0aW5ncy5kcm9wX2VsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYudHJpZ2dlcignRXJyb3InLCB7XG5cdFx0XHRcdFx0Y29kZSA6IHBsdXBsb2FkLklOSVRfRVJST1IsXG5cdFx0XHRcdFx0bWVzc2FnZSA6IHBsdXBsb2FkLnRyYW5zbGF0ZShcIllvdSBtdXN0IHNwZWNpZnkgZWl0aGVyIGJyb3dzZV9idXR0b24gb3IgZHJvcF9lbGVtZW50LlwiKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXG5cdFx0XHRpbml0Q29udHJvbHMuY2FsbChzZWxmLCBzZXR0aW5ncywgZnVuY3Rpb24oaW5pdGVkKSB7XG5cdFx0XHRcdHZhciBpbml0T3B0ID0gc2VsZi5nZXRPcHRpb24oJ2luaXQnKTtcblx0XHRcdFx0aWYgKHR5cGVvZihpbml0T3B0KSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRpbml0T3B0KHNlbGYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBsdXBsb2FkLmVhY2goaW5pdE9wdCwgZnVuY3Rpb24oZnVuYywgbmFtZSkge1xuXHRcdFx0XHRcdFx0c2VsZi5iaW5kKG5hbWUsIGZ1bmMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGluaXRlZCkge1xuXHRcdFx0XHRcdHNlbGYucnVudGltZSA9IFJ1bnRpbWUuZ2V0SW5mbyhnZXRSVUlEKCkpLnR5cGU7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdJbml0JywgeyBydW50aW1lOiBzZWxmLnJ1bnRpbWUgfSk7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdQb3N0SW5pdCcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcignRXJyb3InLCB7XG5cdFx0XHRcdFx0XHRjb2RlIDogcGx1cGxvYWQuSU5JVF9FUlJPUixcblx0XHRcdFx0XHRcdG1lc3NhZ2UgOiBwbHVwbG9hZC50cmFuc2xhdGUoJ0luaXQgZXJyb3IuJylcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgb3B0aW9uKHMpLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBzZXRPcHRpb25cblx0XHQgKiBAc2luY2UgMi4xXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBvcHRpb24gTmFtZSBvZiB0aGUgb3B0aW9uIHRvIGNoYW5nZSBvciB0aGUgc2V0IG9mIGtleS92YWx1ZSBwYWlyc1xuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IFt2YWx1ZV0gVmFsdWUgZm9yIHRoZSBvcHRpb24gKGlzIGlnbm9yZWQsIGlmIGZpcnN0IGFyZ3VtZW50IGlzIG9iamVjdClcblx0XHQgKi9cblx0XHRzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcblx0XHRcdHNldE9wdGlvbi5jYWxsKHRoaXMsIG9wdGlvbiwgdmFsdWUsICF0aGlzLnJ1bnRpbWUpOyAvLyB1bnRpbCBydW50aW1lIG5vdCBzZXQgd2UgZG8gbm90IG5lZWQgdG8gcmVpbml0aWFsaXplXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgb3B0aW9uIG9yIHRoZSB3aG9sZSBjb25maWd1cmF0aW9uLCBpZiBub3Qgc3BlY2lmaWVkLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBnZXRPcHRpb25cblx0XHQgKiBAc2luY2UgMi4xXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25dIE5hbWUgb2YgdGhlIG9wdGlvbiB0byBnZXRcblx0XHQgKiBAcmV0dXJuIHtNaXhlZH0gVmFsdWUgZm9yIHRoZSBvcHRpb24gb3IgdGhlIHdob2xlIHNldFxuXHRcdCAqL1xuXHRcdGdldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uKSB7XG5cdFx0XHRpZiAoIW9wdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gc2V0dGluZ3M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3Nbb3B0aW9uXTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVmcmVzaGVzIHRoZSB1cGxvYWQgaW5zdGFuY2UgYnkgZGlzcGF0Y2hpbmcgb3V0IGEgcmVmcmVzaCBldmVudCB0byBhbGwgcnVudGltZXMuXG5cdFx0ICogVGhpcyB3b3VsZCBmb3IgZXhhbXBsZSByZXBvc2l0aW9uIGZsYXNoL3NpbHZlcmxpZ2h0IHNoaW1zIG9uIHRoZSBwYWdlLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCByZWZyZXNoXG5cdFx0ICovXG5cdFx0cmVmcmVzaCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGZpbGVJbnB1dHMubGVuZ3RoKSB7XG5cdFx0XHRcdHBsdXBsb2FkLmVhY2goZmlsZUlucHV0cywgZnVuY3Rpb24oZmlsZUlucHV0KSB7XG5cdFx0XHRcdFx0ZmlsZUlucHV0LnRyaWdnZXIoJ1JlZnJlc2gnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ1JlZnJlc2gnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU3RhcnRzIHVwbG9hZGluZyB0aGUgcXVldWVkIGZpbGVzLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBzdGFydFxuXHRcdCAqL1xuXHRcdHN0YXJ0IDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZSAhPSBwbHVwbG9hZC5TVEFSVEVEKSB7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBwbHVwbG9hZC5TVEFSVEVEO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ1N0YXRlQ2hhbmdlZCcpO1xuXG5cdFx0XHRcdHVwbG9hZE5leHQuY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU3RvcHMgdGhlIHVwbG9hZCBvZiB0aGUgcXVldWVkIGZpbGVzLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBzdG9wXG5cdFx0ICovXG5cdFx0c3RvcCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUgIT0gcGx1cGxvYWQuU1RPUFBFRCkge1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gcGx1cGxvYWQuU1RPUFBFRDtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdTdGF0ZUNoYW5nZWQnKTtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdDYW5jZWxVcGxvYWQnKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBEaXNhYmxlcy9lbmFibGVzIGJyb3dzZSBidXR0b24gb24gcmVxdWVzdC5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgZGlzYWJsZUJyb3dzZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZSBXaGV0aGVyIHRvIGRpc2FibGUgb3IgZW5hYmxlIChkZWZhdWx0OiB0cnVlKVxuXHRcdCAqL1xuXHRcdGRpc2FibGVCcm93c2UgOiBmdW5jdGlvbigpIHtcblx0XHRcdGRpc2FibGVkID0gYXJndW1lbnRzWzBdICE9PSB1bmRlZiA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cblx0XHRcdGlmIChmaWxlSW5wdXRzLmxlbmd0aCkge1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKGZpbGVJbnB1dHMsIGZ1bmN0aW9uKGZpbGVJbnB1dCkge1xuXHRcdFx0XHRcdGZpbGVJbnB1dC5kaXNhYmxlKGRpc2FibGVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudHJpZ2dlcignRGlzYWJsZUJyb3dzZScsIGRpc2FibGVkKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIGZpbGUgb2JqZWN0IGJ5IGlkLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBnZXRGaWxlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIEZpbGUgaWQgdG8gbG9vayBmb3IuXG5cdFx0ICogQHJldHVybiB7cGx1cGxvYWQuRmlsZX0gRmlsZSBvYmplY3Qgb3IgdW5kZWZpbmVkIGlmIGl0IHdhc24ndCBmb3VuZDtcblx0XHQgKi9cblx0XHRnZXRGaWxlIDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0Zm9yIChpID0gZmlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGZpbGVzW2ldLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHJldHVybiBmaWxlc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGRzIGZpbGUgdG8gdGhlIHF1ZXVlIHByb2dyYW1tYXRpY2FsbHkuIENhbiBiZSBuYXRpdmUgZmlsZSwgaW5zdGFuY2Ugb2YgUGx1cGxvYWQuRmlsZSxcblx0XHQgKiBpbnN0YW5jZSBvZiBtT3hpZS5GaWxlLCBpbnB1dFt0eXBlPVwiZmlsZVwiXSBlbGVtZW50LCBvciBhcnJheSBvZiB0aGVzZS4gRmlyZXMgRmlsZXNBZGRlZCxcblx0XHQgKiBpZiBhbnkgZmlsZXMgd2VyZSBhZGRlZCB0byB0aGUgcXVldWUuIE90aGVyd2lzZSBub3RoaW5nIGhhcHBlbnMuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGFkZEZpbGVcblx0XHQgKiBAc2luY2UgMi4wXG5cdFx0ICogQHBhcmFtIHtwbHVwbG9hZC5GaWxlfG1PeGllLkZpbGV8RmlsZXxOb2RlfEFycmF5fSBmaWxlIEZpbGUgb3IgZmlsZXMgdG8gYWRkIHRvIHRoZSBxdWV1ZS5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gW2ZpbGVOYW1lXSBJZiBzcGVjaWZpZWQsIHdpbGwgYmUgdXNlZCBhcyBhIG5hbWUgZm9yIHRoZSBmaWxlXG5cdFx0ICovXG5cdFx0YWRkRmlsZSA6IGZ1bmN0aW9uKGZpbGUsIGZpbGVOYW1lKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHRcdCwgcXVldWUgPSBbXVxuXHRcdFx0LCBmaWxlc0FkZGVkID0gW11cblx0XHRcdCwgcnVpZFxuXHRcdFx0O1xuXG5cdFx0XHRmdW5jdGlvbiBmaWx0ZXJGaWxlKGZpbGUsIGNiKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKHNlbGYuc2V0dGluZ3MuZmlsdGVycywgZnVuY3Rpb24ocnVsZSwgbmFtZSkge1xuXHRcdFx0XHRcdGlmIChmaWxlRmlsdGVyc1tuYW1lXSkge1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaChmdW5jdGlvbihjYikge1xuXHRcdFx0XHRcdFx0XHRmaWxlRmlsdGVyc1tuYW1lXS5jYWxsKHNlbGYsIHJ1bGUsIGZpbGUsIGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdFx0XHRcdGNiKCFyZXMpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHBsdXBsb2FkLmluU2VyaWVzKHF1ZXVlLCBjYik7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQG1ldGhvZCByZXNvbHZlRmlsZVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEBwYXJhbSB7bW94aWUuZmlsZS5GaWxlfG1veGllLmZpbGUuQmxvYnxwbHVwbG9hZC5GaWxlfEZpbGV8QmxvYnxpbnB1dFt0eXBlPVwiZmlsZVwiXX0gZmlsZVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiByZXNvbHZlRmlsZShmaWxlKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gcGx1cGxvYWQudHlwZU9mKGZpbGUpO1xuXG5cdFx0XHRcdC8vIG1veGllLmZpbGUuRmlsZVxuXHRcdFx0XHRpZiAoZmlsZSBpbnN0YW5jZW9mIG8uZmlsZS5GaWxlKSB7XG5cdFx0XHRcdFx0aWYgKCFmaWxlLnJ1aWQgJiYgIWZpbGUuaXNEZXRhY2hlZCgpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXJ1aWQpIHsgLy8gd2VpcmQgY2FzZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmaWxlLnJ1aWQgPSBydWlkO1xuXHRcdFx0XHRcdFx0ZmlsZS5jb25uZWN0UnVudGltZShydWlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzb2x2ZUZpbGUobmV3IHBsdXBsb2FkLkZpbGUoZmlsZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG1veGllLmZpbGUuQmxvYlxuXHRcdFx0XHRlbHNlIGlmIChmaWxlIGluc3RhbmNlb2Ygby5maWxlLkJsb2IpIHtcblx0XHRcdFx0XHRyZXNvbHZlRmlsZShmaWxlLmdldFNvdXJjZSgpKTtcblx0XHRcdFx0XHRmaWxlLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBwbHVwbG9hZC5GaWxlIC0gZmluYWwgc3RlcCBmb3Igb3RoZXIgYnJhbmNoZXNcblx0XHRcdFx0ZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIHBsdXBsb2FkLkZpbGUpIHtcblx0XHRcdFx0XHRpZiAoZmlsZU5hbWUpIHtcblx0XHRcdFx0XHRcdGZpbGUubmFtZSA9IGZpbGVOYW1lO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHF1ZXVlLnB1c2goZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRcdC8vIHJ1biB0aHJvdWdoIHRoZSBpbnRlcm5hbCBhbmQgdXNlci1kZWZpbmVkIGZpbHRlcnMsIGlmIGFueVxuXHRcdFx0XHRcdFx0ZmlsdGVyRmlsZShmaWxlLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBtYWtlIGZpbGVzIGF2YWlsYWJsZSBmb3IgdGhlIGZpbHRlcnMgYnkgdXBkYXRpbmcgdGhlIG1haW4gcXVldWUgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0XHRmaWxlcy5wdXNoKGZpbGUpO1xuXHRcdFx0XHRcdFx0XHRcdC8vIGNvbGxlY3QgdGhlIGZpbGVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gRmlsZXNBZGRlZCBldmVudFxuXHRcdFx0XHRcdFx0XHRcdGZpbGVzQWRkZWQucHVzaChmaWxlKTtcblxuXHRcdFx0XHRcdFx0XHRcdHNlbGYudHJpZ2dlcihcIkZpbGVGaWx0ZXJlZFwiLCBmaWxlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkZWxheShjYiwgMSk7IC8vIGRvIG5vdCBidWlsZCB1cCByZWN1cnNpb25zIG9yIGV2ZW50dWFsbHkgd2UgbWlnaHQgaGl0IHRoZSBsaW1pdHNcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG5hdGl2ZSBGaWxlIG9yIGJsb2Jcblx0XHRcdFx0ZWxzZSBpZiAocGx1cGxvYWQuaW5BcnJheSh0eXBlLCBbJ2ZpbGUnLCAnYmxvYiddKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXNvbHZlRmlsZShuZXcgby5maWxlLkZpbGUobnVsbCwgZmlsZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlucHV0W3R5cGU9XCJmaWxlXCJdXG5cdFx0XHRcdGVsc2UgaWYgKHR5cGUgPT09ICdub2RlJyAmJiBwbHVwbG9hZC50eXBlT2YoZmlsZS5maWxlcykgPT09ICdmaWxlbGlzdCcpIHtcblx0XHRcdFx0XHQvLyBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGlucHV0W3R5cGU9XCJmaWxlXCJdXG5cdFx0XHRcdFx0cGx1cGxvYWQuZWFjaChmaWxlLmZpbGVzLCByZXNvbHZlRmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbWl4ZWQgYXJyYXkgb2YgYW55IHN1cHBvcnRlZCB0eXBlcyAoc2VlIGFib3ZlKVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0ZmlsZU5hbWUgPSBudWxsOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgdW5zZXQgYW55d2F5IHRvIGF2b2lkIGZ1bm55IHNpdHVhdGlvbnNcblx0XHRcdFx0XHRwbHVwbG9hZC5lYWNoKGZpbGUsIHJlc29sdmVGaWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRydWlkID0gZ2V0UlVJRCgpO1xuXG5cdFx0XHRyZXNvbHZlRmlsZShmaWxlKTtcblxuXHRcdFx0aWYgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRwbHVwbG9hZC5pblNlcmllcyhxdWV1ZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gaWYgYW55IGZpbGVzIGxlZnQgYWZ0ZXIgZmlsdHJhdGlvbiwgdHJpZ2dlciBGaWxlc0FkZGVkXG5cdFx0XHRcdFx0aWYgKGZpbGVzQWRkZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoXCJGaWxlc0FkZGVkXCIsIGZpbGVzQWRkZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYSBzcGVjaWZpYyBmaWxlLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCByZW1vdmVGaWxlXG5cdFx0ICogQHBhcmFtIHtwbHVwbG9hZC5GaWxlfFN0cmluZ30gZmlsZSBGaWxlIHRvIHJlbW92ZSBmcm9tIHF1ZXVlLlxuXHRcdCAqL1xuXHRcdHJlbW92ZUZpbGUgOiBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHR2YXIgaWQgPSB0eXBlb2YoZmlsZSkgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUuaWQ7XG5cblx0XHRcdGZvciAodmFyIGkgPSBmaWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoZmlsZXNbaV0uaWQgPT09IGlkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuc3BsaWNlKGksIDEpWzBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcGFydCBvZiB0aGUgcXVldWUgYW5kIHJldHVybnMgdGhlIGZpbGVzIHJlbW92ZWQuIFRoaXMgd2lsbCBhbHNvIHRyaWdnZXIgdGhlIEZpbGVzUmVtb3ZlZCBhbmQgUXVldWVDaGFuZ2VkIGV2ZW50cy5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2Qgc3BsaWNlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IChPcHRpb25hbCkgU3RhcnQgaW5kZXggdG8gcmVtb3ZlIGZyb20uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAoT3B0aW9uYWwpIExlbmdoIG9mIGl0ZW1zIHRvIHJlbW92ZS5cblx0XHQgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZmlsZXMgdGhhdCB3YXMgcmVtb3ZlZC5cblx0XHQgKi9cblx0XHRzcGxpY2UgOiBmdW5jdGlvbihzdGFydCwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBTcGxpY2UgYW5kIHRyaWdnZXIgZXZlbnRzXG5cdFx0XHR2YXIgcmVtb3ZlZCA9IGZpbGVzLnNwbGljZShzdGFydCA9PT0gdW5kZWYgPyAwIDogc3RhcnQsIGxlbmd0aCA9PT0gdW5kZWYgPyBmaWxlcy5sZW5ndGggOiBsZW5ndGgpO1xuXG5cdFx0XHQvLyBpZiB1cGxvYWQgaXMgaW4gcHJvZ3Jlc3Mgd2UgbmVlZCB0byBzdG9wIGl0IGFuZCByZXN0YXJ0IGFmdGVyIGZpbGVzIGFyZSByZW1vdmVkXG5cdFx0XHR2YXIgcmVzdGFydFJlcXVpcmVkID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZSA9PSBwbHVwbG9hZC5TVEFSVEVEKSB7IC8vIHVwbG9hZCBpbiBwcm9ncmVzc1xuXHRcdFx0XHRwbHVwbG9hZC5lYWNoKHJlbW92ZWQsIGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdFx0XHRpZiAoZmlsZS5zdGF0dXMgPT09IHBsdXBsb2FkLlVQTE9BRElORykge1xuXHRcdFx0XHRcdFx0cmVzdGFydFJlcXVpcmVkID0gdHJ1ZTsgLy8gZG8gbm90IHJlc3RhcnQsIHVubGVzcyBmaWxlIHRoYXQgaXMgYmVpbmcgcmVtb3ZlZCBpcyB1cGxvYWRpbmdcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChyZXN0YXJ0UmVxdWlyZWQpIHtcblx0XHRcdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJGaWxlc1JlbW92ZWRcIiwgcmVtb3ZlZCk7XG5cblx0XHRcdC8vIERpc3Bvc2UgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhvc2UgZmlsZXNcblx0XHRcdHBsdXBsb2FkLmVhY2gocmVtb3ZlZCwgZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRmaWxlLmRlc3Ryb3koKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAocmVzdGFydFJlcXVpcmVkKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdERpc3BhdGNoZXMgdGhlIHNwZWNpZmllZCBldmVudCBuYW1lIGFuZCBpdHMgYXJndW1lbnRzIHRvIGFsbCBsaXN0ZW5lcnMuXG5cblx0XHRAbWV0aG9kIHRyaWdnZXJcblx0XHRAcGFyYW0ge1N0cmluZ30gbmFtZSBFdmVudCBuYW1lIHRvIGZpcmUuXG5cdFx0QHBhcmFtIHtPYmplY3QuLn0gTXVsdGlwbGUgYXJndW1lbnRzIHRvIHBhc3MgYWxvbmcgdG8gdGhlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cblx0XHQqL1xuXG5cdFx0Ly8gb3ZlcnJpZGUgdGhlIHBhcmVudCBtZXRob2QgdG8gbWF0Y2ggUGx1cGxvYWQtbGlrZSBldmVudCBsb2dpY1xuXHRcdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBsaXN0LCBhcmdzLCByZXN1bHQ7XG5cblx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGxpc3QgPSB0aGlzLmhhc0V2ZW50TGlzdGVuZXIodHlwZSk7XG5cblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdC8vIHNvcnQgZXZlbnQgbGlzdCBieSBwcmlvcml0eVxuXHRcdFx0XHRsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7IH0pO1xuXG5cdFx0XHRcdC8vIGZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBjdXJyZW50IHBsdXBsb2FkLlVwbG9hZGVyIGluc3RhbmNlXG5cdFx0XHRcdGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRcdGFyZ3Muc2hpZnQoKTtcblx0XHRcdFx0YXJncy51bnNoaWZ0KHRoaXMpO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdC8vIEZpcmUgZXZlbnQsIGJyZWFrIGNoYWluIGlmIGZhbHNlIGlzIHJldHVybmVkXG5cdFx0XHRcdFx0aWYgKGxpc3RbaV0uZm4uYXBwbHkobGlzdFtpXS5zY29wZSwgYXJncykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0Q2hlY2sgd2hldGhlciB1cGxvYWRlciBoYXMgYW55IGxpc3RlbmVycyB0byB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXG5cdFx0QG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXG5cdFx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgRXZlbnQgbmFtZSB0byBjaGVjayBmb3IuXG5cdFx0Ki9cblxuXG5cdFx0LyoqXG5cdFx0QWRkcyBhbiBldmVudCBsaXN0ZW5lciBieSBuYW1lLlxuXG5cdFx0QG1ldGhvZCBiaW5kXG5cdFx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgRXZlbnQgbmFtZSB0byBsaXN0ZW4gZm9yLlxuXHRcdEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgb25lcyB0aGUgZXZlbnQgZ2V0cyBmaXJlZC5cblx0XHRAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBPcHRpb25hbCBzY29wZSB0byBleGVjdXRlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gaW4uXG5cdFx0QHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT0wXSBQcmlvcml0eSBvZiB0aGUgZXZlbnQgaGFuZGxlciAtIGhhbmRsZXJzIHdpdGggaGlnaGVyIHByaW9yaXRpZXMgd2lsbCBiZSBjYWxsZWQgZmlyc3Rcblx0XHQqL1xuXHRcdGJpbmQ6IGZ1bmN0aW9uKG5hbWUsIGZuLCBzY29wZSwgcHJpb3JpdHkpIHtcblx0XHRcdC8vIGFkYXB0IG1veGllIEV2ZW50VGFyZ2V0IHN0eWxlIHRvIFBsdXBsb2FkLWxpa2Vcblx0XHRcdHBsdXBsb2FkLlVwbG9hZGVyLnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcywgbmFtZSwgZm4sIHByaW9yaXR5LCBzY29wZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdFJlbW92ZXMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci5cblxuXHRcdEBtZXRob2QgdW5iaW5kXG5cdFx0QHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiBldmVudCB0byByZW1vdmUuXG5cdFx0QHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gbGlzdGVuZXIuXG5cdFx0Ki9cblxuXHRcdC8qKlxuXHRcdFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycy5cblxuXHRcdEBtZXRob2QgdW5iaW5kQWxsXG5cdFx0Ki9cblxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveXMgUGx1cGxvYWQgaW5zdGFuY2UgYW5kIGNsZWFucyBhZnRlciBpdHNlbGYuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0XHQgKi9cblx0XHRkZXN0cm95IDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ0Rlc3Ryb3knKTtcblx0XHRcdHNldHRpbmdzID0gdG90YWwgPSBudWxsOyAvLyBwdXJnZSB0aGVzZSBleGNsdXNpdmVseVxuXHRcdFx0dGhpcy51bmJpbmRBbGwoKTtcblx0XHR9XG5cdH0pO1xufTtcblxucGx1cGxvYWQuVXBsb2FkZXIucHJvdG90eXBlID0gby5jb3JlLkV2ZW50VGFyZ2V0Lmluc3RhbmNlO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgZmlsZSBpbnN0YW5jZS5cbiAqXG4gKiBAY2xhc3MgRmlsZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbGUgT2JqZWN0IGNvbnRhaW5pbmcgZmlsZSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZS5uYW1lIE5hbWUgb2YgdGhlIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gZmlsZS5zaXplIEZpbGUgc2l6ZS5cbiAqL1xucGx1cGxvYWQuRmlsZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIGZpbGVwb29sID0ge307XG5cblx0ZnVuY3Rpb24gUGx1cGxvYWRGaWxlKGZpbGUpIHtcblxuXHRcdHBsdXBsb2FkLmV4dGVuZCh0aGlzLCB7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRmlsZSBpZCB0aGlzIGlzIGEgZ2xvYmFsbHkgdW5pcXVlIGlkIGZvciB0aGUgc3BlY2lmaWMgZmlsZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgaWRcblx0XHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRpZDogcGx1cGxvYWQuZ3VpZCgpLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEZpbGUgbmFtZSBmb3IgZXhhbXBsZSBcIm15ZmlsZS5naWZcIi5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgbmFtZVxuXHRcdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdG5hbWU6IGZpbGUubmFtZSB8fCBmaWxlLmZpbGVOYW1lLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEZpbGUgdHlwZSwgYGUuZyBpbWFnZS9qcGVnYFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0dHlwZTogZmlsZS50eXBlIHx8ICcnLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEZpbGUgc2l6ZSBpbiBieXRlcyAobWF5IGNoYW5nZSBhZnRlciBjbGllbnQtc2lkZSBtYW51cGlsYXRpb24pLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwcm9wZXJ0eSBzaXplXG5cdFx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHRcdCAqL1xuXHRcdFx0c2l6ZTogZmlsZS5zaXplIHx8IGZpbGUuZmlsZVNpemUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogT3JpZ2luYWwgZmlsZSBzaXplIGluIGJ5dGVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwcm9wZXJ0eSBvcmlnU2l6ZVxuXHRcdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0XHQgKi9cblx0XHRcdG9yaWdTaXplOiBmaWxlLnNpemUgfHwgZmlsZS5maWxlU2l6ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBOdW1iZXIgb2YgYnl0ZXMgdXBsb2FkZWQgb2YgdGhlIGZpbGVzIHRvdGFsIHNpemUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHByb3BlcnR5IGxvYWRlZFxuXHRcdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0XHQgKi9cblx0XHRcdGxvYWRlZDogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBOdW1iZXIgb2YgcGVyY2VudGFnZSB1cGxvYWRlZCBvZiB0aGUgZmlsZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgcGVyY2VudFxuXHRcdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0XHQgKi9cblx0XHRcdHBlcmNlbnQ6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3RhdHVzIGNvbnN0YW50IG1hdGNoaW5nIHRoZSBwbHVwbG9hZCBzdGF0ZXMgUVVFVUVELCBVUExPQURJTkcsIEZBSUxFRCwgRE9ORS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgc3RhdHVzXG5cdFx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHRcdCAqIEBzZWUgcGx1cGxvYWRcblx0XHRcdCAqL1xuXHRcdFx0c3RhdHVzOiBwbHVwbG9hZC5RVUVVRUQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRGF0ZSBvZiBsYXN0IG1vZGlmaWNhdGlvbi5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcHJvcGVydHkgbGFzdE1vZGlmaWVkRGF0ZVxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0bGFzdE1vZGlmaWVkRGF0ZTogZmlsZS5sYXN0TW9kaWZpZWREYXRlIHx8IChuZXcgRGF0ZSgpKS50b0xvY2FsZVN0cmluZygpLCAvLyBUaHUgQXVnIDIzIDIwMTIgMTk6NDA6MDAgR01UKzA0MDAgKEdFVClcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB3aGVuIGZpbGUgYmVjb21lcyBwbHVwbG9hZC5ET05FIG9yIHBsdXBsb2FkLkZBSUxFRC4gSXMgdXNlZCB0byBjYWxjdWxhdGUgcHJvcGVyIHBsdXBsb2FkLlF1ZXVlUHJvZ3Jlc3MuYnl0ZXNQZXJTZWMuXG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHByb3BlcnR5IGNvbXBsZXRlVGltZXN0YW1wXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdFx0XHRjb21wbGV0ZVRpbWVzdGFtcDogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIG5hdGl2ZSB3aW5kb3cuRmlsZSBvYmplY3QsIHdoZW4gaXQncyBhdmFpbGFibGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBnZXROYXRpdmVcblx0XHRcdCAqIEByZXR1cm4ge3dpbmRvdy5GaWxlfSBvciBudWxsLCBpZiBwbHVwbG9hZC5GaWxlIGlzIG9mIGRpZmZlcmVudCBvcmlnaW5cblx0XHRcdCAqL1xuXHRcdFx0Z2V0TmF0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGZpbGUgPSB0aGlzLmdldFNvdXJjZSgpLmdldFNvdXJjZSgpO1xuXHRcdFx0XHRyZXR1cm4gcGx1cGxvYWQuaW5BcnJheShwbHVwbG9hZC50eXBlT2YoZmlsZSksIFsnYmxvYicsICdmaWxlJ10pICE9PSAtMSA/IGZpbGUgOiBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIG1PeGllLkZpbGUgLSB1bmlmaWVkIHdyYXBwZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYWNyb3NzIHJ1bnRpbWVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZXRob2QgZ2V0U291cmNlXG5cdFx0XHQgKiBAcmV0dXJuIHttT3hpZS5GaWxlfSBvciBudWxsXG5cdFx0XHQgKi9cblx0XHRcdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghZmlsZXBvb2xbdGhpcy5pZF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmlsZXBvb2xbdGhpcy5pZF07XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIERlc3Ryb3lzIHBsdXBsb2FkLkZpbGUgb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZXRob2QgZGVzdHJveVxuXHRcdFx0ICovXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMuZ2V0U291cmNlKCk7XG5cdFx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0XHRzcmMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdGRlbGV0ZSBmaWxlcG9vbFt0aGlzLmlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZmlsZXBvb2xbdGhpcy5pZF0gPSBmaWxlO1xuXHR9XG5cblx0cmV0dXJuIFBsdXBsb2FkRmlsZTtcbn0oKSk7XG5cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcXVldWUgcHJvZ3Jlc3MuXG4gKlxuICogQGNsYXNzIFF1ZXVlUHJvZ3Jlc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG4gcGx1cGxvYWQuUXVldWVQcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7IC8vIFNldHVwIGFsaWFzIGZvciBzZWxmIHRvIHJlZHVjZSBjb2RlIHNpemUgd2hlbiBpdCdzIGNvbXByZXNzZWRcblxuXHQvKipcblx0ICogVG90YWwgcXVldWUgZmlsZSBzaXplLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgc2l6ZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdHNlbGYuc2l6ZSA9IDA7XG5cblx0LyoqXG5cdCAqIFRvdGFsIGJ5dGVzIHVwbG9hZGVkLlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgbG9hZGVkXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0c2VsZi5sb2FkZWQgPSAwO1xuXG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgZmlsZXMgdXBsb2FkZWQuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSB1cGxvYWRlZFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdHNlbGYudXBsb2FkZWQgPSAwO1xuXG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgZmlsZXMgZmFpbGVkIHRvIHVwbG9hZC5cblx0ICpcblx0ICogQHByb3BlcnR5IGZhaWxlZFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdHNlbGYuZmFpbGVkID0gMDtcblxuXHQvKipcblx0ICogTnVtYmVyIG9mIGZpbGVzIHlldCB0byBiZSB1cGxvYWRlZC5cblx0ICpcblx0ICogQHByb3BlcnR5IHF1ZXVlZFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdHNlbGYucXVldWVkID0gMDtcblxuXHQvKipcblx0ICogVG90YWwgcGVyY2VudCBvZiB0aGUgdXBsb2FkZWQgYnl0ZXMuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBwZXJjZW50XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0c2VsZi5wZXJjZW50ID0gMDtcblxuXHQvKipcblx0ICogQnl0ZXMgdXBsb2FkZWQgcGVyIHNlY29uZC5cblx0ICpcblx0ICogQHByb3BlcnR5IGJ5dGVzUGVyU2VjXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0c2VsZi5ieXRlc1BlclNlYyA9IDA7XG5cblx0LyoqXG5cdCAqIFJlc2V0cyB0aGUgcHJvZ3Jlc3MgdG8gaXRzIGluaXRpYWwgdmFsdWVzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqL1xuXHRzZWxmLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0c2VsZi5zaXplID0gc2VsZi5sb2FkZWQgPSBzZWxmLnVwbG9hZGVkID0gc2VsZi5mYWlsZWQgPSBzZWxmLnF1ZXVlZCA9IHNlbGYucGVyY2VudCA9IHNlbGYuYnl0ZXNQZXJTZWMgPSAwO1xuXHR9O1xufTtcblxuZXhwb3J0cy5wbHVwbG9hZCA9IHBsdXBsb2FkO1xuXG59KHRoaXMsIG1veGllKSk7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wbHVwbG9hZC9wbHVwbG9hZC5kZXYuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBxaW5pdS1qcy1zZGsgdkBWRVJTSU9OXG4gKlxuICogQ29weXJpZ2h0IDIwMTUgYnkgUWluaXVcbiAqIFJlbGVhc2VkIHVuZGVyIEdQTCBWMiBMaWNlbnNlLlxuICpcbiAqIEdpdEh1YjogaHR0cDovL2dpdGh1Yi5jb20vcWluaXUvanMtc2RrXG4gKlxuICogRGF0ZTogQERBVEVcbiAqL1xuXG4vKmdsb2JhbCBwbHVwbG9hZCAsbW94aWUqL1xuLypnbG9iYWwgQWN0aXZlWE9iamVjdCAqL1xuLypleHBvcnRlZCBRaW5pdSAqL1xuLypleHBvcnRlZCBRaW5pdUpzU0RLICovXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCkge1xuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjb29raWUgb3IgcmVtb3ZlcyBjb29raWUgd2l0aCBuZWdhdGl2ZSBleHBpcmF0aW9uXG4gICAgICogQHBhcmFtICBrZXkgICAgICAgVGhlIGtleSBvciBpZGVudGlmaWVyIGZvciB0aGUgc3RvcmVcbiAgICAgKiBAcGFyYW0gIHZhbHVlICAgICBDb250ZW50cyBvZiB0aGUgc3RvcmVcbiAgICAgKiBAcGFyYW0gIGV4cCAgICAgICBFeHBpcmF0aW9uIC0gY3JlYXRpb24gZGVmYXVsdHMgdG8gMzAgZGF5c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvb2tpZShrZXksIHZhbHVlLCBleHApIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZXhwICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICB2YXIgZXhwaXJlcyA9IFwiOyBleHBpcmVzPVwiICsgZGF0ZS50b0dNVFN0cmluZygpO1xuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBrZXkgKyBcIj1cIiArIHZhbHVlICsgZXhwaXJlcyArIFwiOyBwYXRoPS9cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRlbnRzIG9mIGNvb2tpZVxuICAgICAqIEBwYXJhbSAga2V5ICAgICAgIFRoZSBrZXkgb3IgaWRlbnRpZmllciBmb3IgdGhlIHN0b3JlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZENvb2tpZShrZXkpIHtcbiAgICAgICAgdmFyIG5hbWVFUSA9IGtleSArIFwiPVwiO1xuICAgICAgICB2YXIgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGNhLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBpZiBjdXJyZW50IGJyb3dzZXIgaXMgbm90IHN1cHBvcnQgbG9jYWxTdG9yYWdlXG4gICAgLy8gdXNlIGNvb2tpZSB0byBtYWtlIGEgcG9seWZpbGxcbiAgICBpZiAoIXdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZSA9IHtcbiAgICAgICAgICAgIHNldEl0ZW06IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ29va2llKGtleSwgdmFsdWUsIDMwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoa2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ29va2llKGtleSwgJycsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBRaW5pdUpzU0RLKCkge1xuICAgICAgICB2YXIgbW94aWUgPSByZXF1aXJlKCcuL3BsdXBsb2FkL21veGllJyk7XG4gICAgICAgIHdpbmRvdy5tb3hpZSA9IG1veGllO1xuICAgICAgICB2YXIgcGx1cGxvYWQgPSByZXF1aXJlKCcuL3BsdXBsb2FkL3BsdXBsb2FkLmRldicpO1xuICAgICAgICB3aW5kb3cucGx1cGxvYWQgPSBwbHVwbG9hZDtcblxuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZWN0IElFIHZlcnNpb25cbiAgICAgICAgICogaWYgY3VycmVudCBicm93c2VyIGlzIG5vdCBJRVxuICAgICAgICAgKiAgICAgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgICAgICAgICogZWxzZVxuICAgICAgICAgKiAgICAgaXQgd2lsbCByZXR1cm4gdmVyc2lvbiBvZiBjdXJyZW50IElFIGJyb3dzZXJcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfEJvb2xlYW59IElFIHZlcnNpb24gb3IgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGV0ZWN0SUVWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHYgPSA0LFxuICAgICAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpO1xuICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPCEtLVtpZiBndCBJRSAnICsgdiArICddPjxpPjwvaT48IVtlbmRpZl0tLT4nLFxuICAgICAgICAgICAgICAgICAgICBhbGxbMF1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdiA+IDQgPyB2IDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IHtcbiAgICAgICAgICAgIE1VVEU6IDAsXG4gICAgICAgICAgICBGQVRBOiAxLFxuICAgICAgICAgICAgRVJST1I6IDIsXG4gICAgICAgICAgICBXQVJOOiAzLFxuICAgICAgICAgICAgSU5GTzogNCxcbiAgICAgICAgICAgIERFQlVHOiA1LFxuICAgICAgICAgICAgVFJBQ0U6IDYsXG4gICAgICAgICAgICBsZXZlbDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZyh0eXBlLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gXCJbcWluaXUtanMtc2RrXVtcIiArIHR5cGUgKyBcIl1cIjtcbiAgICAgICAgICAgIHZhciBtc2cgPSBoZWFkZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiIFwiICsgYXJnc1tpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gXCIgXCIgKyB0aGF0LnN0cmluZ2lmeUpTT04oYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoYXQuZGV0ZWN0SUVWZXJzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1Mzg5NzIvY29uc29sZS1sb2ctYXBwbHktbm90LXdvcmtpbmctaW4taWU5XG4gICAgICAgICAgICAgICAgLy92YXIgbG9nID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gICAgICAgICAgICAgICAgLy9sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KGhlYWRlcik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Fpbml1LWpzLXNkay1sb2cnKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxaW5pdS1qcy1zZGstbG9nJykuaW5uZXJIVE1MICs9ICc8cD4nICsgbXNnICsgJzwvcD4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZUxvZ0Z1bmMoY29kZSkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBjb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBsb2dnZXJbZnVuY10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9nZ2VyW2Z1bmNdLmhpc3RvcnkgPSBsb2dnZXJbZnVuY10uaGlzdG9yeSB8fCBbXTtcbiAgICAgICAgICAgICAgICAvLyBsb2dnZXJbZnVuY10uaGlzdG9yeS5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZyAmJiBsb2dnZXIubGV2ZWwgPj0gbG9nZ2VyW2NvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nKGZ1bmMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBsb2dnZXIpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmICh0eXBlb2YgbG9nZ2VyW3Byb3BlcnR5XSkgPT09IFwibnVtYmVyXCIgJiYgIWxvZ2dlci5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIG1ha2VMb2dGdW5jKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIHFpbml1VXBsb2FkVXJsO1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgcWluaXVVcGxvYWRVcmwgPSAnaHR0cHM6Ly91cGxvYWQucWluaXVwLmNvbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxaW5pdVVwbG9hZFVybCA9ICdodHRwOi8vdXBsb2FkLnFpbml1cC5jb20nO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHFpbml1IHVwbG9hZCB1cmxzXG4gICAgICAgICAqICdxaW5pdVVwbG9hZFVybHMnIGlzIHVzZWQgdG8gY2hhbmdlIHRhcmdldCB3aGVuIGN1cnJlbnQgdXJsIGlzIG5vdCBhdmFsaWFibGVcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHFpbml1VXBsb2FkVXJscyA9IFtcbiAgICAgICAgICAgIFwiaHR0cDovL3VwbG9hZC5xaW5pdXAuY29tXCIsXG4gICAgICAgICAgICBcImh0dHA6Ly91cC5xaW5pdXAuY29tXCJcbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgcWluaXVVcEhvc3RzID0ge1xuICAgICAgICAgICAgXCJodHRwXCI6IFtcbiAgICAgICAgICAgICAgICBcImh0dHA6Ly91cGxvYWQucWluaXVwLmNvbVwiLFxuICAgICAgICAgICAgICAgIFwiaHR0cDovL3VwLnFpbml1cC5jb21cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiaHR0cHNcIjogW1xuICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly91cGxvYWQucWluaXVwLmNvbVwiXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNoYW5nZVVybFRpbWVzID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmVzZXQgdXBsb2FkIHVybFxuICAgICAgICAgKiBpZiBjdXJyZW50IHBhZ2UgcHJvdG9jYWwgaXMgaHR0cHNcbiAgICAgICAgICogICAgIGl0IHdpbGwgYWx3YXlzIHJldHVybiAnaHR0cHM6Ly91cC5xYm94Lm1lJ1xuICAgICAgICAgKiBlbHNlXG4gICAgICAgICAqICAgICBpdCB3aWxsIHNldCAncWluaXVVcGxvYWRVcmwnIHZhbHVlIHdpdGggJ3Fpbml1VXBsb2FkVXJscycgbG9vcGx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkVXJsID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdudW06ICcgKyBudW0pO1xuICAgICAgICAgICAgaWYoIG51bSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwidXNlIG1haW4gdXBob3N0XCIpO1xuICAgICAgICAgICAgICAgIHZhciBob3N0cyA9IHFpbml1VXBIb3N0cy5tYWluO1xuICAgICAgICAgICAgICAgIHFpbml1VXBsb2FkVXJsID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/IFwiaHR0cHM6Ly9cIiArIGhvc3RzWzBdIDogXCJodHRwOi8vXCIgKyBob3N0c1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwidXNlIGJhY2t1cCB1cGhvc3RcIik7XG4gICAgICAgICAgICAgICAgdmFyIGhvc3RzID0gcWluaXVVcEhvc3RzLmJhY2t1cDtcbiAgICAgICAgICAgICAgICBpZiggbnVtICUgMiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpbml1VXBsb2FkVXJsID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/IFwiaHR0cHM6Ly9cIiArIGhvc3RzWzFdIDogXCJodHRwOi8vXCIgKyBob3N0c1sxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxaW5pdVVwbG9hZFVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBcImh0dHBzOi8vXCIgKyBob3N0c1swXSA6IFwiaHR0cDovL1wiICsgaG9zdHNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9xaW5pdVVwbG9hZFVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBcImh0dHBzOi8vXCIgKyBob3N0c1swXSA6IFwiaHR0cDovL1wiICsgaG9zdHNbMF07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc2V0VXBsb2FkVXJsOiAnICsgcWluaXVVcGxvYWRVcmwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0aGlzLnJlc2V0VXBsb2FkVXJsKCk7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogaXMgaW1hZ2VcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSAgdXJsIG9mIGEgZmlsZVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmaWxlIGlzIGEgaW1hZ2Ugb3Igbm90XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzSW1hZ2UgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwuc3BsaXQoL1s/I10vKVswXTtcbiAgICAgICAgICAgIHJldHVybiAoL1xcLihwbmd8anBnfGpwZWd8Z2lmfGJtcCkkL2kpLnRlc3QodXJsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGZpbGUgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZW5hbWVcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgaW5wdXQ6IHRlc3QudHh0XG4gICAgICAgICAqICAgICBvdXRwdXQ6IHR4dFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdGVtcEFyciA9IGZpbGVuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIHZhciBleHQ7XG4gICAgICAgICAgICBpZiAodGVtcEFyci5sZW5ndGggPT09IDEgfHwgKHRlbXBBcnJbMF0gPT09IFwiXCIgJiYgdGVtcEFyci5sZW5ndGggPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ID0gdGVtcEFyci5wb3AoKS50b0xvd2VyQ2FzZSgpOyAvL2dldCB0aGUgZXh0ZW5zaW9uIGFuZCBtYWtlIGl0IGxvd2VyLWNhc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVuY29kZSBzdHJpbmcgYnkgdXRmOFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dGY4X2VuY29kZSA9IGZ1bmN0aW9uIChhcmdTdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gICAgICAgICAgICAvLyArICAgb3JpZ2luYWwgYnk6IFdlYnRvb2xraXQuaW5mbyAoaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm8vKVxuICAgICAgICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgICAgICAgIC8vICsgICBpbXByb3ZlZCBieTogc293YmVycnlcbiAgICAgICAgICAgIC8vICsgICAgdHdlYWtlZCBieTogSmFja1xuICAgICAgICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgICAgICAgICAgIC8vICsgICBpbXByb3ZlZCBieTogWXZlcyBTdWNhZXRcbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gICAgICAgICAgICAvLyArICAgYnVnZml4ZWQgYnk6IFVscmljaFxuICAgICAgICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBSYWZhbCBLdWthd3NraVxuICAgICAgICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBraXJpbGxvaWRcbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieToga2lyaWxsb2lkXG4gICAgICAgICAgICAvLyAqICAgICBleGFtcGxlIDE6IHRoaXMudXRmOF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgICAgICAgICAgIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG5cbiAgICAgICAgICAgIGlmIChhcmdTdHJpbmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZ1N0cmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSAoYXJnU3RyaW5nICsgJycpOyAvLyAucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHV0ZnRleHQgPSAnJyxcbiAgICAgICAgICAgICAgICBzdGFydCwgZW5kLCBzdHJpbmdsID0gMDtcblxuICAgICAgICAgICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgICAgICAgICAgc3RyaW5nbCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHN0cmluZ2w7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgICAgICAgICAgICAgIHZhciBlbmMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYzEgPiAxMjcgJiYgYzEgPCAyMDQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAoYzEgPj4gNikgfCAxOTIsIChjMSAmIDYzKSB8IDEyOFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYzEgJiAweEY4MDAgXiAweEQ4MDAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAoYzEgPj4gMTIpIHwgMjI0LCAoKGMxID4+IDYpICYgNjMpIHwgMTI4LCAoYzEgJiA2MykgfCAxMjhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBzdXJyb2dhdGUgcGFpcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMxICYgMHhGQzAwIF4gMHhEODAwID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VubWF0Y2hlZCB0cmFpbCBzdXJyb2dhdGUgYXQgJyArIG4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHN0cmluZy5jaGFyQ29kZUF0KCsrbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjMiAmIDB4RkMwMCBeIDB4REMwMCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdVbm1hdGNoZWQgbGVhZCBzdXJyb2dhdGUgYXQgJyArIChuIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMxID0gKChjMSAmIDB4M0ZGKSA8PCAxMCkgKyAoYzIgJiAweDNGRikgKyAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGMxID4+IDE4KSB8IDI0MCwgKChjMSA+PiAxMikgJiA2MykgfCAxMjgsICgoYzEgPj4gNikgJiA2MykgfCAxMjgsIChjMSAmIDYzKSB8IDEyOFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5jICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gbiArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zbGljZShzdGFydCwgc3RyaW5nbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGZ0ZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmFzZTY0X2RlY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgICAgICAgICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuICAgICAgICAgICAgLy8gKyAgICAgIGlucHV0IGJ5OiBBbWFuIEd1cHRhXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgICAgICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgICAgICAgIC8vICsgICAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgICAgICAgICAgIC8vICsgICBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAgICAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9kZWNvZGUoJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nKTtcbiAgICAgICAgICAgIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG4gICAgICAgICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydhdG9iJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICAgICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICAgICAgICAgIGFjID0gMCxcbiAgICAgICAgICAgICAgICBkZWMgPSBcIlwiLFxuICAgICAgICAgICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgKz0gJyc7XG5cbiAgICAgICAgICAgIGRvIHsgLy8gdW5wYWNrIGZvdXIgaGV4ZXRzIGludG8gdGhyZWUgb2N0ZXRzIHVzaW5nIGluZGV4IHBvaW50cyBpbiBiNjRcbiAgICAgICAgICAgICAgICBoMSA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgICAgIGgyID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgICAgICAgICAgaDMgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgICAgICBoNCA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXG4gICAgICAgICAgICAgICAgYml0cyA9IGgxIDw8IDE4IHwgaDIgPDwgMTIgfCBoMyA8PCA2IHwgaDQ7XG5cbiAgICAgICAgICAgICAgICBvMSA9IGJpdHMgPj4gMTYgJiAweGZmO1xuICAgICAgICAgICAgICAgIG8yID0gYml0cyA+PiA4ICYgMHhmZjtcbiAgICAgICAgICAgICAgICBvMyA9IGJpdHMgJiAweGZmO1xuXG4gICAgICAgICAgICAgICAgaWYgKGgzID09PSA2NCkge1xuICAgICAgICAgICAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoNCA9PT0gNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIsIG8zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgICAgICAgICBkZWMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVjO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbmNvZGUgZGF0YSBieSBiYXNlNjRcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBkYXRhIHRvIGVuY29kZVxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlNjRfZW5jb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gICAgICAgICAgICAvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcbiAgICAgICAgICAgIC8vICsgICBpbXByb3ZlZCBieTogQmF5cm9uIEd1ZXZhcmFcbiAgICAgICAgICAgIC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBQZWxsZW50ZXNxdWUgTWFsZXN1YWRhXG4gICAgICAgICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgICAgICAgLy8gLSAgICBkZXBlbmRzIG9uOiB0aGlzLnV0ZjhfZW5jb2RlXG4gICAgICAgICAgICAvLyAqICAgICBleGFtcGxlIDE6IHRoaXMuYmFzZTY0X2VuY29kZSgnS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAgICAgICAgICAgLy8gKiAgICAgcmV0dXJucyAxOiAnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PSdcbiAgICAgICAgICAgIC8vIG1vemlsbGEgaGFzIHRoaXMgbmF0aXZlXG4gICAgICAgICAgICAvLyAtIGJ1dCBicmVha3MgaW4gMi4wLjAuMTIhXG4gICAgICAgICAgICAvL2lmICh0eXBlb2YgdGhpcy53aW5kb3dbJ2F0b2InXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gYXRvYihkYXRhKTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgdmFyIGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgICAgICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICAgICAgICAgIGFjID0gMCxcbiAgICAgICAgICAgICAgICBlbmMgPSAnJyxcbiAgICAgICAgICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhID0gdGhpcy51dGY4X2VuY29kZShkYXRhICsgJycpO1xuXG4gICAgICAgICAgICBkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcbiAgICAgICAgICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgIG8yID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICAgICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICAgICAgICAgIGgxID0gYml0cyA+PiAxOCAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgaDIgPSBiaXRzID4+IDEyICYgMHgzZjtcbiAgICAgICAgICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgaDQgPSBiaXRzICYgMHgzZjtcblxuICAgICAgICAgICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgICAgICAgICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgICAgICAgICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgICAgICAgICAgc3dpdGNoIChkYXRhLmxlbmd0aCAlIDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMikgKyAnPT0nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMSkgKyAnPSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbmNvZGUgc3RyaW5nIGluIHVybCBieSBiYXNlNjRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiB1cmxcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5VUkxTYWZlQmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmJhc2U2NF9lbmNvZGUodik7XG4gICAgICAgICAgICByZXR1cm4gdi5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXCsvZywgJy0nKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLlVSTFNhZmVCYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdiA9IHYucmVwbGFjZSgvXy9nLCAnLycpLnJlcGxhY2UoLy0vZywgJysnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2U2NF9kZWNvZGUodik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVE9ETzogdXNlIG1PeGllXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjcmFldGUgb2JqZWN0IHVzZWQgdG8gQUpBWFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUFqYXggPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHZhciB4bWxodHRwID0ge307XG4gICAgICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWxodHRwID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4bWxodHRwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRPRE86IGVuaGFuY2UgSUUgY29tcGF0aWJpbGl0eVxuICAgICAgICAvKipcbiAgICAgICAgICogcGFyc2UganNvbiBzdHJpbmcgdG8gamF2YXNjcmlwdCBvYmplY3RcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBqc29uIHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJzZUpTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gICAgICAgICAgICBpZiAod2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LkpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdmFyIHJ4X29uZSA9IC9eW1xcXSw6e31cXHNdKiQvLFxuICAgICAgICAgICAgLy8gICAgcnhfdHdvID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZyxcbiAgICAgICAgICAgIC8vICAgIHJ4X3RocmVlID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLFxuICAgICAgICAgICAgLy8gICAgcnhfZm91ciA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxcbiAgICAgICAgICAgIHZhciByeF9kYW5nZXJvdXMgPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcblxuICAgICAgICAgICAgLy92YXIganNvbjtcblxuICAgICAgICAgICAgdmFyIHRleHQgPSBTdHJpbmcoZGF0YSk7XG4gICAgICAgICAgICByeF9kYW5nZXJvdXMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChyeF9kYW5nZXJvdXMudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocnhfZGFuZ2Vyb3VzLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRvZG8g5L2/55So5LiA5LiL5Yik5patLOWinuWKoOWuieWFqOaAp1xuICAgICAgICAgICAgLy9pZiAoXG4gICAgICAgICAgICAvLyAgICByeF9vbmUudGVzdChcbiAgICAgICAgICAgIC8vICAgICAgICB0ZXh0XG4gICAgICAgICAgICAvLyAgICAgICAgICAgIC5yZXBsYWNlKHJ4X3R3bywgJ0AnKVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAucmVwbGFjZShyeF90aHJlZSwgJ10nKVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAucmVwbGFjZShyeF9mb3VyLCAnJylcbiAgICAgICAgICAgIC8vICAgIClcbiAgICAgICAgICAgIC8vKSB7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gZXZhbCgnKCcgKyB0ZXh0ICsgJyknKTtcbiAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZhbCgnKCcgKyB0ZXh0ICsgJyknKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcGFyc2UgamF2YXNjcmlwdCBvYmplY3QgdG8ganNvbiBzdHJpbmdcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBqc29uIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHJpbmdpZnlKU09OID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gICAgICAgICAgICBpZiAod2luZG93LkpTT04gJiYgd2luZG93LkpTT04uc3RyaW5naWZ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5KU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgKG9iaikpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJyArIG9iai5yZXBsYWNlKC8oW1wiXFxcXF0pL2csICdcXFxcJDEnKSArICdcIic7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1snICsgb2JqLm1hcCh0aGF0LnN0cmluZ2lmeUpTT04pLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJBcnIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ckFyci5wdXNoKHRoYXQuc3RyaW5naWZ5SlNPTihvYmpbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnWycgKyBzdHJBcnIuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKHRoYXQuc3RyaW5naWZ5SlNPTihwcm9wZXJ0eSkgKyAnOicgKyB0aGF0LnN0cmluZ2lmeUpTT04ob2JqW3Byb3BlcnR5XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneycgKyBzdHJpbmcuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHJpbSBzcGFjZSBiZXNpZGUgdGV4dFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVudHJpbWVkIHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyaW1lZCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpbSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCA9PT0gbnVsbCA/IFwiXCIgOiB0ZXh0LnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY3JlYXRlIGEgdXBsb2FkZXIgYnkgUWluaXVKc1NES1xuICAgICAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZGVyXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gdXBsb2FkZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBsb2FkZXIgPSBmdW5jdGlvbiAob3ApIHtcblxuICAgICAgICAgICAgLyoqKioqKioqKiogaW5uZXIgZnVuY3Rpb24gZGVmaW5lIHN0YXJ0ICoqKioqKioqKiovXG5cbiAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdGhlIGRpZmZlcmVudCBjb25kaXRpb24gdG8gcmVzZXQgY2h1bmsgc2l6ZVxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgdXBsb2FkIHN0cmF0ZWd5IGFjY29yZGluZyB3aXRoIHRoZSBjaHVuayBzaXplXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjaHVuayBzaXplIGlzIHplcm8gd2lsbCBjYXVzZSB0byBkaXJlY3QgdXBsb2FkXG4gICAgICAgICAgICAgICAgLy8gc2VlIHRoZSBzdGF0ZW1lbnQgYmluZGVkIG9uICdCZWZvcmVVcGxvYWQnIGV2ZW50XG4gICAgICAgICAgICB2YXIgcmVzZXRfY2h1bmtfc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGllID0gdGhhdC5kZXRlY3RJRVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEJMT0NLX0JJVFMsIE1BWF9DSFVOS19TSVpFLCBjaHVua19zaXplO1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIFNhZmFyaSA144CBV2luZG93cyA344CBaU9TIDcgc2V0IGlzU3BlY2lhbFNhZmFyaSB0byB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1NwZWNpYWxTYWZhcmkgPSAobW94aWUuY29yZS51dGlscy5FbnYuYnJvd3NlciA9PT0gXCJTYWZhcmlcIiAmJiBtb3hpZS5jb3JlLnV0aWxzLkVudi52ZXJzaW9uIDw9IDUgJiYgbW94aWUuY29yZS51dGlscy5FbnYub3MgPT09IFwiV2luZG93c1wiICYmIG1veGllLmNvcmUudXRpbHMuRW52Lm9zVmVyc2lvbiA9PT0gXCI3XCIpIHx8IChtb3hpZS5jb3JlLnV0aWxzLkVudi5icm93c2VyID09PSBcIlNhZmFyaVwiICYmIG1veGllLmNvcmUudXRpbHMuRW52Lm9zID09PSBcImlPU1wiICYmIG1veGllLmNvcmUudXRpbHMuRW52Lm9zVmVyc2lvbiA9PT0gXCI3XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIElFIDkt77yMY2h1bmtfc2l6ZSBpcyBub3QgZW1wdHkgYW5kIGZsYXNoIGlzIGluY2x1ZGVkIGluIHJ1bnRpbWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBvcC5jaHVua19zaXplIHRvIHplcm9cbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoaWUgJiYgaWUgPCA5ICYmIG9wLmNodW5rX3NpemUgJiYgb3AucnVudGltZXMuaW5kZXhPZignZmxhc2gnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZSA8IDkgJiYgb3AuY2h1bmtfc2l6ZSAmJiBvcC5ydW50aW1lcy5pbmRleE9mKCdmbGFzaCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBsaW5rOiBodHRwOi8vd3d3LnBsdXBsb2FkLmNvbS9kb2NzL0ZyZXF1ZW50bHktQXNrZWQtUXVlc3Rpb25zI3doZW4tdG8tdXNlLWNodW5raW5nLWFuZC13aGVuLW5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdoZW4gcGx1cGxvYWQgY2h1bmtfc2l6ZSBzZXR0aW5nIGlzJ3QgbnVsbCAsaXQgY2F1c2UgYnVnIGluIGllOC85ICB3aGljaCBydW5zICBmbGFzaCBydW50aW1lcyAobm90IHN1cHBvcnQgaHRtbDUpIC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLmNodW5rX3NpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbFNhZmFyaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2luNyBzYWZhcmkgLyBpT1M3IHNhZmFyaSBoYXZlIGJ1ZyB3aGVuIGluIGNodW5rIHVwbG9hZCBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBjaHVua19zaXplIHRvIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgY2h1bmsgaW4gc3BlY2lhbCB2ZXJzaW9uIHNhZmFyaVxuICAgICAgICAgICAgICAgICAgICAgICAgb3AuY2h1bmtfc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBCTE9DS19CSVRTID0gMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBNQVhfQ0hVTktfU0laRSA9IDQgPDwgQkxPQ0tfQklUUzsgLy80TVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua19zaXplID0gcGx1cGxvYWQucGFyc2VTaXplKG9wLmNodW5rX3NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rX3NpemUgPiBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLmNodW5rX3NpemUgPSBNQVhfQ0hVTktfU0laRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHFpbml1IHNlcnZpY2UgIG1heF9jaHVua19zaXplIGlzIDRtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBjaHVua19zaXplIHRvIG1heF9jaHVua19zaXplKDRtKSB3aGVuIGNodW5rX3NpemUgPiA0bVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wLmNodW5rX3NpemUgc2V0IDAgd2lsbCBiZSBjYXVzZSB0byBkaXJlY3QgdXBsb2FkXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldEhvc3RzID0gZnVuY3Rpb24gKGhvc3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3QgPSBob3N0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3QuaW5kZXhPZihcInVwbG9hZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdC5pbmRleE9mKCctSCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChob3N0LnNwbGl0KCcgJylbMl0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaG9zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodXBsb2FkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbWFrZSB1cGxvYWQgZG9tYWlucyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBsb2FkRG9tYWluID0gcmVzdWx0W3VwbG9hZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3VwbG9hZEluZGV4XSA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gdXBsb2FkRG9tYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldFB1dFBvbGljeSA9IGZ1bmN0aW9uICh1cHRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gdXB0b2tlbi5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgdmFyIGFrID0gc2VnbWVudHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHB1dFBvbGljeSA9IHRoYXQucGFyc2VKU09OKHRoYXQuVVJMU2FmZUJhc2U2NERlY29kZShzZWdtZW50c1syXSkpO1xuICAgICAgICAgICAgICAgIHB1dFBvbGljeS5hayA9IGFrO1xuICAgICAgICAgICAgICAgIGlmIChwdXRQb2xpY3kuc2NvcGUuaW5kZXhPZihcIjpcIikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwdXRQb2xpY3kuYnVja2V0ID0gcHV0UG9saWN5LnNjb3BlLnNwbGl0KFwiOlwiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgcHV0UG9saWN5LmtleSA9IHB1dFBvbGljeS5zY29wZS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHV0UG9saWN5LmJ1Y2tldCA9IHB1dFBvbGljeS5zY29wZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1dFBvbGljeTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRVcEhvc3RzID0gZnVuY3Rpb24gKHVwdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHV0UG9saWN5ID0gZ2V0UHV0UG9saWN5KHVwdG9rZW4pO1xuICAgICAgICAgICAgICAgIHZhciB1cGhvc3RzX3VybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBcImh0dHBzOi8vXCIgKyBcIi8vYXBpLnFpbml1LmNvbS92Mi9xdWVyeT9haz1cIiArIHB1dFBvbGljeS5hayArIFwiJmJ1Y2tldD1cIiArIHB1dFBvbGljeS5idWNrZXQgOiBcImh0dHA6Ly9cIiArIFwiLy9hcGkucWluaXUuY29tL3YyL3F1ZXJ5P2FrPVwiICsgcHV0UG9saWN5LmFrICsgXCImYnVja2V0PVwiICsgcHV0UG9saWN5LmJ1Y2tldDtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJwdXRQb2xpY3k6IFwiLCBwdXRQb2xpY3kpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdldCB1cGhvc3RzIGZyb206IFwiLCB1cGhvc3RzX3VybCk7XG4gICAgICAgICAgICAgICAgdmFyIGllID0gdGhhdC5kZXRlY3RJRVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgYWpheDtcbiAgICAgICAgICAgICAgICBpZiAoaWUgJiYgaWUgPD0gOSkge1xuICAgICAgICAgICAgICAgICAgICBhamF4ID0gbmV3IG1veGllLnhoci5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICBtb3hpZS5jb3JlLnV0aWxzLkVudi5zd2ZfdXJsID0gb3AuZmxhc2hfc3dmX3VybDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhamF4ID0gdGhhdC5jcmVhdGVBamF4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFqYXgub3BlbignR0VUJywgdXBob3N0c191cmwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgb25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJhamF4LnJlYWR5U3RhdGU6IFwiLCBhamF4LnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWpheC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJhamF4LnN0YXR1czogXCIsIGFqYXguc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhamF4LnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcWluaXVVcEhvc3RzLm1haW4gPSByZXMudXAuYWNjLm1haW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcWluaXVVcEhvc3RzLmJhY2t1cCA9IHJlcy51cC5hY2MuYmFja3VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdldCBuZXcgdXBob3N0czogXCIsIHFpbml1VXBIb3N0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yZXNldFVwbG9hZFVybCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiZ2V0IHVwaG9zdHMgZXJyb3I6IFwiLCBhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFqYXguYmluZCgncmVhZHlzdGF0ZWNoYW5nZScsIG9ucmVhZHlzdGF0ZWNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWpheC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvbnJlYWR5c3RhdGVjaGFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFqYXguc2VuZCgpO1xuICAgICAgICAgICAgICAgIC8vIGFqYXguc2VuZCgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIChhamF4LnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgcmVzID0gdGhhdC5wYXJzZUpTT04oYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIC8vICAgICBxaW5pdVVwSG9zdHMuaHR0cCA9IGdldEhvc3RzKHJlcy5odHRwLnVwKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgcWluaXVVcEhvc3RzLmh0dHBzID0gZ2V0SG9zdHMocmVzLmh0dHBzLnVwKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IG5ldyB1cGhvc3RzOiBcIiwgcWluaXVVcEhvc3RzKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhhdC5yZXNldFVwbG9hZFVybCgpO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGxvZ2dlci5lcnJvcihcImdldCB1cGhvc3RzIGVycm9yOiBcIiwgYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0VXB0b2tlbiA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGF0LnRva2VuIHx8IChvcC51cHRva2VuX3VybCAmJiB0aGF0LnRva2VuSW5mby5pc0V4cGlyZWQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5ld1VwVG9rZW4oZmlsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ2V0TmV3VXB0b2tlbiBtYXliZSBjYWxsZWQgYXQgSW5pdCBFdmVudCBvciBCZWZvcmVVcGxvYWQgRXZlbnRcbiAgICAgICAgICAgIC8vIGNhc2UgSW5pdCBFdmVudCwgdGhlIGZpbGUgcGFyYW0gb2YgZ2V0VXB0a2VuIHdpbGwgYmUgc2V0IGEgbnVsbCB2YWx1ZVxuICAgICAgICAgICAgLy8gaWYgb3AudXB0b2tlbiBoYXMgdmFsdWUsIHNldCB1cHRva2VuIHdpdGggb3AudXB0b2tlblxuICAgICAgICAgICAgLy8gZWxzZSBpZiBvcC51cHRva2VuX3VybCBoYXMgdmFsdWUsIHNldCB1cHRva2VuIGZyb20gb3AudXB0b2tlbl91cmxcbiAgICAgICAgICAgIC8vIGVsc2UgaWYgb3AudXB0b2tlbl9mdW5jIGhhcyB2YWx1ZSwgc2V0IHVwdG9rZW4gYnkgcmVzdWx0IG9mIG9wLnVwdG9rZW5fZnVuY1xuICAgICAgICAgICAgdmFyIGdldE5ld1VwVG9rZW4gPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcC51cHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudG9rZW4gPSBvcC51cHRva2VuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AudXB0b2tlbl91cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IHVwdG9rZW4gZnJvbTogXCIsIHRoYXQudXB0b2tlbl91cmwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB1c2UgbU94aWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFqYXggPSB0aGF0LmNyZWF0ZUFqYXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYWpheC5vcGVuKCdHRVQnLCB0aGF0LnVwdG9rZW5fdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFqYXguc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWpheC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmIChhamF4LnJlYWR5U3RhdGUgPT09IDQgJiYgYWpheC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGhhdC50b2tlbiA9IHJlcy51cHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB9O1xuICAgICAgICAgICAgICAgICAgICBhamF4LnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXguc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRva2VuID0gcmVzLnVwdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGF0LnRva2VuLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRQb2xpY3kgPSB0aGF0LnBhcnNlSlNPTih0aGF0LlVSTFNhZmVCYXNlNjREZWNvZGUoc2VnbWVudHNbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC50b2tlbk1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudG9rZW5NYXAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwodGltZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyVGltZSA9IGdldFRpbWVzdGFtcChuZXcgRGF0ZShhamF4LmdldFJlc3BvbnNlSGVhZGVyKFwiZGF0ZVwiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudFRpbWUgPSBnZXRUaW1lc3RhbXAobmV3IERhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRva2VuSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEZWxheTogY2xpZW50VGltZSAtIHNlcnZlclRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmU6IHB1dFBvbGljeS5kZWFkbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0V4cGlyZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRUaW1lID0gdGhpcy5kZWFkbGluZSAtIGdldFRpbWVzdGFtcChuZXcgRGF0ZSgpKSArIHRoaXMuc2VydmVyRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VGltZSA8IDYwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IG5ldyB1cHRva2VuOiBcIiwgdGhhdC50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJnZXQgdG9rZW4gaW5mbzogXCIsIHRoYXQudG9rZW5JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcImdldCB1cHRva2VuIGVycm9yOiBcIiwgYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC51cHRva2VuX2Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2V0IHVwdG9rZW4gZnJvbSB1cHRva2VuX2Z1bmNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudG9rZW4gPSBvcC51cHRva2VuX2Z1bmMoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdldCBuZXcgdXB0b2tlbjogXCIsIHRoYXQudG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIm9uZSBvZiBbdXB0b2tlbiwgdXB0b2tlbl91cmwsIHVwdG9rZW5fZnVuY10gc2V0dGluZ3MgaW4gb3B0aW9ucyBpcyByZXF1aXJlZCFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGF0LnRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFVwSG9zdHModGhhdC50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnRva2VuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ2V0IGZpbGUga2V5IGFjY29yZGluZyB3aXRoIHRoZSB1c2VyIHBhc3NlZCBvcHRpb25zXG4gICAgICAgICAgICB2YXIgZ2V0RmlsZUtleSA9IGZ1bmN0aW9uICh1cCwgZmlsZSwgZnVuYykge1xuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkdcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHlvdSBzZXQgdGhlIGtleSBpbiBwdXRQb2xpY3kgYnkgXCJzY29wZVwiOiBcImJ1Y2tldDprZXlcIlxuICAgICAgICAgICAgICAgIC8vIFlvdSBzaG91bGQgdW5kZXJzdGFuZCB0aGUgcmlzayBvZiBvdmVycmlkZSBhIGZpbGUgaW4gdGhlIGJ1Y2tldFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZSBjb2RlIGJlbG93IHRoYXQgYXV0b21hdGljYWxseSBnZXQga2V5IGZyb20gdXB0b2tlbiBoYXMgYmVlbiBjb21tZW50ZWRcbiAgICAgICAgICAgICAgICAvLyB2YXIgcHV0UG9saWN5ID0gZ2V0UHV0UG9saWN5KHRoYXQudG9rZW4pXG4gICAgICAgICAgICAgICAgLy8gaWYgKHB1dFBvbGljeS5rZXkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgbG9nZ2VyLmRlYnVnKFwia2V5IGlzIGRlZmluZWQgaW4gcHV0UG9saWN5LnNjb3BlOiBcIiwgcHV0UG9saWN5LmtleSlcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHB1dFBvbGljeS5rZXlcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnLFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVfbmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wLnNhdmVfa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZV9uYW1lcyA9IHVwLmdldE9wdGlvbiAmJiB1cC5nZXRPcHRpb24oJ3VuaXF1ZV9uYW1lcycpO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVfbmFtZXMgPSB1bmlxdWVfbmFtZXMgfHwgKHVwLnNldHRpbmdzICYmIHVwLnNldHRpbmdzLnVuaXF1ZV9uYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmlxdWVfbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSB0aGF0LmdldEZpbGVFeHRlbnNpb24oZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGV4dCA/IGZpbGUuaWQgKyAnLicgKyBleHQgOiBmaWxlLmlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBmdW5jKHVwLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldERvbWFpbkZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiB1cmwubWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW146Xi9dKikvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwcyA/IGdyb3Vwc1sxXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldFBvcnRGcm9tVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgICAgIGlmICh1cmwgJiYgdXJsLm1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSB1cmwubWF0Y2goLyheaHR0cHM/KS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBncm91cHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwcyA9IHVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW146Xi9dKik6KFxcZCopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cHNbMl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJodHRwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjgwXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI0NDNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKioqKioqKioqIGlubmVyIGZ1bmN0aW9uIGRlZmluZSBlbmQgKioqKioqKioqKi9cblxuICAgICAgICAgICAgaWYgKG9wLmxvZ19sZXZlbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sZXZlbCA9IG9wLmxvZ19sZXZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcC5kb21haW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnZG9tYWluIHNldHRpbmcgaW4gb3B0aW9ucyBpcyByZXF1aXJlZCEnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wLmJyb3dzZV9idXR0b24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYnJvd3NlX2J1dHRvbiBzZXR0aW5nIGluIG9wdGlvbnMgaXMgcmVxdWlyZWQhJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcC51cHRva2VuICYmICFvcC51cHRva2VuX3VybCAmJiAhb3AudXB0b2tlbl9mdW5jKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ29uZSBvZiBbdXB0b2tlbiwgdXB0b2tlbl91cmwsIHVwdG9rZW5fZnVuY10gc2V0dGluZ3MgaW4gb3B0aW9ucyBpcyByZXF1aXJlZCEnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJpbml0IHVwbG9hZGVyIHN0YXJ0XCIpO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJlbnZpcm9ubWVudDogXCIsIG1veGllLmNvcmUudXRpbHMuRW52KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwidXNlckFnZW50OiBcIiwgbmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB7fTtcblxuICAgICAgICAgICAgLy8gaG9sZCB0aGUgaGFuZGxlciBmcm9tIHVzZXIgcGFzc2VkIG9wdGlvbnNcbiAgICAgICAgICAgIHZhciBfRXJyb3JfSGFuZGxlciA9IG9wLmluaXQgJiYgb3AuaW5pdC5FcnJvcjtcbiAgICAgICAgICAgIHZhciBfRmlsZVVwbG9hZGVkX0hhbmRsZXIgPSBvcC5pbml0ICYmIG9wLmluaXQuRmlsZVVwbG9hZGVkO1xuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBoYW5kbGVyIGZvciBpbnRlcmNlcHRcbiAgICAgICAgICAgIG9wLmluaXQuRXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIG9wLmluaXQuRmlsZVVwbG9hZGVkID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICAgIHRoYXQudXB0b2tlbl91cmwgPSBvcC51cHRva2VuX3VybDtcbiAgICAgICAgICAgIHRoYXQudG9rZW4gPSAnJztcbiAgICAgICAgICAgIHRoYXQua2V5X2hhbmRsZXIgPSB0eXBlb2Ygb3AuaW5pdC5LZXkgPT09ICdmdW5jdGlvbicgPyBvcC5pbml0LktleSA6ICcnO1xuICAgICAgICAgICAgdGhpcy5kb21haW4gPSBvcC5kb21haW47XG4gICAgICAgICAgICAvLyBUT0RPOiBjdHggaXMgZ2xvYmFsIGluIHNjb3BlIG9mIGEgdXBsb2FkZXIgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIHRoaXMgbWF5YmUgY2F1c2UgZXJyb3JcbiAgICAgICAgICAgIHZhciBjdHggPSAnJztcbiAgICAgICAgICAgIHZhciBzcGVlZENhbEluZm8gPSB7XG4gICAgICAgICAgICAgICAgaXNSZXN1bWVVcGxvYWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc3VtZUZpbGVzaXplOiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogJycsXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXNldF9jaHVua19zaXplKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJpbnZva2UgcmVzZXRfY2h1bmtfc2l6ZSgpXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwib3AuY2h1bmtfc2l6ZTogXCIsIG9wLmNodW5rX3NpemUpO1xuXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFNldHRpbmcgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBxaW5pdVVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaWUgPSB0aGF0LmRldGVjdElFVmVyc2lvbigpO1xuICAgICAgICAgICAgLy8gY2FzZSBJRSA5LVxuICAgICAgICAgICAgLy8gYWRkIGFjY2VwdCBpbiBtdWx0aXBhcnQgcGFyYW1zXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWUgPD0gOSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTZXR0aW5nLm11bHRpcGFydF9wYXJhbXMuYWNjZXB0ID0gJ3RleHQvcGxhaW47IGNoYXJzZXQ9dXRmLTgnO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFkZCBhY2NlcHQgdGV4dC9wbGFpbiBpbiBtdWx0aXBhcnQgcGFyYW1zXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb21wb3NlIG9wdGlvbnMgd2l0aCB1c2VyIHBhc3NlZCBvcHRpb25zIGFuZCBkZWZhdWx0IHNldHRpbmdcbiAgICAgICAgICAgIHBsdXBsb2FkLmV4dGVuZChvcHRpb24sIG9wLCBkZWZhdWx0U2V0dGluZyk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm9wdGlvbjogXCIsIG9wdGlvbik7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyB1cGxvYWRlciB3aXRoIGNvbXBvc2VkIG9wdGlvbnNcbiAgICAgICAgICAgIHZhciB1cGxvYWRlciA9IG5ldyBwbHVwbG9hZC5VcGxvYWRlcihvcHRpb24pO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJuZXcgcGx1cGxvYWQuVXBsb2FkZXIob3B0aW9uKVwiKTtcblxuICAgICAgICAgICAgLy8gYmluZCBnZXROZXdVcFRva2VuIHRvICdJbml0JyBldmVudFxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnSW5pdCcsIGZ1bmN0aW9uICh1cCwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiSW5pdCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgLy8gaWYgb3AuZ2V0X25ld191cHRva2VuIGlzIG5vdCB0cnVlXG4gICAgICAgICAgICAgICAgLy8gICAgICBpbnZva2UgZ2V0TmV3VXB0b2tlbiB3aGVuIHVwbG9hZGVyIGluaXRcbiAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgLy8gICAgICBnZXROZXdVcHRva2VuIGV2ZXJ5dGltZSBiZWZvcmUgYSBuZXcgZmlsZSB1cGxvYWRcbiAgICAgICAgICAgICAgICBpZiAoIW9wLmdldF9uZXdfdXB0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBnZXROZXdVcFRva2VuKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2dldE5ld1VwVG9rZW4obnVsbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBJbml0IGV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBiaW5kICdGaWxlc0FkZGVkJyBldmVudFxuICAgICAgICAgICAgLy8gd2hlbiBmaWxlIGJlIGFkZGVkIGFuZCBhdXRvX3N0YXJ0IGhhcyBzZXQgdmFsdWVcbiAgICAgICAgICAgIC8vIHVwbG9hZGVyIHdpbGwgYXV0byBzdGFydCB1cGxvYWQgdGhlIGZpbGVcbiAgICAgICAgICAgIHVwbG9hZGVyLmJpbmQoJ0ZpbGVzQWRkZWQnLCBmdW5jdGlvbiAodXAsIGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmlsZXNBZGRlZCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgdmFyIGF1dG9fc3RhcnQgPSB1cC5nZXRPcHRpb24gJiYgdXAuZ2V0T3B0aW9uKCdhdXRvX3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgYXV0b19zdGFydCA9IGF1dG9fc3RhcnQgfHwgKHVwLnNldHRpbmdzICYmIHVwLnNldHRpbmdzLmF1dG9fc3RhcnQpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImF1dG9fc3RhcnQ6IFwiLCBhdXRvX3N0YXJ0KTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJmaWxlczogXCIsIGZpbGVzKTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpcyBpT1NcbiAgICAgICAgICAgICAgICB2YXIgaXNfaW9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW94aWUuY29yZS51dGlscy5FbnYuT1MudG9Mb3dlckNhc2UoKSA9PT0gXCJpb3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudCBlbnYgb3MgaXMgaU9TIGNoYW5nZSBmaWxlIG5hbWUgdG8gW3RpbWVdLltleHRdXG4gICAgICAgICAgICAgICAgaWYgKGlzX2lvcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gdGhhdC5nZXRGaWxlRXh0ZW5zaW9uKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlLmlkICsgXCIuXCIgKyBleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXV0b19zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJpbnZva2UgdXAuc3RhcnQoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBsdXBsb2FkLmVhY2goZmlsZXMsIGZ1bmN0aW9uKGksIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHVwLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsb2dnZXIuZGVidWcoXCJpbnZva2UgdXAuc3RhcnQoKVwiKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbG9nZ2VyLmRlYnVnKFwiZmlsZTogXCIsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXAucmVmcmVzaCgpOyAvLyBSZXBvc2l0aW9uIEZsYXNoL1NpbHZlcmxpZ2h0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBGaWxlc0FkZGVkIGV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBiaW5kICdCZWZvcmVVcGxvYWQnIGV2ZW50XG4gICAgICAgICAgICAvLyBpbnRlcmNlcHQgdGhlIHByb2Nlc3Mgb2YgdXBsb2FkXG4gICAgICAgICAgICAvLyAtIHByZXBhcmUgdXB0b2tlblxuICAgICAgICAgICAgLy8gLSBhY2NvcmRpbmcgdGhlIGNodW5rIHNpemUgdG8gbWFrZSBkaWZmZXJudCB1cGxvYWQgc3RyYXRlZ3lcbiAgICAgICAgICAgIC8vIC0gcmVzdW1lIHVwbG9hZCB3aXRoIHRoZSBsYXN0IGJyZWFrcG9pbnQgb2YgZmlsZVxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnQmVmb3JlVXBsb2FkJywgZnVuY3Rpb24gKHVwLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQmVmb3JlVXBsb2FkIGV2ZW50IGFjdGl2YXRlZFwiKTtcbiAgICAgICAgICAgICAgICBmaWxlLl9zdGFydF9hdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGEga2V5IG5hbWVkIHNwZWVkIGZvciBmaWxlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZpbGUuc3BlZWQgPSBmaWxlLnNwZWVkIHx8IDA7XG4gICAgICAgICAgICAgICAgY3R4ID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAob3AuZ2V0X25ld191cHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE5ld1VwVG9rZW4oZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdFVwbG9hZCA9IGZ1bmN0aW9uICh1cCwgZmlsZSwgZnVuYykge1xuICAgICAgICAgICAgICAgICAgICBzcGVlZENhbEluZm8uc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBhcnRfcGFyYW1zX29iajtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnNhdmVfa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9rZW4nOiB0aGF0LnRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwYXJ0X3BhcmFtc19vYmogPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2tleSc6IGdldEZpbGVLZXkodXAsIGZpbGUsIGZ1bmMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbic6IHRoYXQudG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGllID0gdGhhdC5kZXRlY3RJRVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSBJRSA5LVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWNjZXB0IGluIG11bHRpcGFydCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGllICYmIGllIDw9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGFydF9wYXJhbXNfb2JqLmFjY2VwdCA9ICd0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFkZCBhY2NlcHQgdGV4dC9wbGFpbiBpbiBtdWx0aXBhcnQgcGFyYW1zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZGlyZWN0VXBsb2FkIG11bHRpcGFydF9wYXJhbXNfb2JqOiBcIiwgbXVsdGlwYXJ0X3BhcmFtc19vYmopO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4X3ZhcnMgPSBvcC54X3ZhcnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4X3ZhcnMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgeF92YXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeF9rZXkgaW4geF92YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhfdmFycy5oYXNPd25Qcm9wZXJ0eSh4X2tleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4X3ZhcnNbeF9rZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29ialsneDonICsgeF9rZXldID0geF92YXJzW3hfa2V5XSh1cCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHhfdmFyc1t4X2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29ialsneDonICsgeF9rZXldID0geF92YXJzW3hfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHVwLnNldE9wdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAndXJsJzogcWluaXVVcGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXVsdGlwYXJ0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaHVua19zaXplJzogaXNfYW5kcm9pZF93ZWl4aW5fb3JfcXEoKSA/IG9wLm1heF9maWxlX3NpemUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXVsdGlwYXJ0X3BhcmFtcyc6IG11bHRpcGFydF9wYXJhbXNfb2JqXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgaXMgd2VpeGluIG9yIHFxIGlubmVyIGJyb3dzZXJcbiAgICAgICAgICAgICAgICB2YXIgaXNfYW5kcm9pZF93ZWl4aW5fb3JfcXEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh1YS5tYXRjaCgvTWljcm9NZXNzZW5nZXIvaSkgfHwgbW94aWUuY29yZS51dGlscy5FbnYuYnJvd3NlciA9PT0gXCJRUUJyb3dzZXJcIiB8fCB1YS5tYXRjaCgvVjFfQU5EX1NRL2kpKSAmJiBtb3hpZS5jb3JlLnV0aWxzLkVudi5PUy50b0xvd2VyQ2FzZSgpID09PSBcImFuZHJvaWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGNodW5rX3NpemUgPSB1cC5nZXRPcHRpb24gJiYgdXAuZ2V0T3B0aW9uKCdjaHVua19zaXplJyk7XG4gICAgICAgICAgICAgICAgY2h1bmtfc2l6ZSA9IGNodW5rX3NpemUgfHwgKHVwLnNldHRpbmdzICYmIHVwLnNldHRpbmdzLmNodW5rX3NpemUpO1xuXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwidXBsb2FkZXIucnVudGltZTogXCIsIHVwbG9hZGVyLnJ1bnRpbWUpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImNodW5rX3NpemU6IFwiLCBjaHVua19zaXplKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZsYXNoIHN1cHBvcnQgY2h1bmsgdXBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKCh1cGxvYWRlci5ydW50aW1lID09PSAnaHRtbDUnIHx8IHVwbG9hZGVyLnJ1bnRpbWUgPT09ICdmbGFzaCcpICYmIGNodW5rX3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuc2l6ZSA8IGNodW5rX3NpemUgfHwgaXNfYW5kcm9pZF93ZWl4aW5fb3JfcXEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZGlyZWN0VXBsb2FkIGJlY2F1c2UgZmlsZS5zaXplIDwgY2h1bmtfc2l6ZSB8fCBpc19hbmRyb2lkX3dlaXhpbl9vcl9xcSgpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0IHVwbG9hZCBpZiBmaWxlIHNpemUgaXMgbGVzcyB0aGVuIHRoZSBjaHVuayBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RVcGxvYWQodXAsIGZpbGUsIHRoYXQua2V5X2hhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZCBhIHBvbGlmaWxsIHRvIG1ha2UgaXQgd29yayBpbiBJRSA5LVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVNTVUU6IGlmIGZpbGUubmFtZSBpcyBleGlzdGVkIGluIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IG5vdCB0aGUgc2FtZSBmaWxlIG1heWJlIGNhdXNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxGaWxlSW5mbyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2h1bmtfc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEZpbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYWx0aG91Z2ggb25seSB0aGUgaHRtbDUgcnVudGltZSB3aWxsIGVudGVyIHRoaXMgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IG5lZWQgdW5pZm9ybSB3YXkgdG8gbWFrZSBjb252ZXJ0aW9uIGJldHdlZW4gc3RyaW5nIGFuZCBqc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWxlSW5mbyA9IHRoYXQucGFyc2VKU09OKGxvY2FsRmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBsb2NhbEZpbGVJbmZvLnRpbWUgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYURheSA9IDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vICBtaWxsaXNlY29uZHMgb2Ygb25lIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYXN0IHVwbG9hZCB0aW1lIGlzIHdpdGhpbiBvbmUgZGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICB3aWxsIHVwbG9hZCBjb250aW51b3VzbHkgZm9sbG93IHRoZSBsYXN0IGJyZWFrcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICB3aWxsIHJldXBsb2FkIGVudGlyZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyAtIGJlZm9yZSA8IGFEYXkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxGaWxlSW5mby5wZXJjZW50ICE9PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnNpemUgPT09IGxvY2FsRmlsZUluZm8udG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiBmaWxlLm5hbWUgYW5kIGZpbGUuc2l6ZSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBub3QgdGhlIHNhbWUgZmlsZSB3aWxsIGNhdXNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5wZXJjZW50ID0gbG9jYWxGaWxlSW5mby5wZXJjZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUubG9hZGVkID0gbG9jYWxGaWxlSW5mby5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4ID0gbG9jYWxGaWxlSW5mby5jdHg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgc3BlZWQgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkQ2FsSW5mby5pc1Jlc3VtZVVwbG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWRDYWxJbmZvLnJlc3VtZUZpbGVzaXplID0gbG9jYWxGaWxlSW5mby5vZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgYmxvY2sgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEZpbGVJbmZvLm9mZnNldCArIGJsb2NrU2l6ZSA+IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NpemUgPSBmaWxlLnNpemUgLSBsb2NhbEZpbGVJbmZvLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmaWxlIGluZm8gd2hlbiBmaWxlLnNpemUgaXMgY29uZmxpY3Qgd2l0aCBmaWxlIGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShmaWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZmlsZSBpbmZvIHdoZW4gdXBsb2FkIHBlcmNlbnQgaXMgMTAwJVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgNDk5IGJ1Z1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmaWxlIGluZm8gd2hlbiBsYXN0IHVwbG9hZCB0aW1lIGlzIG92ZXIgb25lIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShmaWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkQ2FsSW5mby5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBhcnRfcGFyYW1zX29iaiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGllID0gdGhhdC5kZXRlY3RJRVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgSUUgOS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhY2NlcHQgaW4gbXVsdGlwYXJ0IHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGllICYmIGllIDw9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBhcnRfcGFyYW1zX29iai5hY2NlcHQgPSAndGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWRkIGFjY2VwdCB0ZXh0L3BsYWluIGluIG11bHRpcGFydCBwYXJhbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0byBzdXBwb3J0IGJwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIucWluaXUuY29tL2RvY3MvdjYvYXBpL3JlZmVyZW5jZS91cC9icHV0Lmh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLnNldE9wdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VybCc6IHFpbml1VXBsb2FkVXJsICsgJy9ta2Jsay8nICsgYmxvY2tTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtdWx0aXBhcnQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2h1bmtfc2l6ZSc6IGNodW5rX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcXVpcmVkX2ZlYXR1cmVzJzogXCJjaHVua3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnVXBUb2tlbiAnICsgZ2V0VXB0b2tlbihmaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ211bHRpcGFydF9wYXJhbXMnOiBtdWx0aXBhcnRfcGFyYW1zX29ialxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJkaXJlY3RVcGxvYWQgYmVjYXVzZSB1cGxvYWRlci5ydW50aW1lICE9PSAnaHRtbDUnIHx8IHVwbG9hZGVyLnJ1bnRpbWUgIT09ICdmbGFzaCcgfHwgIWNodW5rX3NpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpcmVjdCB1cGxvYWQgaWYgcnVudGltZSBpcyBub3QgaHRtbDVcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0VXBsb2FkKHVwLCBmaWxlLCB0aGF0LmtleV9oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBCZWZvcmVVcGxvYWQgZXZlbnRcIik7XG5cbiAgICAgICAgICAgIC8vIGJpbmQgJ1VwbG9hZFByb2dyZXNzJyBldmVudFxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHVwbG9hZCBzcGVlZFxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnVXBsb2FkUHJvZ3Jlc3MnLCBmdW5jdGlvbiAodXAsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJVcGxvYWRQcm9ncmVzcyBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgc3BlZWRDYWxJbmZvLmN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVVc2VkID0gc3BlZWRDYWxJbmZvLmN1cnJlbnRUaW1lIC0gc3BlZWRDYWxJbmZvLnN0YXJ0VGltZTsgLy8gbXNcbiAgICAgICAgICAgICAgICB2YXIgZmlsZVVwbG9hZGVkID0gZmlsZS5sb2FkZWQgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWRDYWxJbmZvLmlzUmVzdW1lVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVVcGxvYWRlZCA9IGZpbGUubG9hZGVkIC0gc3BlZWRDYWxJbmZvLnJlc3VtZUZpbGVzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlLnNwZWVkID0gKGZpbGVVcGxvYWRlZCAvIHRpbWVVc2VkICogMTAwMCkudG9GaXhlZCgwKSB8fCAwOyAvLyB1bml0OiBieXRlL3NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJiaW5kIFVwbG9hZFByb2dyZXNzIGV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBiaW5kICdDaHVua1VwbG9hZGVkJyBldmVudFxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGNodW5rIHVwbG9hZCBpbmZvIGFuZCBzZXQgbmV4dCBjaHVuayB1cGxvYWQgdXJsXG4gICAgICAgICAgICB1cGxvYWRlci5iaW5kKCdDaHVua1VwbG9hZGVkJywgZnVuY3Rpb24gKHVwLCBmaWxlLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2h1bmtVcGxvYWRlZCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2h1bmtVcGxvYWRlZCBmaWxlOiBcIiwgZmlsZSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2h1bmtVcGxvYWRlZCBpbmZvOiBcIiwgaW5mbyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoYXQucGFyc2VKU09OKGluZm8ucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNodW5rVXBsb2FkZWQgcmVzOiBcIiwgcmVzKTtcbiAgICAgICAgICAgICAgICAvLyBjdHggc2hvdWxkIGxvb2sgbGlrZSAnW2NodW5rMDFfY3R4XSxbY2h1bmswMl9jdHhdLFtjaHVuazAzX2N0eF0sLi4uJ1xuICAgICAgICAgICAgICAgIGN0eCA9IGN0eCA/IGN0eCArICcsJyArIHJlcy5jdHggOiByZXMuY3R4O1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0U2l6ZSA9IGluZm8udG90YWwgLSBpbmZvLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtfc2l6ZSA9IHVwLmdldE9wdGlvbiAmJiB1cC5nZXRPcHRpb24oJ2NodW5rX3NpemUnKTtcbiAgICAgICAgICAgICAgICBjaHVua19zaXplID0gY2h1bmtfc2l6ZSB8fCAodXAuc2V0dGluZ3MgJiYgdXAuc2V0dGluZ3MuY2h1bmtfc2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRTaXplIDwgY2h1bmtfc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cC5zZXRPcHRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VybCc6IHFpbml1VXBsb2FkVXJsICsgJy9ta2Jsay8nICsgbGVmdFNpemVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcInVwLnNldE9wdGlvbiB1cmw6IFwiLCBxaW5pdVVwbG9hZFVybCArICcvbWtibGsvJyArIGxlZnRTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXAuc2V0T3B0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdVcFRva2VuICcgKyBnZXRVcHRva2VuKGZpbGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShmaWxlLm5hbWUsIHRoYXQuc3RyaW5naWZ5SlNPTih7XG4gICAgICAgICAgICAgICAgICAgIGN0eDogY3R4LFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiBmaWxlLnBlcmNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiBpbmZvLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGluZm8ub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImJpbmQgQ2h1bmtVcGxvYWRlZCBldmVudFwiKTtcblxuICAgICAgICAgICAgdmFyIHJldHJpZXMgPSBvcC5tYXhfcmV0cmllcztcblxuICAgICAgICAgICAgLy8gaWYgZXJyb3IgaXMgdW5rb3duIHN3aXRjaCB1cGxvYWQgdXJsIGFuZCByZXRyeVxuICAgICAgICAgICAgdmFyIHVua25vd19lcnJvcl9yZXRyeSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHJpZXMtLSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJlc2V0VXBsb2FkVXJsKHJldHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zdGF0dXMgPSBwbHVwbG9hZC5RVUVVRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cmllcyA9IHFpbml1VXBsb2FkVXJscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBiaW5kICdFcnJvcicgZXZlbnRcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBlcnIuY29kZSBhbmQgcmV0dXJuIHRoZSBlcnJUaXBcbiAgICAgICAgICAgIHVwbG9hZGVyLmJpbmQoJ0Vycm9yJywgKGZ1bmN0aW9uIChfRXJyb3JfSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodXAsIGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcImVycjogXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3dUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyclRpcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGVyci5maWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcGx1cGxvYWQuRkFJTEVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn5LiK5Lyg5aSx6LSl44CC6K+356iN5ZCO5YaN6K+V44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBwbHVwbG9hZC5GSUxFX1NJWkVfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhfZmlsZV9zaXplID0gdXAuZ2V0T3B0aW9uICYmIHVwLmdldE9wdGlvbignbWF4X2ZpbGVfc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfZmlsZV9zaXplID0gbWF4X2ZpbGVfc2l6ZSB8fCAodXAuc2V0dGluZ3MgJiYgdXAuc2V0dGluZ3MubWF4X2ZpbGVfc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9ICfmtY/op4jlmajmnIDlpKflj6/kuIrkvKAnICsgbWF4X2ZpbGVfc2l6ZSArICfjgILmm7TlpKfmlofku7bor7fkvb/nlKjlkb3ku6TooYzlt6XlhbfjgIInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHBsdXBsb2FkLkZJTEVfRVhURU5TSU9OX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn5paH5Lu26aqM6K+B5aSx6LSl44CC6K+356iN5ZCO6YeN6K+V44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBwbHVwbG9hZC5IVFRQX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLnJlc3BvbnNlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IHBhcnNlSlNPTiBlcnJvciAsd2hlbiBodHRwIGVycm9yIGlzIGxpa2UgbmV0OjpFUlJfQUREUkVTU19VTlJFQUNIQUJMRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gZXJyLm1lc3NhZ2UgfHwgJ+acquefpee9kee7nOmUmeivr+OAgic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVua25vd19lcnJvcl9yZXRyeShmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck9iaiA9IHRoYXQucGFyc2VKU09OKGVyci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclRleHQgPSBlcnJvck9iai5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBcIuivt+axguaKpeaWh+agvOW8j+mUmeivr+OAglwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLlrqLmiLfnq6/orqTor4HmjojmnYPlpLHotKXjgILor7fph43or5XmiJbmj5DkuqTlj43ppojjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9IFwi5a6i5oi356uv6K+35rGC6ZSZ6K+v44CC6K+36YeN6K+V5oiW5o+Q5Lqk5Y+N6aaI44CCXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU3OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBcIui1hOa6kOS4iuS8oOaIkOWKn++8jOS9huWbnuiwg+Wksei0peOAglwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLnvZHnu5zov57mjqXlvILluLjjgILor7fph43or5XmiJbmj5DkuqTlj43ppojjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVua25vd19lcnJvcl9yZXRyeShmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2MTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLmlofku7blt7LlrZjlnKjjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iaiA9IHRoYXQucGFyc2VKU09OKGVycm9yT2JqLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gZXJyb3JPYmouZXJyb3IgfHwgJ2ZpbGUgZXhpc3RzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IGVycm9yT2JqLmVycm9yIHx8ICdmaWxlIGV4aXN0cyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2MzE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyVGlwID0gXCLmjIflrprnqbrpl7TkuI3lrZjlnKjjgIJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9IFwi5LiK5Lyg5pWw5o2u5Z2X5qCh6aqM5Ye66ZSZ44CC6K+36YeN6K+V5oiW5o+Q5Lqk5Y+N6aaI44CCXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9IFwi5pyq55+l6ZSZ6K+v44CCXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1bmtub3dfZXJyb3JfcmV0cnkoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBlcnJUaXAgKyAnKCcgKyBlcnIuc3RhdHVzICsgJ++8micgKyBlcnJvclRleHQgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcGx1cGxvYWQuU0VDVVJJVFlfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9ICflronlhajphY3nva7plJnor6/jgILor7fogZTns7vnvZHnq5nnrqHnkIblkZjjgIInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHBsdXBsb2FkLkdFTkVSSUNfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclRpcCA9ICfkuIrkvKDlpLHotKXjgILor7fnqI3lkI7lho3or5XjgIInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHBsdXBsb2FkLklPX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn5LiK5Lyg5aSx6LSl44CC6K+356iN5ZCO5YaN6K+V44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBwbHVwbG9hZC5JTklUX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSAn572R56uZ6YWN572u6ZSZ6K+v44CC6K+36IGU57O7572R56uZ566h55CG5ZGY44CCJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJUaXAgPSBlcnIubWVzc2FnZSArIGVyci5kZXRhaWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVua25vd19lcnJvcl9yZXRyeShmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9FcnJvcl9IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX0Vycm9yX0hhbmRsZXIodXAsIGVyciwgZXJyVGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cC5yZWZyZXNoKCk7IC8vIFJlcG9zaXRpb24gRmxhc2gvU2lsdmVybGlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoX0Vycm9yX0hhbmRsZXIpKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYmluZCBFcnJvciBldmVudFwiKTtcblxuICAgICAgICAgICAgLy8gYmluZCAnRmlsZVVwbG9hZGVkJyBldmVudFxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0IHRoZSBjb21wbGV0ZSBvZiB1cGxvYWRcbiAgICAgICAgICAgIC8vIC0gZ2V0IGRvd250b2tlbiBmcm9tIGRvd250b2tlbl91cmwgaWYgYnVja2V0IGlzIHByaXZhdGVcbiAgICAgICAgICAgIC8vIC0gaW52b2tlIG1rZmlsZSBhcGkgdG8gY29tcG9zZSBjaHVua3MgaWYgdXBsb2FkIHN0cmF0ZWd5IGlzIGNodW5rIHVwbG9hZFxuICAgICAgICAgICAgdXBsb2FkZXIuYmluZCgnRmlsZVVwbG9hZGVkJywgKGZ1bmN0aW9uIChfRmlsZVVwbG9hZGVkX0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHVwLCBmaWxlLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVVcGxvYWRlZCBldmVudCBhY3RpdmF0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVVcGxvYWRlZCBmaWxlOiBcIiwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVVcGxvYWRlZCBpbmZvOiBcIiwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3dUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3Rfc3RlcCA9IGZ1bmN0aW9uICh1cCwgZmlsZSwgaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmlsZVVwbG9hZGVkIGxhc3Qgc3RlcDpcIiwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AuZG93bnRva2VuX3VybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wLmRvd29udG9rZW5fdXJsIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgZ2V0IGRvd250b2tlbiBiZWZvcmUgaW52b2tlIHRoZSBfRmlsZVVwbG9hZGVkX0hhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWpheF9kb3dudG9rZW4gPSB0aGF0LmNyZWF0ZUFqYXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4X2Rvd250b2tlbi5vcGVuKCdQT1NUJywgb3AuZG93bnRva2VuX3VybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheF9kb3dudG9rZW4uc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhfZG93bnRva2VuLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXhfZG93bnRva2VuLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhamF4X2Rvd250b2tlbi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNfZG93bnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc19kb3dudG9rZW4gPSB0aGF0LnBhcnNlSlNPTihhamF4X2Rvd250b2tlbi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKCdpbnZhbGlkIGpzb24gZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvX2V4dGVuZGVkID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1cGxvYWQuZXh0ZW5kKGluZm9fZXh0ZW5kZWQsIHRoYXQucGFyc2VKU09OKGluZm8ucmVzcG9uc2UpLCByZXNfZG93bnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnJlc3BvbnNlID0gdGhhdC5zdHJpbmdpZnlKU09OKGluZm9fZXh0ZW5kZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfRmlsZVVwbG9hZGVkX0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX0ZpbGVVcGxvYWRlZF9IYW5kbGVyKHVwLCBmaWxlLCBpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVyLnRyaWdnZXIoJ0Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGFqYXhfZG93bnRva2VuLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGFqYXhfZG93bnRva2VuLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogcGx1cGxvYWQuSFRUUF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4X2Rvd250b2tlbi5zZW5kKCdrZXk9JyArIHRoYXQucGFyc2VKU09OKGluZm8ucmVzcG9uc2UpLmtleSArICcmZG9tYWluPScgKyBvcC5kb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfRmlsZVVwbG9hZGVkX0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfRmlsZVVwbG9hZGVkX0hhbmRsZXIodXAsIGZpbGUsIGluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGF0LnBhcnNlSlNPTihpbmZvLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gY3R4ID8gY3R4IDogcmVzLmN0eDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3R4IGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIHRoYXQgbWVhbnMgdGhlIHVwbG9hZCBzdHJhdGVneSBpcyBjaHVuayB1cGxvYWRcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICBiZWZvcmUgdGhlIGludm9rZSB0aGUgbGFzdF9zdGVwXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgd2UgbmVlZCByZXF1ZXN0IHRoZSBta2ZpbGUgdG8gY29tcG9zZSBhbGwgdXBsb2FkZWQgY2h1bmtzXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICBpbnZva2UgdGhlIGxhc3Rfc3RlcFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJjdHg6IFwiLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJzYXZlX2tleTogXCIsIG9wLnNhdmVfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3Auc2F2ZV9rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZXRGaWxlS2V5KHVwLCBmaWxlLCB0aGF0LmtleV9oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkgPyAnL2tleS8nICsgdGhhdC5VUkxTYWZlQmFzZTY0RW5jb2RlKGtleSkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gJy9mbmFtZS8nICsgdGhhdC5VUkxTYWZlQmFzZTY0RW5jb2RlKGZpbGUubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm9wLnhfdmFyczogXCIsIG9wLnhfdmFycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeF92YXJzID0gb3AueF92YXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhfdmFsID0gJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeF92YXJzX3VybCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhfdmFycyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB4X3ZhcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeF9rZXkgaW4geF92YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4X3ZhcnMuaGFzT3duUHJvcGVydHkoeF9rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhfdmFyc1t4X2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4X3ZhbCA9IHRoYXQuVVJMU2FmZUJhc2U2NEVuY29kZSh4X3ZhcnNbeF9rZXldKHVwLCBmaWxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB4X3ZhcnNbeF9rZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhfdmFsID0gdGhhdC5VUkxTYWZlQmFzZTY0RW5jb2RlKHhfdmFyc1t4X2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeF92YXJzX3VybCArPSAnL3g6JyArIHhfa2V5ICsgJy8nICsgeF92YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBxaW5pdVVwbG9hZFVybCArICcvbWtmaWxlLycgKyBmaWxlLnNpemUgKyBrZXkgKyBmbmFtZSArIHhfdmFyc191cmw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZSA9IHRoYXQuZGV0ZWN0SUVWZXJzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWpheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheCA9IG5ldyBtb3hpZS54aHIuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3hpZS5jb3JlLnV0aWxzLkVudi5zd2ZfdXJsID0gb3AuZmxhc2hfc3dmX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheCA9IHRoYXQuY3JlYXRlQWpheCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheC5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFqYXguc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3VwdG9rZW46Jyt0aGF0LnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFqYXguc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsICdVcFRva2VuICcgKyB0aGF0LnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWpheC5yZWFkeVN0YXRlOiBcIiwgYWpheC5yZWFkeVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWpheC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhamF4SW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXguc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogYWpheC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGFqYXgucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczogYWpheC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJta2ZpbGUgaXMgc3VjY2VzczogXCIsIGFqYXhJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Rfc3RlcCh1cCwgZmlsZSwgYWpheEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheEluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBhamF4LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogYWpheC5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAtMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczogYWpheC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm1rZmlsZSBpcyBlcnJvcjogXCIsIGFqYXhJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVyLnRyaWdnZXIoJ0Vycm9yJywgYWpheEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheC5iaW5kKCdyZWFkeXN0YXRlY2hhbmdlJywgb25yZWFkeXN0YXRlY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvbnJlYWR5c3RhdGVjaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4LnNlbmQoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIm1rZmlsZTogXCIsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3N0ZXAodXAsIGZpbGUsIGluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKF9GaWxlVXBsb2FkZWRfSGFuZGxlcikpO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJiaW5kIEZpbGVVcGxvYWRlZCBldmVudFwiKTtcblxuICAgICAgICAgICAgLy8gaW5pdCB1cGxvYWRlclxuICAgICAgICAgICAgdXBsb2FkZXIuaW5pdCgpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiaW52b2tlIHVwbG9hZGVyLmluaXQoKVwiKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiaW5pdCB1cGxvYWRlciBlbmRcIik7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHVybCBieSBrZXlcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkgb2YgZmlsZVxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHVybCBvZiBmaWxlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFVybCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gZW5jb2RlVVJJKGtleSk7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gdGhpcy5kb21haW47XG4gICAgICAgICAgICBpZiAoZG9tYWluLnNsaWNlKGRvbWFpbi5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gZG9tYWluICsgJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbiArIGtleTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgUWluaXUgPSBuZXcgUWluaXVKc1NESygpO1xuXG4gICAgZ2xvYmFsLlFpbml1ID0gUWluaXU7XG4gICAgZ2xvYmFsLlFpbml1SnNTREsgPSBRaW5pdUpzU0RLO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFFpbml1SnNTREs7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIHJlZ2lzdGVyIGFzICdxaW5pdS1qcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG4gICAgICAgIGRlZmluZSgncWluaXUtanMnLCBbJy4vcGx1cGxvYWQvbW94aWUuanMnLCcuL3BsdXBsb2FkL3BsdXBsb2FkLmRldi5qcyddLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUWluaXVKc1NESztcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLlFpbml1SnNTREsgPSBRaW5pdUpzU0RLO1xuICAgIH1cbn0pKHdpbmRvdyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9xaW5pdS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9